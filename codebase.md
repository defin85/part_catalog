# Tree View:
```
./lib
├─core
│ ├─config
│ │ └─global_api_settings_service.dart
│ ├─database
│ │ ├─daos
│ │ │ ├─cars_dao.dart
│ │ │ ├─cars_dao.g.dart
│ │ │ ├─clients_dao.dart
│ │ │ ├─clients_dao.g.dart
│ │ │ ├─orders_dao.dart
│ │ │ ├─orders_dao.g.dart
│ │ │ ├─supplier_settings_dao.dart
│ │ │ └─supplier_settings_dao.g.dart
│ │ ├─database.dart
│ │ ├─database.g.dart
│ │ ├─database_logger.dart
│ │ ├─items
│ │ │ ├─app_info_items.dart
│ │ │ ├─cars_items.dart
│ │ │ ├─clients_items.dart
│ │ │ ├─order_parts_items.dart
│ │ │ ├─order_services_items.dart
│ │ │ ├─orders_items.dart
│ │ │ ├─reference_closure_items.dart
│ │ │ └─supplier_settings_items.dart
│ │ └─schema_synchronizer.dart
│ ├─i18n
│ │ ├─clients
│ │ │ ├─clients_en.i18n.json
│ │ │ └─clients_ru.i18n.json
│ │ ├─common
│ │ │ ├─common_en.i18n.json
│ │ │ └─common_ru.i18n.json
│ │ ├─core
│ │ │ ├─core_en.i18n.json
│ │ │ └─core_ru.i18n.json
│ │ ├─custom_app_locale.dart
│ │ ├─errors
│ │ │ ├─errors_en.i18n.json
│ │ │ └─errors_ru.i18n.json
│ │ ├─orders
│ │ │ ├─orders_en.i18n.json
│ │ │ └─orders_ru.i18n.json
│ │ ├─parts
│ │ │ ├─parts_en.i18n.json
│ │ │ └─parts_ru.i18n.json
│ │ ├─services
│ │ │ ├─services_en.i18n.json
│ │ │ └─services_ru.i18n.json
│ │ ├─settings
│ │ │ ├─settings_en.i18n.json
│ │ │ └─settings_ru.i18n.json
│ │ ├─strings.g.dart
│ │ ├─strings_en.g.dart
│ │ ├─strings_ru.g.dart
│ │ └─vehicles
│ │   ├─vehicles_en.i18n.json
│ │   └─vehicles_ru.i18n.json
│ ├─navigation
│ │ ├─app_router.dart
│ │ └─app_routes.dart
│ ├─providers
│ │ ├─core_providers.dart
│ │ └─core_providers.g.dart
│ ├─schemas
│ │ └─app_schema.json
│ ├─service_locator.dart
│ ├─utils
│ │ ├─json_converter.dart
│ │ ├─log_messages.dart
│ │ └─logger_config.dart
│ └─widgets
│   └─language_switcher.dart
├─features
│ ├─armtek
│ │ └─api
│ │   ├─MaterialRestConnection.md
│ │   ├─MaterialRestResponse.md
│ │   ├─MaterialRestRules.md
│ │   ├─MaterialWsGetOrder2.md
│ │   ├─ServiceInvoice.md
│ │   ├─ServiceOrder.md
│ │   ├─ServicePing.md
│ │   ├─ServiceReports.md
│ │   ├─ServiceSearch.md
│ │   └─ServiceUser.md
│ ├─core
│ │ ├─base_item_type.dart
│ │ ├─document_item_specific_data.dart
│ │ ├─document_item_specific_data.freezed.dart
│ │ ├─document_item_specific_data.g.dart
│ │ ├─document_specific_data.dart
│ │ ├─document_specific_data.freezed.dart
│ │ ├─document_specific_data.g.dart
│ │ ├─document_status.dart
│ │ ├─entity_core_data.dart
│ │ ├─entity_core_data.freezed.dart
│ │ ├─entity_core_data.g.dart
│ │ ├─i_document_entity.dart
│ │ ├─i_document_item_entity.dart
│ │ ├─i_entity.dart
│ │ ├─i_item_entity.dart
│ │ ├─i_reference_entity.dart
│ │ ├─i_reference_item_entity.dart
│ │ ├─item_core_data.dart
│ │ ├─item_core_data.freezed.dart
│ │ └─item_core_data.g.dart
│ ├─documents
│ │ ├─orders
│ │ │ ├─models
│ │ │ │ ├─order_model_composite.dart
│ │ │ │ ├─order_part_model_composite.dart
│ │ │ │ ├─order_service_model_composite.dart
│ │ │ │ ├─order_specific_data.dart
│ │ │ │ ├─order_specific_data.freezed.dart
│ │ │ │ ├─order_specific_data.g.dart
│ │ │ │ ├─order_status.dart
│ │ │ │ ├─part_specific_data.dart
│ │ │ │ ├─part_specific_data.freezed.dart
│ │ │ │ ├─part_specific_data.g.dart
│ │ │ │ ├─service_specific_data.dart
│ │ │ │ ├─service_specific_data.freezed.dart
│ │ │ │ └─service_specific_data.g.dart
│ │ │ ├─notifiers
│ │ │ │ ├─order_form_notifier.dart
│ │ │ │ ├─orders_notifier.dart
│ │ │ │ └─orders_notifier.g.dart
│ │ │ ├─providers
│ │ │ │ └─order_providers.dart
│ │ │ ├─screens
│ │ │ │ ├─order_details_screen.dart
│ │ │ │ ├─order_form_screen.dart
│ │ │ │ └─orders_screen.dart
│ │ │ ├─services
│ │ │ │ └─order_service.dart
│ │ │ ├─state
│ │ │ │ ├─order_form_state.dart
│ │ │ │ └─order_form_state.freezed.dart
│ │ │ └─widgets
│ │ │   └─order_list_item.dart
│ │ └─part_orders
│ ├─home
│ │ ├─models
│ │ │ └─navigation_item.dart
│ │ └─screens
│ │   └─home_screen.dart
│ ├─parts_catalog
│ │ ├─api
│ │ │ ├─PartsCatalogsRestAPI.md
│ │ │ ├─api_client_parts_catalogs.dart
│ │ │ └─api_client_parts_catalogs.g.dart
│ │ ├─models
│ │ │ ├─car2.dart
│ │ │ ├─car2.freezed.dart
│ │ │ ├─car2.g.dart
│ │ │ ├─car_info.dart
│ │ │ ├─car_info.freezed.dart
│ │ │ ├─car_info.g.dart
│ │ │ ├─car_parameter.dart
│ │ │ ├─car_parameter.freezed.dart
│ │ │ ├─car_parameter.g.dart
│ │ │ ├─car_parameter_idx.dart
│ │ │ ├─car_parameter_idx.freezed.dart
│ │ │ ├─car_parameter_idx.g.dart
│ │ │ ├─car_parameter_info.dart
│ │ │ ├─car_parameter_info.freezed.dart
│ │ │ ├─car_parameter_info.g.dart
│ │ │ ├─catalog.dart
│ │ │ ├─catalog.freezed.dart
│ │ │ ├─catalog.g.dart
│ │ │ ├─error.dart
│ │ │ ├─error.freezed.dart
│ │ │ ├─error.g.dart
│ │ │ ├─example_prices_response.dart
│ │ │ ├─example_prices_response.freezed.dart
│ │ │ ├─example_prices_response.g.dart
│ │ │ ├─group.dart
│ │ │ ├─group.freezed.dart
│ │ │ ├─group.g.dart
│ │ │ ├─groups_tree.dart
│ │ │ ├─groups_tree.freezed.dart
│ │ │ ├─groups_tree.g.dart
│ │ │ ├─groups_tree_response.dart
│ │ │ ├─groups_tree_response.freezed.dart
│ │ │ ├─groups_tree_response.g.dart
│ │ │ ├─ip.dart
│ │ │ ├─ip.freezed.dart
│ │ │ ├─ip.g.dart
│ │ │ ├─model.dart
│ │ │ ├─model.freezed.dart
│ │ │ ├─model.g.dart
│ │ │ ├─option_code.dart
│ │ │ ├─option_code.freezed.dart
│ │ │ ├─option_code.g.dart
│ │ │ ├─part.dart
│ │ │ ├─part.freezed.dart
│ │ │ ├─part.g.dart
│ │ │ ├─part_name.dart
│ │ │ ├─part_name.freezed.dart
│ │ │ ├─part_name.g.dart
│ │ │ ├─parts.dart
│ │ │ ├─parts.freezed.dart
│ │ │ ├─parts.g.dart
│ │ │ ├─parts_group.dart
│ │ │ ├─parts_group.freezed.dart
│ │ │ ├─parts_group.g.dart
│ │ │ ├─position.dart
│ │ │ ├─position.freezed.dart
│ │ │ ├─position.g.dart
│ │ │ ├─schema_model.dart
│ │ │ ├─schema_model.freezed.dart
│ │ │ ├─schema_model.g.dart
│ │ │ ├─schemas_response.dart
│ │ │ ├─schemas_response.freezed.dart
│ │ │ ├─schemas_response.g.dart
│ │ │ ├─suggest.dart
│ │ │ ├─suggest.freezed.dart
│ │ │ └─suggest.g.dart
│ │ ├─screens
│ │ └─widgets
│ │   ├─car_info_widget.dart
│ │   └─schema_list_widget.dart
│ ├─references
│ │ ├─clients
│ │ │ ├─models
│ │ │ │ ├─client_model_composite.dart
│ │ │ │ ├─client_specific_data.dart
│ │ │ │ ├─client_specific_data.freezed.dart
│ │ │ │ ├─client_specific_data.g.dart
│ │ │ │ └─client_type.dart
│ │ │ ├─providers
│ │ │ │ ├─client_providers.dart
│ │ │ │ └─client_providers.g.dart
│ │ │ ├─screens
│ │ │ │ └─clients_screen.dart
│ │ │ └─services
│ │ │   └─client_service.dart
│ │ ├─suppliers
│ │ │ ├─api
│ │ │ └─models
│ │ │   ├─price_offer.dart
│ │ │   ├─price_offer.g.dart
│ │ │   ├─supplier.dart
│ │ │   └─supplier.g.dart
│ │ └─vehicles
│ │   ├─models
│ │   │ ├─car_model_composite.dart
│ │   │ ├─car_specific_data.dart
│ │   │ ├─car_specific_data.freezed.dart
│ │   │ └─car_specific_data.g.dart
│ │   ├─providers
│ │   │ ├─car_providers.dart
│ │   │ └─car_providers.g.dart
│ │   ├─screens
│ │   │ └─cars_screen.dart
│ │   └─services
│ │     └─car_service.dart
│ ├─registers
│ │ ├─finances
│ │ └─parts_inventory
│ ├─settings
│ │ ├─api_control_center
│ │ │ ├─notifiers
│ │ │ │ └─api_control_center_notifier.dart
│ │ │ ├─screens
│ │ │ │ └─api_control_center_screen.dart
│ │ │ └─state
│ │ │   ├─api_control_center_state.dart
│ │ │   └─api_control_center_state.freezed.dart
│ │ └─armtek
│ │   ├─notifiers
│ │   │ └─armtek_settings_notifier.dart
│ │   ├─screens
│ │   │ └─armtek_settings_screen.dart
│ │   └─state
│ │     ├─armtek_settings_state.dart
│ │     └─armtek_settings_state.freezed.dart
│ └─suppliers
│   ├─api
│   │ ├─api_client_manager.dart
│   │ ├─api_connection_mode.dart
│   │ ├─base_supplier_api_client.dart
│   │ └─implementations
│   │   ├─armtek_api_client.dart
│   │   └─armtek_api_client.g.dart
│   ├─config
│   │ └─supported_suppliers.dart
│   ├─models
│   │ ├─armtek
│   │ │ ├─armtek_message.dart
│   │ │ ├─armtek_message.freezed.dart
│   │ │ ├─armtek_message.g.dart
│   │ │ ├─armtek_response_wrapper.dart
│   │ │ ├─armtek_response_wrapper.freezed.dart
│   │ │ ├─armtek_response_wrapper.g.dart
│   │ │ ├─brand_item.dart
│   │ │ ├─brand_item.freezed.dart
│   │ │ ├─brand_item.g.dart
│   │ │ ├─ping_response.dart
│   │ │ ├─ping_response.freezed.dart
│   │ │ ├─ping_response.g.dart
│   │ │ ├─store_item.dart
│   │ │ ├─store_item.freezed.dart
│   │ │ ├─store_item.g.dart
│   │ │ ├─user_contact.dart
│   │ │ ├─user_contact.freezed.dart
│   │ │ ├─user_contact.g.dart
│   │ │ ├─user_delivery_address.dart
│   │ │ ├─user_delivery_address.freezed.dart
│   │ │ ├─user_delivery_address.g.dart
│   │ │ ├─user_ftp_data.dart
│   │ │ ├─user_ftp_data.freezed.dart
│   │ │ ├─user_ftp_data.g.dart
│   │ │ ├─user_info_request.dart
│   │ │ ├─user_info_request.freezed.dart
│   │ │ ├─user_info_request.g.dart
│   │ │ ├─user_info_response.dart
│   │ │ ├─user_info_response.freezed.dart
│   │ │ ├─user_info_response.g.dart
│   │ │ ├─user_structure_item.dart
│   │ │ ├─user_structure_item.freezed.dart
│   │ │ ├─user_structure_item.g.dart
│   │ │ ├─user_vkorg.dart
│   │ │ ├─user_vkorg.freezed.dart
│   │ │ └─user_vkorg.g.dart
│   │ └─base
│   │   ├─part_price_response.dart
│   │   ├─part_price_response.freezed.dart
│   │   └─part_price_response.g.dart
│   └─services
│     └─suppliers_service.dart
├─main.dart
└─models
```

# Content:

## lib\core\config\global_api_settings_service.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/service_locator.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:part_catalog/features/suppliers/api/api_connection_mode.dart';
import 'package:part_catalog/core/utils/logger_config.dart';

// --- Провайдер для GlobalApiSettingsService ---
final globalApiSettingsServiceProvider =
    Provider<GlobalApiSettingsService>((ref) {
  return locator<GlobalApiSettingsService>();
});
// --- Конец провайдера ---

class GlobalApiSettingsService {
  final _logger = AppLoggers.core;
  static const String _apiModeKey = 'api_connection_mode';
  static const String _proxyUrlKey = 'proxy_url';

  Future<SharedPreferences> get _prefs async => SharedPreferences.getInstance();

  Future<ApiConnectionMode> getApiConnectionMode() async {
    try {
      final prefs = await _prefs;
      final modeName = prefs.getString(_apiModeKey);
      return ApiConnectionModeExtension.fromName(modeName);
    } catch (e, s) {
      _logger.e('Error getting API connection mode', error: e, stackTrace: s);
      return ApiConnectionMode.direct; // Значение по умолчанию при ошибке
    }
  }

  Future<void> setApiConnectionMode(ApiConnectionMode mode) async {
    try {
      final prefs = await _prefs;
      await prefs.setString(_apiModeKey, mode.name);
      _logger.i('API connection mode set to: ${mode.name}');
    } catch (e, s) {
      _logger.e('Error setting API connection mode', error: e, stackTrace: s);
    }
  }

  Future<String?> getProxyUrl() async {
    try {
      final prefs = await _prefs;
      return prefs.getString(_proxyUrlKey);
    } catch (e, s) {
      _logger.e('Error getting proxy URL', error: e, stackTrace: s);
      return null;
    }
  }

  Future<void> setProxyUrl(String? url) async {
    try {
      final prefs = await _prefs;
      if (url == null || url.isEmpty) {
        await prefs.remove(_proxyUrlKey);
        _logger.i('Proxy URL removed');
      } else {
        await prefs.setString(_proxyUrlKey, url);
        _logger.i('Proxy URL set to: $url');
      }
    } catch (e, s) {
      _logger.e('Error setting proxy URL', error: e, stackTrace: s);
    }
  }
}

```

## lib\core\database\daos\cars_dao.dart
```dart
import 'package:drift/drift.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/items/cars_items.dart';
import 'package:part_catalog/core/database/items/clients_items.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
// Импортируем @freezed модели данных
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/references/vehicles/models/car_specific_data.dart';
// Импортируем @freezed модели для клиента
import 'package:part_catalog/features/references/clients/models/client_specific_data.dart';
import 'package:part_catalog/features/references/clients/models/client_type.dart';
// Логгер
import 'package:part_catalog/core/utils/logger_config.dart';

part 'cars_dao.g.dart';

/// Модель для возврата полных данных автомобиля (@freezed модели)
class CarFullData {
  final EntityCoreData coreData;
  final CarSpecificData carData;

  CarFullData({required this.coreData, required this.carData});
}

/// Модель для представления автомобиля с данными владельца (@freezed модели)
class CarWithOwnerData {
  final CarFullData carFullData;
  final EntityCoreData ownerCoreData; // Используем EntityCoreData для владельца
  final ClientSpecificData ownerSpecificData; // Используем ClientSpecificData

  CarWithOwnerData({
    required this.carFullData,
    required this.ownerCoreData,
    required this.ownerSpecificData,
  });
}

/// {@template cars_dao}
/// Объект доступа к данным для работы с автомобилями.
/// Работает с @freezed моделями данных (EntityCoreData, CarSpecificData),
/// используя UUID для связывания и маппинга.
/// {@endtemplate}
@DriftAccessor(tables: [CarsItems, ClientsItems])
class CarsDao extends DatabaseAccessor<AppDatabase> with _$CarsDaoMixin {
  /// {@macro cars_dao}
  CarsDao(super.db);

  // Используем логгер из AppLoggers
  final _logger = AppLoggers.database; // Или AppLoggers.vehiclesLogger

  // --- Приватные методы маппинга (из таблицы в @freezed) ---

  /// Маппинг из CarsItem в EntityCoreData
  EntityCoreData _mapToCoreData(CarsItem item) {
    return EntityCoreData(
      uuid: item.uuid,
      code: item.code,
      displayName:
          '${item.make} ${item.model} (${item.year})', // Формируем displayName
      createdAt: item.createdAt,
      modifiedAt: item.modifiedAt,
      deletedAt: item.deletedAt,
      isDeleted: item.deletedAt != null,
    );
  }

  /// Маппинг из CarsItem и clientUuid в CarSpecificData
  CarSpecificData _mapToCarSpecificData(CarsItem item, String clientUuid) {
    return CarSpecificData(
      clientId: clientUuid, // Используем переданный UUID клиента
      vin: item.vin ?? '', // Обеспечиваем non-nullable String
      make: item.make,
      model: item.model,
      year: item.year ?? 0, // Обеспечиваем non-nullable int
      licensePlate: item.licensePlate,
      additionalInfo: item.additionalInfo,
    );
  }

  /// Маппинг из CarsItem и clientUuid в CarFullData
  CarFullData _mapToCarFullData(CarsItem item, String clientUuid) {
    return CarFullData(
      coreData: _mapToCoreData(item),
      carData: _mapToCarSpecificData(item, clientUuid),
    );
  }

  /// Вспомогательный метод для получения int ID клиента по его UUID.
  Future<int?> _getClientIntId(String clientUuid) async {
    final client = await (select(clientsItems)
          ..where((c) => c.uuid.equals(clientUuid)))
        .getSingleOrNull();
    if (client == null) {
      // Используем константу
      _logger
          .w(LogMessages.clientNotFoundByUuid.replaceAll('{uuid}', clientUuid));
    }
    return client?.id;
  }

  // --- Публичные методы DAO ---

  /// Возвращает поток списка всех активных автомобилей в виде CarFullData.
  Stream<List<CarFullData>> watchAllActiveCars() {
    // Используем JOIN для получения UUID клиента
    final query = select(carsItems).join([
      innerJoin(clientsItems, clientsItems.id.equalsExp(carsItems.clientId))
    ])
      ..where(carsItems.deletedAt.isNull() & clientsItems.deletedAt.isNull());

    return query.watch().map((rows) {
      return rows.map((row) {
        final carItem = row.readTable(carsItems);
        final clientItem = row.readTable(clientsItems);
        return _mapToCarFullData(
            carItem, clientItem.uuid); // Передаем UUID клиента
      }).toList();
    });
  }

  /// Возвращает поток списка активных автомобилей клиента в виде CarFullData.
  Stream<List<CarFullData>> watchActiveClientCars(String clientUuid) {
    // JOIN с ClientsItems для фильтрации по UUID клиента
    final query = select(carsItems).join([
      innerJoin(clientsItems, clientsItems.id.equalsExp(carsItems.clientId))
    ])
      ..where(
          clientsItems.uuid.equals(clientUuid) & carsItems.deletedAt.isNull());

    return query.watch().map((rows) {
      return rows.map((row) {
        final carItem = row.readTable(carsItems);
        // UUID клиента у нас уже есть из параметра clientUuid
        return _mapToCarFullData(carItem, clientUuid);
      }).toList();
    });
  }

  /// Возвращает автомобиль по его UUID в виде CarFullData.
  ///
  /// По умолчанию возвращает только активные (не удаленные) автомобили.
  /// Если [includeDeleted] установлен в true, вернет и мягко удаленный автомобиль.
  Future<CarFullData?> getCarByUuid(String carUuid,
      {bool includeDeleted = false}) async {
    // Используем JOIN для получения UUID клиента
    final query = select(carsItems).join([
      innerJoin(clientsItems, clientsItems.id.equalsExp(carsItems.clientId))
    ])
      ..where(carsItems.uuid.equals(carUuid)); // Ищем по UUID

    // Добавляем условие на deletedAt только если не нужно включать удаленные
    if (!includeDeleted) {
      query.where(carsItems.deletedAt.isNull());
    }

    final row = await query.getSingleOrNull();
    if (row == null) return null;

    final carItem = row.readTable(carsItems);
    final clientItem = row.readTable(clientsItems);
    return _mapToCarFullData(carItem, clientItem.uuid); // Передаем UUID клиента
  }

  /// Находит автомобиль по VIN (возвращает полную модель данных CarFullData).
  ///
  /// По умолчанию ищет только активные (не удаленные) автомобили.
  /// Если [includeDeleted] установлен в true, вернет и мягко удаленный автомобиль.
  Future<CarFullData?> getCarByVin(String vin,
      {bool includeDeleted = false}) async {
    _logger.d('Getting car by VIN: "$vin", includeDeleted: $includeDeleted');
    // Используем JOIN для получения UUID клиента
    final query = select(carsItems).join([
      innerJoin(clientsItems, clientsItems.id.equalsExp(carsItems.clientId))
    ])
      ..where(carsItems.vin.equals(vin)); // Ищем по VIN

    // Добавляем условие на deletedAt только если не нужно включать удаленные
    if (!includeDeleted) {
      query.where(carsItems.deletedAt.isNull());
    }

    final row = await query.getSingleOrNull();
    if (row == null) {
      _logger.w('Car with VIN "$vin" not found.');
      return null;
    }

    final carItem = row.readTable(carsItems);
    final clientItem = row.readTable(clientsItems);
    _logger.d('Found car with VIN "$vin", UUID: ${carItem.uuid}');
    return _mapToCarFullData(carItem, clientItem.uuid); // Передаем UUID клиента
  }

  /// Добавляет новый автомобиль. Принимает @freezed модели.
  Future<int> insertCar(EntityCoreData core, CarSpecificData specific) async {
    // Получаем int ID клиента по его UUID для внешнего ключа
    final clientIntId = await _getClientIntId(specific.clientId);
    if (clientIntId == null) {
      throw Exception(
          'Client with UUID ${specific.clientId} not found, cannot insert car.');
    }

    final companion = CarsItemsCompanion(
      uuid: Value(core.uuid),
      clientId: Value(clientIntId), // Используем полученный int ID
      vin: Value(specific.vin),
      make: Value(specific.make),
      model: Value(specific.model),
      year: Value(specific.year),
      licensePlate: Value(specific.licensePlate),
      additionalInfo: Value(specific.additionalInfo),
      code: Value(core.code),
      createdAt: Value(core.createdAt),
      modifiedAt: Value(core.modifiedAt ?? DateTime.now()),
      deletedAt: Value(core.deletedAt),
    );
    _logger.d(LogMessages.carInserting
        .replaceAll('{uuid}', core.uuid)
        .replaceAll('{clientId}', clientIntId.toString()));
    try {
      return await into(carsItems).insert(companion);
    } catch (e, s) {
      _logger.e(LogMessages.carAddError, error: e, stackTrace: s);
      rethrow; // Перебрасываем исключение для обработки выше
    }
  }

  /// Обновляет информацию об автомобиле по UUID. Принимает @freezed модели.
  Future<int> updateCarByUuid(
      EntityCoreData core, CarSpecificData specific) async {
    // Получаем int ID клиента по его UUID для внешнего ключа
    final clientIntId = await _getClientIntId(specific.clientId);
    if (clientIntId == null) {
      // Решаем, что делать: выбросить ошибку или обновить без изменения клиента?
      // Пока выбросим ошибку, т.к. смена владельца должна быть явной операцией.
      throw Exception(
          'Client with UUID ${specific.clientId} not found, cannot update car owner.');
      // Альтернатива: обновить только данные машины, не трогая clientId
      /*
      final currentCar = await (select(carsItems)..where((c) => c.uuid.equals(core.uuid))).getSingleOrNull();
      if (currentCar == null) return 0; // Машина не найдена
      clientIntId = currentCar.clientId; // Оставляем старого владельца
      */
    }

    final companion = CarsItemsCompanion(
      // id не указываем, обновление по where
      clientId: Value(clientIntId), // Используем полученный int ID
      vin: Value(specific.vin),
      make: Value(specific.make),
      model: Value(specific.model),
      year: Value(specific.year),
      licensePlate: Value(specific.licensePlate),
      additionalInfo: Value(specific.additionalInfo),
      code: Value(core.code),
      // createdAt не обновляем
      modifiedAt: Value(DateTime.now()), // Всегда обновляем modifiedAt
      deletedAt: Value(core.deletedAt), // Позволяем обновить/сбросить deletedAt
    );
    _logger.d(LogMessages.carUpdating.replaceAll('{uuid}', core.uuid));
    try {
      return await (update(carsItems)..where((c) => c.uuid.equals(core.uuid)))
          .write(companion);
    } catch (e, s) {
      _logger.e(LogMessages.carUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Мягкое удаление автомобиля по UUID.
  Future<int> softDeleteCarByUuid(String carUuid) {
    _logger.i(LogMessages.carSoftDeleting.replaceAll('{uuid}', carUuid));
    try {
      return (update(carsItems)..where((c) => c.uuid.equals(carUuid)))
          .write(CarsItemsCompanion(
        deletedAt: Value(DateTime.now()),
        modifiedAt: Value(DateTime.now()),
      ));
    } catch (e, s) {
      _logger.e(LogMessages.carDeleteError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Восстановление мягко удаленного автомобиля по UUID.
  Future<int> restoreCarByUuid(String carUuid) {
    _logger.i(LogMessages.carRestoring.replaceAll('{uuid}', carUuid));
    try {
      return (update(carsItems)..where((c) => c.uuid.equals(carUuid)))
          .write(const CarsItemsCompanion(
        deletedAt: Value(null),
        modifiedAt: Value.absent(),
      ));
    } catch (e, s) {
      _logger.e(LogMessages.carRestoreError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Возвращает список автомобилей с информацией о владельцах в виде CarWithOwnerData.
  Future<List<CarWithOwnerData>> getCarsWithOwners() async {
    final query = select(carsItems).join([
      innerJoin(
        clientsItems,
        clientsItems.id.equalsExp(carsItems.clientId),
      )
    ])
      ..where(carsItems.deletedAt.isNull() &
          clientsItems.deletedAt
              .isNull()); // Убедимся, что клиент тоже не удален

    final rows = await query.get();

    return rows.map((row) {
      final carItem = row.readTable(carsItems);
      final clientItem = row.readTable(clientsItems);

      // Маппим данные автомобиля, используя UUID клиента из JOIN
      final carFullData = _mapToCarFullData(carItem, clientItem.uuid);

      // Маппим данные владельца
      final ownerCoreData = EntityCoreData(
        uuid: clientItem.uuid,
        code: clientItem.code,
        displayName: clientItem.name,
        createdAt: clientItem.createdAt,
        modifiedAt: clientItem.modifiedAt,
        deletedAt: clientItem.deletedAt,
        isDeleted: clientItem.deletedAt != null,
      );
      // Предполагаем, что ClientSpecificData имеет конструктор fromJson или поля доступны
      // Здесь создаем вручную для примера
      final ownerSpecificData = ClientSpecificData(
        type: ClientType.values.firstWhere((e) => e.name == clientItem.type,
            orElse: () => ClientType.other), // Преобразуем строку в enum
        contactInfo: clientItem.contactInfo,
        additionalInfo: clientItem.additionalInfo,
      );

      return CarWithOwnerData(
        carFullData: carFullData,
        ownerCoreData: ownerCoreData,
        ownerSpecificData: ownerSpecificData,
      );
    }).toList();
  }

  /// Возвращает поток списка автомобилей с информацией о владельцах в виде CarWithOwnerData.
  Stream<List<CarWithOwnerData>> watchCarsWithOwners() {
    final query = select(carsItems).join([
      innerJoin(
        clientsItems,
        clientsItems.id.equalsExp(carsItems.clientId),
      )
    ])
      ..where(carsItems.deletedAt.isNull() &
          clientsItems.deletedAt
              .isNull()); // Убедимся, что клиент тоже не удален

    return query.watch().map((rows) {
      // Используем .watch()
      return rows.map((row) {
        final carItem = row.readTable(carsItems);
        final clientItem = row.readTable(clientsItems);

        // Маппим данные автомобиля, используя UUID клиента из JOIN
        final carFullData = _mapToCarFullData(carItem, clientItem.uuid);

        // Маппим данные владельца
        final ownerCoreData = EntityCoreData(
          uuid: clientItem.uuid,
          code: clientItem.code,
          displayName: clientItem.name,
          createdAt: clientItem.createdAt,
          modifiedAt: clientItem.modifiedAt,
          deletedAt: clientItem.deletedAt,
          isDeleted: clientItem.deletedAt != null,
        );
        // Предполагаем, что ClientSpecificData имеет конструктор fromJson или поля доступны
        // Здесь создаем вручную для примера
        final ownerSpecificData = ClientSpecificData(
          type: ClientType.values.firstWhere((e) => e.name == clientItem.type,
              orElse: () => ClientType.other), // Преобразуем строку в enum
          contactInfo: clientItem.contactInfo,
          additionalInfo: clientItem.additionalInfo,
        );

        return CarWithOwnerData(
          carFullData: carFullData,
          ownerCoreData: ownerCoreData,
          ownerSpecificData: ownerSpecificData,
        );
      }).toList();
    });
  }

  /// Возвращает базовые данные автомобиля по UUID.
  Future<EntityCoreData?> getCarCoreData(String uuid) async {
    final item = await (select(carsItems)..where((c) => c.uuid.equals(uuid)))
        .getSingleOrNull();
    if (item == null) return null;
    // Маппинг в EntityCoreData
    return EntityCoreData(
      uuid: item.uuid,
      code: item.vin ??
          item.licensePlate ??
          '', // Используем VIN или госномер как code
      displayName: '${item.make} ${item.model} (${item.year})',
      createdAt: item.createdAt,
      modifiedAt: item.modifiedAt,
      deletedAt: item.deletedAt,
      isDeleted: item.deletedAt != null,
    );
  }
}

```

## lib\core\database\daos\cars_dao.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'cars_dao.dart';

// ignore_for_file: type=lint
mixin _$CarsDaoMixin on DatabaseAccessor<AppDatabase> {
  $ClientsItemsTable get clientsItems => attachedDatabase.clientsItems;
  $CarsItemsTable get carsItems => attachedDatabase.carsItems;
}

```

## lib\core\database\daos\clients_dao.dart
```dart
import 'package:drift/drift.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/items/clients_items.dart';
// Импортируем @freezed модели данных
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/references/clients/models/client_specific_data.dart';
import 'package:part_catalog/features/references/clients/models/client_type.dart';
// Логгер и сообщения
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/core/utils/log_messages.dart';

part 'clients_dao.g.dart';

/// Модель для возврата полных данных клиента (@freezed модели)
class ClientFullData {
  final EntityCoreData coreData;
  final ClientSpecificData clientData;

  ClientFullData({required this.coreData, required this.clientData});
}

/// {@template clients_dao}
/// DAO для работы с таблицей клиентов.
/// Работает с @freezed моделями данных (EntityCoreData, ClientSpecificData).
/// {@endtemplate}
@DriftAccessor(tables: [ClientsItems])
class ClientsDao extends DatabaseAccessor<AppDatabase> with _$ClientsDaoMixin {
  /// {@macro clients_dao}
  ClientsDao(super.db);

  final _logger = AppLoggers.database;

  // --- Приватные методы маппинга ---

  /// Маппинг из ClientsItem в EntityCoreData
  EntityCoreData _mapToCoreData(ClientsItem item) {
    return EntityCoreData(
      uuid: item.uuid,
      code: item.code,
      displayName: item.name, // Используем name из таблицы как displayName
      createdAt: item.createdAt,
      modifiedAt: item.modifiedAt,
      deletedAt: item.deletedAt,
      isDeleted: item.deletedAt != null,
    );
  }

  /// Маппинг из ClientsItem в ClientSpecificData
  ClientSpecificData _mapToClientSpecificData(ClientsItem item) {
    return ClientSpecificData(
      type: ClientType.values.firstWhere((e) => e.name == item.type,
          orElse: () => ClientType.other), // Преобразуем строку в enum
      contactInfo: item.contactInfo,
      additionalInfo: item.additionalInfo,
    );
  }

  /// Маппинг из ClientsItem в ClientFullData
  ClientFullData _mapToClientFullData(ClientsItem item) {
    return ClientFullData(
      coreData: _mapToCoreData(item),
      clientData: _mapToClientSpecificData(item),
    );
  }

  // --- Публичные методы DAO ---

  /// Возвращает поток списка активных клиентов в виде ClientFullData.
  Stream<List<ClientFullData>> watchActiveClients() {
    final query = select(clientsItems)..where((c) => c.deletedAt.isNull());
    return query.watch().map((rows) => rows.map(_mapToClientFullData).toList());
  }

  /// Возвращает клиента по UUID в виде ClientFullData.
  Future<ClientFullData?> getClientByUuid(String uuid) async {
    final item = await (select(clientsItems)
          ..where((c) => c.uuid.equals(uuid) & c.deletedAt.isNull()))
        .getSingleOrNull();
    return item != null ? _mapToClientFullData(item) : null;
  }

  /// Возвращает клиента по коду в виде ClientFullData.
  Future<ClientFullData?> getClientByCode(String code) async {
    final item = await (select(clientsItems)
          ..where((c) => c.code.equals(code) & c.deletedAt.isNull()))
        .getSingleOrNull();
    return item != null ? _mapToClientFullData(item) : null;
  }

  /// Добавляет нового клиента. Принимает @freezed модели.
  /// Генерирует код, если он не предоставлен.
  Future<int> insertClient(
      EntityCoreData core, ClientSpecificData specific) async {
    String finalCode = core.code;
    // Генерируем код, если он пустой или не уникальный
    if (finalCode.isEmpty || !(await isCodeUnique(finalCode))) {
      final count = await (selectOnly(clientsItems)..addColumns([countAll()]))
          .getSingle()
          .then((value) => value.read(countAll()) ?? 0);
      finalCode = 'CL-${(count + 1).toString().padLeft(5, '0')}';
      _logger
          .i(LogMessages.clientGeneratedCode.replaceAll('{code}', finalCode));
    }

    final companion = ClientsItemsCompanion(
      uuid: Value(core.uuid),
      code: Value(finalCode),
      name: Value(core.displayName),
      type: Value(specific.type.name), // Преобразуем enum в строку
      contactInfo: Value(specific.contactInfo),
      additionalInfo: Value(specific.additionalInfo),
      createdAt: Value(core.createdAt),
      modifiedAt: Value(core.modifiedAt ?? core.createdAt),
      deletedAt: Value(core.deletedAt),
    );
    _logger.d(LogMessages.clientInserting
        .replaceAll('{uuid}', core.uuid)
        .replaceAll('{code}', finalCode));
    try {
      return await into(clientsItems).insert(companion);
    } catch (e, s) {
      _logger.e(LogMessages.clientAddError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет данные клиента по UUID. Принимает @freezed модели.
  Future<int> updateClientByUuid(
      EntityCoreData core, ClientSpecificData specific) async {
    // Проверяем уникальность кода, если он меняется
    if (core.code.isNotEmpty) {
      final existingClient = await getClientByUuid(core.uuid);
      if (existingClient != null && existingClient.coreData.code != core.code) {
        if (!(await isCodeUnique(core.code, excludeUuid: core.uuid))) {
          throw Exception(
              'Client code ${core.code} is not unique, cannot update.');
        }
      }
    }

    final companion = ClientsItemsCompanion(
      // uuid и createdAt не обновляем
      code: Value(core.code),
      name: Value(core.displayName),
      type: Value(specific.type.name),
      contactInfo: Value(specific.contactInfo),
      additionalInfo: Value(specific.additionalInfo),
      modifiedAt: Value(DateTime.now()), // Всегда обновляем modifiedAt
      deletedAt: Value(core.deletedAt), // Позволяем обновить/сбросить deletedAt
    );
    _logger.d(LogMessages.clientUpdating.replaceAll('{uuid}', core.uuid));
    try {
      return await (update(clientsItems)
            ..where((c) => c.uuid.equals(core.uuid)))
          .write(companion);
    } catch (e, s) {
      _logger.e(LogMessages.clientUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Выполняет soft-delete клиента по UUID.
  Future<int> softDeleteClientByUuid(String uuid) {
    _logger.i(LogMessages.clientSoftDeleting.replaceAll('{uuid}', uuid));
    try {
      return (update(clientsItems)..where((c) => c.uuid.equals(uuid)))
          .write(ClientsItemsCompanion(
        deletedAt: Value(DateTime.now()),
        modifiedAt: Value(DateTime.now()),
      ));
    } catch (e, s) {
      _logger.e(LogMessages.clientDeleteError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Возвращает список всех клиентов в виде ClientFullData.
  Future<List<ClientFullData>> getAllClients(
      {bool includeDeleted = false}) async {
    final query = select(clientsItems);
    if (!includeDeleted) {
      query.where((c) => c.deletedAt.isNull());
    }
    final items = await query.get();
    return items.map(_mapToClientFullData).toList();
  }

  /// Фильтрует клиентов по типу и возвращает список ClientFullData.
  Future<List<ClientFullData>> getClientsByType(ClientType type) async {
    final items = await (select(clientsItems)
          ..where((c) => c.type.equals(type.name) & c.deletedAt.isNull()))
        .get();
    return items.map(_mapToClientFullData).toList();
  }

  /// Восстанавливает удалённого клиента по UUID.
  Future<int> restoreClientByUuid(String uuid) {
    _logger.i(LogMessages.clientRestoring.replaceAll('{uuid}', uuid));
    try {
      return (update(clientsItems)..where((c) => c.uuid.equals(uuid)))
          .write(const ClientsItemsCompanion(
        deletedAt: Value(null),
        modifiedAt: Value.absent(), // modifiedAt обновится в сервисе
      ));
    } catch (e, s) {
      _logger.e(LogMessages.clientRestoreError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Поиск клиентов по имени, коду или контактной информации. Возвращает ClientFullData.
  Future<List<ClientFullData>> searchClients(String query) async {
    if (query.isEmpty) return [];
    final lowerQuery = '%${query.toLowerCase()}%';
    final items = await (select(clientsItems)
          ..where((c) =>
              (c.name.lower().like(lowerQuery) |
                  c.code.lower().like(lowerQuery) |
                  c.contactInfo.lower().like(lowerQuery)) &
              c.deletedAt.isNull()))
        .get();
    return items.map(_mapToClientFullData).toList();
  }

  /// Подсчитывает количество активных клиентов по типу.
  Future<int> countClientsByType(ClientType type) async {
    final query = selectOnly(clientsItems)
      ..addColumns([countAll()])
      ..where(clientsItems.type.equals(type.name) &
          clientsItems.deletedAt.isNull());

    final result = await query.getSingle();
    return result.read(countAll()) ?? 0;
  }

  /// Получает поток с количеством активных клиентов.
  Stream<int> watchClientCount() {
    final query = selectOnly(clientsItems)
      ..addColumns([countAll()])
      ..where(clientsItems.deletedAt.isNull());

    return query.watchSingle().map((row) => row.read(countAll()) ?? 0);
  }

  /// Проверяет уникальность кода, исключая клиента с заданным UUID.
  Future<bool> isCodeUnique(String code, {String? excludeUuid}) async {
    final query = select(clientsItems)
      ..where((c) => c.code.equals(code) & c.deletedAt.isNull());

    if (excludeUuid != null) {
      query.where((c) => c.uuid.equals(excludeUuid).not());
    }

    final existingClient = await query.getSingleOrNull();
    return existingClient == null;
  }

  /// Получает список клиентов (ClientFullData), обновленных после указанной даты.
  Future<List<ClientFullData>> getClientsModifiedAfter(DateTime date) async {
    final items = await (select(clientsItems)
          ..where((c) => c.modifiedAt.isBiggerOrEqualValue(date)))
        .get();
    return items.map(_mapToClientFullData).toList();
  }

  /// Возвращает базовые данные клиента по UUID.
  Future<EntityCoreData?> getClientCoreData(String uuid) async {
    final item = await (select(clientsItems)..where((c) => c.uuid.equals(uuid)))
        .getSingleOrNull();
    if (item == null) return null;
    // Маппинг в EntityCoreData
    return EntityCoreData(
      uuid: item.uuid,
      code: '', // У клиентов нет явного кода в таблице?
      displayName: item.name,
      createdAt: item.createdAt,
      modifiedAt: item.modifiedAt,
      deletedAt: item.deletedAt,
      isDeleted: item.deletedAt != null,
    );
  }
}

```

## lib\core\database\daos\clients_dao.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'clients_dao.dart';

// ignore_for_file: type=lint
mixin _$ClientsDaoMixin on DatabaseAccessor<AppDatabase> {
  $ClientsItemsTable get clientsItems => attachedDatabase.clientsItems;
}

```

## lib\core\database\daos\orders_dao.dart
```dart
import 'dart:async';
import 'package:rxdart/rxdart.dart';
import 'package:drift/drift.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/items/orders_items.dart';
import 'package:part_catalog/core/database/items/order_parts_items.dart';
import 'package:part_catalog/core/database/items/order_services_items.dart';
import 'package:part_catalog/core/database/items/clients_items.dart'; // Нужен для JOIN
import 'package:part_catalog/core/database/items/cars_items.dart'; // Нужен для JOIN
// Импортируем @freezed модели данных
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/core/document_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/order_specific_data.dart';
import 'package:part_catalog/features/core/item_core_data.dart';
import 'package:part_catalog/features/core/document_item_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/part_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/service_specific_data.dart';
import 'package:part_catalog/features/core/document_status.dart'; // Используем DocumentStatus
import 'package:part_catalog/features/core/base_item_type.dart';
// Логгер и сообщения
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/core/utils/log_messages.dart';

part 'orders_dao.g.dart';

// --- Вспомогательные классы для возврата данных ---

/// Данные заголовка заказ-наряда (@freezed модели)
class OrderHeaderData {
  final EntityCoreData coreData;
  final DocumentSpecificData docData;
  final OrderSpecificData orderData;

  OrderHeaderData({
    required this.coreData,
    required this.docData,
    required this.orderData,
  });
}

/// Данные элемента заказ-наряда (запчасть или услуга) (@freezed модели)
class FullOrderItemData {
  final ItemCoreData coreData;
  final DocumentItemSpecificData docItemData;
  final BaseItemType itemType; // Добавляем тип для различения
  // Специфичные данные (одно из полей будет не null)
  final PartSpecificData? partData;
  final ServiceSpecificData? serviceData;

  FullOrderItemData({
    required this.coreData,
    required this.docItemData,
    required this.itemType,
    this.partData,
    this.serviceData,
  }) : assert(
            (partData != null &&
                    serviceData == null &&
                    itemType == BaseItemType.part) ||
                (partData == null &&
                    serviceData != null &&
                    itemType == BaseItemType.service),
            'Должны быть предоставлены данные только одного типа (Part или Service)');
}

/// Полные данные заказ-наряда с элементами (@freezed модели)
class FullOrderData {
  final OrderHeaderData headerData;
  final List<FullOrderItemData> items;

  FullOrderData({required this.headerData, required this.items});
}

/// {@template orders_dao}
/// DAO для работы с заказ-нарядами и их элементами.
/// Работает с @freezed моделями данных.
/// {@endtemplate}
@DriftAccessor(tables: [
  OrdersItems,
  OrderPartsItems,
  OrderServicesItems,
  ClientsItems, // Добавляем для JOIN
  CarsItems // Добавляем для JOIN
])
class OrdersDao extends DatabaseAccessor<AppDatabase> with _$OrdersDaoMixin {
  /// {@macro orders_dao}
  OrdersDao(super.db);

  final _logger = AppLoggers.database;

  // --- Приватные методы маппинга (из таблицы в @freezed) ---

  EntityCoreData _mapToOrderCoreData(OrdersItem item) {
    return EntityCoreData(
      uuid: item.uuid,
      code: item.number, // Используем number как code
      displayName: 'Заказ-наряд №${item.number} от ${item.date.toLocal()}',
      createdAt: item.createdAt,
      modifiedAt: item.modifiedAt,
      deletedAt: item.deletedAt,
      isDeleted: item.deletedAt != null,
    );
  }

  DocumentSpecificData _mapToOrderDocData(OrdersItem item) {
    return DocumentSpecificData(
      status: DocumentStatus.fromString(item.status),
      documentDate: item.date,
      isPosted: item.isPosted,
      postedAt: item.isPosted ? item.modifiedAt : null, // Примерная логика
    );
  }

  OrderSpecificData _mapToOrderSpecificData(OrdersItem item) {
    return OrderSpecificData(
      clientId: item.clientUuid,
      carId: item.carUuid,
      description: item.description,
      // Добавить другие поля при необходимости
    );
  }

  OrderHeaderData _mapToOrderHeaderData(OrdersItem item) {
    return OrderHeaderData(
      coreData: _mapToOrderCoreData(item),
      docData: _mapToOrderDocData(item),
      orderData: _mapToOrderSpecificData(item),
    );
  }

  ItemCoreData _mapToPartCoreData(OrderPartsItem item) {
    return ItemCoreData(
      uuid: item.uuid,
      name: item.name,
      itemType: BaseItemType.part,
      lineNumber: item.lineNumber,
      data: {}, // Можно добавить доп. данные при необходимости
    );
  }

  DocumentItemSpecificData _mapToPartDocItemData(OrderPartsItem item) {
    return DocumentItemSpecificData(
      price: item.price,
      quantity: item.quantity,
      isCompleted: item.isReceived, // Завершено = Получено
    );
  }

  PartSpecificData _mapToPartSpecificData(OrderPartsItem item) {
    return PartSpecificData(
      documentUuid: item.documentUuid,
      partNumber: item.partNumber,
      brand: item.brand,
      supplierName: item.supplierName,
      deliveryDays: item.deliveryDays,
      isOrdered: item.isOrdered,
      isReceived: item.isReceived,
    );
  }

  FullOrderItemData _mapToFullPartData(OrderPartsItem item) {
    return FullOrderItemData(
      coreData: _mapToPartCoreData(item),
      docItemData: _mapToPartDocItemData(item),
      itemType: BaseItemType.part,
      partData: _mapToPartSpecificData(item),
    );
  }

  ItemCoreData _mapToServiceCoreData(OrderServicesItem item) {
    return ItemCoreData(
      uuid: item.uuid,
      name: item.name,
      itemType: BaseItemType.service,
      lineNumber: item.lineNumber,
      data: {},
    );
  }

  DocumentItemSpecificData _mapToServiceDocItemData(OrderServicesItem item) {
    return DocumentItemSpecificData(
      price: item.price,
      quantity: 1.0, // Услуги обычно имеют количество 1
      isCompleted: item.isCompleted,
    );
  }

  ServiceSpecificData _mapToServiceSpecificData(OrderServicesItem item) {
    return ServiceSpecificData(
      documentUuid: item.documentUuid,
      duration: item.duration,
      performedBy: item.performedBy,
    );
  }

  FullOrderItemData _mapToFullServiceData(OrderServicesItem item) {
    return FullOrderItemData(
      coreData: _mapToServiceCoreData(item),
      docItemData: _mapToServiceDocItemData(item),
      itemType: BaseItemType.service,
      serviceData: _mapToServiceSpecificData(item),
    );
  }

  // --- Публичные методы DAO ---

  /// Возвращает поток списка заголовков активных заказ-нарядов.
  Stream<List<OrderHeaderData>> watchActiveOrderHeaders() {
    final query = select(ordersItems)..where((o) => o.deletedAt.isNull());
    return query
        .watch()
        .map((rows) => rows.map(_mapToOrderHeaderData).toList());
  }

  /// Возвращает заголовок заказ-наряда по UUID.
  Future<OrderHeaderData?> getOrderHeaderByUuid(String uuid) async {
    final item = await (select(ordersItems)
          ..where((o) => o.uuid.equals(uuid) & o.deletedAt.isNull()))
        .getSingleOrNull();
    return item != null ? _mapToOrderHeaderData(item) : null;
  }

  /// Возвращает заголовки заказ-нарядов клиента по UUID клиента.
  Future<List<OrderHeaderData>> getOrderHeadersByClientUuid(
      String clientUuid) async {
    final items = await (select(ordersItems)
          ..where(
              (o) => o.clientUuid.equals(clientUuid) & o.deletedAt.isNull()))
        .get();
    return items.map(_mapToOrderHeaderData).toList();
  }

  /// Реактивно наблюдает за заголовком заказ-наряда по UUID.
  Stream<OrderHeaderData?> watchOrderHeaderByUuid(String uuid) {
    return (select(ordersItems)
          ..where((o) => o.uuid.equals(uuid) & o.deletedAt.isNull()))
        .watchSingleOrNull()
        .map((item) => item != null ? _mapToOrderHeaderData(item) : null);
  }

  /// Возвращает заголовки заказ-нарядов автомобиля по UUID автомобиля.
  Future<List<OrderHeaderData>> getOrderHeadersByCarUuid(String carUuid) async {
    final items = await (select(ordersItems)
          ..where((o) => o.carUuid.equals(carUuid) & o.deletedAt.isNull()))
        .get();
    return items.map(_mapToOrderHeaderData).toList();
  }

  /// Возвращает заголовки заказ-нарядов по статусу.
  Future<List<OrderHeaderData>> getOrderHeadersByStatus(
      DocumentStatus status) async {
    final items = await (select(ordersItems)
          ..where((o) => o.status.equals(status.name) & o.deletedAt.isNull()))
        .get();
    return items.map(_mapToOrderHeaderData).toList();
  }

  /// Добавляет новый заказ-наряд. Принимает @freezed модели.
  Future<int> insertOrder(EntityCoreData core, DocumentSpecificData doc,
      OrderSpecificData order) async {
    // Добавляем проверку на null для обязательных внешних ключей
    if (order.clientId == null) {
      final errorMsg = 'clientId не может быть null при добавлении заказа.';
      _logger.e(errorMsg);
      throw ArgumentError(errorMsg);
    }
    if (order.carId == null) {
      final errorMsg = 'carId не может быть null при добавлении заказа.';
      _logger.e(errorMsg);
      throw ArgumentError(errorMsg);
    }
    final companion = OrdersItemsCompanion(
      uuid: Value(core.uuid),
      clientUuid: Value(order.clientId!),
      carUuid: Value(order.carId!),
      number: Value(core.code), // Используем code как number
      date: Value(doc.documentDate),
      scheduledDate: Value(doc.scheduledDate),
      completedAt: Value(doc.completedAt),
      status: Value(doc.status.name),
      description: Value(order.description ?? ''),
      totalAmount: Value(doc.totalAmount ?? 0.0),
      isPosted: Value(doc.isPosted),
      createdAt: Value(core.createdAt),
      modifiedAt: Value(core.modifiedAt ?? core.createdAt),
      deletedAt: Value(core.deletedAt),
    );
    _logger.d(LogMessages.orderInserting.replaceAll('{uuid}', core.uuid));
    try {
      return await into(ordersItems).insert(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderAddError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет существующий заказ-наряд. Принимает @freezed модели.
  Future<int> updateOrder(EntityCoreData core, DocumentSpecificData doc,
      OrderSpecificData order) async {
    // Добавляем проверку на null для обязательных внешних ключей
    if (order.clientId == null) {
      final errorMsg = 'clientId не может быть null при обновлении заказа.';
      _logger.e(errorMsg);
      throw ArgumentError(errorMsg);
    }
    if (order.carId == null) {
      final errorMsg = 'carId не может быть null при обновлении заказа.';
      _logger.e(errorMsg);
      throw ArgumentError(errorMsg);
    }
    final companion = OrdersItemsCompanion(
      // uuid и createdAt не обновляем
      clientUuid: Value(order.clientId!),
      carUuid: Value(order.carId!),
      number: Value(core.code),
      date: Value(doc.documentDate),
      scheduledDate: Value(doc.scheduledDate),
      completedAt: Value(doc.completedAt),
      status: Value(doc.status.name),
      description: Value(order.description ?? ''),
      totalAmount: Value(doc.totalAmount ?? 0.0),
      isPosted: Value(doc.isPosted),
      modifiedAt: Value(DateTime.now()), // Всегда обновляем modifiedAt
      deletedAt: Value(core.deletedAt), // Позволяем обновить/сбросить deletedAt
    );
    _logger.d(LogMessages.orderUpdating.replaceAll('{uuid}', core.uuid));
    try {
      return await (update(ordersItems)..where((o) => o.uuid.equals(core.uuid)))
          .write(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет статус заказ-наряда.
  Future<int> updateOrderStatus(String uuid, DocumentStatus status) {
    _logger.i(LogMessages.orderStatusUpdating
        .replaceAll('{uuid}', uuid)
        .replaceAll('{status}', status.name));
    try {
      return (update(ordersItems)..where((o) => o.uuid.equals(uuid)))
          .write(OrdersItemsCompanion(
        status: Value(status.name),
        modifiedAt: Value(DateTime.now()),
      ));
    } catch (e, s) {
      _logger.e(LogMessages.orderStatusUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Мягкое удаление заказ-наряда по UUID.
  Future<int> softDeleteOrder(String uuid) {
    _logger.i(LogMessages.orderSoftDeleting.replaceAll('{uuid}', uuid));
    try {
      return (update(ordersItems)..where((o) => o.uuid.equals(uuid)))
          .write(OrdersItemsCompanion(
        deletedAt: Value(DateTime.now()),
        modifiedAt: Value(DateTime.now()),
      ));
    } catch (e, s) {
      _logger.e(LogMessages.orderDeleteError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Восстановление удаленного заказ-наряда по UUID.
  Future<int> restoreOrder(String uuid) {
    _logger.i(LogMessages.orderRestoring.replaceAll('{uuid}', uuid));
    try {
      return (update(ordersItems)..where((o) => o.uuid.equals(uuid)))
          .write(OrdersItemsCompanion(
        deletedAt: Value(null),
        modifiedAt:
            Value(DateTime.now()), // Обновляем modifiedAt при восстановлении
      ));
    } catch (e, s) {
      _logger.e(LogMessages.orderRestoreError, error: e, stackTrace: s);
      rethrow;
    }
  }

  // --- Методы для получения UUID заказов ---

  /// Возвращает список UUID активных заказ-нарядов.
  Future<List<String?>> getActiveOrderUuids() async {
    final query = selectOnly(ordersItems)
      ..where(ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    final result = await query.get();
    return result.map((row) => row.read(ordersItems.uuid)).toList();
  }

  /// Реактивно наблюдает за списком UUID активных заказ-нарядов.
  Stream<List<String?>> watchActiveOrderUuids() {
    final query = selectOnly(ordersItems)
      ..where(ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    return query
        .watch()
        .map((rows) => rows.map((row) => row.read(ordersItems.uuid)).toList());
  }

  /// Возвращает список UUID заказ-нарядов клиента.
  Future<List<String?>> getOrderUuidsByClientUuid(String clientUuid) async {
    final query = selectOnly(ordersItems)
      ..where(ordersItems.clientUuid.equals(clientUuid) &
          ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    final result = await query.get();
    return result.map((row) => row.read(ordersItems.uuid)).toList();
  }

  /// Возвращает список UUID заказ-нарядов автомобиля.
  Future<List<String?>> getOrderUuidsByCarUuid(String carUuid) async {
    final query = selectOnly(ordersItems)
      ..where(
          ordersItems.carUuid.equals(carUuid) & ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    final result = await query.get();
    return result.map((row) => row.read(ordersItems.uuid)).toList();
  }

  /// Возвращает список UUID заказ-нарядов по статусу.
  Future<List<String?>> getOrderUuidsByStatus(DocumentStatus status) async {
    final query = selectOnly(ordersItems)
      ..where(ordersItems.status.equals(status.name) &
          ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    final result = await query.get();
    return result.map((row) => row.read(ordersItems.uuid)).toList();
  }

  /// Возвращает список UUID заказ-нарядов по строке поиска.
  Future<List<String?>> searchOrderUuids(String query) async {
    if (query.isEmpty) return [];
    final lowerQuery = '%${query.toLowerCase()}%';
    final queryBuilder = selectOnly(ordersItems)
      ..where((ordersItems.number.lower().like(lowerQuery) |
              ordersItems.description.lower().like(lowerQuery)) &
          ordersItems.deletedAt.isNull())
      ..addColumns([ordersItems.uuid]);
    final result = await queryBuilder.get();
    return result.map((row) => row.read(ordersItems.uuid)).toList();
  }

  // --- Методы для работы с элементами заказ-наряда ---

  /// Возвращает поток списка элементов (запчастей и услуг) для заказ-наряда,
  /// отсортированный по номеру строки.
  Stream<List<FullOrderItemData>> watchOrderItems(String orderUuid) {
    final partsStream = (select(orderPartsItems)
          ..where((p) => p.documentUuid.equals(orderUuid)))
        .watch()
        .map((parts) => parts.map(_mapToFullPartData).toList());

    final servicesStream = (select(orderServicesItems)
          ..where((s) => s.documentUuid.equals(orderUuid)))
        .watch()
        .map((services) => services.map(_mapToFullServiceData).toList());

    // Объединяем потоки запчастей и услуг, используя ZipStream
    return ZipStream([partsStream, servicesStream], (data) {
      final List<FullOrderItemData> parts = data[0];
      final List<FullOrderItemData> services = data[1];
      final combined = [...parts, ...services];
      // Сортируем объединенный список по номеру строки
      combined.sort(
          (a, b) => a.coreData.lineNumber.compareTo(b.coreData.lineNumber));
      return combined;
    });
  }

  /// Возвращает список элементов (запчастей и услуг) для заказ-наряда.
  Future<List<FullOrderItemData>> getOrderItems(String orderUuid) async {
    final parts = await (select(orderPartsItems)
          ..where((p) => p.documentUuid.equals(orderUuid)))
        .get();
    final services = await (select(orderServicesItems)
          ..where((s) => s.documentUuid.equals(orderUuid)))
        .get();

    final combined = [
      ...parts.map(_mapToFullPartData),
      ...services.map(_mapToFullServiceData),
    ];
    combined
        .sort((a, b) => a.coreData.lineNumber.compareTo(b.coreData.lineNumber));
    return combined;
  }

  /// Добавляет новую запчасть в заказ-наряд.
  Future<int> insertOrderPart(ItemCoreData core,
      DocumentItemSpecificData docItem, PartSpecificData part) async {
    final companion = OrderPartsItemsCompanion(
      uuid: Value(core.uuid),
      documentUuid: Value(part.documentUuid),
      lineNumber: Value(core.lineNumber), // Сохраняем номер строки
      partNumber: Value(part.partNumber),
      name: Value(core.name),
      brand: Value(part.brand),
      quantity: Value(docItem.quantity ?? 0.0),
      price: Value(docItem.price ?? 0.0),
      supplierName: Value(part.supplierName),
      deliveryDays: Value(part.deliveryDays),
      isOrdered: Value(part.isOrdered),
      isReceived: Value(part.isReceived),
      createdAt: Value(DateTime.now()),
    );
    _logger.d(LogMessages.orderItemInserting
        .replaceAll('{itemUuid}', core.uuid)
        .replaceAll('{orderUuid}', part.documentUuid));
    try {
      return await into(orderPartsItems).insert(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderItemAddError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет существующую запчасть заказ-наряда.
  Future<int> updateOrderPart(ItemCoreData core,
      DocumentItemSpecificData docItem, PartSpecificData part) async {
    final companion = OrderPartsItemsCompanion(
      // uuid, documentUuid, createdAt не обновляем
      lineNumber: Value(core.lineNumber), // Обновляем номер строки
      partNumber: Value(part.partNumber),
      name: Value(core.name),
      brand: Value(part.brand),
      quantity: Value(docItem.quantity ?? 0.0),
      price: Value(docItem.price ?? 0.0),
      supplierName: Value(part.supplierName),
      deliveryDays: Value(part.deliveryDays),
      isOrdered: Value(part.isOrdered),
      isReceived: Value(part.isReceived),
      modifiedAt: Value(DateTime.now()),
    );
    _logger.d(LogMessages.orderItemUpdating
        .replaceAll('{itemUuid}', core.uuid)
        .replaceAll('{orderUuid}', part.documentUuid));
    try {
      return await (update(orderPartsItems)
            ..where((p) => p.uuid.equals(core.uuid)))
          .write(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderItemUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Удаляет запчасть из заказ-наряда по UUID.
  Future<int> deleteOrderPart(String itemUuid) {
    // Не логируем orderUuid здесь, т.к. он не передается
    _logger.i(LogMessages.orderItemDeleting.replaceAll('{itemUuid}', itemUuid));
    try {
      return (delete(orderPartsItems)..where((p) => p.uuid.equals(itemUuid)))
          .go();
    } catch (e, s) {
      _logger.e(LogMessages.orderItemDeleteError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Добавляет новую услугу в заказ-наряд.
  Future<int> insertOrderService(ItemCoreData core,
      DocumentItemSpecificData docItem, ServiceSpecificData service) async {
    final companion = OrderServicesItemsCompanion(
      uuid: Value(core.uuid),
      documentUuid: Value(service.documentUuid),
      lineNumber: Value(core.lineNumber), // Сохраняем номер строки
      name: Value(core.name),
      description: Value(null),
      price: Value(docItem.price ?? 0.0),
      duration: Value(service.duration),
      performedBy: Value(service.performedBy),
      isCompleted: Value(docItem.isCompleted),
      createdAt: Value(DateTime.now()),
    );
    _logger.d(LogMessages.orderItemInserting
        .replaceAll('{itemUuid}', core.uuid)
        .replaceAll('{orderUuid}', service.documentUuid));
    try {
      return await into(orderServicesItems).insert(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderItemAddError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет существующую услугу заказ-наряда.
  Future<int> updateOrderService(ItemCoreData core,
      DocumentItemSpecificData docItem, ServiceSpecificData service) async {
    final companion = OrderServicesItemsCompanion(
      // uuid, documentUuid, createdAt не обновляем
      lineNumber: Value(core.lineNumber), // Обновляем номер строки
      name: Value(core.name),
      description: Value(null),
      price: Value(docItem.price ?? 0.0),
      duration: Value(service.duration),
      performedBy: Value(service.performedBy),
      isCompleted: Value(docItem.isCompleted),
      modifiedAt: Value(DateTime.now()),
    );
    _logger.d(LogMessages.orderItemUpdating
        .replaceAll('{itemUuid}', core.uuid)
        .replaceAll('{orderUuid}', service.documentUuid));
    try {
      return await (update(orderServicesItems)
            ..where((s) => s.uuid.equals(core.uuid)))
          .write(companion);
    } catch (e, s) {
      _logger.e(LogMessages.orderItemUpdateError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Удаляет услугу из заказ-наряда по UUID.
  Future<int> deleteOrderService(String itemUuid) {
    _logger.i(LogMessages.orderItemDeleting.replaceAll('{itemUuid}', itemUuid));
    try {
      return (delete(orderServicesItems)..where((s) => s.uuid.equals(itemUuid)))
          .go();
    } catch (e, s) {
      _logger.e(LogMessages.orderItemDeleteError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Возвращает поток полных данных заказ-наряда (заголовок + элементы).
  Stream<FullOrderData?> watchFullOrderData(String orderUuid) {
    final headerStream = (select(ordersItems)
          ..where((o) => o.uuid.equals(orderUuid) & o.deletedAt.isNull()))
        .watchSingleOrNull() // Используем watchSingleOrNull для обработки удаления
        .map((item) => item != null ? _mapToOrderHeaderData(item) : null);

    final itemsStream = watchOrderItems(orderUuid);

    // Объединяем поток заголовка и поток элементов, используя ZipStream
    return ZipStream([headerStream, itemsStream], (data) {
      // data[0] - это OrderHeaderData? (из headerStream)
      // data[1] - это List<FullOrderItemData> (из itemsStream)
      final OrderHeaderData? header =
          data[0] as OrderHeaderData?; // Приводим тип
      final List<FullOrderItemData> items =
          data[1] as List<FullOrderItemData>; // Приводим тип

      if (header == null) {
        return null; // Заказ-наряд не найден или удален
      }

      return FullOrderData(headerData: header, items: items);
    });
  }

  /// Поиск заголовков заказ-нарядов по строке (номер, описание).
  Future<List<OrderHeaderData>> searchOrderHeaders(String query) async {
    if (query.isEmpty) return [];
    final lowerQuery = '%${query.toLowerCase()}%';

    // TODO: Добавить поиск по имени клиента/автомобиля через JOIN?
    final items = await (select(ordersItems)
          ..where((o) =>
              (o.number.lower().like(lowerQuery) |
                  o.description.lower().like(lowerQuery)) & // Добавили lower()
              o.deletedAt.isNull()))
        .get();
    return items.map(_mapToOrderHeaderData).toList();
  }

  // --- Метод для сохранения полных данных заказа (в транзакции) ---

  /// Сохраняет полные данные заказ-наряда (заголовок и элементы) в транзакции.
  /// Если заказ новый, он будет вставлен. Если существующий - обновлен.
  /// Элементы синхронизируются: существующие обновляются, новые добавляются, отсутствующие удаляются.
  Future<void> saveFullOrderData(
    EntityCoreData coreData,
    DocumentSpecificData docData,
    OrderSpecificData orderData,
    List<Tuple3<ItemCoreData, DocumentItemSpecificData, dynamic>> itemsData,
  ) async {
    _logger.d('Сохранение полных данных заказа ${coreData.uuid}');
    try {
      await transaction(() async {
        // 1. Проверяем, существует ли заказ
        final existingOrder = await (select(ordersItems)
              ..where((o) => o.uuid.equals(coreData.uuid)))
            .getSingleOrNull();

        // 2. Сохраняем заголовок (insert или update)
        if (existingOrder == null) {
          await insertOrder(coreData, docData, orderData);
        } else {
          // Убедимся, что передаем правильные данные для обновления
          // coreData может содержать старые createdAt, которые не нужно обновлять
          // docData и orderData содержат актуальные данные
          await updateOrder(coreData, docData, orderData);
        }

        // 3. Получаем текущие UUID элементов из БД
        final currentDbPartUuids = await (selectOnly(orderPartsItems)
              ..where(orderPartsItems.documentUuid.equals(coreData.uuid))
              ..addColumns([orderPartsItems.uuid]))
            .get()
            .then((rows) =>
                rows.map((r) => r.read(orderPartsItems.uuid)).toSet());

        final currentDbServiceUuids = await (selectOnly(orderServicesItems)
              ..where(orderServicesItems.documentUuid.equals(coreData.uuid))
              ..addColumns([orderServicesItems.uuid]))
            .get()
            .then((rows) =>
                rows.map((r) => r.read(orderServicesItems.uuid)).toSet());

        // 4. Обрабатываем переданные элементы
        final Set<String> incomingPartUuids = {};
        final Set<String> incomingServiceUuids = {};

        for (final itemTuple in itemsData) {
          final itemCore = itemTuple.item1;
          final itemDoc = itemTuple.item2;
          final itemSpecific = itemTuple.item3;

          if (itemSpecific is PartSpecificData) {
            incomingPartUuids.add(itemCore.uuid);
            if (currentDbPartUuids.contains(itemCore.uuid)) {
              await updateOrderPart(itemCore, itemDoc, itemSpecific);
            } else {
              await insertOrderPart(itemCore, itemDoc, itemSpecific);
            }
          } else if (itemSpecific is ServiceSpecificData) {
            incomingServiceUuids.add(itemCore.uuid);
            if (currentDbServiceUuids.contains(itemCore.uuid)) {
              await updateOrderService(itemCore, itemDoc, itemSpecific);
            } else {
              await insertOrderService(itemCore, itemDoc, itemSpecific);
            }
          }
        }

        // 5. Удаляем элементы, которых нет во входящем списке
        final partsToDelete = currentDbPartUuids.difference(incomingPartUuids);
        // Фильтруем null значения перед итерацией с помощью whereType<String>()
        for (final uuid in partsToDelete.whereType<String>()) {
          // Теперь uuid гарантированно имеет тип String
          await deleteOrderPart(uuid);
        }

        final servicesToDelete =
            currentDbServiceUuids.difference(incomingServiceUuids);
        // Фильтруем null значения перед итерацией с помощью whereType<String>()
        for (final uuid in servicesToDelete.whereType<String>()) {
          // Теперь uuid гарантированно имеет тип String
          await deleteOrderService(uuid); // Строка 750
        }
      });
    } catch (e, s) {
      _logger.e('Ошибка транзакции сохранения заказа ${coreData.uuid}',
          error: e, stackTrace: s);
      rethrow;
    }
  }
}

// Пример кортежа (можно использовать пакет tuple или свой класс)
// Убедитесь, что этот класс или аналогичный импортирован/определен
// там, где он используется (в DAO и Service)
class Tuple3<T1, T2, T3> {
  final T1 item1;
  final T2 item2;
  final T3 item3;
  Tuple3(this.item1, this.item2, this.item3);
}

```

## lib\core\database\daos\orders_dao.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'orders_dao.dart';

// ignore_for_file: type=lint
mixin _$OrdersDaoMixin on DatabaseAccessor<AppDatabase> {
  $ClientsItemsTable get clientsItems => attachedDatabase.clientsItems;
  $CarsItemsTable get carsItems => attachedDatabase.carsItems;
  $OrdersItemsTable get ordersItems => attachedDatabase.ordersItems;
  $OrderPartsItemsTable get orderPartsItems => attachedDatabase.orderPartsItems;
  $OrderServicesItemsTable get orderServicesItems =>
      attachedDatabase.orderServicesItems;
}

```

## lib\core\database\daos\supplier_settings_dao.dart
```dart
import 'package:drift/drift.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/items/supplier_settings_items.dart';

part 'supplier_settings_dao.g.dart';

@DriftAccessor(tables: [SupplierSettingsItems])
class SupplierSettingsDao extends DatabaseAccessor<AppDatabase>
    with _$SupplierSettingsDaoMixin {
  final AppDatabase db;

  SupplierSettingsDao(this.db) : super(db);

  // Получить все настройки поставщиков
  Future<List<SupplierSettingsItem>> getAllSupplierSettings() =>
      select(supplierSettingsItems).get();

  // Наблюдать за всеми настройками поставщиков
  Stream<List<SupplierSettingsItem>> watchAllSupplierSettings() =>
      select(supplierSettingsItems).watch();

  // Получить настройки для конкретного поставщика по коду
  Future<SupplierSettingsItem?> getSupplierSettingByCode(String supplierCode) {
    return (select(supplierSettingsItems)
          ..where((tbl) => tbl.supplierCode.equals(supplierCode)))
        .getSingleOrNull();
  }

  // Наблюдать за настройками конкретного поставщика по коду
  Stream<SupplierSettingsItem?> watchSupplierSettingByCode(
      String supplierCode) {
    return (select(supplierSettingsItems)
          ..where((tbl) => tbl.supplierCode.equals(supplierCode)))
        .watchSingleOrNull();
  }

  // Вставить новую настройку поставщика
  Future<int> insertSupplierSetting(
      SupplierSettingsItemsCompanion entry) async {
    return into(supplierSettingsItems)
        .insert(entry, mode: InsertMode.insertOrReplace);
  }

  // Обновить существующую настройку поставщика
  Future<bool> updateSupplierSetting(
      SupplierSettingsItemsCompanion entry) async {
    return update(supplierSettingsItems).replace(entry);
  }

  // Обновить или вставить настройку поставщика
  Future<int> upsertSupplierSetting(
      SupplierSettingsItemsCompanion entry) async {
    return into(supplierSettingsItems).insertOnConflictUpdate(entry);
  }

  // Удалить настройку поставщика по ID
  Future<int> deleteSupplierSettingById(int id) =>
      (delete(supplierSettingsItems)..where((tbl) => tbl.id.equals(id))).go();

  // Удалить настройку поставщика по коду
  Future<int> deleteSupplierSettingByCode(String supplierCode) =>
      (delete(supplierSettingsItems)
            ..where((tbl) => tbl.supplierCode.equals(supplierCode)))
          .go();

  // Получить все активные настройки поставщиков
  Future<List<SupplierSettingsItem>> getActiveSupplierSettings() {
    return (select(supplierSettingsItems)
          ..where((tbl) => tbl.isEnabled.equals(true)))
        .get();
  }

  // Наблюдать за всеми активными настройками поставщиков
  Stream<List<SupplierSettingsItem>> watchActiveSupplierSettings() {
    return (select(supplierSettingsItems)
          ..where((tbl) => tbl.isEnabled.equals(true)))
        .watch();
  }
}

```

## lib\core\database\daos\supplier_settings_dao.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'supplier_settings_dao.dart';

// ignore_for_file: type=lint
mixin _$SupplierSettingsDaoMixin on DatabaseAccessor<AppDatabase> {
  $SupplierSettingsItemsTable get supplierSettingsItems =>
      attachedDatabase.supplierSettingsItems;
}

```

## lib\core\database\database.dart
```dart
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/service_locator.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:drift/native.dart';
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';
import 'dart:io';
import 'package:logger/logger.dart';
import 'schema_synchronizer.dart';
import 'package:uuid/uuid.dart';

// импорты таблиц
import 'items/clients_items.dart';
import 'items/cars_items.dart';
import 'items/app_info_items.dart';
import 'items/orders_items.dart';
import 'items/order_parts_items.dart';
import 'items/order_services_items.dart';
import 'items/supplier_settings_items.dart';

// импорты DAO
import 'daos/clients_dao.dart';
import 'daos/cars_dao.dart';
import 'daos/orders_dao.dart';
import 'daos/supplier_settings_dao.dart';

part 'database.g.dart';

/// {@template app_database}
/// База данных приложения, использующая Drift ORM.
/// {@endtemplate}
@DriftDatabase(
  tables: [
    ClientsItems,
    CarsItems,
    AppInfoItems,
    OrdersItems,
    OrderPartsItems,
    OrderServicesItems,
    SupplierSettingsItems
  ],
  daos: [ClientsDao, CarsDao, OrdersDao, SupplierSettingsDao],
) // Обновлены имена таблиц
class AppDatabase extends _$AppDatabase {
  /// {@macro app_database}
  AppDatabase([QueryExecutor? executor]) : super(executor ?? _openConnection());

  /// Логгер для отслеживания операций с базой данных.
  final Logger _logger = Logger();

  @override
  int get schemaVersion => 11; // Увеличиваем версию из-за изменения схемы

  /// Получает экземпляр DAO клиентов.
  @override
  ClientsDao get clientsDao => ClientsDao(this);

  /// Получает экземпляр DAO автомобилей.
  @override
  CarsDao get carsDao => CarsDao(this);

  /// Получает экземпляр DAO заказ-нарядов.
  @override
  OrdersDao get ordersDao => OrdersDao(this);

  /// Получает экземпляр DAO настройки поставщиков.
  @override
  SupplierSettingsDao get supplierSettingsDao => SupplierSettingsDao(this);

  // Определите стратегию миграции
  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) async {
          // Создаём все таблицы при первом запуске
          await m.createAll();
          await setAppVersion(schemaVersion);
        },
        onUpgrade: (Migrator m, int from, int to) async {
          // Создаем таблицу AppInfo, если её ещё нет (нужно в любом случае)
          await m.createTable(appInfoItems);
          // Обновляем версию в таблице AppInfo
          await setAppVersion(to);
        },
        beforeOpen: (details) async {
          if (details.wasCreated) {
            _logger.i('База данных была создана с нуля');
          }

          // Включаем внешние ключи
          await customStatement('PRAGMA foreign_keys = ON');

          if (details.hadUpgrade) {
            _logger.i(
                'База данных была обновлена с версии ${details.versionBefore} до ${details.versionNow}');
          }

          // Проверяем, требуется ли синхронизация схемы
          await _checkAndSynchronizeSchema();
        },
      );

  /// Проверяет необходимость синхронизации схемы и выполняет её при необходимости
  Future<void> _checkAndSynchronizeSchema() async {
    try {
      // Проверяем, существует ли таблица AppInfo
      final tableExists = await customSelect(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='app_info'",
      ).get().then((result) => result.isNotEmpty);

      if (!tableExists) {
        _logger.i('Таблица app_info не найдена, создаем её');
        await customStatement('''
          CREATE TABLE IF NOT EXISTS app_info (
            key TEXT PRIMARY KEY,
            value TEXT NOT NULL
          )
        ''');
        await setAppVersion(schemaVersion);
        await _runSchemaSynchronization();
        return;
      }

      // Получаем сохраненную версию схемы
      final savedVersion = await getAppVersion();
      if (savedVersion == null || savedVersion != schemaVersion) {
        _logger.i('Обнаружено несоответствие версий: '
            'сохраненная=$savedVersion, текущая=$schemaVersion');

        await _runSchemaSynchronization();

        // Обновляем версию после синхронизации
        await setAppVersion(schemaVersion);
      } else {
        _logger.i(
            'Синхронизация схемы не требуется, версии совпадают: $savedVersion');
      }
    } catch (e) {
      _logger.e('Ошибка при проверке/синхронизации схемы: $e');
    }
  }

  /// Запускает синхронизацию схемы БД
  Future<void> _runSchemaSynchronization() async {
    _logger.i('Запуск синхронизации схемы БД...');

    final synchronizer = SchemaSynchronizer(this, _logger);
    await synchronizer.synchronize();

    _logger.i('Синхронизация схемы завершена');
  }

  /// Получает сохраненную версию схемы из таблицы AppInfo
  Future<int?> getAppVersion() async {
    try {
      final result = await (select(appInfoItems)
            ..where((t) => t.key.equals('schema_version')))
          .getSingleOrNull();

      return result != null ? int.tryParse(result.value) : null;
    } catch (e) {
      _logger.e('Ошибка при получении версии схемы: $e');
      return null;
    }
  }

  /// Сохраняет версию схемы в таблицу AppInfo
  Future<void> setAppVersion(int version) async {
    try {
      await into(appInfoItems).insertOnConflictUpdate(
        AppInfoItemsCompanion.insert(
          key: 'schema_version',
          value: version.toString(),
        ),
      );
      _logger.i('Версия схемы $version сохранена в БД');
    } catch (e) {
      _logger.e('Ошибка при сохранении версии схемы: $e');
    }
  }

  /// Удаляет файл базы данных.
  ///
  /// Используется для отладки и сброса базы данных к начальному состоянию.
  Future<void> deleteDatabase() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    if (await file.exists()) {
      await file.delete();
      close();
      _logger.i('База данных была удалена');
    }
  }

  /// Создает резервную копию базы данных.
  ///
  /// Возвращает путь к созданному файлу резервной копии.
  Future<String> backupDatabase() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final dbFile = File(p.join(dbFolder.path, 'db.sqlite'));
    final backupFolder = Directory(p.join(dbFolder.path, 'backups'));

    if (!await backupFolder.exists()) {
      await backupFolder.create(recursive: true);
    }

    final timestamp = DateTime.now().toIso8601String().replaceAll(':', '-');
    final backupFile =
        File(p.join(backupFolder.path, 'db_backup_$timestamp.sqlite'));

    await dbFile.copy(backupFile.path);
    _logger.i('Создана резервная копия БД: ${backupFile.path}');
    return backupFile.path;
  }

  /// Сбрасывает базу данных (удаляет и создает заново)
  ///
  /// Создает временный файл и переключает приложение на него,
  /// чтобы безопасно удалить оригинальный файл базы данных.
  Future<void> resetDatabase() async {
    try {
      _logger.i('Начинаем процесс сброса базы данных...');

      // Закрываем текущее соединение
      close();

      // Создаем временный файл для хранения новой базы данных
      final dbFolder = await getApplicationDocumentsDirectory();
      final oldDbPath = p.join(dbFolder.path, 'db.sqlite');
      final tempDbPath = p.join(dbFolder.path,
          'db_temp_${DateTime.now().millisecondsSinceEpoch}.sqlite');

      // Создаем пустой временный файл
      final tempFile = File(tempDbPath);
      if (!await tempFile.exists()) {
        await tempFile.create();
        _logger.i('Создан временный файл: $tempDbPath');
      }

      // Удаляем старый файл, если можно
      final oldFile = File(oldDbPath);
      if (await oldFile.exists()) {
        try {
          await oldFile.delete();
          _logger.i('Старый файл базы данных удален');
        } catch (e) {
          _logger.w('Не удалось удалить старый файл базы данных: $e');
          // Если не удалось удалить, попробуем переименовать
          final backupPath = p.join(dbFolder.path,
              'db_old_${DateTime.now().millisecondsSinceEpoch}.sqlite');
          await oldFile.rename(backupPath);
          _logger.i('Старый файл базы данных переименован в: $backupPath');
        }
      }

      // Перемещаем временный файл на место основного
      await tempFile.rename(oldDbPath);
      _logger.i('Временный файл перемещен на место основного');

      _logger.i('База данных успешно сброшена');
    } catch (e) {
      _logger.e('Ошибка при сбросе базы данных: $e');
      rethrow;
    }
  }

  /// Проверяет существование всех таблиц и создает их при необходимости
  Future<void> ensureDatabaseReady() async {
    // Проверяем существование таблицы клиентов
    final clientsTableExists = await customSelect(
      "SELECT name FROM sqlite_master WHERE type='table' AND name='clients_items'",
    ).get().then((result) => result.isNotEmpty);

    if (!clientsTableExists) {
      _logger
          .w('Таблица clients_items не найдена, выполняем создание схемы...');

      // Создаем все таблицы принудительно
      final migrator = Migrator(this);
      for (var table in allTables) {
        _logger.i('Создание таблицы: ${table.actualTableName}');
        await migrator.createTable(table);
      }

      // Обновляем версию
      await setAppVersion(schemaVersion);

      _logger.i('Инициализация схемы БД завершена');
    }
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));

    // Обходное решение для старых версий Android
    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
    }

    return NativeDatabase.createInBackground(file);
  });
}

// Провайдер для AppDatabase, получающий экземпляр из locator
final appDatabaseProvider = Provider<AppDatabase>((ref) {
  return locator<AppDatabase>();
});

```

## lib\core\database\database.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $ClientsItemsTable extends ClientsItems
    with TableInfo<$ClientsItemsTable, ClientsItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClientsItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => const Uuid().v4());
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _contactInfoMeta =
      const VerificationMeta('contactInfo');
  @override
  late final GeneratedColumn<String> contactInfo = GeneratedColumn<String>(
      'contact_info', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _additionalInfoMeta =
      const VerificationMeta('additionalInfo');
  @override
  late final GeneratedColumn<String> additionalInfo = GeneratedColumn<String>(
      'additional_info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _modifiedAtMeta =
      const VerificationMeta('modifiedAt');
  @override
  late final GeneratedColumn<DateTime> modifiedAt = GeneratedColumn<DateTime>(
      'modified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deletedAtMeta =
      const VerificationMeta('deletedAt');
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
      'deleted_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        code,
        type,
        name,
        contactInfo,
        additionalInfo,
        createdAt,
        modifiedAt,
        deletedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'clients_items';
  @override
  VerificationContext validateIntegrity(Insertable<ClientsItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('contact_info')) {
      context.handle(
          _contactInfoMeta,
          contactInfo.isAcceptableOrUnknown(
              data['contact_info']!, _contactInfoMeta));
    } else if (isInserting) {
      context.missing(_contactInfoMeta);
    }
    if (data.containsKey('additional_info')) {
      context.handle(
          _additionalInfoMeta,
          additionalInfo.isAcceptableOrUnknown(
              data['additional_info']!, _additionalInfoMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('modified_at')) {
      context.handle(
          _modifiedAtMeta,
          modifiedAt.isAcceptableOrUnknown(
              data['modified_at']!, _modifiedAtMeta));
    }
    if (data.containsKey('deleted_at')) {
      context.handle(_deletedAtMeta,
          deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClientsItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClientsItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      contactInfo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_info'])!,
      additionalInfo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}additional_info']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      modifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}modified_at']),
      deletedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}deleted_at']),
    );
  }

  @override
  $ClientsItemsTable createAlias(String alias) {
    return $ClientsItemsTable(attachedDatabase, alias);
  }
}

class ClientsItem extends DataClass implements Insertable<ClientsItem> {
  final int id;
  final String uuid;
  final String code;
  final String type;
  final String name;
  final String contactInfo;
  final String? additionalInfo;
  final DateTime createdAt;
  final DateTime? modifiedAt;
  final DateTime? deletedAt;
  const ClientsItem(
      {required this.id,
      required this.uuid,
      required this.code,
      required this.type,
      required this.name,
      required this.contactInfo,
      this.additionalInfo,
      required this.createdAt,
      this.modifiedAt,
      this.deletedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['code'] = Variable<String>(code);
    map['type'] = Variable<String>(type);
    map['name'] = Variable<String>(name);
    map['contact_info'] = Variable<String>(contactInfo);
    if (!nullToAbsent || additionalInfo != null) {
      map['additional_info'] = Variable<String>(additionalInfo);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || modifiedAt != null) {
      map['modified_at'] = Variable<DateTime>(modifiedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  ClientsItemsCompanion toCompanion(bool nullToAbsent) {
    return ClientsItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      code: Value(code),
      type: Value(type),
      name: Value(name),
      contactInfo: Value(contactInfo),
      additionalInfo: additionalInfo == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalInfo),
      createdAt: Value(createdAt),
      modifiedAt: modifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory ClientsItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClientsItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      code: serializer.fromJson<String>(json['code']),
      type: serializer.fromJson<String>(json['type']),
      name: serializer.fromJson<String>(json['name']),
      contactInfo: serializer.fromJson<String>(json['contactInfo']),
      additionalInfo: serializer.fromJson<String?>(json['additionalInfo']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      modifiedAt: serializer.fromJson<DateTime?>(json['modifiedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'code': serializer.toJson<String>(code),
      'type': serializer.toJson<String>(type),
      'name': serializer.toJson<String>(name),
      'contactInfo': serializer.toJson<String>(contactInfo),
      'additionalInfo': serializer.toJson<String?>(additionalInfo),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'modifiedAt': serializer.toJson<DateTime?>(modifiedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  ClientsItem copyWith(
          {int? id,
          String? uuid,
          String? code,
          String? type,
          String? name,
          String? contactInfo,
          Value<String?> additionalInfo = const Value.absent(),
          DateTime? createdAt,
          Value<DateTime?> modifiedAt = const Value.absent(),
          Value<DateTime?> deletedAt = const Value.absent()}) =>
      ClientsItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        code: code ?? this.code,
        type: type ?? this.type,
        name: name ?? this.name,
        contactInfo: contactInfo ?? this.contactInfo,
        additionalInfo:
            additionalInfo.present ? additionalInfo.value : this.additionalInfo,
        createdAt: createdAt ?? this.createdAt,
        modifiedAt: modifiedAt.present ? modifiedAt.value : this.modifiedAt,
        deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
      );
  ClientsItem copyWithCompanion(ClientsItemsCompanion data) {
    return ClientsItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      code: data.code.present ? data.code.value : this.code,
      type: data.type.present ? data.type.value : this.type,
      name: data.name.present ? data.name.value : this.name,
      contactInfo:
          data.contactInfo.present ? data.contactInfo.value : this.contactInfo,
      additionalInfo: data.additionalInfo.present
          ? data.additionalInfo.value
          : this.additionalInfo,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      modifiedAt:
          data.modifiedAt.present ? data.modifiedAt.value : this.modifiedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ClientsItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('contactInfo: $contactInfo, ')
          ..write('additionalInfo: $additionalInfo, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, code, type, name, contactInfo,
      additionalInfo, createdAt, modifiedAt, deletedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClientsItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.code == this.code &&
          other.type == this.type &&
          other.name == this.name &&
          other.contactInfo == this.contactInfo &&
          other.additionalInfo == this.additionalInfo &&
          other.createdAt == this.createdAt &&
          other.modifiedAt == this.modifiedAt &&
          other.deletedAt == this.deletedAt);
}

class ClientsItemsCompanion extends UpdateCompanion<ClientsItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> code;
  final Value<String> type;
  final Value<String> name;
  final Value<String> contactInfo;
  final Value<String?> additionalInfo;
  final Value<DateTime> createdAt;
  final Value<DateTime?> modifiedAt;
  final Value<DateTime?> deletedAt;
  const ClientsItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.code = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.contactInfo = const Value.absent(),
    this.additionalInfo = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  });
  ClientsItemsCompanion.insert({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    required String code,
    required String type,
    required String name,
    required String contactInfo,
    this.additionalInfo = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  })  : code = Value(code),
        type = Value(type),
        name = Value(name),
        contactInfo = Value(contactInfo);
  static Insertable<ClientsItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? code,
    Expression<String>? type,
    Expression<String>? name,
    Expression<String>? contactInfo,
    Expression<String>? additionalInfo,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? modifiedAt,
    Expression<DateTime>? deletedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (code != null) 'code': code,
      if (type != null) 'type': type,
      if (name != null) 'name': name,
      if (contactInfo != null) 'contact_info': contactInfo,
      if (additionalInfo != null) 'additional_info': additionalInfo,
      if (createdAt != null) 'created_at': createdAt,
      if (modifiedAt != null) 'modified_at': modifiedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
    });
  }

  ClientsItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? code,
      Value<String>? type,
      Value<String>? name,
      Value<String>? contactInfo,
      Value<String?>? additionalInfo,
      Value<DateTime>? createdAt,
      Value<DateTime?>? modifiedAt,
      Value<DateTime?>? deletedAt}) {
    return ClientsItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      code: code ?? this.code,
      type: type ?? this.type,
      name: name ?? this.name,
      contactInfo: contactInfo ?? this.contactInfo,
      additionalInfo: additionalInfo ?? this.additionalInfo,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
      deletedAt: deletedAt ?? this.deletedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (contactInfo.present) {
      map['contact_info'] = Variable<String>(contactInfo.value);
    }
    if (additionalInfo.present) {
      map['additional_info'] = Variable<String>(additionalInfo.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (modifiedAt.present) {
      map['modified_at'] = Variable<DateTime>(modifiedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClientsItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('contactInfo: $contactInfo, ')
          ..write('additionalInfo: $additionalInfo, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }
}

class $CarsItemsTable extends CarsItems
    with TableInfo<$CarsItemsTable, CarsItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CarsItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => const Uuid().v4());
  static const VerificationMeta _clientIdMeta =
      const VerificationMeta('clientId');
  @override
  late final GeneratedColumn<int> clientId = GeneratedColumn<int>(
      'client_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES clients_items (id)'));
  static const VerificationMeta _vinMeta = const VerificationMeta('vin');
  @override
  late final GeneratedColumn<String> vin = GeneratedColumn<String>(
      'vin', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _makeMeta = const VerificationMeta('make');
  @override
  late final GeneratedColumn<String> make = GeneratedColumn<String>(
      'make', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _modelMeta = const VerificationMeta('model');
  @override
  late final GeneratedColumn<String> model = GeneratedColumn<String>(
      'model', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _yearMeta = const VerificationMeta('year');
  @override
  late final GeneratedColumn<int> year = GeneratedColumn<int>(
      'year', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _licensePlateMeta =
      const VerificationMeta('licensePlate');
  @override
  late final GeneratedColumn<String> licensePlate = GeneratedColumn<String>(
      'license_plate', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalInfoMeta =
      const VerificationMeta('additionalInfo');
  @override
  late final GeneratedColumn<String> additionalInfo = GeneratedColumn<String>(
      'additional_info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant(''));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _modifiedAtMeta =
      const VerificationMeta('modifiedAt');
  @override
  late final GeneratedColumn<DateTime> modifiedAt = GeneratedColumn<DateTime>(
      'modified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deletedAtMeta =
      const VerificationMeta('deletedAt');
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
      'deleted_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        clientId,
        vin,
        make,
        model,
        year,
        licensePlate,
        additionalInfo,
        code,
        createdAt,
        modifiedAt,
        deletedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cars_items';
  @override
  VerificationContext validateIntegrity(Insertable<CarsItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('client_id')) {
      context.handle(_clientIdMeta,
          clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta));
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('vin')) {
      context.handle(
          _vinMeta, vin.isAcceptableOrUnknown(data['vin']!, _vinMeta));
    }
    if (data.containsKey('make')) {
      context.handle(
          _makeMeta, make.isAcceptableOrUnknown(data['make']!, _makeMeta));
    } else if (isInserting) {
      context.missing(_makeMeta);
    }
    if (data.containsKey('model')) {
      context.handle(
          _modelMeta, model.isAcceptableOrUnknown(data['model']!, _modelMeta));
    } else if (isInserting) {
      context.missing(_modelMeta);
    }
    if (data.containsKey('year')) {
      context.handle(
          _yearMeta, year.isAcceptableOrUnknown(data['year']!, _yearMeta));
    }
    if (data.containsKey('license_plate')) {
      context.handle(
          _licensePlateMeta,
          licensePlate.isAcceptableOrUnknown(
              data['license_plate']!, _licensePlateMeta));
    }
    if (data.containsKey('additional_info')) {
      context.handle(
          _additionalInfoMeta,
          additionalInfo.isAcceptableOrUnknown(
              data['additional_info']!, _additionalInfoMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('modified_at')) {
      context.handle(
          _modifiedAtMeta,
          modifiedAt.isAcceptableOrUnknown(
              data['modified_at']!, _modifiedAtMeta));
    }
    if (data.containsKey('deleted_at')) {
      context.handle(_deletedAtMeta,
          deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CarsItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CarsItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      clientId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}client_id'])!,
      vin: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}vin']),
      make: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}make'])!,
      model: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}model'])!,
      year: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}year']),
      licensePlate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}license_plate']),
      additionalInfo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}additional_info']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      modifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}modified_at']),
      deletedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}deleted_at']),
    );
  }

  @override
  $CarsItemsTable createAlias(String alias) {
    return $CarsItemsTable(attachedDatabase, alias);
  }
}

class CarsItem extends DataClass implements Insertable<CarsItem> {
  final int id;
  final String uuid;
  final int clientId;
  final String? vin;
  final String make;
  final String model;
  final int? year;
  final String? licensePlate;
  final String? additionalInfo;
  final String code;
  final DateTime createdAt;
  final DateTime? modifiedAt;
  final DateTime? deletedAt;
  const CarsItem(
      {required this.id,
      required this.uuid,
      required this.clientId,
      this.vin,
      required this.make,
      required this.model,
      this.year,
      this.licensePlate,
      this.additionalInfo,
      required this.code,
      required this.createdAt,
      this.modifiedAt,
      this.deletedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['client_id'] = Variable<int>(clientId);
    if (!nullToAbsent || vin != null) {
      map['vin'] = Variable<String>(vin);
    }
    map['make'] = Variable<String>(make);
    map['model'] = Variable<String>(model);
    if (!nullToAbsent || year != null) {
      map['year'] = Variable<int>(year);
    }
    if (!nullToAbsent || licensePlate != null) {
      map['license_plate'] = Variable<String>(licensePlate);
    }
    if (!nullToAbsent || additionalInfo != null) {
      map['additional_info'] = Variable<String>(additionalInfo);
    }
    map['code'] = Variable<String>(code);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || modifiedAt != null) {
      map['modified_at'] = Variable<DateTime>(modifiedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  CarsItemsCompanion toCompanion(bool nullToAbsent) {
    return CarsItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      clientId: Value(clientId),
      vin: vin == null && nullToAbsent ? const Value.absent() : Value(vin),
      make: Value(make),
      model: Value(model),
      year: year == null && nullToAbsent ? const Value.absent() : Value(year),
      licensePlate: licensePlate == null && nullToAbsent
          ? const Value.absent()
          : Value(licensePlate),
      additionalInfo: additionalInfo == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalInfo),
      code: Value(code),
      createdAt: Value(createdAt),
      modifiedAt: modifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory CarsItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CarsItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      clientId: serializer.fromJson<int>(json['clientId']),
      vin: serializer.fromJson<String?>(json['vin']),
      make: serializer.fromJson<String>(json['make']),
      model: serializer.fromJson<String>(json['model']),
      year: serializer.fromJson<int?>(json['year']),
      licensePlate: serializer.fromJson<String?>(json['licensePlate']),
      additionalInfo: serializer.fromJson<String?>(json['additionalInfo']),
      code: serializer.fromJson<String>(json['code']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      modifiedAt: serializer.fromJson<DateTime?>(json['modifiedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'clientId': serializer.toJson<int>(clientId),
      'vin': serializer.toJson<String?>(vin),
      'make': serializer.toJson<String>(make),
      'model': serializer.toJson<String>(model),
      'year': serializer.toJson<int?>(year),
      'licensePlate': serializer.toJson<String?>(licensePlate),
      'additionalInfo': serializer.toJson<String?>(additionalInfo),
      'code': serializer.toJson<String>(code),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'modifiedAt': serializer.toJson<DateTime?>(modifiedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  CarsItem copyWith(
          {int? id,
          String? uuid,
          int? clientId,
          Value<String?> vin = const Value.absent(),
          String? make,
          String? model,
          Value<int?> year = const Value.absent(),
          Value<String?> licensePlate = const Value.absent(),
          Value<String?> additionalInfo = const Value.absent(),
          String? code,
          DateTime? createdAt,
          Value<DateTime?> modifiedAt = const Value.absent(),
          Value<DateTime?> deletedAt = const Value.absent()}) =>
      CarsItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        clientId: clientId ?? this.clientId,
        vin: vin.present ? vin.value : this.vin,
        make: make ?? this.make,
        model: model ?? this.model,
        year: year.present ? year.value : this.year,
        licensePlate:
            licensePlate.present ? licensePlate.value : this.licensePlate,
        additionalInfo:
            additionalInfo.present ? additionalInfo.value : this.additionalInfo,
        code: code ?? this.code,
        createdAt: createdAt ?? this.createdAt,
        modifiedAt: modifiedAt.present ? modifiedAt.value : this.modifiedAt,
        deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
      );
  CarsItem copyWithCompanion(CarsItemsCompanion data) {
    return CarsItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      clientId: data.clientId.present ? data.clientId.value : this.clientId,
      vin: data.vin.present ? data.vin.value : this.vin,
      make: data.make.present ? data.make.value : this.make,
      model: data.model.present ? data.model.value : this.model,
      year: data.year.present ? data.year.value : this.year,
      licensePlate: data.licensePlate.present
          ? data.licensePlate.value
          : this.licensePlate,
      additionalInfo: data.additionalInfo.present
          ? data.additionalInfo.value
          : this.additionalInfo,
      code: data.code.present ? data.code.value : this.code,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      modifiedAt:
          data.modifiedAt.present ? data.modifiedAt.value : this.modifiedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CarsItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clientId: $clientId, ')
          ..write('vin: $vin, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('year: $year, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('additionalInfo: $additionalInfo, ')
          ..write('code: $code, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, clientId, vin, make, model, year,
      licensePlate, additionalInfo, code, createdAt, modifiedAt, deletedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CarsItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.clientId == this.clientId &&
          other.vin == this.vin &&
          other.make == this.make &&
          other.model == this.model &&
          other.year == this.year &&
          other.licensePlate == this.licensePlate &&
          other.additionalInfo == this.additionalInfo &&
          other.code == this.code &&
          other.createdAt == this.createdAt &&
          other.modifiedAt == this.modifiedAt &&
          other.deletedAt == this.deletedAt);
}

class CarsItemsCompanion extends UpdateCompanion<CarsItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<int> clientId;
  final Value<String?> vin;
  final Value<String> make;
  final Value<String> model;
  final Value<int?> year;
  final Value<String?> licensePlate;
  final Value<String?> additionalInfo;
  final Value<String> code;
  final Value<DateTime> createdAt;
  final Value<DateTime?> modifiedAt;
  final Value<DateTime?> deletedAt;
  const CarsItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.clientId = const Value.absent(),
    this.vin = const Value.absent(),
    this.make = const Value.absent(),
    this.model = const Value.absent(),
    this.year = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.additionalInfo = const Value.absent(),
    this.code = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  });
  CarsItemsCompanion.insert({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    required int clientId,
    this.vin = const Value.absent(),
    required String make,
    required String model,
    this.year = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.additionalInfo = const Value.absent(),
    this.code = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  })  : clientId = Value(clientId),
        make = Value(make),
        model = Value(model);
  static Insertable<CarsItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<int>? clientId,
    Expression<String>? vin,
    Expression<String>? make,
    Expression<String>? model,
    Expression<int>? year,
    Expression<String>? licensePlate,
    Expression<String>? additionalInfo,
    Expression<String>? code,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? modifiedAt,
    Expression<DateTime>? deletedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (clientId != null) 'client_id': clientId,
      if (vin != null) 'vin': vin,
      if (make != null) 'make': make,
      if (model != null) 'model': model,
      if (year != null) 'year': year,
      if (licensePlate != null) 'license_plate': licensePlate,
      if (additionalInfo != null) 'additional_info': additionalInfo,
      if (code != null) 'code': code,
      if (createdAt != null) 'created_at': createdAt,
      if (modifiedAt != null) 'modified_at': modifiedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
    });
  }

  CarsItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<int>? clientId,
      Value<String?>? vin,
      Value<String>? make,
      Value<String>? model,
      Value<int?>? year,
      Value<String?>? licensePlate,
      Value<String?>? additionalInfo,
      Value<String>? code,
      Value<DateTime>? createdAt,
      Value<DateTime?>? modifiedAt,
      Value<DateTime?>? deletedAt}) {
    return CarsItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      clientId: clientId ?? this.clientId,
      vin: vin ?? this.vin,
      make: make ?? this.make,
      model: model ?? this.model,
      year: year ?? this.year,
      licensePlate: licensePlate ?? this.licensePlate,
      additionalInfo: additionalInfo ?? this.additionalInfo,
      code: code ?? this.code,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
      deletedAt: deletedAt ?? this.deletedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<int>(clientId.value);
    }
    if (vin.present) {
      map['vin'] = Variable<String>(vin.value);
    }
    if (make.present) {
      map['make'] = Variable<String>(make.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (year.present) {
      map['year'] = Variable<int>(year.value);
    }
    if (licensePlate.present) {
      map['license_plate'] = Variable<String>(licensePlate.value);
    }
    if (additionalInfo.present) {
      map['additional_info'] = Variable<String>(additionalInfo.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (modifiedAt.present) {
      map['modified_at'] = Variable<DateTime>(modifiedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CarsItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clientId: $clientId, ')
          ..write('vin: $vin, ')
          ..write('make: $make, ')
          ..write('model: $model, ')
          ..write('year: $year, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('additionalInfo: $additionalInfo, ')
          ..write('code: $code, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }
}

class $AppInfoItemsTable extends AppInfoItems
    with TableInfo<$AppInfoItemsTable, AppInfoItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AppInfoItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _keyMeta = const VerificationMeta('key');
  @override
  late final GeneratedColumn<String> key = GeneratedColumn<String>(
      'key', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [key, value];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'app_info_items';
  @override
  VerificationContext validateIntegrity(Insertable<AppInfoItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('key')) {
      context.handle(
          _keyMeta, key.isAcceptableOrUnknown(data['key']!, _keyMeta));
    } else if (isInserting) {
      context.missing(_keyMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {key};
  @override
  AppInfoItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AppInfoItem(
      key: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}key'])!,
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
    );
  }

  @override
  $AppInfoItemsTable createAlias(String alias) {
    return $AppInfoItemsTable(attachedDatabase, alias);
  }
}

class AppInfoItem extends DataClass implements Insertable<AppInfoItem> {
  final String key;
  final String value;
  const AppInfoItem({required this.key, required this.value});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['key'] = Variable<String>(key);
    map['value'] = Variable<String>(value);
    return map;
  }

  AppInfoItemsCompanion toCompanion(bool nullToAbsent) {
    return AppInfoItemsCompanion(
      key: Value(key),
      value: Value(value),
    );
  }

  factory AppInfoItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AppInfoItem(
      key: serializer.fromJson<String>(json['key']),
      value: serializer.fromJson<String>(json['value']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'key': serializer.toJson<String>(key),
      'value': serializer.toJson<String>(value),
    };
  }

  AppInfoItem copyWith({String? key, String? value}) => AppInfoItem(
        key: key ?? this.key,
        value: value ?? this.value,
      );
  AppInfoItem copyWithCompanion(AppInfoItemsCompanion data) {
    return AppInfoItem(
      key: data.key.present ? data.key.value : this.key,
      value: data.value.present ? data.value.value : this.value,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AppInfoItem(')
          ..write('key: $key, ')
          ..write('value: $value')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(key, value);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AppInfoItem &&
          other.key == this.key &&
          other.value == this.value);
}

class AppInfoItemsCompanion extends UpdateCompanion<AppInfoItem> {
  final Value<String> key;
  final Value<String> value;
  final Value<int> rowid;
  const AppInfoItemsCompanion({
    this.key = const Value.absent(),
    this.value = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AppInfoItemsCompanion.insert({
    required String key,
    required String value,
    this.rowid = const Value.absent(),
  })  : key = Value(key),
        value = Value(value);
  static Insertable<AppInfoItem> custom({
    Expression<String>? key,
    Expression<String>? value,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (key != null) 'key': key,
      if (value != null) 'value': value,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AppInfoItemsCompanion copyWith(
      {Value<String>? key, Value<String>? value, Value<int>? rowid}) {
    return AppInfoItemsCompanion(
      key: key ?? this.key,
      value: value ?? this.value,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (key.present) {
      map['key'] = Variable<String>(key.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AppInfoItemsCompanion(')
          ..write('key: $key, ')
          ..write('value: $value, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrdersItemsTable extends OrdersItems
    with TableInfo<$OrdersItemsTable, OrdersItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrdersItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => const Uuid().v4());
  static const VerificationMeta _clientUuidMeta =
      const VerificationMeta('clientUuid');
  @override
  late final GeneratedColumn<String> clientUuid = GeneratedColumn<String>(
      'client_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES clients_items (uuid)'));
  static const VerificationMeta _carUuidMeta =
      const VerificationMeta('carUuid');
  @override
  late final GeneratedColumn<String> carUuid = GeneratedColumn<String>(
      'car_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES cars_items (uuid)'));
  static const VerificationMeta _numberMeta = const VerificationMeta('number');
  @override
  late final GeneratedColumn<String> number = GeneratedColumn<String>(
      'number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _scheduledDateMeta =
      const VerificationMeta('scheduledDate');
  @override
  late final GeneratedColumn<DateTime> scheduledDate =
      GeneratedColumn<DateTime>('scheduled_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _completedAtMeta =
      const VerificationMeta('completedAt');
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
      'completed_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalAmountMeta =
      const VerificationMeta('totalAmount');
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
      'total_amount', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _isPostedMeta =
      const VerificationMeta('isPosted');
  @override
  late final GeneratedColumn<bool> isPosted = GeneratedColumn<bool>(
      'is_posted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_posted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _modifiedAtMeta =
      const VerificationMeta('modifiedAt');
  @override
  late final GeneratedColumn<DateTime> modifiedAt = GeneratedColumn<DateTime>(
      'modified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deletedAtMeta =
      const VerificationMeta('deletedAt');
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
      'deleted_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        clientUuid,
        carUuid,
        number,
        date,
        scheduledDate,
        completedAt,
        status,
        description,
        totalAmount,
        isPosted,
        createdAt,
        modifiedAt,
        deletedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'orders_items';
  @override
  VerificationContext validateIntegrity(Insertable<OrdersItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('client_uuid')) {
      context.handle(
          _clientUuidMeta,
          clientUuid.isAcceptableOrUnknown(
              data['client_uuid']!, _clientUuidMeta));
    } else if (isInserting) {
      context.missing(_clientUuidMeta);
    }
    if (data.containsKey('car_uuid')) {
      context.handle(_carUuidMeta,
          carUuid.isAcceptableOrUnknown(data['car_uuid']!, _carUuidMeta));
    } else if (isInserting) {
      context.missing(_carUuidMeta);
    }
    if (data.containsKey('number')) {
      context.handle(_numberMeta,
          number.isAcceptableOrUnknown(data['number']!, _numberMeta));
    } else if (isInserting) {
      context.missing(_numberMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('scheduled_date')) {
      context.handle(
          _scheduledDateMeta,
          scheduledDate.isAcceptableOrUnknown(
              data['scheduled_date']!, _scheduledDateMeta));
    }
    if (data.containsKey('completed_at')) {
      context.handle(
          _completedAtMeta,
          completedAt.isAcceptableOrUnknown(
              data['completed_at']!, _completedAtMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('total_amount')) {
      context.handle(
          _totalAmountMeta,
          totalAmount.isAcceptableOrUnknown(
              data['total_amount']!, _totalAmountMeta));
    }
    if (data.containsKey('is_posted')) {
      context.handle(_isPostedMeta,
          isPosted.isAcceptableOrUnknown(data['is_posted']!, _isPostedMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('modified_at')) {
      context.handle(
          _modifiedAtMeta,
          modifiedAt.isAcceptableOrUnknown(
              data['modified_at']!, _modifiedAtMeta));
    }
    if (data.containsKey('deleted_at')) {
      context.handle(_deletedAtMeta,
          deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrdersItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrdersItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      clientUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_uuid'])!,
      carUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}car_uuid'])!,
      number: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}number'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      scheduledDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}scheduled_date']),
      completedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}completed_at']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      totalAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_amount'])!,
      isPosted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_posted'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      modifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}modified_at']),
      deletedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}deleted_at']),
    );
  }

  @override
  $OrdersItemsTable createAlias(String alias) {
    return $OrdersItemsTable(attachedDatabase, alias);
  }
}

class OrdersItem extends DataClass implements Insertable<OrdersItem> {
  final int id;
  final String uuid;
  final String clientUuid;
  final String carUuid;
  final String number;
  final DateTime date;
  final DateTime? scheduledDate;
  final DateTime? completedAt;
  final String status;
  final String? description;
  final double totalAmount;
  final bool isPosted;
  final DateTime createdAt;
  final DateTime? modifiedAt;
  final DateTime? deletedAt;
  const OrdersItem(
      {required this.id,
      required this.uuid,
      required this.clientUuid,
      required this.carUuid,
      required this.number,
      required this.date,
      this.scheduledDate,
      this.completedAt,
      required this.status,
      this.description,
      required this.totalAmount,
      required this.isPosted,
      required this.createdAt,
      this.modifiedAt,
      this.deletedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['client_uuid'] = Variable<String>(clientUuid);
    map['car_uuid'] = Variable<String>(carUuid);
    map['number'] = Variable<String>(number);
    map['date'] = Variable<DateTime>(date);
    if (!nullToAbsent || scheduledDate != null) {
      map['scheduled_date'] = Variable<DateTime>(scheduledDate);
    }
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['total_amount'] = Variable<double>(totalAmount);
    map['is_posted'] = Variable<bool>(isPosted);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || modifiedAt != null) {
      map['modified_at'] = Variable<DateTime>(modifiedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  OrdersItemsCompanion toCompanion(bool nullToAbsent) {
    return OrdersItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      clientUuid: Value(clientUuid),
      carUuid: Value(carUuid),
      number: Value(number),
      date: Value(date),
      scheduledDate: scheduledDate == null && nullToAbsent
          ? const Value.absent()
          : Value(scheduledDate),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      status: Value(status),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      totalAmount: Value(totalAmount),
      isPosted: Value(isPosted),
      createdAt: Value(createdAt),
      modifiedAt: modifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory OrdersItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrdersItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      clientUuid: serializer.fromJson<String>(json['clientUuid']),
      carUuid: serializer.fromJson<String>(json['carUuid']),
      number: serializer.fromJson<String>(json['number']),
      date: serializer.fromJson<DateTime>(json['date']),
      scheduledDate: serializer.fromJson<DateTime?>(json['scheduledDate']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      status: serializer.fromJson<String>(json['status']),
      description: serializer.fromJson<String?>(json['description']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      isPosted: serializer.fromJson<bool>(json['isPosted']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      modifiedAt: serializer.fromJson<DateTime?>(json['modifiedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'clientUuid': serializer.toJson<String>(clientUuid),
      'carUuid': serializer.toJson<String>(carUuid),
      'number': serializer.toJson<String>(number),
      'date': serializer.toJson<DateTime>(date),
      'scheduledDate': serializer.toJson<DateTime?>(scheduledDate),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'status': serializer.toJson<String>(status),
      'description': serializer.toJson<String?>(description),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'isPosted': serializer.toJson<bool>(isPosted),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'modifiedAt': serializer.toJson<DateTime?>(modifiedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  OrdersItem copyWith(
          {int? id,
          String? uuid,
          String? clientUuid,
          String? carUuid,
          String? number,
          DateTime? date,
          Value<DateTime?> scheduledDate = const Value.absent(),
          Value<DateTime?> completedAt = const Value.absent(),
          String? status,
          Value<String?> description = const Value.absent(),
          double? totalAmount,
          bool? isPosted,
          DateTime? createdAt,
          Value<DateTime?> modifiedAt = const Value.absent(),
          Value<DateTime?> deletedAt = const Value.absent()}) =>
      OrdersItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        clientUuid: clientUuid ?? this.clientUuid,
        carUuid: carUuid ?? this.carUuid,
        number: number ?? this.number,
        date: date ?? this.date,
        scheduledDate:
            scheduledDate.present ? scheduledDate.value : this.scheduledDate,
        completedAt: completedAt.present ? completedAt.value : this.completedAt,
        status: status ?? this.status,
        description: description.present ? description.value : this.description,
        totalAmount: totalAmount ?? this.totalAmount,
        isPosted: isPosted ?? this.isPosted,
        createdAt: createdAt ?? this.createdAt,
        modifiedAt: modifiedAt.present ? modifiedAt.value : this.modifiedAt,
        deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
      );
  OrdersItem copyWithCompanion(OrdersItemsCompanion data) {
    return OrdersItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      clientUuid:
          data.clientUuid.present ? data.clientUuid.value : this.clientUuid,
      carUuid: data.carUuid.present ? data.carUuid.value : this.carUuid,
      number: data.number.present ? data.number.value : this.number,
      date: data.date.present ? data.date.value : this.date,
      scheduledDate: data.scheduledDate.present
          ? data.scheduledDate.value
          : this.scheduledDate,
      completedAt:
          data.completedAt.present ? data.completedAt.value : this.completedAt,
      status: data.status.present ? data.status.value : this.status,
      description:
          data.description.present ? data.description.value : this.description,
      totalAmount:
          data.totalAmount.present ? data.totalAmount.value : this.totalAmount,
      isPosted: data.isPosted.present ? data.isPosted.value : this.isPosted,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      modifiedAt:
          data.modifiedAt.present ? data.modifiedAt.value : this.modifiedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrdersItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clientUuid: $clientUuid, ')
          ..write('carUuid: $carUuid, ')
          ..write('number: $number, ')
          ..write('date: $date, ')
          ..write('scheduledDate: $scheduledDate, ')
          ..write('completedAt: $completedAt, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('isPosted: $isPosted, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      clientUuid,
      carUuid,
      number,
      date,
      scheduledDate,
      completedAt,
      status,
      description,
      totalAmount,
      isPosted,
      createdAt,
      modifiedAt,
      deletedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrdersItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.clientUuid == this.clientUuid &&
          other.carUuid == this.carUuid &&
          other.number == this.number &&
          other.date == this.date &&
          other.scheduledDate == this.scheduledDate &&
          other.completedAt == this.completedAt &&
          other.status == this.status &&
          other.description == this.description &&
          other.totalAmount == this.totalAmount &&
          other.isPosted == this.isPosted &&
          other.createdAt == this.createdAt &&
          other.modifiedAt == this.modifiedAt &&
          other.deletedAt == this.deletedAt);
}

class OrdersItemsCompanion extends UpdateCompanion<OrdersItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> clientUuid;
  final Value<String> carUuid;
  final Value<String> number;
  final Value<DateTime> date;
  final Value<DateTime?> scheduledDate;
  final Value<DateTime?> completedAt;
  final Value<String> status;
  final Value<String?> description;
  final Value<double> totalAmount;
  final Value<bool> isPosted;
  final Value<DateTime> createdAt;
  final Value<DateTime?> modifiedAt;
  final Value<DateTime?> deletedAt;
  const OrdersItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.clientUuid = const Value.absent(),
    this.carUuid = const Value.absent(),
    this.number = const Value.absent(),
    this.date = const Value.absent(),
    this.scheduledDate = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.status = const Value.absent(),
    this.description = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.isPosted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  });
  OrdersItemsCompanion.insert({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    required String clientUuid,
    required String carUuid,
    required String number,
    required DateTime date,
    this.scheduledDate = const Value.absent(),
    this.completedAt = const Value.absent(),
    required String status,
    this.description = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.isPosted = const Value.absent(),
    required DateTime createdAt,
    this.modifiedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
  })  : clientUuid = Value(clientUuid),
        carUuid = Value(carUuid),
        number = Value(number),
        date = Value(date),
        status = Value(status),
        createdAt = Value(createdAt);
  static Insertable<OrdersItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? clientUuid,
    Expression<String>? carUuid,
    Expression<String>? number,
    Expression<DateTime>? date,
    Expression<DateTime>? scheduledDate,
    Expression<DateTime>? completedAt,
    Expression<String>? status,
    Expression<String>? description,
    Expression<double>? totalAmount,
    Expression<bool>? isPosted,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? modifiedAt,
    Expression<DateTime>? deletedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (clientUuid != null) 'client_uuid': clientUuid,
      if (carUuid != null) 'car_uuid': carUuid,
      if (number != null) 'number': number,
      if (date != null) 'date': date,
      if (scheduledDate != null) 'scheduled_date': scheduledDate,
      if (completedAt != null) 'completed_at': completedAt,
      if (status != null) 'status': status,
      if (description != null) 'description': description,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (isPosted != null) 'is_posted': isPosted,
      if (createdAt != null) 'created_at': createdAt,
      if (modifiedAt != null) 'modified_at': modifiedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
    });
  }

  OrdersItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? clientUuid,
      Value<String>? carUuid,
      Value<String>? number,
      Value<DateTime>? date,
      Value<DateTime?>? scheduledDate,
      Value<DateTime?>? completedAt,
      Value<String>? status,
      Value<String?>? description,
      Value<double>? totalAmount,
      Value<bool>? isPosted,
      Value<DateTime>? createdAt,
      Value<DateTime?>? modifiedAt,
      Value<DateTime?>? deletedAt}) {
    return OrdersItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      clientUuid: clientUuid ?? this.clientUuid,
      carUuid: carUuid ?? this.carUuid,
      number: number ?? this.number,
      date: date ?? this.date,
      scheduledDate: scheduledDate ?? this.scheduledDate,
      completedAt: completedAt ?? this.completedAt,
      status: status ?? this.status,
      description: description ?? this.description,
      totalAmount: totalAmount ?? this.totalAmount,
      isPosted: isPosted ?? this.isPosted,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
      deletedAt: deletedAt ?? this.deletedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (clientUuid.present) {
      map['client_uuid'] = Variable<String>(clientUuid.value);
    }
    if (carUuid.present) {
      map['car_uuid'] = Variable<String>(carUuid.value);
    }
    if (number.present) {
      map['number'] = Variable<String>(number.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (scheduledDate.present) {
      map['scheduled_date'] = Variable<DateTime>(scheduledDate.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (isPosted.present) {
      map['is_posted'] = Variable<bool>(isPosted.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (modifiedAt.present) {
      map['modified_at'] = Variable<DateTime>(modifiedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrdersItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clientUuid: $clientUuid, ')
          ..write('carUuid: $carUuid, ')
          ..write('number: $number, ')
          ..write('date: $date, ')
          ..write('scheduledDate: $scheduledDate, ')
          ..write('completedAt: $completedAt, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('isPosted: $isPosted, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }
}

class $OrderPartsItemsTable extends OrderPartsItems
    with TableInfo<$OrderPartsItemsTable, OrderPartsItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderPartsItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => const Uuid().v4());
  static const VerificationMeta _documentUuidMeta =
      const VerificationMeta('documentUuid');
  @override
  late final GeneratedColumn<String> documentUuid = GeneratedColumn<String>(
      'document_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES orders_items (uuid)'));
  static const VerificationMeta _lineNumberMeta =
      const VerificationMeta('lineNumber');
  @override
  late final GeneratedColumn<int> lineNumber = GeneratedColumn<int>(
      'line_number', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _partNumberMeta =
      const VerificationMeta('partNumber');
  @override
  late final GeneratedColumn<String> partNumber = GeneratedColumn<String>(
      'part_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
      'brand', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _supplierNameMeta =
      const VerificationMeta('supplierName');
  @override
  late final GeneratedColumn<String> supplierName = GeneratedColumn<String>(
      'supplier_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deliveryDaysMeta =
      const VerificationMeta('deliveryDays');
  @override
  late final GeneratedColumn<int> deliveryDays = GeneratedColumn<int>(
      'delivery_days', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isOrderedMeta =
      const VerificationMeta('isOrdered');
  @override
  late final GeneratedColumn<bool> isOrdered = GeneratedColumn<bool>(
      'is_ordered', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_ordered" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _isReceivedMeta =
      const VerificationMeta('isReceived');
  @override
  late final GeneratedColumn<bool> isReceived = GeneratedColumn<bool>(
      'is_received', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_received" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _modifiedAtMeta =
      const VerificationMeta('modifiedAt');
  @override
  late final GeneratedColumn<DateTime> modifiedAt = GeneratedColumn<DateTime>(
      'modified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        documentUuid,
        lineNumber,
        partNumber,
        name,
        brand,
        quantity,
        price,
        supplierName,
        deliveryDays,
        isOrdered,
        isReceived,
        createdAt,
        modifiedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_parts_items';
  @override
  VerificationContext validateIntegrity(Insertable<OrderPartsItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('document_uuid')) {
      context.handle(
          _documentUuidMeta,
          documentUuid.isAcceptableOrUnknown(
              data['document_uuid']!, _documentUuidMeta));
    } else if (isInserting) {
      context.missing(_documentUuidMeta);
    }
    if (data.containsKey('line_number')) {
      context.handle(
          _lineNumberMeta,
          lineNumber.isAcceptableOrUnknown(
              data['line_number']!, _lineNumberMeta));
    }
    if (data.containsKey('part_number')) {
      context.handle(
          _partNumberMeta,
          partNumber.isAcceptableOrUnknown(
              data['part_number']!, _partNumberMeta));
    } else if (isInserting) {
      context.missing(_partNumberMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('brand')) {
      context.handle(
          _brandMeta, brand.isAcceptableOrUnknown(data['brand']!, _brandMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    }
    if (data.containsKey('supplier_name')) {
      context.handle(
          _supplierNameMeta,
          supplierName.isAcceptableOrUnknown(
              data['supplier_name']!, _supplierNameMeta));
    }
    if (data.containsKey('delivery_days')) {
      context.handle(
          _deliveryDaysMeta,
          deliveryDays.isAcceptableOrUnknown(
              data['delivery_days']!, _deliveryDaysMeta));
    }
    if (data.containsKey('is_ordered')) {
      context.handle(_isOrderedMeta,
          isOrdered.isAcceptableOrUnknown(data['is_ordered']!, _isOrderedMeta));
    }
    if (data.containsKey('is_received')) {
      context.handle(
          _isReceivedMeta,
          isReceived.isAcceptableOrUnknown(
              data['is_received']!, _isReceivedMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('modified_at')) {
      context.handle(
          _modifiedAtMeta,
          modifiedAt.isAcceptableOrUnknown(
              data['modified_at']!, _modifiedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderPartsItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderPartsItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      documentUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_uuid'])!,
      lineNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}line_number'])!,
      partNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}part_number'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      brand: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}brand']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      supplierName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_name']),
      deliveryDays: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delivery_days']),
      isOrdered: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_ordered'])!,
      isReceived: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_received'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      modifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}modified_at']),
    );
  }

  @override
  $OrderPartsItemsTable createAlias(String alias) {
    return $OrderPartsItemsTable(attachedDatabase, alias);
  }
}

class OrderPartsItem extends DataClass implements Insertable<OrderPartsItem> {
  final int id;
  final String uuid;
  final String documentUuid;
  final int lineNumber;
  final String partNumber;
  final String name;
  final String? brand;
  final double quantity;
  final double price;
  final String? supplierName;
  final int? deliveryDays;
  final bool isOrdered;
  final bool isReceived;
  final DateTime createdAt;
  final DateTime? modifiedAt;
  const OrderPartsItem(
      {required this.id,
      required this.uuid,
      required this.documentUuid,
      required this.lineNumber,
      required this.partNumber,
      required this.name,
      this.brand,
      required this.quantity,
      required this.price,
      this.supplierName,
      this.deliveryDays,
      required this.isOrdered,
      required this.isReceived,
      required this.createdAt,
      this.modifiedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['document_uuid'] = Variable<String>(documentUuid);
    map['line_number'] = Variable<int>(lineNumber);
    map['part_number'] = Variable<String>(partNumber);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    map['quantity'] = Variable<double>(quantity);
    map['price'] = Variable<double>(price);
    if (!nullToAbsent || supplierName != null) {
      map['supplier_name'] = Variable<String>(supplierName);
    }
    if (!nullToAbsent || deliveryDays != null) {
      map['delivery_days'] = Variable<int>(deliveryDays);
    }
    map['is_ordered'] = Variable<bool>(isOrdered);
    map['is_received'] = Variable<bool>(isReceived);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || modifiedAt != null) {
      map['modified_at'] = Variable<DateTime>(modifiedAt);
    }
    return map;
  }

  OrderPartsItemsCompanion toCompanion(bool nullToAbsent) {
    return OrderPartsItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      documentUuid: Value(documentUuid),
      lineNumber: Value(lineNumber),
      partNumber: Value(partNumber),
      name: Value(name),
      brand:
          brand == null && nullToAbsent ? const Value.absent() : Value(brand),
      quantity: Value(quantity),
      price: Value(price),
      supplierName: supplierName == null && nullToAbsent
          ? const Value.absent()
          : Value(supplierName),
      deliveryDays: deliveryDays == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryDays),
      isOrdered: Value(isOrdered),
      isReceived: Value(isReceived),
      createdAt: Value(createdAt),
      modifiedAt: modifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiedAt),
    );
  }

  factory OrderPartsItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderPartsItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      documentUuid: serializer.fromJson<String>(json['documentUuid']),
      lineNumber: serializer.fromJson<int>(json['lineNumber']),
      partNumber: serializer.fromJson<String>(json['partNumber']),
      name: serializer.fromJson<String>(json['name']),
      brand: serializer.fromJson<String?>(json['brand']),
      quantity: serializer.fromJson<double>(json['quantity']),
      price: serializer.fromJson<double>(json['price']),
      supplierName: serializer.fromJson<String?>(json['supplierName']),
      deliveryDays: serializer.fromJson<int?>(json['deliveryDays']),
      isOrdered: serializer.fromJson<bool>(json['isOrdered']),
      isReceived: serializer.fromJson<bool>(json['isReceived']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      modifiedAt: serializer.fromJson<DateTime?>(json['modifiedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'documentUuid': serializer.toJson<String>(documentUuid),
      'lineNumber': serializer.toJson<int>(lineNumber),
      'partNumber': serializer.toJson<String>(partNumber),
      'name': serializer.toJson<String>(name),
      'brand': serializer.toJson<String?>(brand),
      'quantity': serializer.toJson<double>(quantity),
      'price': serializer.toJson<double>(price),
      'supplierName': serializer.toJson<String?>(supplierName),
      'deliveryDays': serializer.toJson<int?>(deliveryDays),
      'isOrdered': serializer.toJson<bool>(isOrdered),
      'isReceived': serializer.toJson<bool>(isReceived),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'modifiedAt': serializer.toJson<DateTime?>(modifiedAt),
    };
  }

  OrderPartsItem copyWith(
          {int? id,
          String? uuid,
          String? documentUuid,
          int? lineNumber,
          String? partNumber,
          String? name,
          Value<String?> brand = const Value.absent(),
          double? quantity,
          double? price,
          Value<String?> supplierName = const Value.absent(),
          Value<int?> deliveryDays = const Value.absent(),
          bool? isOrdered,
          bool? isReceived,
          DateTime? createdAt,
          Value<DateTime?> modifiedAt = const Value.absent()}) =>
      OrderPartsItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        documentUuid: documentUuid ?? this.documentUuid,
        lineNumber: lineNumber ?? this.lineNumber,
        partNumber: partNumber ?? this.partNumber,
        name: name ?? this.name,
        brand: brand.present ? brand.value : this.brand,
        quantity: quantity ?? this.quantity,
        price: price ?? this.price,
        supplierName:
            supplierName.present ? supplierName.value : this.supplierName,
        deliveryDays:
            deliveryDays.present ? deliveryDays.value : this.deliveryDays,
        isOrdered: isOrdered ?? this.isOrdered,
        isReceived: isReceived ?? this.isReceived,
        createdAt: createdAt ?? this.createdAt,
        modifiedAt: modifiedAt.present ? modifiedAt.value : this.modifiedAt,
      );
  OrderPartsItem copyWithCompanion(OrderPartsItemsCompanion data) {
    return OrderPartsItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      documentUuid: data.documentUuid.present
          ? data.documentUuid.value
          : this.documentUuid,
      lineNumber:
          data.lineNumber.present ? data.lineNumber.value : this.lineNumber,
      partNumber:
          data.partNumber.present ? data.partNumber.value : this.partNumber,
      name: data.name.present ? data.name.value : this.name,
      brand: data.brand.present ? data.brand.value : this.brand,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      price: data.price.present ? data.price.value : this.price,
      supplierName: data.supplierName.present
          ? data.supplierName.value
          : this.supplierName,
      deliveryDays: data.deliveryDays.present
          ? data.deliveryDays.value
          : this.deliveryDays,
      isOrdered: data.isOrdered.present ? data.isOrdered.value : this.isOrdered,
      isReceived:
          data.isReceived.present ? data.isReceived.value : this.isReceived,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      modifiedAt:
          data.modifiedAt.present ? data.modifiedAt.value : this.modifiedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderPartsItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('documentUuid: $documentUuid, ')
          ..write('lineNumber: $lineNumber, ')
          ..write('partNumber: $partNumber, ')
          ..write('name: $name, ')
          ..write('brand: $brand, ')
          ..write('quantity: $quantity, ')
          ..write('price: $price, ')
          ..write('supplierName: $supplierName, ')
          ..write('deliveryDays: $deliveryDays, ')
          ..write('isOrdered: $isOrdered, ')
          ..write('isReceived: $isReceived, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      documentUuid,
      lineNumber,
      partNumber,
      name,
      brand,
      quantity,
      price,
      supplierName,
      deliveryDays,
      isOrdered,
      isReceived,
      createdAt,
      modifiedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderPartsItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.documentUuid == this.documentUuid &&
          other.lineNumber == this.lineNumber &&
          other.partNumber == this.partNumber &&
          other.name == this.name &&
          other.brand == this.brand &&
          other.quantity == this.quantity &&
          other.price == this.price &&
          other.supplierName == this.supplierName &&
          other.deliveryDays == this.deliveryDays &&
          other.isOrdered == this.isOrdered &&
          other.isReceived == this.isReceived &&
          other.createdAt == this.createdAt &&
          other.modifiedAt == this.modifiedAt);
}

class OrderPartsItemsCompanion extends UpdateCompanion<OrderPartsItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> documentUuid;
  final Value<int> lineNumber;
  final Value<String> partNumber;
  final Value<String> name;
  final Value<String?> brand;
  final Value<double> quantity;
  final Value<double> price;
  final Value<String?> supplierName;
  final Value<int?> deliveryDays;
  final Value<bool> isOrdered;
  final Value<bool> isReceived;
  final Value<DateTime> createdAt;
  final Value<DateTime?> modifiedAt;
  const OrderPartsItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.documentUuid = const Value.absent(),
    this.lineNumber = const Value.absent(),
    this.partNumber = const Value.absent(),
    this.name = const Value.absent(),
    this.brand = const Value.absent(),
    this.quantity = const Value.absent(),
    this.price = const Value.absent(),
    this.supplierName = const Value.absent(),
    this.deliveryDays = const Value.absent(),
    this.isOrdered = const Value.absent(),
    this.isReceived = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
  });
  OrderPartsItemsCompanion.insert({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    required String documentUuid,
    this.lineNumber = const Value.absent(),
    required String partNumber,
    required String name,
    this.brand = const Value.absent(),
    this.quantity = const Value.absent(),
    this.price = const Value.absent(),
    this.supplierName = const Value.absent(),
    this.deliveryDays = const Value.absent(),
    this.isOrdered = const Value.absent(),
    this.isReceived = const Value.absent(),
    required DateTime createdAt,
    this.modifiedAt = const Value.absent(),
  })  : documentUuid = Value(documentUuid),
        partNumber = Value(partNumber),
        name = Value(name),
        createdAt = Value(createdAt);
  static Insertable<OrderPartsItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? documentUuid,
    Expression<int>? lineNumber,
    Expression<String>? partNumber,
    Expression<String>? name,
    Expression<String>? brand,
    Expression<double>? quantity,
    Expression<double>? price,
    Expression<String>? supplierName,
    Expression<int>? deliveryDays,
    Expression<bool>? isOrdered,
    Expression<bool>? isReceived,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? modifiedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (documentUuid != null) 'document_uuid': documentUuid,
      if (lineNumber != null) 'line_number': lineNumber,
      if (partNumber != null) 'part_number': partNumber,
      if (name != null) 'name': name,
      if (brand != null) 'brand': brand,
      if (quantity != null) 'quantity': quantity,
      if (price != null) 'price': price,
      if (supplierName != null) 'supplier_name': supplierName,
      if (deliveryDays != null) 'delivery_days': deliveryDays,
      if (isOrdered != null) 'is_ordered': isOrdered,
      if (isReceived != null) 'is_received': isReceived,
      if (createdAt != null) 'created_at': createdAt,
      if (modifiedAt != null) 'modified_at': modifiedAt,
    });
  }

  OrderPartsItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? documentUuid,
      Value<int>? lineNumber,
      Value<String>? partNumber,
      Value<String>? name,
      Value<String?>? brand,
      Value<double>? quantity,
      Value<double>? price,
      Value<String?>? supplierName,
      Value<int?>? deliveryDays,
      Value<bool>? isOrdered,
      Value<bool>? isReceived,
      Value<DateTime>? createdAt,
      Value<DateTime?>? modifiedAt}) {
    return OrderPartsItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      documentUuid: documentUuid ?? this.documentUuid,
      lineNumber: lineNumber ?? this.lineNumber,
      partNumber: partNumber ?? this.partNumber,
      name: name ?? this.name,
      brand: brand ?? this.brand,
      quantity: quantity ?? this.quantity,
      price: price ?? this.price,
      supplierName: supplierName ?? this.supplierName,
      deliveryDays: deliveryDays ?? this.deliveryDays,
      isOrdered: isOrdered ?? this.isOrdered,
      isReceived: isReceived ?? this.isReceived,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (documentUuid.present) {
      map['document_uuid'] = Variable<String>(documentUuid.value);
    }
    if (lineNumber.present) {
      map['line_number'] = Variable<int>(lineNumber.value);
    }
    if (partNumber.present) {
      map['part_number'] = Variable<String>(partNumber.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (supplierName.present) {
      map['supplier_name'] = Variable<String>(supplierName.value);
    }
    if (deliveryDays.present) {
      map['delivery_days'] = Variable<int>(deliveryDays.value);
    }
    if (isOrdered.present) {
      map['is_ordered'] = Variable<bool>(isOrdered.value);
    }
    if (isReceived.present) {
      map['is_received'] = Variable<bool>(isReceived.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (modifiedAt.present) {
      map['modified_at'] = Variable<DateTime>(modifiedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderPartsItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('documentUuid: $documentUuid, ')
          ..write('lineNumber: $lineNumber, ')
          ..write('partNumber: $partNumber, ')
          ..write('name: $name, ')
          ..write('brand: $brand, ')
          ..write('quantity: $quantity, ')
          ..write('price: $price, ')
          ..write('supplierName: $supplierName, ')
          ..write('deliveryDays: $deliveryDays, ')
          ..write('isOrdered: $isOrdered, ')
          ..write('isReceived: $isReceived, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt')
          ..write(')'))
        .toString();
  }
}

class $OrderServicesItemsTable extends OrderServicesItems
    with TableInfo<$OrderServicesItemsTable, OrderServicesItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderServicesItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      clientDefault: () => const Uuid().v4());
  static const VerificationMeta _documentUuidMeta =
      const VerificationMeta('documentUuid');
  @override
  late final GeneratedColumn<String> documentUuid = GeneratedColumn<String>(
      'document_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES orders_items (uuid)'));
  static const VerificationMeta _lineNumberMeta =
      const VerificationMeta('lineNumber');
  @override
  late final GeneratedColumn<int> lineNumber = GeneratedColumn<int>(
      'line_number', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _durationMeta =
      const VerificationMeta('duration');
  @override
  late final GeneratedColumn<double> duration = GeneratedColumn<double>(
      'duration', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _performedByMeta =
      const VerificationMeta('performedBy');
  @override
  late final GeneratedColumn<String> performedBy = GeneratedColumn<String>(
      'performed_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isCompletedMeta =
      const VerificationMeta('isCompleted');
  @override
  late final GeneratedColumn<bool> isCompleted = GeneratedColumn<bool>(
      'is_completed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_completed" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _modifiedAtMeta =
      const VerificationMeta('modifiedAt');
  @override
  late final GeneratedColumn<DateTime> modifiedAt = GeneratedColumn<DateTime>(
      'modified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        documentUuid,
        lineNumber,
        name,
        description,
        price,
        duration,
        performedBy,
        isCompleted,
        createdAt,
        modifiedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_services_items';
  @override
  VerificationContext validateIntegrity(Insertable<OrderServicesItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('document_uuid')) {
      context.handle(
          _documentUuidMeta,
          documentUuid.isAcceptableOrUnknown(
              data['document_uuid']!, _documentUuidMeta));
    } else if (isInserting) {
      context.missing(_documentUuidMeta);
    }
    if (data.containsKey('line_number')) {
      context.handle(
          _lineNumberMeta,
          lineNumber.isAcceptableOrUnknown(
              data['line_number']!, _lineNumberMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    }
    if (data.containsKey('duration')) {
      context.handle(_durationMeta,
          duration.isAcceptableOrUnknown(data['duration']!, _durationMeta));
    }
    if (data.containsKey('performed_by')) {
      context.handle(
          _performedByMeta,
          performedBy.isAcceptableOrUnknown(
              data['performed_by']!, _performedByMeta));
    }
    if (data.containsKey('is_completed')) {
      context.handle(
          _isCompletedMeta,
          isCompleted.isAcceptableOrUnknown(
              data['is_completed']!, _isCompletedMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('modified_at')) {
      context.handle(
          _modifiedAtMeta,
          modifiedAt.isAcceptableOrUnknown(
              data['modified_at']!, _modifiedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderServicesItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderServicesItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      documentUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_uuid'])!,
      lineNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}line_number'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      duration: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}duration']),
      performedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}performed_by']),
      isCompleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_completed'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      modifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}modified_at']),
    );
  }

  @override
  $OrderServicesItemsTable createAlias(String alias) {
    return $OrderServicesItemsTable(attachedDatabase, alias);
  }
}

class OrderServicesItem extends DataClass
    implements Insertable<OrderServicesItem> {
  final int id;
  final String uuid;
  final String documentUuid;
  final int lineNumber;
  final String name;
  final String? description;
  final double price;
  final double? duration;
  final String? performedBy;
  final bool isCompleted;
  final DateTime createdAt;
  final DateTime? modifiedAt;
  const OrderServicesItem(
      {required this.id,
      required this.uuid,
      required this.documentUuid,
      required this.lineNumber,
      required this.name,
      this.description,
      required this.price,
      this.duration,
      this.performedBy,
      required this.isCompleted,
      required this.createdAt,
      this.modifiedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['document_uuid'] = Variable<String>(documentUuid);
    map['line_number'] = Variable<int>(lineNumber);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['price'] = Variable<double>(price);
    if (!nullToAbsent || duration != null) {
      map['duration'] = Variable<double>(duration);
    }
    if (!nullToAbsent || performedBy != null) {
      map['performed_by'] = Variable<String>(performedBy);
    }
    map['is_completed'] = Variable<bool>(isCompleted);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || modifiedAt != null) {
      map['modified_at'] = Variable<DateTime>(modifiedAt);
    }
    return map;
  }

  OrderServicesItemsCompanion toCompanion(bool nullToAbsent) {
    return OrderServicesItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      documentUuid: Value(documentUuid),
      lineNumber: Value(lineNumber),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      price: Value(price),
      duration: duration == null && nullToAbsent
          ? const Value.absent()
          : Value(duration),
      performedBy: performedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(performedBy),
      isCompleted: Value(isCompleted),
      createdAt: Value(createdAt),
      modifiedAt: modifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiedAt),
    );
  }

  factory OrderServicesItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderServicesItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      documentUuid: serializer.fromJson<String>(json['documentUuid']),
      lineNumber: serializer.fromJson<int>(json['lineNumber']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      price: serializer.fromJson<double>(json['price']),
      duration: serializer.fromJson<double?>(json['duration']),
      performedBy: serializer.fromJson<String?>(json['performedBy']),
      isCompleted: serializer.fromJson<bool>(json['isCompleted']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      modifiedAt: serializer.fromJson<DateTime?>(json['modifiedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'documentUuid': serializer.toJson<String>(documentUuid),
      'lineNumber': serializer.toJson<int>(lineNumber),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'price': serializer.toJson<double>(price),
      'duration': serializer.toJson<double?>(duration),
      'performedBy': serializer.toJson<String?>(performedBy),
      'isCompleted': serializer.toJson<bool>(isCompleted),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'modifiedAt': serializer.toJson<DateTime?>(modifiedAt),
    };
  }

  OrderServicesItem copyWith(
          {int? id,
          String? uuid,
          String? documentUuid,
          int? lineNumber,
          String? name,
          Value<String?> description = const Value.absent(),
          double? price,
          Value<double?> duration = const Value.absent(),
          Value<String?> performedBy = const Value.absent(),
          bool? isCompleted,
          DateTime? createdAt,
          Value<DateTime?> modifiedAt = const Value.absent()}) =>
      OrderServicesItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        documentUuid: documentUuid ?? this.documentUuid,
        lineNumber: lineNumber ?? this.lineNumber,
        name: name ?? this.name,
        description: description.present ? description.value : this.description,
        price: price ?? this.price,
        duration: duration.present ? duration.value : this.duration,
        performedBy: performedBy.present ? performedBy.value : this.performedBy,
        isCompleted: isCompleted ?? this.isCompleted,
        createdAt: createdAt ?? this.createdAt,
        modifiedAt: modifiedAt.present ? modifiedAt.value : this.modifiedAt,
      );
  OrderServicesItem copyWithCompanion(OrderServicesItemsCompanion data) {
    return OrderServicesItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      documentUuid: data.documentUuid.present
          ? data.documentUuid.value
          : this.documentUuid,
      lineNumber:
          data.lineNumber.present ? data.lineNumber.value : this.lineNumber,
      name: data.name.present ? data.name.value : this.name,
      description:
          data.description.present ? data.description.value : this.description,
      price: data.price.present ? data.price.value : this.price,
      duration: data.duration.present ? data.duration.value : this.duration,
      performedBy:
          data.performedBy.present ? data.performedBy.value : this.performedBy,
      isCompleted:
          data.isCompleted.present ? data.isCompleted.value : this.isCompleted,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      modifiedAt:
          data.modifiedAt.present ? data.modifiedAt.value : this.modifiedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderServicesItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('documentUuid: $documentUuid, ')
          ..write('lineNumber: $lineNumber, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('price: $price, ')
          ..write('duration: $duration, ')
          ..write('performedBy: $performedBy, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      documentUuid,
      lineNumber,
      name,
      description,
      price,
      duration,
      performedBy,
      isCompleted,
      createdAt,
      modifiedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderServicesItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.documentUuid == this.documentUuid &&
          other.lineNumber == this.lineNumber &&
          other.name == this.name &&
          other.description == this.description &&
          other.price == this.price &&
          other.duration == this.duration &&
          other.performedBy == this.performedBy &&
          other.isCompleted == this.isCompleted &&
          other.createdAt == this.createdAt &&
          other.modifiedAt == this.modifiedAt);
}

class OrderServicesItemsCompanion extends UpdateCompanion<OrderServicesItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> documentUuid;
  final Value<int> lineNumber;
  final Value<String> name;
  final Value<String?> description;
  final Value<double> price;
  final Value<double?> duration;
  final Value<String?> performedBy;
  final Value<bool> isCompleted;
  final Value<DateTime> createdAt;
  final Value<DateTime?> modifiedAt;
  const OrderServicesItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.documentUuid = const Value.absent(),
    this.lineNumber = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.price = const Value.absent(),
    this.duration = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.isCompleted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.modifiedAt = const Value.absent(),
  });
  OrderServicesItemsCompanion.insert({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    required String documentUuid,
    this.lineNumber = const Value.absent(),
    required String name,
    this.description = const Value.absent(),
    this.price = const Value.absent(),
    this.duration = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.isCompleted = const Value.absent(),
    required DateTime createdAt,
    this.modifiedAt = const Value.absent(),
  })  : documentUuid = Value(documentUuid),
        name = Value(name),
        createdAt = Value(createdAt);
  static Insertable<OrderServicesItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? documentUuid,
    Expression<int>? lineNumber,
    Expression<String>? name,
    Expression<String>? description,
    Expression<double>? price,
    Expression<double>? duration,
    Expression<String>? performedBy,
    Expression<bool>? isCompleted,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? modifiedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (documentUuid != null) 'document_uuid': documentUuid,
      if (lineNumber != null) 'line_number': lineNumber,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (price != null) 'price': price,
      if (duration != null) 'duration': duration,
      if (performedBy != null) 'performed_by': performedBy,
      if (isCompleted != null) 'is_completed': isCompleted,
      if (createdAt != null) 'created_at': createdAt,
      if (modifiedAt != null) 'modified_at': modifiedAt,
    });
  }

  OrderServicesItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? documentUuid,
      Value<int>? lineNumber,
      Value<String>? name,
      Value<String?>? description,
      Value<double>? price,
      Value<double?>? duration,
      Value<String?>? performedBy,
      Value<bool>? isCompleted,
      Value<DateTime>? createdAt,
      Value<DateTime?>? modifiedAt}) {
    return OrderServicesItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      documentUuid: documentUuid ?? this.documentUuid,
      lineNumber: lineNumber ?? this.lineNumber,
      name: name ?? this.name,
      description: description ?? this.description,
      price: price ?? this.price,
      duration: duration ?? this.duration,
      performedBy: performedBy ?? this.performedBy,
      isCompleted: isCompleted ?? this.isCompleted,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (documentUuid.present) {
      map['document_uuid'] = Variable<String>(documentUuid.value);
    }
    if (lineNumber.present) {
      map['line_number'] = Variable<int>(lineNumber.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (duration.present) {
      map['duration'] = Variable<double>(duration.value);
    }
    if (performedBy.present) {
      map['performed_by'] = Variable<String>(performedBy.value);
    }
    if (isCompleted.present) {
      map['is_completed'] = Variable<bool>(isCompleted.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (modifiedAt.present) {
      map['modified_at'] = Variable<DateTime>(modifiedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderServicesItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('documentUuid: $documentUuid, ')
          ..write('lineNumber: $lineNumber, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('price: $price, ')
          ..write('duration: $duration, ')
          ..write('performedBy: $performedBy, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('modifiedAt: $modifiedAt')
          ..write(')'))
        .toString();
  }
}

class $SupplierSettingsItemsTable extends SupplierSettingsItems
    with TableInfo<$SupplierSettingsItemsTable, SupplierSettingsItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplierSettingsItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _supplierCodeMeta =
      const VerificationMeta('supplierCode');
  @override
  late final GeneratedColumn<String> supplierCode = GeneratedColumn<String>(
      'supplier_code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _isEnabledMeta =
      const VerificationMeta('isEnabled');
  @override
  late final GeneratedColumn<bool> isEnabled = GeneratedColumn<bool>(
      'is_enabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_enabled" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _encryptedCredentialsMeta =
      const VerificationMeta('encryptedCredentials');
  @override
  late final GeneratedColumn<String> encryptedCredentials =
      GeneratedColumn<String>('encrypted_credentials', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastCheckStatusMeta =
      const VerificationMeta('lastCheckStatus');
  @override
  late final GeneratedColumn<String> lastCheckStatus = GeneratedColumn<String>(
      'last_check_status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastCheckMessageMeta =
      const VerificationMeta('lastCheckMessage');
  @override
  late final GeneratedColumn<String> lastCheckMessage = GeneratedColumn<String>(
      'last_check_message', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastSuccessfulCheckAtMeta =
      const VerificationMeta('lastSuccessfulCheckAt');
  @override
  late final GeneratedColumn<DateTime> lastSuccessfulCheckAt =
      GeneratedColumn<DateTime>('last_successful_check_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _clientIdentifierAtSupplierMeta =
      const VerificationMeta('clientIdentifierAtSupplier');
  @override
  late final GeneratedColumn<String> clientIdentifierAtSupplier =
      GeneratedColumn<String>(
          'client_identifier_at_supplier', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalConfigMeta =
      const VerificationMeta('additionalConfig');
  @override
  late final GeneratedColumn<String> additionalConfig = GeneratedColumn<String>(
      'additional_config', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        supplierCode,
        isEnabled,
        encryptedCredentials,
        lastCheckStatus,
        lastCheckMessage,
        lastSuccessfulCheckAt,
        clientIdentifierAtSupplier,
        additionalConfig,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplier_settings';
  @override
  VerificationContext validateIntegrity(
      Insertable<SupplierSettingsItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('supplier_code')) {
      context.handle(
          _supplierCodeMeta,
          supplierCode.isAcceptableOrUnknown(
              data['supplier_code']!, _supplierCodeMeta));
    } else if (isInserting) {
      context.missing(_supplierCodeMeta);
    }
    if (data.containsKey('is_enabled')) {
      context.handle(_isEnabledMeta,
          isEnabled.isAcceptableOrUnknown(data['is_enabled']!, _isEnabledMeta));
    }
    if (data.containsKey('encrypted_credentials')) {
      context.handle(
          _encryptedCredentialsMeta,
          encryptedCredentials.isAcceptableOrUnknown(
              data['encrypted_credentials']!, _encryptedCredentialsMeta));
    }
    if (data.containsKey('last_check_status')) {
      context.handle(
          _lastCheckStatusMeta,
          lastCheckStatus.isAcceptableOrUnknown(
              data['last_check_status']!, _lastCheckStatusMeta));
    }
    if (data.containsKey('last_check_message')) {
      context.handle(
          _lastCheckMessageMeta,
          lastCheckMessage.isAcceptableOrUnknown(
              data['last_check_message']!, _lastCheckMessageMeta));
    }
    if (data.containsKey('last_successful_check_at')) {
      context.handle(
          _lastSuccessfulCheckAtMeta,
          lastSuccessfulCheckAt.isAcceptableOrUnknown(
              data['last_successful_check_at']!, _lastSuccessfulCheckAtMeta));
    }
    if (data.containsKey('client_identifier_at_supplier')) {
      context.handle(
          _clientIdentifierAtSupplierMeta,
          clientIdentifierAtSupplier.isAcceptableOrUnknown(
              data['client_identifier_at_supplier']!,
              _clientIdentifierAtSupplierMeta));
    }
    if (data.containsKey('additional_config')) {
      context.handle(
          _additionalConfigMeta,
          additionalConfig.isAcceptableOrUnknown(
              data['additional_config']!, _additionalConfigMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplierSettingsItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplierSettingsItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      supplierCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_code'])!,
      isEnabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_enabled'])!,
      encryptedCredentials: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}encrypted_credentials']),
      lastCheckStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_check_status']),
      lastCheckMessage: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_check_message']),
      lastSuccessfulCheckAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime,
          data['${effectivePrefix}last_successful_check_at']),
      clientIdentifierAtSupplier: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}client_identifier_at_supplier']),
      additionalConfig: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_config']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SupplierSettingsItemsTable createAlias(String alias) {
    return $SupplierSettingsItemsTable(attachedDatabase, alias);
  }
}

class SupplierSettingsItem extends DataClass
    implements Insertable<SupplierSettingsItem> {
  final int id;
  final String supplierCode;
  final bool isEnabled;

  /// Зашифрованные учетные данные (логин, пароль, API-ключ в виде JSON-строки, затем зашифрованной).
  /// Может храниться как BLOB, если шифрование дает бинарные данные,
  /// или как TEXT, если результат шифрования - base64 строка.
  /// Выберем TEXT для простоты, предполагая base64.
  final String? encryptedCredentials;

  /// Статус последней проверки ("success", "error_auth", "error_network", "not_checked" и т.д.).
  final String? lastCheckStatus;
  final String? lastCheckMessage;
  final DateTime? lastSuccessfulCheckAt;

  /// ID клиента у поставщика (если есть, например, после успешной регистрации/подключения).
  final String? clientIdentifierAtSupplier;

  /// JSON-строка для хранения специфичных для поставщика настроек
  /// (например, выбранный VKORG для Armtek, список выбранных складов и т.д.).
  final String? additionalConfig;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SupplierSettingsItem(
      {required this.id,
      required this.supplierCode,
      required this.isEnabled,
      this.encryptedCredentials,
      this.lastCheckStatus,
      this.lastCheckMessage,
      this.lastSuccessfulCheckAt,
      this.clientIdentifierAtSupplier,
      this.additionalConfig,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['supplier_code'] = Variable<String>(supplierCode);
    map['is_enabled'] = Variable<bool>(isEnabled);
    if (!nullToAbsent || encryptedCredentials != null) {
      map['encrypted_credentials'] = Variable<String>(encryptedCredentials);
    }
    if (!nullToAbsent || lastCheckStatus != null) {
      map['last_check_status'] = Variable<String>(lastCheckStatus);
    }
    if (!nullToAbsent || lastCheckMessage != null) {
      map['last_check_message'] = Variable<String>(lastCheckMessage);
    }
    if (!nullToAbsent || lastSuccessfulCheckAt != null) {
      map['last_successful_check_at'] =
          Variable<DateTime>(lastSuccessfulCheckAt);
    }
    if (!nullToAbsent || clientIdentifierAtSupplier != null) {
      map['client_identifier_at_supplier'] =
          Variable<String>(clientIdentifierAtSupplier);
    }
    if (!nullToAbsent || additionalConfig != null) {
      map['additional_config'] = Variable<String>(additionalConfig);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SupplierSettingsItemsCompanion toCompanion(bool nullToAbsent) {
    return SupplierSettingsItemsCompanion(
      id: Value(id),
      supplierCode: Value(supplierCode),
      isEnabled: Value(isEnabled),
      encryptedCredentials: encryptedCredentials == null && nullToAbsent
          ? const Value.absent()
          : Value(encryptedCredentials),
      lastCheckStatus: lastCheckStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(lastCheckStatus),
      lastCheckMessage: lastCheckMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(lastCheckMessage),
      lastSuccessfulCheckAt: lastSuccessfulCheckAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSuccessfulCheckAt),
      clientIdentifierAtSupplier:
          clientIdentifierAtSupplier == null && nullToAbsent
              ? const Value.absent()
              : Value(clientIdentifierAtSupplier),
      additionalConfig: additionalConfig == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalConfig),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SupplierSettingsItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplierSettingsItem(
      id: serializer.fromJson<int>(json['id']),
      supplierCode: serializer.fromJson<String>(json['supplierCode']),
      isEnabled: serializer.fromJson<bool>(json['isEnabled']),
      encryptedCredentials:
          serializer.fromJson<String?>(json['encryptedCredentials']),
      lastCheckStatus: serializer.fromJson<String?>(json['lastCheckStatus']),
      lastCheckMessage: serializer.fromJson<String?>(json['lastCheckMessage']),
      lastSuccessfulCheckAt:
          serializer.fromJson<DateTime?>(json['lastSuccessfulCheckAt']),
      clientIdentifierAtSupplier:
          serializer.fromJson<String?>(json['clientIdentifierAtSupplier']),
      additionalConfig: serializer.fromJson<String?>(json['additionalConfig']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'supplierCode': serializer.toJson<String>(supplierCode),
      'isEnabled': serializer.toJson<bool>(isEnabled),
      'encryptedCredentials': serializer.toJson<String?>(encryptedCredentials),
      'lastCheckStatus': serializer.toJson<String?>(lastCheckStatus),
      'lastCheckMessage': serializer.toJson<String?>(lastCheckMessage),
      'lastSuccessfulCheckAt':
          serializer.toJson<DateTime?>(lastSuccessfulCheckAt),
      'clientIdentifierAtSupplier':
          serializer.toJson<String?>(clientIdentifierAtSupplier),
      'additionalConfig': serializer.toJson<String?>(additionalConfig),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SupplierSettingsItem copyWith(
          {int? id,
          String? supplierCode,
          bool? isEnabled,
          Value<String?> encryptedCredentials = const Value.absent(),
          Value<String?> lastCheckStatus = const Value.absent(),
          Value<String?> lastCheckMessage = const Value.absent(),
          Value<DateTime?> lastSuccessfulCheckAt = const Value.absent(),
          Value<String?> clientIdentifierAtSupplier = const Value.absent(),
          Value<String?> additionalConfig = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      SupplierSettingsItem(
        id: id ?? this.id,
        supplierCode: supplierCode ?? this.supplierCode,
        isEnabled: isEnabled ?? this.isEnabled,
        encryptedCredentials: encryptedCredentials.present
            ? encryptedCredentials.value
            : this.encryptedCredentials,
        lastCheckStatus: lastCheckStatus.present
            ? lastCheckStatus.value
            : this.lastCheckStatus,
        lastCheckMessage: lastCheckMessage.present
            ? lastCheckMessage.value
            : this.lastCheckMessage,
        lastSuccessfulCheckAt: lastSuccessfulCheckAt.present
            ? lastSuccessfulCheckAt.value
            : this.lastSuccessfulCheckAt,
        clientIdentifierAtSupplier: clientIdentifierAtSupplier.present
            ? clientIdentifierAtSupplier.value
            : this.clientIdentifierAtSupplier,
        additionalConfig: additionalConfig.present
            ? additionalConfig.value
            : this.additionalConfig,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  SupplierSettingsItem copyWithCompanion(SupplierSettingsItemsCompanion data) {
    return SupplierSettingsItem(
      id: data.id.present ? data.id.value : this.id,
      supplierCode: data.supplierCode.present
          ? data.supplierCode.value
          : this.supplierCode,
      isEnabled: data.isEnabled.present ? data.isEnabled.value : this.isEnabled,
      encryptedCredentials: data.encryptedCredentials.present
          ? data.encryptedCredentials.value
          : this.encryptedCredentials,
      lastCheckStatus: data.lastCheckStatus.present
          ? data.lastCheckStatus.value
          : this.lastCheckStatus,
      lastCheckMessage: data.lastCheckMessage.present
          ? data.lastCheckMessage.value
          : this.lastCheckMessage,
      lastSuccessfulCheckAt: data.lastSuccessfulCheckAt.present
          ? data.lastSuccessfulCheckAt.value
          : this.lastSuccessfulCheckAt,
      clientIdentifierAtSupplier: data.clientIdentifierAtSupplier.present
          ? data.clientIdentifierAtSupplier.value
          : this.clientIdentifierAtSupplier,
      additionalConfig: data.additionalConfig.present
          ? data.additionalConfig.value
          : this.additionalConfig,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplierSettingsItem(')
          ..write('id: $id, ')
          ..write('supplierCode: $supplierCode, ')
          ..write('isEnabled: $isEnabled, ')
          ..write('encryptedCredentials: $encryptedCredentials, ')
          ..write('lastCheckStatus: $lastCheckStatus, ')
          ..write('lastCheckMessage: $lastCheckMessage, ')
          ..write('lastSuccessfulCheckAt: $lastSuccessfulCheckAt, ')
          ..write('clientIdentifierAtSupplier: $clientIdentifierAtSupplier, ')
          ..write('additionalConfig: $additionalConfig, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      supplierCode,
      isEnabled,
      encryptedCredentials,
      lastCheckStatus,
      lastCheckMessage,
      lastSuccessfulCheckAt,
      clientIdentifierAtSupplier,
      additionalConfig,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplierSettingsItem &&
          other.id == this.id &&
          other.supplierCode == this.supplierCode &&
          other.isEnabled == this.isEnabled &&
          other.encryptedCredentials == this.encryptedCredentials &&
          other.lastCheckStatus == this.lastCheckStatus &&
          other.lastCheckMessage == this.lastCheckMessage &&
          other.lastSuccessfulCheckAt == this.lastSuccessfulCheckAt &&
          other.clientIdentifierAtSupplier == this.clientIdentifierAtSupplier &&
          other.additionalConfig == this.additionalConfig &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SupplierSettingsItemsCompanion
    extends UpdateCompanion<SupplierSettingsItem> {
  final Value<int> id;
  final Value<String> supplierCode;
  final Value<bool> isEnabled;
  final Value<String?> encryptedCredentials;
  final Value<String?> lastCheckStatus;
  final Value<String?> lastCheckMessage;
  final Value<DateTime?> lastSuccessfulCheckAt;
  final Value<String?> clientIdentifierAtSupplier;
  final Value<String?> additionalConfig;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const SupplierSettingsItemsCompanion({
    this.id = const Value.absent(),
    this.supplierCode = const Value.absent(),
    this.isEnabled = const Value.absent(),
    this.encryptedCredentials = const Value.absent(),
    this.lastCheckStatus = const Value.absent(),
    this.lastCheckMessage = const Value.absent(),
    this.lastSuccessfulCheckAt = const Value.absent(),
    this.clientIdentifierAtSupplier = const Value.absent(),
    this.additionalConfig = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SupplierSettingsItemsCompanion.insert({
    this.id = const Value.absent(),
    required String supplierCode,
    this.isEnabled = const Value.absent(),
    this.encryptedCredentials = const Value.absent(),
    this.lastCheckStatus = const Value.absent(),
    this.lastCheckMessage = const Value.absent(),
    this.lastSuccessfulCheckAt = const Value.absent(),
    this.clientIdentifierAtSupplier = const Value.absent(),
    this.additionalConfig = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : supplierCode = Value(supplierCode);
  static Insertable<SupplierSettingsItem> custom({
    Expression<int>? id,
    Expression<String>? supplierCode,
    Expression<bool>? isEnabled,
    Expression<String>? encryptedCredentials,
    Expression<String>? lastCheckStatus,
    Expression<String>? lastCheckMessage,
    Expression<DateTime>? lastSuccessfulCheckAt,
    Expression<String>? clientIdentifierAtSupplier,
    Expression<String>? additionalConfig,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (supplierCode != null) 'supplier_code': supplierCode,
      if (isEnabled != null) 'is_enabled': isEnabled,
      if (encryptedCredentials != null)
        'encrypted_credentials': encryptedCredentials,
      if (lastCheckStatus != null) 'last_check_status': lastCheckStatus,
      if (lastCheckMessage != null) 'last_check_message': lastCheckMessage,
      if (lastSuccessfulCheckAt != null)
        'last_successful_check_at': lastSuccessfulCheckAt,
      if (clientIdentifierAtSupplier != null)
        'client_identifier_at_supplier': clientIdentifierAtSupplier,
      if (additionalConfig != null) 'additional_config': additionalConfig,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SupplierSettingsItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? supplierCode,
      Value<bool>? isEnabled,
      Value<String?>? encryptedCredentials,
      Value<String?>? lastCheckStatus,
      Value<String?>? lastCheckMessage,
      Value<DateTime?>? lastSuccessfulCheckAt,
      Value<String?>? clientIdentifierAtSupplier,
      Value<String?>? additionalConfig,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return SupplierSettingsItemsCompanion(
      id: id ?? this.id,
      supplierCode: supplierCode ?? this.supplierCode,
      isEnabled: isEnabled ?? this.isEnabled,
      encryptedCredentials: encryptedCredentials ?? this.encryptedCredentials,
      lastCheckStatus: lastCheckStatus ?? this.lastCheckStatus,
      lastCheckMessage: lastCheckMessage ?? this.lastCheckMessage,
      lastSuccessfulCheckAt:
          lastSuccessfulCheckAt ?? this.lastSuccessfulCheckAt,
      clientIdentifierAtSupplier:
          clientIdentifierAtSupplier ?? this.clientIdentifierAtSupplier,
      additionalConfig: additionalConfig ?? this.additionalConfig,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (supplierCode.present) {
      map['supplier_code'] = Variable<String>(supplierCode.value);
    }
    if (isEnabled.present) {
      map['is_enabled'] = Variable<bool>(isEnabled.value);
    }
    if (encryptedCredentials.present) {
      map['encrypted_credentials'] =
          Variable<String>(encryptedCredentials.value);
    }
    if (lastCheckStatus.present) {
      map['last_check_status'] = Variable<String>(lastCheckStatus.value);
    }
    if (lastCheckMessage.present) {
      map['last_check_message'] = Variable<String>(lastCheckMessage.value);
    }
    if (lastSuccessfulCheckAt.present) {
      map['last_successful_check_at'] =
          Variable<DateTime>(lastSuccessfulCheckAt.value);
    }
    if (clientIdentifierAtSupplier.present) {
      map['client_identifier_at_supplier'] =
          Variable<String>(clientIdentifierAtSupplier.value);
    }
    if (additionalConfig.present) {
      map['additional_config'] = Variable<String>(additionalConfig.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplierSettingsItemsCompanion(')
          ..write('id: $id, ')
          ..write('supplierCode: $supplierCode, ')
          ..write('isEnabled: $isEnabled, ')
          ..write('encryptedCredentials: $encryptedCredentials, ')
          ..write('lastCheckStatus: $lastCheckStatus, ')
          ..write('lastCheckMessage: $lastCheckMessage, ')
          ..write('lastSuccessfulCheckAt: $lastSuccessfulCheckAt, ')
          ..write('clientIdentifierAtSupplier: $clientIdentifierAtSupplier, ')
          ..write('additionalConfig: $additionalConfig, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $ClientsItemsTable clientsItems = $ClientsItemsTable(this);
  late final $CarsItemsTable carsItems = $CarsItemsTable(this);
  late final $AppInfoItemsTable appInfoItems = $AppInfoItemsTable(this);
  late final $OrdersItemsTable ordersItems = $OrdersItemsTable(this);
  late final $OrderPartsItemsTable orderPartsItems =
      $OrderPartsItemsTable(this);
  late final $OrderServicesItemsTable orderServicesItems =
      $OrderServicesItemsTable(this);
  late final $SupplierSettingsItemsTable supplierSettingsItems =
      $SupplierSettingsItemsTable(this);
  late final ClientsDao clientsDao = ClientsDao(this as AppDatabase);
  late final CarsDao carsDao = CarsDao(this as AppDatabase);
  late final OrdersDao ordersDao = OrdersDao(this as AppDatabase);
  late final SupplierSettingsDao supplierSettingsDao =
      SupplierSettingsDao(this as AppDatabase);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        clientsItems,
        carsItems,
        appInfoItems,
        ordersItems,
        orderPartsItems,
        orderServicesItems,
        supplierSettingsItems
      ];
}

typedef $$ClientsItemsTableCreateCompanionBuilder = ClientsItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  required String code,
  required String type,
  required String name,
  required String contactInfo,
  Value<String?> additionalInfo,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});
typedef $$ClientsItemsTableUpdateCompanionBuilder = ClientsItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> code,
  Value<String> type,
  Value<String> name,
  Value<String> contactInfo,
  Value<String?> additionalInfo,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});

final class $$ClientsItemsTableReferences
    extends BaseReferences<_$AppDatabase, $ClientsItemsTable, ClientsItem> {
  $$ClientsItemsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$CarsItemsTable, List<CarsItem>>
      _carsItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.carsItems,
          aliasName:
              $_aliasNameGenerator(db.clientsItems.id, db.carsItems.clientId));

  $$CarsItemsTableProcessedTableManager get carsItemsRefs {
    final manager = $$CarsItemsTableTableManager($_db, $_db.carsItems)
        .filter((f) => f.clientId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_carsItemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$OrdersItemsTable, List<OrdersItem>>
      _ordersItemsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.ordersItems,
              aliasName: $_aliasNameGenerator(
                  db.clientsItems.uuid, db.ordersItems.clientUuid));

  $$OrdersItemsTableProcessedTableManager get ordersItemsRefs {
    final manager = $$OrdersItemsTableTableManager($_db, $_db.ordersItems)
        .filter(
            (f) => f.clientUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult.readTableOrNull(_ordersItemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ClientsItemsTableFilterComposer
    extends Composer<_$AppDatabase, $ClientsItemsTable> {
  $$ClientsItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contactInfo => $composableBuilder(
      column: $table.contactInfo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnFilters(column));

  Expression<bool> carsItemsRefs(
      Expression<bool> Function($$CarsItemsTableFilterComposer f) f) {
    final $$CarsItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.carsItems,
        getReferencedColumn: (t) => t.clientId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CarsItemsTableFilterComposer(
              $db: $db,
              $table: $db.carsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> ordersItemsRefs(
      Expression<bool> Function($$OrdersItemsTableFilterComposer f) f) {
    final $$OrdersItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.clientUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableFilterComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ClientsItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $ClientsItemsTable> {
  $$ClientsItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contactInfo => $composableBuilder(
      column: $table.contactInfo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnOrderings(column));
}

class $$ClientsItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClientsItemsTable> {
  $$ClientsItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get contactInfo => $composableBuilder(
      column: $table.contactInfo, builder: (column) => column);

  GeneratedColumn<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  Expression<T> carsItemsRefs<T extends Object>(
      Expression<T> Function($$CarsItemsTableAnnotationComposer a) f) {
    final $$CarsItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.carsItems,
        getReferencedColumn: (t) => t.clientId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CarsItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.carsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> ordersItemsRefs<T extends Object>(
      Expression<T> Function($$OrdersItemsTableAnnotationComposer a) f) {
    final $$OrdersItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.clientUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ClientsItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ClientsItemsTable,
    ClientsItem,
    $$ClientsItemsTableFilterComposer,
    $$ClientsItemsTableOrderingComposer,
    $$ClientsItemsTableAnnotationComposer,
    $$ClientsItemsTableCreateCompanionBuilder,
    $$ClientsItemsTableUpdateCompanionBuilder,
    (ClientsItem, $$ClientsItemsTableReferences),
    ClientsItem,
    PrefetchHooks Function({bool carsItemsRefs, bool ordersItemsRefs})> {
  $$ClientsItemsTableTableManager(_$AppDatabase db, $ClientsItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClientsItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClientsItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ClientsItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> contactInfo = const Value.absent(),
            Value<String?> additionalInfo = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              ClientsItemsCompanion(
            id: id,
            uuid: uuid,
            code: code,
            type: type,
            name: name,
            contactInfo: contactInfo,
            additionalInfo: additionalInfo,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            required String code,
            required String type,
            required String name,
            required String contactInfo,
            Value<String?> additionalInfo = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              ClientsItemsCompanion.insert(
            id: id,
            uuid: uuid,
            code: code,
            type: type,
            name: name,
            contactInfo: contactInfo,
            additionalInfo: additionalInfo,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ClientsItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {carsItemsRefs = false, ordersItemsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (carsItemsRefs) db.carsItems,
                if (ordersItemsRefs) db.ordersItems
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (carsItemsRefs)
                    await $_getPrefetchedData<ClientsItem, $ClientsItemsTable,
                            CarsItem>(
                        currentTable: table,
                        referencedTable: $$ClientsItemsTableReferences
                            ._carsItemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ClientsItemsTableReferences(db, table, p0)
                                .carsItemsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clientId == item.id),
                        typedResults: items),
                  if (ordersItemsRefs)
                    await $_getPrefetchedData<ClientsItem, $ClientsItemsTable,
                            OrdersItem>(
                        currentTable: table,
                        referencedTable: $$ClientsItemsTableReferences
                            ._ordersItemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ClientsItemsTableReferences(db, table, p0)
                                .ordersItemsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.clientUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ClientsItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ClientsItemsTable,
    ClientsItem,
    $$ClientsItemsTableFilterComposer,
    $$ClientsItemsTableOrderingComposer,
    $$ClientsItemsTableAnnotationComposer,
    $$ClientsItemsTableCreateCompanionBuilder,
    $$ClientsItemsTableUpdateCompanionBuilder,
    (ClientsItem, $$ClientsItemsTableReferences),
    ClientsItem,
    PrefetchHooks Function({bool carsItemsRefs, bool ordersItemsRefs})>;
typedef $$CarsItemsTableCreateCompanionBuilder = CarsItemsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  required int clientId,
  Value<String?> vin,
  required String make,
  required String model,
  Value<int?> year,
  Value<String?> licensePlate,
  Value<String?> additionalInfo,
  Value<String> code,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});
typedef $$CarsItemsTableUpdateCompanionBuilder = CarsItemsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<int> clientId,
  Value<String?> vin,
  Value<String> make,
  Value<String> model,
  Value<int?> year,
  Value<String?> licensePlate,
  Value<String?> additionalInfo,
  Value<String> code,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});

final class $$CarsItemsTableReferences
    extends BaseReferences<_$AppDatabase, $CarsItemsTable, CarsItem> {
  $$CarsItemsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ClientsItemsTable _clientIdTable(_$AppDatabase db) =>
      db.clientsItems.createAlias(
          $_aliasNameGenerator(db.carsItems.clientId, db.clientsItems.id));

  $$ClientsItemsTableProcessedTableManager get clientId {
    final $_column = $_itemColumn<int>('client_id')!;

    final manager = $$ClientsItemsTableTableManager($_db, $_db.clientsItems)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clientIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$OrdersItemsTable, List<OrdersItem>>
      _ordersItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.ordersItems,
          aliasName:
              $_aliasNameGenerator(db.carsItems.uuid, db.ordersItems.carUuid));

  $$OrdersItemsTableProcessedTableManager get ordersItemsRefs {
    final manager = $$OrdersItemsTableTableManager($_db, $_db.ordersItems)
        .filter((f) => f.carUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult.readTableOrNull(_ordersItemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$CarsItemsTableFilterComposer
    extends Composer<_$AppDatabase, $CarsItemsTable> {
  $$CarsItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get vin => $composableBuilder(
      column: $table.vin, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get make => $composableBuilder(
      column: $table.make, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get model => $composableBuilder(
      column: $table.model, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get year => $composableBuilder(
      column: $table.year, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get licensePlate => $composableBuilder(
      column: $table.licensePlate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnFilters(column));

  $$ClientsItemsTableFilterComposer get clientId {
    final $$ClientsItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientId,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableFilterComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> ordersItemsRefs(
      Expression<bool> Function($$OrdersItemsTableFilterComposer f) f) {
    final $$OrdersItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.carUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableFilterComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$CarsItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $CarsItemsTable> {
  $$CarsItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get vin => $composableBuilder(
      column: $table.vin, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get make => $composableBuilder(
      column: $table.make, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get model => $composableBuilder(
      column: $table.model, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get year => $composableBuilder(
      column: $table.year, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get licensePlate => $composableBuilder(
      column: $table.licensePlate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnOrderings(column));

  $$ClientsItemsTableOrderingComposer get clientId {
    final $$ClientsItemsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientId,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableOrderingComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CarsItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CarsItemsTable> {
  $$CarsItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get vin =>
      $composableBuilder(column: $table.vin, builder: (column) => column);

  GeneratedColumn<String> get make =>
      $composableBuilder(column: $table.make, builder: (column) => column);

  GeneratedColumn<String> get model =>
      $composableBuilder(column: $table.model, builder: (column) => column);

  GeneratedColumn<int> get year =>
      $composableBuilder(column: $table.year, builder: (column) => column);

  GeneratedColumn<String> get licensePlate => $composableBuilder(
      column: $table.licensePlate, builder: (column) => column);

  GeneratedColumn<String> get additionalInfo => $composableBuilder(
      column: $table.additionalInfo, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$ClientsItemsTableAnnotationComposer get clientId {
    final $$ClientsItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientId,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> ordersItemsRefs<T extends Object>(
      Expression<T> Function($$OrdersItemsTableAnnotationComposer a) f) {
    final $$OrdersItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.carUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$CarsItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CarsItemsTable,
    CarsItem,
    $$CarsItemsTableFilterComposer,
    $$CarsItemsTableOrderingComposer,
    $$CarsItemsTableAnnotationComposer,
    $$CarsItemsTableCreateCompanionBuilder,
    $$CarsItemsTableUpdateCompanionBuilder,
    (CarsItem, $$CarsItemsTableReferences),
    CarsItem,
    PrefetchHooks Function({bool clientId, bool ordersItemsRefs})> {
  $$CarsItemsTableTableManager(_$AppDatabase db, $CarsItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CarsItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CarsItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CarsItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<int> clientId = const Value.absent(),
            Value<String?> vin = const Value.absent(),
            Value<String> make = const Value.absent(),
            Value<String> model = const Value.absent(),
            Value<int?> year = const Value.absent(),
            Value<String?> licensePlate = const Value.absent(),
            Value<String?> additionalInfo = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              CarsItemsCompanion(
            id: id,
            uuid: uuid,
            clientId: clientId,
            vin: vin,
            make: make,
            model: model,
            year: year,
            licensePlate: licensePlate,
            additionalInfo: additionalInfo,
            code: code,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            required int clientId,
            Value<String?> vin = const Value.absent(),
            required String make,
            required String model,
            Value<int?> year = const Value.absent(),
            Value<String?> licensePlate = const Value.absent(),
            Value<String?> additionalInfo = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              CarsItemsCompanion.insert(
            id: id,
            uuid: uuid,
            clientId: clientId,
            vin: vin,
            make: make,
            model: model,
            year: year,
            licensePlate: licensePlate,
            additionalInfo: additionalInfo,
            code: code,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$CarsItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({clientId = false, ordersItemsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (ordersItemsRefs) db.ordersItems],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clientId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clientId,
                    referencedTable:
                        $$CarsItemsTableReferences._clientIdTable(db),
                    referencedColumn:
                        $$CarsItemsTableReferences._clientIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (ordersItemsRefs)
                    await $_getPrefetchedData<CarsItem, $CarsItemsTable,
                            OrdersItem>(
                        currentTable: table,
                        referencedTable: $$CarsItemsTableReferences
                            ._ordersItemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$CarsItemsTableReferences(db, table, p0)
                                .ordersItemsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.carUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$CarsItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CarsItemsTable,
    CarsItem,
    $$CarsItemsTableFilterComposer,
    $$CarsItemsTableOrderingComposer,
    $$CarsItemsTableAnnotationComposer,
    $$CarsItemsTableCreateCompanionBuilder,
    $$CarsItemsTableUpdateCompanionBuilder,
    (CarsItem, $$CarsItemsTableReferences),
    CarsItem,
    PrefetchHooks Function({bool clientId, bool ordersItemsRefs})>;
typedef $$AppInfoItemsTableCreateCompanionBuilder = AppInfoItemsCompanion
    Function({
  required String key,
  required String value,
  Value<int> rowid,
});
typedef $$AppInfoItemsTableUpdateCompanionBuilder = AppInfoItemsCompanion
    Function({
  Value<String> key,
  Value<String> value,
  Value<int> rowid,
});

class $$AppInfoItemsTableFilterComposer
    extends Composer<_$AppDatabase, $AppInfoItemsTable> {
  $$AppInfoItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get key => $composableBuilder(
      column: $table.key, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnFilters(column));
}

class $$AppInfoItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $AppInfoItemsTable> {
  $$AppInfoItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get key => $composableBuilder(
      column: $table.key, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnOrderings(column));
}

class $$AppInfoItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AppInfoItemsTable> {
  $$AppInfoItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get key =>
      $composableBuilder(column: $table.key, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);
}

class $$AppInfoItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AppInfoItemsTable,
    AppInfoItem,
    $$AppInfoItemsTableFilterComposer,
    $$AppInfoItemsTableOrderingComposer,
    $$AppInfoItemsTableAnnotationComposer,
    $$AppInfoItemsTableCreateCompanionBuilder,
    $$AppInfoItemsTableUpdateCompanionBuilder,
    (
      AppInfoItem,
      BaseReferences<_$AppDatabase, $AppInfoItemsTable, AppInfoItem>
    ),
    AppInfoItem,
    PrefetchHooks Function()> {
  $$AppInfoItemsTableTableManager(_$AppDatabase db, $AppInfoItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AppInfoItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AppInfoItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AppInfoItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> key = const Value.absent(),
            Value<String> value = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AppInfoItemsCompanion(
            key: key,
            value: value,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String key,
            required String value,
            Value<int> rowid = const Value.absent(),
          }) =>
              AppInfoItemsCompanion.insert(
            key: key,
            value: value,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AppInfoItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $AppInfoItemsTable,
    AppInfoItem,
    $$AppInfoItemsTableFilterComposer,
    $$AppInfoItemsTableOrderingComposer,
    $$AppInfoItemsTableAnnotationComposer,
    $$AppInfoItemsTableCreateCompanionBuilder,
    $$AppInfoItemsTableUpdateCompanionBuilder,
    (
      AppInfoItem,
      BaseReferences<_$AppDatabase, $AppInfoItemsTable, AppInfoItem>
    ),
    AppInfoItem,
    PrefetchHooks Function()>;
typedef $$OrdersItemsTableCreateCompanionBuilder = OrdersItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  required String clientUuid,
  required String carUuid,
  required String number,
  required DateTime date,
  Value<DateTime?> scheduledDate,
  Value<DateTime?> completedAt,
  required String status,
  Value<String?> description,
  Value<double> totalAmount,
  Value<bool> isPosted,
  required DateTime createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});
typedef $$OrdersItemsTableUpdateCompanionBuilder = OrdersItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> clientUuid,
  Value<String> carUuid,
  Value<String> number,
  Value<DateTime> date,
  Value<DateTime?> scheduledDate,
  Value<DateTime?> completedAt,
  Value<String> status,
  Value<String?> description,
  Value<double> totalAmount,
  Value<bool> isPosted,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
  Value<DateTime?> deletedAt,
});

final class $$OrdersItemsTableReferences
    extends BaseReferences<_$AppDatabase, $OrdersItemsTable, OrdersItem> {
  $$OrdersItemsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ClientsItemsTable _clientUuidTable(_$AppDatabase db) =>
      db.clientsItems.createAlias($_aliasNameGenerator(
          db.ordersItems.clientUuid, db.clientsItems.uuid));

  $$ClientsItemsTableProcessedTableManager get clientUuid {
    final $_column = $_itemColumn<String>('client_uuid')!;

    final manager = $$ClientsItemsTableTableManager($_db, $_db.clientsItems)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clientUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $CarsItemsTable _carUuidTable(_$AppDatabase db) =>
      db.carsItems.createAlias(
          $_aliasNameGenerator(db.ordersItems.carUuid, db.carsItems.uuid));

  $$CarsItemsTableProcessedTableManager get carUuid {
    final $_column = $_itemColumn<String>('car_uuid')!;

    final manager = $$CarsItemsTableTableManager($_db, $_db.carsItems)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_carUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$OrderPartsItemsTable, List<OrderPartsItem>>
      _orderPartsItemsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.orderPartsItems,
              aliasName: $_aliasNameGenerator(
                  db.ordersItems.uuid, db.orderPartsItems.documentUuid));

  $$OrderPartsItemsTableProcessedTableManager get orderPartsItemsRefs {
    final manager =
        $$OrderPartsItemsTableTableManager($_db, $_db.orderPartsItems).filter(
            (f) =>
                f.documentUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_orderPartsItemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$OrderServicesItemsTable, List<OrderServicesItem>>
      _orderServicesItemsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.orderServicesItems,
              aliasName: $_aliasNameGenerator(
                  db.ordersItems.uuid, db.orderServicesItems.documentUuid));

  $$OrderServicesItemsTableProcessedTableManager get orderServicesItemsRefs {
    final manager =
        $$OrderServicesItemsTableTableManager($_db, $_db.orderServicesItems)
            .filter((f) =>
                f.documentUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_orderServicesItemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$OrdersItemsTableFilterComposer
    extends Composer<_$AppDatabase, $OrdersItemsTable> {
  $$OrdersItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get number => $composableBuilder(
      column: $table.number, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get scheduledDate => $composableBuilder(
      column: $table.scheduledDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPosted => $composableBuilder(
      column: $table.isPosted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnFilters(column));

  $$ClientsItemsTableFilterComposer get clientUuid {
    final $$ClientsItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientUuid,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableFilterComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CarsItemsTableFilterComposer get carUuid {
    final $$CarsItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.carUuid,
        referencedTable: $db.carsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CarsItemsTableFilterComposer(
              $db: $db,
              $table: $db.carsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> orderPartsItemsRefs(
      Expression<bool> Function($$OrderPartsItemsTableFilterComposer f) f) {
    final $$OrderPartsItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.orderPartsItems,
        getReferencedColumn: (t) => t.documentUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderPartsItemsTableFilterComposer(
              $db: $db,
              $table: $db.orderPartsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> orderServicesItemsRefs(
      Expression<bool> Function($$OrderServicesItemsTableFilterComposer f) f) {
    final $$OrderServicesItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.orderServicesItems,
        getReferencedColumn: (t) => t.documentUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderServicesItemsTableFilterComposer(
              $db: $db,
              $table: $db.orderServicesItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$OrdersItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrdersItemsTable> {
  $$OrdersItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get number => $composableBuilder(
      column: $table.number, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get scheduledDate => $composableBuilder(
      column: $table.scheduledDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPosted => $composableBuilder(
      column: $table.isPosted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnOrderings(column));

  $$ClientsItemsTableOrderingComposer get clientUuid {
    final $$ClientsItemsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientUuid,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableOrderingComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CarsItemsTableOrderingComposer get carUuid {
    final $$CarsItemsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.carUuid,
        referencedTable: $db.carsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CarsItemsTableOrderingComposer(
              $db: $db,
              $table: $db.carsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrdersItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrdersItemsTable> {
  $$OrdersItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get number =>
      $composableBuilder(column: $table.number, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<DateTime> get scheduledDate => $composableBuilder(
      column: $table.scheduledDate, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => column);

  GeneratedColumn<bool> get isPosted =>
      $composableBuilder(column: $table.isPosted, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$ClientsItemsTableAnnotationComposer get clientUuid {
    final $$ClientsItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clientUuid,
        referencedTable: $db.clientsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClientsItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.clientsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CarsItemsTableAnnotationComposer get carUuid {
    final $$CarsItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.carUuid,
        referencedTable: $db.carsItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CarsItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.carsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> orderPartsItemsRefs<T extends Object>(
      Expression<T> Function($$OrderPartsItemsTableAnnotationComposer a) f) {
    final $$OrderPartsItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.orderPartsItems,
        getReferencedColumn: (t) => t.documentUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderPartsItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.orderPartsItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> orderServicesItemsRefs<T extends Object>(
      Expression<T> Function($$OrderServicesItemsTableAnnotationComposer a) f) {
    final $$OrderServicesItemsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.orderServicesItems,
            getReferencedColumn: (t) => t.documentUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$OrderServicesItemsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.orderServicesItems,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$OrdersItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrdersItemsTable,
    OrdersItem,
    $$OrdersItemsTableFilterComposer,
    $$OrdersItemsTableOrderingComposer,
    $$OrdersItemsTableAnnotationComposer,
    $$OrdersItemsTableCreateCompanionBuilder,
    $$OrdersItemsTableUpdateCompanionBuilder,
    (OrdersItem, $$OrdersItemsTableReferences),
    OrdersItem,
    PrefetchHooks Function(
        {bool clientUuid,
        bool carUuid,
        bool orderPartsItemsRefs,
        bool orderServicesItemsRefs})> {
  $$OrdersItemsTableTableManager(_$AppDatabase db, $OrdersItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrdersItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrdersItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrdersItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> clientUuid = const Value.absent(),
            Value<String> carUuid = const Value.absent(),
            Value<String> number = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<DateTime?> scheduledDate = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<double> totalAmount = const Value.absent(),
            Value<bool> isPosted = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              OrdersItemsCompanion(
            id: id,
            uuid: uuid,
            clientUuid: clientUuid,
            carUuid: carUuid,
            number: number,
            date: date,
            scheduledDate: scheduledDate,
            completedAt: completedAt,
            status: status,
            description: description,
            totalAmount: totalAmount,
            isPosted: isPosted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            required String clientUuid,
            required String carUuid,
            required String number,
            required DateTime date,
            Value<DateTime?> scheduledDate = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
            required String status,
            Value<String?> description = const Value.absent(),
            Value<double> totalAmount = const Value.absent(),
            Value<bool> isPosted = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> modifiedAt = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
          }) =>
              OrdersItemsCompanion.insert(
            id: id,
            uuid: uuid,
            clientUuid: clientUuid,
            carUuid: carUuid,
            number: number,
            date: date,
            scheduledDate: scheduledDate,
            completedAt: completedAt,
            status: status,
            description: description,
            totalAmount: totalAmount,
            isPosted: isPosted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrdersItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {clientUuid = false,
              carUuid = false,
              orderPartsItemsRefs = false,
              orderServicesItemsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (orderPartsItemsRefs) db.orderPartsItems,
                if (orderServicesItemsRefs) db.orderServicesItems
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clientUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clientUuid,
                    referencedTable:
                        $$OrdersItemsTableReferences._clientUuidTable(db),
                    referencedColumn:
                        $$OrdersItemsTableReferences._clientUuidTable(db).uuid,
                  ) as T;
                }
                if (carUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.carUuid,
                    referencedTable:
                        $$OrdersItemsTableReferences._carUuidTable(db),
                    referencedColumn:
                        $$OrdersItemsTableReferences._carUuidTable(db).uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (orderPartsItemsRefs)
                    await $_getPrefetchedData<OrdersItem, $OrdersItemsTable,
                            OrderPartsItem>(
                        currentTable: table,
                        referencedTable: $$OrdersItemsTableReferences
                            ._orderPartsItemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrdersItemsTableReferences(db, table, p0)
                                .orderPartsItemsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.documentUuid == item.uuid),
                        typedResults: items),
                  if (orderServicesItemsRefs)
                    await $_getPrefetchedData<OrdersItem, $OrdersItemsTable,
                            OrderServicesItem>(
                        currentTable: table,
                        referencedTable: $$OrdersItemsTableReferences
                            ._orderServicesItemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrdersItemsTableReferences(db, table, p0)
                                .orderServicesItemsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.documentUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$OrdersItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrdersItemsTable,
    OrdersItem,
    $$OrdersItemsTableFilterComposer,
    $$OrdersItemsTableOrderingComposer,
    $$OrdersItemsTableAnnotationComposer,
    $$OrdersItemsTableCreateCompanionBuilder,
    $$OrdersItemsTableUpdateCompanionBuilder,
    (OrdersItem, $$OrdersItemsTableReferences),
    OrdersItem,
    PrefetchHooks Function(
        {bool clientUuid,
        bool carUuid,
        bool orderPartsItemsRefs,
        bool orderServicesItemsRefs})>;
typedef $$OrderPartsItemsTableCreateCompanionBuilder = OrderPartsItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  required String documentUuid,
  Value<int> lineNumber,
  required String partNumber,
  required String name,
  Value<String?> brand,
  Value<double> quantity,
  Value<double> price,
  Value<String?> supplierName,
  Value<int?> deliveryDays,
  Value<bool> isOrdered,
  Value<bool> isReceived,
  required DateTime createdAt,
  Value<DateTime?> modifiedAt,
});
typedef $$OrderPartsItemsTableUpdateCompanionBuilder = OrderPartsItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> documentUuid,
  Value<int> lineNumber,
  Value<String> partNumber,
  Value<String> name,
  Value<String?> brand,
  Value<double> quantity,
  Value<double> price,
  Value<String?> supplierName,
  Value<int?> deliveryDays,
  Value<bool> isOrdered,
  Value<bool> isReceived,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
});

final class $$OrderPartsItemsTableReferences extends BaseReferences<
    _$AppDatabase, $OrderPartsItemsTable, OrderPartsItem> {
  $$OrderPartsItemsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrdersItemsTable _documentUuidTable(_$AppDatabase db) =>
      db.ordersItems.createAlias($_aliasNameGenerator(
          db.orderPartsItems.documentUuid, db.ordersItems.uuid));

  $$OrdersItemsTableProcessedTableManager get documentUuid {
    final $_column = $_itemColumn<String>('document_uuid')!;

    final manager = $$OrdersItemsTableTableManager($_db, $_db.ordersItems)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_documentUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$OrderPartsItemsTableFilterComposer
    extends Composer<_$AppDatabase, $OrderPartsItemsTable> {
  $$OrderPartsItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get partNumber => $composableBuilder(
      column: $table.partNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get brand => $composableBuilder(
      column: $table.brand, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supplierName => $composableBuilder(
      column: $table.supplierName, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get deliveryDays => $composableBuilder(
      column: $table.deliveryDays, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isOrdered => $composableBuilder(
      column: $table.isOrdered, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isReceived => $composableBuilder(
      column: $table.isReceived, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnFilters(column));

  $$OrdersItemsTableFilterComposer get documentUuid {
    final $$OrdersItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableFilterComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderPartsItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderPartsItemsTable> {
  $$OrderPartsItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get partNumber => $composableBuilder(
      column: $table.partNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get brand => $composableBuilder(
      column: $table.brand, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supplierName => $composableBuilder(
      column: $table.supplierName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get deliveryDays => $composableBuilder(
      column: $table.deliveryDays,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isOrdered => $composableBuilder(
      column: $table.isOrdered, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isReceived => $composableBuilder(
      column: $table.isReceived, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnOrderings(column));

  $$OrdersItemsTableOrderingComposer get documentUuid {
    final $$OrdersItemsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableOrderingComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderPartsItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderPartsItemsTable> {
  $$OrderPartsItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => column);

  GeneratedColumn<String> get partNumber => $composableBuilder(
      column: $table.partNumber, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get supplierName => $composableBuilder(
      column: $table.supplierName, builder: (column) => column);

  GeneratedColumn<int> get deliveryDays => $composableBuilder(
      column: $table.deliveryDays, builder: (column) => column);

  GeneratedColumn<bool> get isOrdered =>
      $composableBuilder(column: $table.isOrdered, builder: (column) => column);

  GeneratedColumn<bool> get isReceived => $composableBuilder(
      column: $table.isReceived, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => column);

  $$OrdersItemsTableAnnotationComposer get documentUuid {
    final $$OrdersItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderPartsItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrderPartsItemsTable,
    OrderPartsItem,
    $$OrderPartsItemsTableFilterComposer,
    $$OrderPartsItemsTableOrderingComposer,
    $$OrderPartsItemsTableAnnotationComposer,
    $$OrderPartsItemsTableCreateCompanionBuilder,
    $$OrderPartsItemsTableUpdateCompanionBuilder,
    (OrderPartsItem, $$OrderPartsItemsTableReferences),
    OrderPartsItem,
    PrefetchHooks Function({bool documentUuid})> {
  $$OrderPartsItemsTableTableManager(
      _$AppDatabase db, $OrderPartsItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderPartsItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderPartsItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderPartsItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> documentUuid = const Value.absent(),
            Value<int> lineNumber = const Value.absent(),
            Value<String> partNumber = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> brand = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<String?> supplierName = const Value.absent(),
            Value<int?> deliveryDays = const Value.absent(),
            Value<bool> isOrdered = const Value.absent(),
            Value<bool> isReceived = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
          }) =>
              OrderPartsItemsCompanion(
            id: id,
            uuid: uuid,
            documentUuid: documentUuid,
            lineNumber: lineNumber,
            partNumber: partNumber,
            name: name,
            brand: brand,
            quantity: quantity,
            price: price,
            supplierName: supplierName,
            deliveryDays: deliveryDays,
            isOrdered: isOrdered,
            isReceived: isReceived,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            required String documentUuid,
            Value<int> lineNumber = const Value.absent(),
            required String partNumber,
            required String name,
            Value<String?> brand = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<String?> supplierName = const Value.absent(),
            Value<int?> deliveryDays = const Value.absent(),
            Value<bool> isOrdered = const Value.absent(),
            Value<bool> isReceived = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> modifiedAt = const Value.absent(),
          }) =>
              OrderPartsItemsCompanion.insert(
            id: id,
            uuid: uuid,
            documentUuid: documentUuid,
            lineNumber: lineNumber,
            partNumber: partNumber,
            name: name,
            brand: brand,
            quantity: quantity,
            price: price,
            supplierName: supplierName,
            deliveryDays: deliveryDays,
            isOrdered: isOrdered,
            isReceived: isReceived,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrderPartsItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({documentUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (documentUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.documentUuid,
                    referencedTable:
                        $$OrderPartsItemsTableReferences._documentUuidTable(db),
                    referencedColumn: $$OrderPartsItemsTableReferences
                        ._documentUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$OrderPartsItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrderPartsItemsTable,
    OrderPartsItem,
    $$OrderPartsItemsTableFilterComposer,
    $$OrderPartsItemsTableOrderingComposer,
    $$OrderPartsItemsTableAnnotationComposer,
    $$OrderPartsItemsTableCreateCompanionBuilder,
    $$OrderPartsItemsTableUpdateCompanionBuilder,
    (OrderPartsItem, $$OrderPartsItemsTableReferences),
    OrderPartsItem,
    PrefetchHooks Function({bool documentUuid})>;
typedef $$OrderServicesItemsTableCreateCompanionBuilder
    = OrderServicesItemsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  required String documentUuid,
  Value<int> lineNumber,
  required String name,
  Value<String?> description,
  Value<double> price,
  Value<double?> duration,
  Value<String?> performedBy,
  Value<bool> isCompleted,
  required DateTime createdAt,
  Value<DateTime?> modifiedAt,
});
typedef $$OrderServicesItemsTableUpdateCompanionBuilder
    = OrderServicesItemsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> documentUuid,
  Value<int> lineNumber,
  Value<String> name,
  Value<String?> description,
  Value<double> price,
  Value<double?> duration,
  Value<String?> performedBy,
  Value<bool> isCompleted,
  Value<DateTime> createdAt,
  Value<DateTime?> modifiedAt,
});

final class $$OrderServicesItemsTableReferences extends BaseReferences<
    _$AppDatabase, $OrderServicesItemsTable, OrderServicesItem> {
  $$OrderServicesItemsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrdersItemsTable _documentUuidTable(_$AppDatabase db) =>
      db.ordersItems.createAlias($_aliasNameGenerator(
          db.orderServicesItems.documentUuid, db.ordersItems.uuid));

  $$OrdersItemsTableProcessedTableManager get documentUuid {
    final $_column = $_itemColumn<String>('document_uuid')!;

    final manager = $$OrdersItemsTableTableManager($_db, $_db.ordersItems)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_documentUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$OrderServicesItemsTableFilterComposer
    extends Composer<_$AppDatabase, $OrderServicesItemsTable> {
  $$OrderServicesItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get duration => $composableBuilder(
      column: $table.duration, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isCompleted => $composableBuilder(
      column: $table.isCompleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnFilters(column));

  $$OrdersItemsTableFilterComposer get documentUuid {
    final $$OrdersItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableFilterComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderServicesItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderServicesItemsTable> {
  $$OrderServicesItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get duration => $composableBuilder(
      column: $table.duration, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isCompleted => $composableBuilder(
      column: $table.isCompleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => ColumnOrderings(column));

  $$OrdersItemsTableOrderingComposer get documentUuid {
    final $$OrdersItemsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableOrderingComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderServicesItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderServicesItemsTable> {
  $$OrderServicesItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<int> get lineNumber => $composableBuilder(
      column: $table.lineNumber, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<double> get duration =>
      $composableBuilder(column: $table.duration, builder: (column) => column);

  GeneratedColumn<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => column);

  GeneratedColumn<bool> get isCompleted => $composableBuilder(
      column: $table.isCompleted, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get modifiedAt => $composableBuilder(
      column: $table.modifiedAt, builder: (column) => column);

  $$OrdersItemsTableAnnotationComposer get documentUuid {
    final $$OrdersItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.documentUuid,
        referencedTable: $db.ordersItems,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.ordersItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderServicesItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrderServicesItemsTable,
    OrderServicesItem,
    $$OrderServicesItemsTableFilterComposer,
    $$OrderServicesItemsTableOrderingComposer,
    $$OrderServicesItemsTableAnnotationComposer,
    $$OrderServicesItemsTableCreateCompanionBuilder,
    $$OrderServicesItemsTableUpdateCompanionBuilder,
    (OrderServicesItem, $$OrderServicesItemsTableReferences),
    OrderServicesItem,
    PrefetchHooks Function({bool documentUuid})> {
  $$OrderServicesItemsTableTableManager(
      _$AppDatabase db, $OrderServicesItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderServicesItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderServicesItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderServicesItemsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> documentUuid = const Value.absent(),
            Value<int> lineNumber = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<double?> duration = const Value.absent(),
            Value<String?> performedBy = const Value.absent(),
            Value<bool> isCompleted = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> modifiedAt = const Value.absent(),
          }) =>
              OrderServicesItemsCompanion(
            id: id,
            uuid: uuid,
            documentUuid: documentUuid,
            lineNumber: lineNumber,
            name: name,
            description: description,
            price: price,
            duration: duration,
            performedBy: performedBy,
            isCompleted: isCompleted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            required String documentUuid,
            Value<int> lineNumber = const Value.absent(),
            required String name,
            Value<String?> description = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<double?> duration = const Value.absent(),
            Value<String?> performedBy = const Value.absent(),
            Value<bool> isCompleted = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> modifiedAt = const Value.absent(),
          }) =>
              OrderServicesItemsCompanion.insert(
            id: id,
            uuid: uuid,
            documentUuid: documentUuid,
            lineNumber: lineNumber,
            name: name,
            description: description,
            price: price,
            duration: duration,
            performedBy: performedBy,
            isCompleted: isCompleted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrderServicesItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({documentUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (documentUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.documentUuid,
                    referencedTable: $$OrderServicesItemsTableReferences
                        ._documentUuidTable(db),
                    referencedColumn: $$OrderServicesItemsTableReferences
                        ._documentUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$OrderServicesItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrderServicesItemsTable,
    OrderServicesItem,
    $$OrderServicesItemsTableFilterComposer,
    $$OrderServicesItemsTableOrderingComposer,
    $$OrderServicesItemsTableAnnotationComposer,
    $$OrderServicesItemsTableCreateCompanionBuilder,
    $$OrderServicesItemsTableUpdateCompanionBuilder,
    (OrderServicesItem, $$OrderServicesItemsTableReferences),
    OrderServicesItem,
    PrefetchHooks Function({bool documentUuid})>;
typedef $$SupplierSettingsItemsTableCreateCompanionBuilder
    = SupplierSettingsItemsCompanion Function({
  Value<int> id,
  required String supplierCode,
  Value<bool> isEnabled,
  Value<String?> encryptedCredentials,
  Value<String?> lastCheckStatus,
  Value<String?> lastCheckMessage,
  Value<DateTime?> lastSuccessfulCheckAt,
  Value<String?> clientIdentifierAtSupplier,
  Value<String?> additionalConfig,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$SupplierSettingsItemsTableUpdateCompanionBuilder
    = SupplierSettingsItemsCompanion Function({
  Value<int> id,
  Value<String> supplierCode,
  Value<bool> isEnabled,
  Value<String?> encryptedCredentials,
  Value<String?> lastCheckStatus,
  Value<String?> lastCheckMessage,
  Value<DateTime?> lastSuccessfulCheckAt,
  Value<String?> clientIdentifierAtSupplier,
  Value<String?> additionalConfig,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$SupplierSettingsItemsTableFilterComposer
    extends Composer<_$AppDatabase, $SupplierSettingsItemsTable> {
  $$SupplierSettingsItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supplierCode => $composableBuilder(
      column: $table.supplierCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isEnabled => $composableBuilder(
      column: $table.isEnabled, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get encryptedCredentials => $composableBuilder(
      column: $table.encryptedCredentials,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lastCheckStatus => $composableBuilder(
      column: $table.lastCheckStatus,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lastCheckMessage => $composableBuilder(
      column: $table.lastCheckMessage,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSuccessfulCheckAt => $composableBuilder(
      column: $table.lastSuccessfulCheckAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clientIdentifierAtSupplier => $composableBuilder(
      column: $table.clientIdentifierAtSupplier,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get additionalConfig => $composableBuilder(
      column: $table.additionalConfig,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$SupplierSettingsItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplierSettingsItemsTable> {
  $$SupplierSettingsItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supplierCode => $composableBuilder(
      column: $table.supplierCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isEnabled => $composableBuilder(
      column: $table.isEnabled, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get encryptedCredentials => $composableBuilder(
      column: $table.encryptedCredentials,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lastCheckStatus => $composableBuilder(
      column: $table.lastCheckStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lastCheckMessage => $composableBuilder(
      column: $table.lastCheckMessage,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSuccessfulCheckAt => $composableBuilder(
      column: $table.lastSuccessfulCheckAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clientIdentifierAtSupplier => $composableBuilder(
      column: $table.clientIdentifierAtSupplier,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get additionalConfig => $composableBuilder(
      column: $table.additionalConfig,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$SupplierSettingsItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplierSettingsItemsTable> {
  $$SupplierSettingsItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get supplierCode => $composableBuilder(
      column: $table.supplierCode, builder: (column) => column);

  GeneratedColumn<bool> get isEnabled =>
      $composableBuilder(column: $table.isEnabled, builder: (column) => column);

  GeneratedColumn<String> get encryptedCredentials => $composableBuilder(
      column: $table.encryptedCredentials, builder: (column) => column);

  GeneratedColumn<String> get lastCheckStatus => $composableBuilder(
      column: $table.lastCheckStatus, builder: (column) => column);

  GeneratedColumn<String> get lastCheckMessage => $composableBuilder(
      column: $table.lastCheckMessage, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSuccessfulCheckAt => $composableBuilder(
      column: $table.lastSuccessfulCheckAt, builder: (column) => column);

  GeneratedColumn<String> get clientIdentifierAtSupplier => $composableBuilder(
      column: $table.clientIdentifierAtSupplier, builder: (column) => column);

  GeneratedColumn<String> get additionalConfig => $composableBuilder(
      column: $table.additionalConfig, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SupplierSettingsItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SupplierSettingsItemsTable,
    SupplierSettingsItem,
    $$SupplierSettingsItemsTableFilterComposer,
    $$SupplierSettingsItemsTableOrderingComposer,
    $$SupplierSettingsItemsTableAnnotationComposer,
    $$SupplierSettingsItemsTableCreateCompanionBuilder,
    $$SupplierSettingsItemsTableUpdateCompanionBuilder,
    (
      SupplierSettingsItem,
      BaseReferences<_$AppDatabase, $SupplierSettingsItemsTable,
          SupplierSettingsItem>
    ),
    SupplierSettingsItem,
    PrefetchHooks Function()> {
  $$SupplierSettingsItemsTableTableManager(
      _$AppDatabase db, $SupplierSettingsItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplierSettingsItemsTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$SupplierSettingsItemsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SupplierSettingsItemsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> supplierCode = const Value.absent(),
            Value<bool> isEnabled = const Value.absent(),
            Value<String?> encryptedCredentials = const Value.absent(),
            Value<String?> lastCheckStatus = const Value.absent(),
            Value<String?> lastCheckMessage = const Value.absent(),
            Value<DateTime?> lastSuccessfulCheckAt = const Value.absent(),
            Value<String?> clientIdentifierAtSupplier = const Value.absent(),
            Value<String?> additionalConfig = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SupplierSettingsItemsCompanion(
            id: id,
            supplierCode: supplierCode,
            isEnabled: isEnabled,
            encryptedCredentials: encryptedCredentials,
            lastCheckStatus: lastCheckStatus,
            lastCheckMessage: lastCheckMessage,
            lastSuccessfulCheckAt: lastSuccessfulCheckAt,
            clientIdentifierAtSupplier: clientIdentifierAtSupplier,
            additionalConfig: additionalConfig,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String supplierCode,
            Value<bool> isEnabled = const Value.absent(),
            Value<String?> encryptedCredentials = const Value.absent(),
            Value<String?> lastCheckStatus = const Value.absent(),
            Value<String?> lastCheckMessage = const Value.absent(),
            Value<DateTime?> lastSuccessfulCheckAt = const Value.absent(),
            Value<String?> clientIdentifierAtSupplier = const Value.absent(),
            Value<String?> additionalConfig = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SupplierSettingsItemsCompanion.insert(
            id: id,
            supplierCode: supplierCode,
            isEnabled: isEnabled,
            encryptedCredentials: encryptedCredentials,
            lastCheckStatus: lastCheckStatus,
            lastCheckMessage: lastCheckMessage,
            lastSuccessfulCheckAt: lastSuccessfulCheckAt,
            clientIdentifierAtSupplier: clientIdentifierAtSupplier,
            additionalConfig: additionalConfig,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SupplierSettingsItemsTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $SupplierSettingsItemsTable,
        SupplierSettingsItem,
        $$SupplierSettingsItemsTableFilterComposer,
        $$SupplierSettingsItemsTableOrderingComposer,
        $$SupplierSettingsItemsTableAnnotationComposer,
        $$SupplierSettingsItemsTableCreateCompanionBuilder,
        $$SupplierSettingsItemsTableUpdateCompanionBuilder,
        (
          SupplierSettingsItem,
          BaseReferences<_$AppDatabase, $SupplierSettingsItemsTable,
              SupplierSettingsItem>
        ),
        SupplierSettingsItem,
        PrefetchHooks Function()>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$ClientsItemsTableTableManager get clientsItems =>
      $$ClientsItemsTableTableManager(_db, _db.clientsItems);
  $$CarsItemsTableTableManager get carsItems =>
      $$CarsItemsTableTableManager(_db, _db.carsItems);
  $$AppInfoItemsTableTableManager get appInfoItems =>
      $$AppInfoItemsTableTableManager(_db, _db.appInfoItems);
  $$OrdersItemsTableTableManager get ordersItems =>
      $$OrdersItemsTableTableManager(_db, _db.ordersItems);
  $$OrderPartsItemsTableTableManager get orderPartsItems =>
      $$OrderPartsItemsTableTableManager(_db, _db.orderPartsItems);
  $$OrderServicesItemsTableTableManager get orderServicesItems =>
      $$OrderServicesItemsTableTableManager(_db, _db.orderServicesItems);
  $$SupplierSettingsItemsTableTableManager get supplierSettingsItems =>
      $$SupplierSettingsItemsTableTableManager(_db, _db.supplierSettingsItems);
}

```

## lib\core\database\database_logger.dart
```dart
import 'package:drift/drift.dart';
import 'package:logger/logger.dart';

/// {@template database_logger}
/// Декоратор QueryExecutor, который добавляет логирование SQL-запросов.
/// {@endtemplate}
class DatabaseLogger extends QueryExecutorUser {
  /// {@macro database_logger}
  DatabaseLogger(this.executor, this.logger, {required this.version});

  final Logger logger;
  final QueryExecutor executor;
  final int version;

  Future<void> runCustom(String statement, [List<Object?>? args]) async {
    final stopwatch = Stopwatch()..start();
    try {
      await executor.runCustom(statement,
          args ?? []); // Исправлено: добавлен дефолтный пустой список
      logger.d(
          'SQL [${stopwatch.elapsedMilliseconds}ms] $statement ${args ?? ''}');
    } catch (e) {
      logger.e('SQL Error: $e on $statement ${args ?? ''}');
      rethrow;
    }
  }

  Future<List<Map<String, Object?>>> runSelect(String statement,
      [List<Object?>? args]) async {
    final stopwatch = Stopwatch()..start();
    try {
      final result =
          await executor.runSelect(statement, args ?? []); // Исправлено
      logger.d(
          'SQL [${stopwatch.elapsedMilliseconds}ms] $statement ${args ?? ''} -> ${result.length} rows');
      return result;
    } catch (e) {
      logger.e('SQL Error: $e on $statement ${args ?? ''}');
      rethrow;
    }
  }

  @override
  int get schemaVersion => version;

  @override
  Future<void> beforeOpen(QueryExecutor user, OpeningDetails details) async {
    logger.i(
        'Opening database v${details.versionNow} (previous: ${details.versionBefore})');
    // Если executor реализует QueryExecutorUser, можно делегировать вызов:
    if (executor is QueryExecutorUser) {
      await (executor as QueryExecutorUser).beforeOpen(user, details);
    }
  }

  Future<int> runInsert(String statement, [List<Object?>? args]) async {
    final stopwatch = Stopwatch()..start();
    try {
      final result =
          await executor.runInsert(statement, args ?? []); // Исправлено
      logger.d(
          'SQL INSERT [${stopwatch.elapsedMilliseconds}ms] $statement ${args ?? ''} -> ID: $result');
      return result;
    } catch (e) {
      logger.e('SQL Error: $e on $statement ${args ?? ''}');
      rethrow;
    }
  }

  Future<int> runUpdate(String statement, [List<Object?>? args]) async {
    final stopwatch = Stopwatch()..start();
    try {
      final result =
          await executor.runUpdate(statement, args ?? []); // Исправлено
      logger.d(
          'SQL UPDATE [${stopwatch.elapsedMilliseconds}ms] $statement ${args ?? ''} -> $result rows affected');
      return result;
    } catch (e) {
      logger.e('SQL Error: $e on $statement ${args ?? ''}');
      rethrow;
    }
  }
}

```

## lib\core\database\items\app_info_items.dart
```dart
import 'package:drift/drift.dart';

/// {@template app_info_items}
/// Таблица для хранения метаданных приложения.
/// {@endtemplate}
class AppInfoItems extends Table {
  TextColumn get key => text().named('key')();
  TextColumn get value => text()();

  @override
  Set<Column> get primaryKey => {key};
}

```

## lib\core\database\items\cars_items.dart
```dart
import 'package:drift/drift.dart';
import 'clients_items.dart';
import 'package:uuid/uuid.dart';

/// {@template cars_items}
/// Таблица автомобилей для хранения в базе данных.
/// {@endtemplate}
class CarsItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get uuid => text().clientDefault(() => const Uuid().v4())();
  IntColumn get clientId => integer().references(ClientsItems, #id)();
  TextColumn get vin => text().nullable()();
  TextColumn get make => text()();
  TextColumn get model => text()();
  IntColumn get year => integer().nullable()();
  TextColumn get licensePlate => text().nullable()();
  TextColumn get additionalInfo => text().nullable()();
  TextColumn get code => text().withDefault(const Constant(''))();
  // Дата и время создания записи
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  // Дата и время последнего изменения записи
  DateTimeColumn get modifiedAt => dateTime().nullable()();
  // Дата и время удаления, null если запись активна
  DateTimeColumn get deletedAt => dateTime().nullable()();
  // Метод для фильтрации только активных записей
  Expression<bool> get isActive => deletedAt.isNull();

  // Определяем индексы для таблицы
  List<Index> get indexes => [
        // Индекс для улучшения производительности поиска по clientId
        Index(
          'cars_client_id_idx',
          'CREATE INDEX IF NOT EXISTS "cars_client_id_idx" ON "cars_items"("client_id")',
        ),
        // Уникальный индекс для uuid
        Index(
          'cars_uuid_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "cars_uuid_unique_idx" ON "cars_items"("uuid")',
        ),
        // Уникальный индекс для vin с частичным условием
        Index(
          'cars_vin_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "cars_vin_unique_idx" ON "cars_items"("vin") WHERE "vin" IS NOT NULL',
        ),
        // Индекс по deletedAt для быстрой фильтрации активных автомобилей
        Index(
          'cars_deleted_at_idx',
          'CREATE INDEX IF NOT EXISTS "cars_deleted_at_idx" ON "cars_items"("deleted_at")',
        ),
        // Индекс по licensePlate с частичным условием
        Index(
          'cars_license_plate_idx',
          'CREATE INDEX IF NOT EXISTS "cars_license_plate_idx" ON "cars_items"("license_plate") WHERE "license_plate" IS NOT NULL',
        ),
        // Составной индекс по марке и модели для быстрого поиска
        Index(
          'cars_make_model_idx',
          'CREATE INDEX IF NOT EXISTS "cars_make_model_idx" ON "cars_items"("make", "model")',
        ),
        // Составной индекс для полнотекстового поиска
        Index(
          'cars_search_idx',
          'CREATE INDEX IF NOT EXISTS "cars_search_idx" ON "cars_items"("make", "model", "vin", "license_plate")',
        ),
        // Индекс по коду автомобиля
        Index(
          'cars_code_idx',
          'CREATE INDEX IF NOT EXISTS "cars_code_idx" ON "cars_items"("code")',
        ),
        // Составной индекс по году выпуска и deletedAt для запросов с фильтрацией
        Index(
          'cars_year_active_idx',
          'CREATE INDEX IF NOT EXISTS "cars_year_active_idx" ON "cars_items"("year", "deleted_at")',
        ),
      ];
}

```

## lib\core\database\items\clients_items.dart
```dart
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';

/// {@template clients_items}
/// Таблица клиентов для хранения в базе данных.
/// {@endtemplate}
class ClientsItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get uuid => text().clientDefault(() => const Uuid().v4())();
  TextColumn get code => text()(); // Код клиента
  TextColumn get type => text()();
  TextColumn get name => text()();
  TextColumn get contactInfo => text()();
  TextColumn get additionalInfo => text().nullable()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get modifiedAt => dateTime().nullable()();
  DateTimeColumn get deletedAt => dateTime().nullable()();

  List<Index> get indexes => [
        // Уникальный индекс по uuid (если не null)
        Index('clients_uuid_idx',
            'CREATE UNIQUE INDEX IF NOT EXISTS clients_uuid_idx ON clients_items(uuid) WHERE uuid IS NOT NULL'),

        // Уникальный индекс по коду клиента
        Index('clients_code_idx',
            'CREATE UNIQUE INDEX IF NOT EXISTS clients_code_idx ON clients_items(code)'),

        // Обычный индекс по имени для быстрого поиска
        Index('clients_name_idx',
            'CREATE INDEX IF NOT EXISTS clients_name_idx ON clients_items(name)'),

        // Индекс по deletedAt для быстрой фильтрации активных клиентов
        Index('clients_deleted_at_idx',
            'CREATE INDEX IF NOT EXISTS clients_deleted_at_idx ON clients_items(deleted_at)'),

        // Составной индекс по типу и deletedAt для запросов с фильтрацией
        Index('clients_type_active_idx',
            'CREATE INDEX IF NOT EXISTS clients_type_active_idx ON clients_items(type, deleted_at)'),

        // Составной индекс для полнотекстового поиска
        Index('clients_search_idx',
            'CREATE INDEX IF NOT EXISTS clients_search_idx ON clients_items(name, contact_info)'),
      ];
}

```

## lib\core\database\items\order_parts_items.dart
```dart
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';
import 'package:part_catalog/core/database/items/orders_items.dart';

/// Таблица для хранения запчастей, связанных с заказ-нарядами.
class OrderPartsItems extends Table {
  // Автоинкрементный числовой ID для эффективного индексирования в БД
  IntColumn get id => integer().autoIncrement()();

  // UUID для бизнес-логики и синхронизации
  TextColumn get uuid => text().clientDefault(() => const Uuid().v4())();

  // Связь с заказ-нарядом
  TextColumn get documentUuid => text().references(OrdersItems, #uuid)();

  // Номер строки в документе
  IntColumn get lineNumber => integer().withDefault(const Constant(0))();

  // Данные о запчасти
  TextColumn get partNumber => text()();
  TextColumn get name => text()();
  TextColumn get brand => text().nullable()();
  RealColumn get quantity => real().withDefault(const Constant(0.0))();
  RealColumn get price => real().withDefault(const Constant(0.0))();

  // Дополнительная информация
  TextColumn get supplierName => text().nullable()();
  IntColumn get deliveryDays => integer().nullable()();

  // Статус запчасти в заказе
  BoolColumn get isOrdered => boolean().withDefault(const Constant(false))();
  BoolColumn get isReceived => boolean().withDefault(const Constant(false))();

  // Служебные поля
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get modifiedAt => dateTime().nullable()();

  // Определяем минимально необходимые индексы для таблицы
  List<Index> get indexes => [
        // Уникальный индекс для UUID
        Index(
          'order_parts_uuid_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "order_parts_uuid_unique_idx" ON "order_parts_items"("uuid")',
        ),
        // Индекс для поиска по заказу
        Index(
          'order_parts_order_uuid_idx',
          'CREATE INDEX IF NOT EXISTS "order_parts_order_uuid_idx" ON "order_parts_items"("document_uuid")',
        ),
        // Индекс для поиска по артикулу
        Index(
          'order_parts_part_number_idx',
          'CREATE INDEX IF NOT EXISTS "order_parts_part_number_idx" ON "order_parts_items"("part_number")',
        ),
        // Индекс для сортировки по номеру строки
        Index(
          'order_parts_line_number_idx',
          'CREATE INDEX IF NOT EXISTS "order_parts_line_number_idx" ON "order_parts_items"("document_uuid", "line_number")',
        ),
      ];
}

```

## lib\core\database\items\order_services_items.dart
```dart
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';
import 'package:part_catalog/core/database/items/orders_items.dart';

/// Таблица для хранения услуг, связанных с заказ-нарядами.
class OrderServicesItems extends Table {
  // Автоинкрементный числовой ID для эффективного индексирования в БД
  IntColumn get id => integer().autoIncrement()();

  // UUID для бизнес-логики и синхронизации
  TextColumn get uuid => text().clientDefault(() => const Uuid().v4())();

  // Связь с заказ-нарядом
  TextColumn get documentUuid => text().references(OrdersItems, #uuid)();

  // Номер строки в документе
  IntColumn get lineNumber => integer().withDefault(const Constant(0))();

  // Данные об услуге
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  RealColumn get price => real().withDefault(const Constant(0.0))();

  // Продолжительность работы в часах
  RealColumn get duration => real().nullable()();

  // Информация об исполнителе
  TextColumn get performedBy => text().nullable()();

  // Статус услуги
  BoolColumn get isCompleted => boolean().withDefault(const Constant(false))();

  // Служебные поля
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get modifiedAt => dateTime().nullable()();

  // Определяем минимально необходимые индексы для таблицы
  List<Index> get indexes => [
        // Уникальный индекс для UUID
        Index(
          'order_services_uuid_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "order_services_uuid_unique_idx" ON "order_services_items"("uuid")',
        ),
        // Индекс для поиска по заказу
        Index(
          'order_services_order_uuid_idx',
          'CREATE INDEX IF NOT EXISTS "order_services_order_uuid_idx" ON "order_services_items"("document_uuid")',
        ),
        // Индекс для поиска по статусу завершения
        Index(
          'order_services_is_completed_idx',
          'CREATE INDEX IF NOT EXISTS "order_services_is_completed_idx" ON "order_services_items"("is_completed")',
        ),
        // Индекс для сортировки по номеру строки
        Index(
          'order_services_line_number_idx',
          'CREATE INDEX IF NOT EXISTS "order_services_line_number_idx" ON "order_services_items"("document_uuid", "line_number")',
        ),
      ];
}

```

## lib\core\database\items\orders_items.dart
```dart
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';
import 'package:part_catalog/core/database/items/clients_items.dart';
import 'package:part_catalog/core/database/items/cars_items.dart';

class OrdersItems extends Table {
  // Автоинкрементный числовой ID для эффективного индексирования в БД
  IntColumn get id => integer().autoIncrement()();

  // UUID для бизнес-логики и синхронизации
  TextColumn get uuid => text().clientDefault(() => const Uuid().v4())();

  // Переименовано в соответствии с OrderModel
  TextColumn get clientUuid => text().references(ClientsItems, #uuid)();
  TextColumn get carUuid => text().references(CarsItems, #uuid)();

  // Номер заказ-наряда (соответствует code в OrderModel)
  TextColumn get number => text()();

  // Дата заказ-наряда
  DateTimeColumn get date => dateTime()();
  DateTimeColumn get scheduledDate => dateTime().nullable()();
  DateTimeColumn get completedAt => dateTime().nullable()();

  // Статус заказ-наряда, хранится как строка (имя enum)
  TextColumn get status => text()(); // Значения из OrderStatus.name

  TextColumn get description => text().nullable()();
  RealColumn get totalAmount => real().withDefault(const Constant(0.0))();

  // Добавленные поля из OrderModel
  BoolColumn get isPosted => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get modifiedAt => dateTime().nullable()();
  DateTimeColumn get deletedAt => dateTime().nullable()();

  // Метод для фильтрации только активных записей
  Expression<bool> get isActive => deletedAt.isNull();

  // Определяем минимально необходимые индексы для таблицы
  List<Index> get indexes => [
        // Уникальный индекс для UUID
        Index(
          'orders_uuid_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "orders_uuid_unique_idx" ON "orders_items"("uuid")',
        ),
        // Индекс для поиска по clientUuid
        Index(
          'orders_client_uuid_idx',
          'CREATE INDEX IF NOT EXISTS "orders_client_uuid_idx" ON "orders_items"("client_uuid")',
        ),
        // Индекс для поиска по carUuid
        Index(
          'orders_car_uuid_idx',
          'CREATE INDEX IF NOT EXISTS "orders_car_uuid_idx" ON "orders_items"("car_uuid")',
        ),
        // Уникальный индекс для номера заказа
        Index(
          'orders_number_unique_idx',
          'CREATE UNIQUE INDEX IF NOT EXISTS "orders_number_unique_idx" ON "orders_items"("number")',
        ),
        // Индекс по статусу для быстрого поиска по состоянию заказа
        Index(
          'orders_status_idx',
          'CREATE INDEX IF NOT EXISTS "orders_status_idx" ON "orders_items"("status")',
        ),
        // Индекс по полю deleted_at для быстрой фильтрации активных заказов
        Index(
          'orders_deleted_at_idx',
          'CREATE INDEX IF NOT EXISTS "orders_deleted_at_idx" ON "orders_items"("deleted_at")',
        ),
      ];
}

```

## lib\core\database\items\reference_closure_items.dart
```dart
import 'package:drift/drift.dart';

/// Closure table для иерархических справочников (ReferenceEntity)
class ReferenceClosureItems extends Table {
  /// Идентификатор предка (ancestor)
  TextColumn get ancestorId => text()();

  /// Идентификатор потомка (descendant)
  TextColumn get descendantId => text()();

  /// Глубина (0 - сам элемент, 1 - прямой потомок и т.д.)
  IntColumn get depth => integer()();

  @override
  Set<Column> get primaryKey => {ancestorId, descendantId};

  // Индекс для быстрого поиска всех потомков по ancestorId
  List<Index> get indexes => [
        Index(
          'reference_closure_ancestor_idx',
          'CREATE INDEX IF NOT EXISTS "reference_closure_ancestor_idx" ON "reference_closure_items"("ancestor_id")',
        ),
        Index(
          'reference_closure_descendant_idx',
          'CREATE INDEX IF NOT EXISTS "reference_closure_descendant_idx" ON "reference_closure_items"("descendant_id")',
        ),
      ];
}

```

## lib\core\database\items\supplier_settings_items.dart
```dart
import 'package:drift/drift.dart';

class SupplierSettingsItems extends Table {
  @override
  String get tableName => 'supplier_settings';

  IntColumn get id => integer().autoIncrement()();

  TextColumn get supplierCode => text().unique().withLength(min: 1, max: 50)();
  BoolColumn get isEnabled => boolean().withDefault(const Constant(true))();

  /// Зашифрованные учетные данные (логин, пароль, API-ключ в виде JSON-строки, затем зашифрованной).
  /// Может храниться как BLOB, если шифрование дает бинарные данные,
  /// или как TEXT, если результат шифрования - base64 строка.
  /// Выберем TEXT для простоты, предполагая base64.
  TextColumn get encryptedCredentials => text().nullable()();

  /// Статус последней проверки ("success", "error_auth", "error_network", "not_checked" и т.д.).
  TextColumn get lastCheckStatus => text().nullable()();
  TextColumn get lastCheckMessage => text().nullable()();
  DateTimeColumn get lastSuccessfulCheckAt => dateTime().nullable()();

  /// ID клиента у поставщика (если есть, например, после успешной регистрации/подключения).
  TextColumn get clientIdentifierAtSupplier => text().nullable()();

  /// JSON-строка для хранения специфичных для поставщика настроек
  /// (например, выбранный VKORG для Armtek, список выбранных складов и т.д.).
  TextColumn get additionalConfig => text().nullable()();

  // Можно добавить поля created_at и updated_at, если необходимо отслеживать изменения
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}

```

## lib\core\database\schema_synchronizer.dart
```dart
import 'package:drift/drift.dart';
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';

/// {@template schema_synchronizer}
/// Утилита для синхронизации схемы базы данных с моделями ORM.
/// Используется для автоматического обновления таблиц при изменении схемы.
/// {@endtemplate}
class SchemaSynchronizer {
  /// {@macro schema_synchronizer}
  SchemaSynchronizer(this._db, this._logger);

  final AppDatabase _db;
  final Logger _logger;

  /// Выполняет синхронизацию схемы базы данных с моделями ORM.
  Future<void> synchronize() async {
    _logger.i('Начало синхронизации схемы базы данных');

    // Получаем все таблицы из кода ORM
    final ormTables = _db.allTables;

    // Запрашиваем информацию о существующих таблицах из SQLite
    final existingTables = await _getExistingTables();

    // Создаём временный экземпляр Migrator для создания таблиц
    final migrator = Migrator(_db);

    // Сравниваем и обновляем таблицы
    for (final table in ormTables) {
      final tableName = table.actualTableName;

      if (!existingTables.contains(tableName)) {
        // Таблица не существует - создаём её
        _logger.i('Создание отсутствующей таблицы: $tableName');
        await migrator.createTable(table);
      } else {
        // Таблица существует - проверяем структуру и обновляем при необходимости
        await _syncTableColumns(table);
      }
    }

    _logger.i('Синхронизация схемы базы данных завершена');
  }

  /// Получает список имен существующих таблиц в базе данных.
  Future<List<String>> _getExistingTables() async {
    final result = await _db
        .customSelect(
          'SELECT name FROM sqlite_master WHERE type="table" AND name NOT LIKE "sqlite_%"',
        )
        .get();

    return result.map((row) => row.read<String>('name')).toList();
  }

  /// Синхронизирует структуру колонок таблицы.
  Future<void> _syncTableColumns(TableInfo table) async {
    final tableName = table.actualTableName;

    // Получаем информацию о колонках из базы данных
    final existingColumns = await _getExistingColumns(tableName);

    // Получаем информацию о колонках из модели
    final modelColumns = table.columnsByName.keys.toSet();

    // Проверяем на недостающие колонки
    final missingColumns = modelColumns.difference(existingColumns);

    if (missingColumns.isNotEmpty) {
      _logger.i(
          'Найдены отсутствующие колонки в таблице $tableName: $missingColumns');

      // Добавляем недостающие колонки
      for (final columnName in missingColumns) {
        final column = table.columnsByName[columnName]!;
        await _addColumn(tableName, column);
      }
    }
  }

  /// Получает список имен колонок в таблице.
  Future<Set<String>> _getExistingColumns(String tableName) async {
    final result = await _db
        .customSelect(
          'PRAGMA table_info($tableName)',
        )
        .get();

    return Set.from(result.map((row) => row.read<String>('name')));
  }

  /// Добавляет колонку в существующую таблицу.
  Future<void> _addColumn(String tableName, GeneratedColumn column) async {
    final columnType = _getSqlType(column);
    // В более старых версиях Drift свойство nullable находится непосредственно на колонке
    final nullableText = column.$nullable ? '' : ' NOT NULL';
    final defaultValue = _getDefaultValue(column);

    _logger.i('Добавление колонки ${column.name} в таблицу $tableName');

    await _db.customStatement(
      'ALTER TABLE $tableName ADD COLUMN ${column.name} $columnType$nullableText$defaultValue',
    );
  }

  /// Определяет SQL-тип для колонки.
  String _getSqlType(GeneratedColumn column) {
    // Для более старых версий Drift, которые используют другое API
    if (column is IntColumn) {
      return 'INTEGER';
    } else if (column is TextColumn) {
      return 'TEXT';
    } else if (column is BoolColumn) {
      return 'INTEGER';
    } else if (column is DateTimeColumn) {
      return 'INTEGER';
    } else if (column is BlobColumn) {
      return 'BLOB';
    } else if (column is RealColumn) {
      return 'REAL';
    } else {
      return 'TEXT'; // По умолчанию для неизвестных типов
    }
  }

  /// Получает выражение для значения по умолчанию.
  String _getDefaultValue(GeneratedColumn column) {
    // SQLite требует DEFAULT для NOT NULL колонок при изменении таблицы
    if (!column.$nullable) {
      if (column is IntColumn) {
        return ' DEFAULT 0';
      } else if (column is TextColumn) {
        return ' DEFAULT ""';
      } else if (column is BoolColumn) {
        return ' DEFAULT 0';
      } else if (column is RealColumn) {
        return ' DEFAULT 0.0';
      }
    }
    return '';
  }
}

```

## lib\core\i18n\clients\clients_en.i18n.json
```json
{
    "screenTitle": "Clients",
    "add": "Add Client",
    "edit": "Edit Client",
    "name": "Name",
    "type": "Client Type",
    "contactInfo": "Contact Info",
    "additionalInfo": "Additional Info",
    "types": {
        "physical": "Person",
        "legal": "Company",
        "entrepreneur": "Entrepreneur",
        "other": "Other"
    },
    "filterByClient": "Filter by Client",
    "allClients": "All Clients",
    "noClientsAvailable": "No clients available",
    "emptyList": "The clients list is empty. Add a client by clicking the '+' button",
    "code": "Code",
    "codeRequired": "Client code is required",
    "codeNotUnique": "Code must be unique",
    "personName": "Person's name",
    "companyName": "Company name",
    "nameRequired": "Client name is required",
    "contactInfoRequired": "Contact info is required",
    "contactInfoHint": "Phone, email, address",
    "additionalInfoHint": "Notes, special conditions, etc.",
    "search": "Search clients",
    "startTyping": "Start typing to search",
    "noClientsFound": "No clients found",
    "clientAdded(name: String)": "Client {name} added",
    "clientUpdated(name: String)": "Client {name} updated",
    "clientDeleted": "Client {name} deleted",
    "clientRestored": "Client {name} restored",
    "undoDelete": "Undo",
    "deleteError": "Error deleting client: {error}",
    "addError": "Error adding client: {error}",
    "updateError": "Error updating client: {error}",
    "confirmDelete": "Are you sure you want to delete client {name}?",
    "clientNotFound": "Client not found",
    "clientNotSelected": "Client not selected",
    "clientLoadError": "Error loading client data",
    "client": "Client",
    "typeRequired": "Client type is required",
    "restoreError(error: String)": "Error restoring client: {error}",
    "clientRequired": "Please select a client"
}
```

## lib\core\i18n\clients\clients_ru.i18n.json
```json
{
    "screenTitle": "Клиенты",
    "add": "Добавить клиента",
    "edit": "Редактировать клиента",
    "name": "Имя/Название",
    "type": "Тип клиента",
    "contactInfo": "Контактная информация",
    "additionalInfo": "Дополнительная информация",
    "types": {
        "physical": "Физическое лицо",
        "legal": "Юридическое лицо",
        "entrepreneur": "ИП",
        "other": "Другое"
    },
    "filterByClient": "Фильтр по клиенту",
    "allClients": "Все клиенты",
    "noClientsAvailable": "Нет доступных клиентов",
    "emptyList": "Список клиентов пуст. Добавьте клиента, нажав на кнопку '+'",
    "code": "Код",
    "codeRequired": "Введите код клиента",
    "codeNotUnique": "Код должен быть уникальным",
    "personName": "ФИО клиента",
    "companyName": "Наименование организации",
    "nameRequired": "Введите имя клиента",
    "contactInfoRequired": "Введите контактную информацию",
    "contactInfoHint": "Телефон, email, адрес",
    "additionalInfoHint": "Примечания, особые условия и т.д.",
    "search": "Поиск клиентов",
    "startTyping": "Начните вводить для поиска",
    "noClientsFound": "Клиенты не найдены",
    "clientAdded(name: String)": "Клиент {name} добавлен",
    "clientUpdated(name: String)": "Клиент {name} обновлен",
    "clientDeleted": "Клиент {name} удален",
    "clientRestored": "Клиент {name} восстановлен",
    "undoDelete": "Отменить",
    "deleteError": "Ошибка при удалении клиента: {error}",
    "addError": "Ошибка при добавлении клиента: {error}",
    "updateError": "Ошибка при обновлении клиента: {error}",
    "confirmDelete": "Вы действительно хотите удалить клиента {name}?",
    "clientNotFound": "Клиент не найден",
    "clientNotSelected": "Клиент не выбран",
    "clientLoadError": "Ошибка загрузки данных клиента",
    "client": "Клиент",
    "typeRequired": "Выберите тип клиента",
    "restoreError(error: String)": "Ошибка при восстановлении клиента: {error}",
    "clientRequired": "Выберите клиента"
}
```

## lib\core\i18n\common\common_en.i18n.json
```json
{
    "edit": "Edit",
    "delete": "Delete",
    "cancel": "Cancel",
    "confirm": "Confirm",
    "save": "Save",
    "confirmDeletion": "Confirm Deletion",
    "createdAtDate": "Created: {date}",
    "scheduledForDate": "Scheduled for: {date}",
    "completedAtDate": "Completed: {date}",
    "dataLoadingError": "Error loading data",
    "add": "Add",
    "loading": "Loading...",
    "filter": "Filter",
    "noResultsFound": "No results found",
    "resetFilter": "Reset filter",
    "resetButtonLabel": "Reset",
    "closeButtonLabel": "Close",
    "noDataAvailable": "No data available",
    "createdAt": "Created at",
    "modifiedAt": "Modified at",
    "confirmationTitle": "Confirmation",
    "remove": "Remove",
    "cancelButtonLabel": "Cancel",
    "saveButtonLabel": "Save",
    "featureNotImplemented": "\"{featureName}\" feature is not implemented",
    "editingNotImplemented": "Editing \"{itemType}\" is not implemented",
    "undo": "Undo",
    "clear": "Clear",
    "selectDate": "Select date",
    "resetSearch": "Reset search"
}
```

## lib\core\i18n\common\common_ru.i18n.json
```json
{
    "edit": "Редактировать",
    "delete": "Удалить",
    "cancel": "Отмена",
    "confirm": "Подтвердить",
    "save": "Сохранить",
    "confirmDeletion": "Подтверждение удаления",
    "createdAtDate": "Создан: {date}",
    "scheduledForDate": "Запланирован на: {date}",
    "completedAtDate": "Завершен: {date}",
    "dataLoadingError": "Ошибка при загрузке данных",
    "add": "Добавить",
    "loading": "Загрузка...",
    "filter": "Фильтр",
    "noResultsFound": "Ничего не найдено",
    "resetFilter": "Сбросить фильтр",
    "resetButtonLabel": "Сбросить",
    "closeButtonLabel": "Закрыть",
    "noDataAvailable": "Нет доступных данных",
    "createdAt": "Создано",
    "modifiedAt": "Изменено",
    "confirmationTitle": "Подтверждение",
    "remove": "Удалить",
    "cancelButtonLabel": "Отмена",
    "saveButtonLabel": "Сохранить",
    "featureNotImplemented": "Функция \"{featureName}\" не реализована",
    "editingNotImplemented": "Редактирование \"{itemType}\" не реализовано",
    "undo": "Отменить",
    "clear": "Очистить",
    "selectDate": "Выберите дату",
    "resetSearch": "Сбросить поиск"
}
```

## lib\core\i18n\core\core_en.i18n.json
```json
{
    "appTitle": "Part Catalog",
    "error": "Error",
    "delete": "Delete",
    "cancel": "Cancel",
    "save": "Save",
    "resetDatabase": "Reset Database",
    "resetDatabaseSuccess": "Database reset successfully",
    "resetDatabaseError": "Error resetting database: {error}",
    "dataLoadingError": "Error loading data",
    "errorLoadingData": "Error loading data: {error}",
    "resetButtonLabel": "Reset",
    "closeButtonLabel": "Close",
    "filter": "Filter",
    "changeLanguageTooltip": "Change language",
    "filterOff": "Clear Filter",
    "all": "All",
    "filterByClient": "Filter by Client",
    "loading": "Loading...",
    "confirmResetDatabaseTitle": "Confirm DB Reset",
    "confirmResetDatabaseMessage": "All data will be deleted permanently. Are you sure?",
    "copiedToClipboard(value: String)": "{value} copied to clipboard",
    "noDataAvailable": "No data available"
}
```

## lib\core\i18n\core\core_ru.i18n.json
```json
{
    "appTitle": "Каталог запчастей",
    "error": "Ошибка",
    "delete": "Удалить",
    "cancel": "Отмена",
    "save": "Сохранить",
    "resetDatabase": "Сбросить базу данных",
    "resetDatabaseSuccess": "База данных успешно сброшена",
    "resetDatabaseError": "Ошибка сброса базы данных: {error}",
    "dataLoadingError": "Ошибка при загрузке данных",
    "errorLoadingData": "Ошибка загрузки данных: {error}",
    "resetButtonLabel": "Сбросить",
    "closeButtonLabel": "Закрыть",
    "filter": "Фильтр",
    "changeLanguageTooltip": "Сменить язык",
    "filterOff": "Сбросить фильтр",
    "all": "Все",
    "filterByClient": "Фильтр по клиенту",
    "loading": "Загрузка...",
    "confirmResetDatabaseTitle": "Подтвердите сброс БД",
    "confirmResetDatabaseMessage": "Все данные будут удалены без возможности восстановления. Вы уверены?",
    "copiedToClipboard(value: String)": "{value} скопировано в буфер обмена",
    "noDataAvailable": "Нет данных для отображения"
}
```

## lib\core\i18n\custom_app_locale.dart
```dart
import 'package:flutter/material.dart';
import 'strings.g.dart';

/// Класс для управления локализацией в приложении
class CustomAppLocale {
  static const supportedLocales = [
    Locale('en'),
    Locale('ru'),
  ];

  /// Текущая активная локаль
  static Locale _currentLocale = const Locale('ru');

  /// Глобальный объект для доступа к переводам
  static late Translations translations;

  /// Инициализация переводов
  static Future<void> load([Locale? locale]) async {
    final localeToUse = locale ?? _currentLocale;
    _currentLocale = localeToUse;

    // Получаем соответствующий AppLocale
    final appLocale = AppLocaleUtils.instance.parse(localeToUse.toString());

    // Создаем экземпляр переводов для указанной локали
    translations = await appLocale.build();

    // Устанавливаем локаль в LocaleSettings
    await LocaleSettings.setLocale(appLocale);
  }

  /// Изменение локали в рантайме
  static Future<void> setLocale(Locale locale) async {
    if (!isLocaleSupported(locale)) {
      throw Exception('Locale $locale is not supported');
    }

    await load(locale);
  }

  /// Проверка, поддерживается ли указанная локаль
  static bool isLocaleSupported(Locale locale) {
    return supportedLocales.any((supportedLocale) =>
        supportedLocale.languageCode == locale.languageCode);
  }

  /// Метод для получения делегата локализации Flutter
  static LocalizationsDelegate<Translations> get delegate =>
      _LocalizationsDelegate(supportedLocales: supportedLocales);
}

/// Делегат локализации для работы с slang
class _LocalizationsDelegate extends LocalizationsDelegate<Translations> {
  final List<Locale> supportedLocales;

  const _LocalizationsDelegate({
    required this.supportedLocales,
  });

  @override
  bool isSupported(Locale locale) {
    return supportedLocales.any((supportedLocale) =>
        supportedLocale.languageCode == locale.languageCode);
  }

  @override
  Future<Translations> load(Locale locale) async {
    // Используем AppLocale для установки текущей локали
    await CustomAppLocale.load(locale);
    return CustomAppLocale.translations;
  }

  @override
  bool shouldReload(covariant LocalizationsDelegate<Translations> old) => false;
}

```

## lib\core\i18n\errors\errors_en.i18n.json
```json
{
    "dataLoadingError": "Data loading error",
    "saveError": "Error saving data",
    "fieldRequired": "This field is required"
}
```

## lib\core\i18n\errors\errors_ru.i18n.json
```json
{
    "dataLoadingError": "Ошибка загрузки данных",
    "saveError": "Ошибка сохранения данных",
    "fieldRequired": "Это поле обязательно для заполнения"
}
```

## lib\core\i18n\orders\orders_en.i18n.json
```json
{
    "screenTitle": "Work Orders",
    "add": "Add Work Order",
    "searchByNumberOrClient": "Search by number or client",
    "noOrdersFound": "No work orders found",
    "filterByStatus": "Filter by Status",
    "createdSuccess": "Work order created successfully",
    "orderDetailsTitle": "Work Order Details",
    "clientInfoTitle": "Client Information",
    "problemDescription": "Problem Description",
    "partsList": "Parts",
    "servicesList": "Services",
    "noPartsAdded": "No parts added",
    "noServicesAdded": "No services added",
    "addButtonLabel": "Add",
    "totalAmount": "Total Amount",
    "orderUpdatedSuccess": "Work order successfully updated",
    "orderDeletedSuccess": "Work order successfully deleted",
    "orderDeleteError": "Error deleting work order",
    "changeStatusTitle": "Change Status",
    "statusChangeError": "Error changing status",
    "partRemovedSuccess": "Part successfully removed",
    "partRemoveError": "Error removing part",
    "partOrderedSuccess": "Part marked as ordered",
    "partReceivedSuccess": "Part marked as received",
    "partUpdateError": "Error updating part status",
    "serviceRemovedSuccess": "Service successfully removed",
    "serviceRemoveError": "Error removing service",
    "serviceCompletedSuccess": "Service marked as completed",
    "serviceUpdateError": "Error updating service status",
    "startWorkAction": "Start Work",
    "markReadyAction": "Mark as Ready",
    "resumeWorkAction": "Resume Work",
    "completeOrderAction": "Complete Order",
    "orderCompletedStatus": "Order Completed",
    "orderCancelledStatus": "Order Cancelled",
    "confirmOrderDeletion": "Are you sure you want to delete this work order? This action cannot be undone.",
    "confirmPartDeletion": "Are you sure you want to remove part \"{name}\" from the work order?",
    "confirmServiceDeletion": "Are you sure you want to remove service \"{name}\" from the work order?",
    "orderNotFound": "Work order not found",
    "dataLoadingError": "Error loading data",
    "orderNumberFormat": "Work Order # {number}",
    "createdAtDate": "Created: {date}",
    "scheduledForDate": "Scheduled: {date}",
    "completedAtDate": "Completed: {date}",
    "loadingClient": "Loading client...",
    "loadingVehicle": "Loading vehicle...",
    "addPartFeature": "Add part",
    "addServiceFeature": "Add service",
    "selectClientFirst": "Select a client first",
    "selectClientError": "Client selection is required",
    "selectVehicleError": "Vehicle selection is required",
    "updatedSuccess": "Work order updated successfully",
    "editOrderTitle": "Edit Work Order",
    "newOrderTitle": "New Work Order",
    "selectClientHint": "Select a client",
    "vehicleInfoTitle": "Vehicle Information",
    "selectVehicleHint": "Select a vehicle",
    "problemDescriptionHint": "Describe the issue...",
    "scheduledDate": "Scheduled Date",
    "selectClient": "Select Client",
    "selectVehicle": "Select Vehicle",
    "addService": "Add Service",
    "editService": "Edit Service",
    "addPart": "Add Part",
    "editPart": "Edit Part",
    "scheduledShort": "Sched"
}
```

## lib\core\i18n\orders\orders_ru.i18n.json
```json
{
    "screenTitle": "Заказ-наряды",
    "add": "Добавить заказ-наряд",
    "searchByNumberOrClient": "Поиск по номеру или клиенту",
    "noOrdersFound": "Заказ-наряды не найдены",
    "filterByStatus": "Фильтр по статусу",
    "createdSuccess": "Заказ-наряд успешно создан",
    "orderDetailsTitle": "Информация о заказ-наряде",
    "clientInfoTitle": "Информация о клиенте",
    "problemDescription": "Описание проблемы",
    "partsList": "Запчасти",
    "servicesList": "Услуги",
    "noPartsAdded": "Запчасти не добавлены",
    "noServicesAdded": "Услуги не добавлены",
    "addButtonLabel": "Добавить",
    "totalAmount": "Итого:",
    "orderUpdatedSuccess": "Заказ-наряд успешно обновлен",
    "orderDeletedSuccess": "Заказ-наряд успешно удален",
    "orderDeleteError": "Ошибка при удалении заказ-наряда",
    "changeStatusTitle": "Изменение статуса",
    "statusChangeError": "Ошибка при изменении статуса",
    "partRemovedSuccess": "Запчасть успешно удалена",
    "partRemoveError": "Ошибка при удалении запчасти",
    "partOrderedSuccess": "Запчасть отмечена как заказанная",
    "partReceivedSuccess": "Запчасть отмечена как полученная",
    "partUpdateError": "Ошибка при обновлении статуса запчасти",
    "serviceRemovedSuccess": "Услуга успешно удалена",
    "serviceRemoveError": "Ошибка при удалении услуги",
    "serviceCompletedSuccess": "Услуга отмечена как выполненная",
    "serviceUpdateError": "Ошибка при обновлении статуса услуги",
    "startWorkAction": "Начать работу",
    "markReadyAction": "Готов к выдаче",
    "resumeWorkAction": "Возобновить работу",
    "completeOrderAction": "Завершить заказ",
    "orderCompletedStatus": "Заказ завершен",
    "orderCancelledStatus": "Заказ отменен",
    "confirmOrderDeletion": "Вы уверены, что хотите удалить этот заказ-наряд? Это действие нельзя отменить.",
    "confirmPartDeletion": "Вы уверены, что хотите удалить запчасть \"{name}\" из заказ-наряда?",
    "confirmServiceDeletion": "Вы уверены, что хотите удалить услугу \"{name}\" из заказ-наряда?",
    "orderNotFound": "Заказ-наряд не найден",
    "dataLoadingError": "Ошибка при загрузке данных",
    "orderNumberFormat": "Заказ-наряд № {number}",
    "createdAtDate": "Создан: {date}",
    "scheduledForDate": "Запланирован: {date}",
    "completedAtDate": "Завершен: {date}",
    "loadingClient": "Загрузка клиента...",
    "loadingVehicle": "Загрузка автомобиля...",
    "addPartFeature": "Добавление запчасти",
    "addServiceFeature": "Добавление услуги",
    "selectClientFirst": "Сначала выберите клиента",
    "selectClientError": "Необходимо выбрать клиента",
    "selectVehicleError": "Необходимо выбрать автомобиль",
    "updatedSuccess": "Заказ-наряд успешно обновлен",
    "editOrderTitle": "Редактирование заказ-наряда",
    "newOrderTitle": "Новый заказ-наряд",
    "selectClientHint": "Выберите клиента",
    "vehicleInfoTitle": "Информация об автомобиле",
    "selectVehicleHint": "Выберите автомобиль",
    "problemDescriptionHint": "Опишите причину обращения...",
    "scheduledDate": "Запланированная дата",
    "selectClient": "Выбор клиента",
    "selectVehicle": "Выбор автомобиля",
    "addService": "Добавить услугу",
    "editService": "Редактировать услугу",
    "addPart": "Добавить запчасть",
    "editPart": "Редактировать запчасть",
    "scheduledShort": "План"
}
```

## lib\core\i18n\parts\parts_en.i18n.json
```json
{
    "statusReceived": "Received",
    "statusOrdered": "Ordered",
    "statusNotOrdered": "Not ordered",
    "partNumberLabel": "Part Number",
    "brandLabel": "Brand",
    "pcs": "pcs"
}
```

## lib\core\i18n\parts\parts_ru.i18n.json
```json
{
    "statusReceived": "Получено",
    "statusOrdered": "Заказано",
    "statusNotOrdered": "Не заказано",
    "partNumberLabel": "Артикул",
    "brandLabel": "Бренд",
    "pcs": "шт."
}
```

## lib\core\i18n\services\services_en.i18n.json
```json
{
    "statusCompleted": "Completed",
    "statusNotCompleted": "Not completed"
}
```

## lib\core\i18n\services\services_ru.i18n.json
```json
{
    "statusCompleted": "Выполнено",
    "statusNotCompleted": "Не выполнено"
}
```

## lib\core\i18n\settings\settings_en.i18n.json
```json
{
    "apiControlCenter": {
        "screenTitle": "API Control Center",
        "apiConnectionMode": "API Connection Mode",
        "directMode": "Direct",
        "proxyMode": "Via Proxy",
        "proxyUrlLabel": "Proxy Server URL",
        "proxyUrlHint": "e.g., http://localhost:8080",
        "suppliersListTitle": "Suppliers",
        "configureButton": "Configure"
    },
    "armtekSettings": {
        "screenTitle": "Armtek Settings",
        "credentialsSectionTitle": "Credentials",
        "loginLabel": "Login",
        "passwordLabel": "Password",
        "loginRequiredError": "Login is required",
        "passwordRequiredError": "Password is required for new connection",
        "checkAndSaveButton": "Check and Save",
        "supplierInfoSectionTitle": "Supplier Information",
        "vkorgLabel": "Sales Organization (VKORG)",
        "clientInfoTitle": "Client Information",
        "clientStructureKUNAG": "Client No. (KUNAG)",
        "clientStructureVKORG": "Sales Org. (VKORG)",
        "clientStructureSNAME": "Name",
        "clientStructureADRESS": "Address",
        "userInfoUnavailable": "Client information unavailable"
    }
}
```

## lib\core\i18n\settings\settings_ru.i18n.json
```json
{
    "apiControlCenter": {
        "screenTitle": "Центр управления API",
        "apiConnectionMode": "Режим подключения API",
        "directMode": "Напрямую",
        "proxyMode": "Через прокси",
        "proxyUrlLabel": "URL прокси-сервера",
        "proxyUrlHint": "например, http://localhost:8080",
        "suppliersListTitle": "Поставщики",
        "configureButton": "Настроить"
    },
    "armtekSettings": {
        "screenTitle": "Настройки Armtek",
        "credentialsSectionTitle": "Учетные данные",
        "loginLabel": "Логин",
        "passwordLabel": "Пароль",
        "loginRequiredError": "Логин обязателен",
        "passwordRequiredError": "Пароль обязателен для нового подключения",
        "checkAndSaveButton": "Проверить и сохранить",
        "supplierInfoSectionTitle": "Информация от поставщика",
        "vkorgLabel": "Сбытовая организация",
        "clientInfoTitle": "Информация о клиенте",
        "clientStructureKUNAG": "KUNAG",
        "clientStructureVKORG": "VKORG",
        "clientStructureSNAME": "Наименование",
        "clientStructureADRESS": "Адрес",
        "userInfoUnavailable": "Информация о клиенте недоступна"
    }
}
```

## lib\core\i18n\strings.g.dart
```dart
/// Generated file. Do not edit.
///
/// Source: lib/core/i18n
/// To regenerate, run: `dart run slang`
///
/// Locales: 2
/// Strings: 482 (241 per locale)
///
/// Built on 2025-05-15 at 16:19 UTC

// coverage:ignore-file
// ignore_for_file: type=lint, unused_import

import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';
import 'package:slang/generated.dart';
import 'package:slang_flutter/slang_flutter.dart';
export 'package:slang_flutter/slang_flutter.dart';

import 'strings_ru.g.dart' deferred as l_ru;
part 'strings_en.g.dart';

/// Supported locales.
///
/// Usage:
/// - LocaleSettings.setLocale(AppLocale.en) // set locale
/// - Locale locale = AppLocale.en.flutterLocale // get flutter locale from enum
/// - if (LocaleSettings.currentLocale == AppLocale.en) // locale check
enum AppLocale with BaseAppLocale<AppLocale, Translations> {
	en(languageCode: 'en'),
	ru(languageCode: 'ru');

	const AppLocale({
		required this.languageCode,
		this.scriptCode, // ignore: unused_element, unused_element_parameter
		this.countryCode, // ignore: unused_element, unused_element_parameter
	});

	@override final String languageCode;
	@override final String? scriptCode;
	@override final String? countryCode;

	@override
	Future<Translations> build({
		Map<String, Node>? overrides,
		PluralResolver? cardinalResolver,
		PluralResolver? ordinalResolver,
	}) async {
		switch (this) {
			case AppLocale.en:
				return TranslationsEn(
					overrides: overrides,
					cardinalResolver: cardinalResolver,
					ordinalResolver: ordinalResolver,
				);
			case AppLocale.ru:
				await l_ru.loadLibrary();
				return l_ru.TranslationsRu(
					overrides: overrides,
					cardinalResolver: cardinalResolver,
					ordinalResolver: ordinalResolver,
				);
		}
	}

	@override
	Translations buildSync({
		Map<String, Node>? overrides,
		PluralResolver? cardinalResolver,
		PluralResolver? ordinalResolver,
	}) {
		switch (this) {
			case AppLocale.en:
				return TranslationsEn(
					overrides: overrides,
					cardinalResolver: cardinalResolver,
					ordinalResolver: ordinalResolver,
				);
			case AppLocale.ru:
				return l_ru.TranslationsRu(
					overrides: overrides,
					cardinalResolver: cardinalResolver,
					ordinalResolver: ordinalResolver,
				);
		}
	}

	/// Gets current instance managed by [LocaleSettings].
	Translations get translations => LocaleSettings.instance.getTranslations(this);
}

/// Method A: Simple
///
/// No rebuild after locale change.
/// Translation happens during initialization of the widget (call of t).
/// Configurable via 'translate_var'.
///
/// Usage:
/// String a = t.someKey.anotherKey;
/// String b = t['someKey.anotherKey']; // Only for edge cases!
Translations get t => LocaleSettings.instance.currentTranslations;

/// Method B: Advanced
///
/// All widgets using this method will trigger a rebuild when locale changes.
/// Use this if you have e.g. a settings page where the user can select the locale during runtime.
///
/// Step 1:
/// wrap your App with
/// TranslationProvider(
/// 	child: MyApp()
/// );
///
/// Step 2:
/// final t = Translations.of(context); // Get t variable.
/// String a = t.someKey.anotherKey; // Use t variable.
/// String b = t['someKey.anotherKey']; // Only for edge cases!
class TranslationProvider extends BaseTranslationProvider<AppLocale, Translations> {
	TranslationProvider({required super.child}) : super(settings: LocaleSettings.instance);

	static InheritedLocaleData<AppLocale, Translations> of(BuildContext context) => InheritedLocaleData.of<AppLocale, Translations>(context);
}

/// Method B shorthand via [BuildContext] extension method.
/// Configurable via 'translate_var'.
///
/// Usage (e.g. in a widget's build method):
/// context.t.someKey.anotherKey
extension BuildContextTranslationsExtension on BuildContext {
	Translations get t => TranslationProvider.of(this).translations;
}

/// Manages all translation instances and the current locale
class LocaleSettings extends BaseFlutterLocaleSettings<AppLocale, Translations> {
	LocaleSettings._() : super(
		utils: AppLocaleUtils.instance,
		lazy: true,
	);

	static final instance = LocaleSettings._();

	// static aliases (checkout base methods for documentation)
	static AppLocale get currentLocale => instance.currentLocale;
	static Stream<AppLocale> getLocaleStream() => instance.getLocaleStream();
	static Future<AppLocale> setLocale(AppLocale locale, {bool? listenToDeviceLocale = false}) => instance.setLocale(locale, listenToDeviceLocale: listenToDeviceLocale);
	static Future<AppLocale> setLocaleRaw(String rawLocale, {bool? listenToDeviceLocale = false}) => instance.setLocaleRaw(rawLocale, listenToDeviceLocale: listenToDeviceLocale);
	static Future<AppLocale> useDeviceLocale() => instance.useDeviceLocale();
	static Future<void> setPluralResolver({String? language, AppLocale? locale, PluralResolver? cardinalResolver, PluralResolver? ordinalResolver}) => instance.setPluralResolver(
		language: language,
		locale: locale,
		cardinalResolver: cardinalResolver,
		ordinalResolver: ordinalResolver,
	);

	// synchronous versions
	static AppLocale setLocaleSync(AppLocale locale, {bool? listenToDeviceLocale = false}) => instance.setLocaleSync(locale, listenToDeviceLocale: listenToDeviceLocale);
	static AppLocale setLocaleRawSync(String rawLocale, {bool? listenToDeviceLocale = false}) => instance.setLocaleRawSync(rawLocale, listenToDeviceLocale: listenToDeviceLocale);
	static AppLocale useDeviceLocaleSync() => instance.useDeviceLocaleSync();
	static void setPluralResolverSync({String? language, AppLocale? locale, PluralResolver? cardinalResolver, PluralResolver? ordinalResolver}) => instance.setPluralResolverSync(
		language: language,
		locale: locale,
		cardinalResolver: cardinalResolver,
		ordinalResolver: ordinalResolver,
	);
}

/// Provides utility functions without any side effects.
class AppLocaleUtils extends BaseAppLocaleUtils<AppLocale, Translations> {
	AppLocaleUtils._() : super(
		baseLocale: AppLocale.en,
		locales: AppLocale.values,
	);

	static final instance = AppLocaleUtils._();

	// static aliases (checkout base methods for documentation)
	static AppLocale parse(String rawLocale) => instance.parse(rawLocale);
	static AppLocale parseLocaleParts({required String languageCode, String? scriptCode, String? countryCode}) => instance.parseLocaleParts(languageCode: languageCode, scriptCode: scriptCode, countryCode: countryCode);
	static AppLocale findDeviceLocale() => instance.findDeviceLocale();
	static List<Locale> get supportedLocales => instance.supportedLocales;
	static List<String> get supportedLocalesRaw => instance.supportedLocalesRaw;
}

```

## lib\core\i18n\strings_en.g.dart
```dart
///
/// Generated file. Do not edit.
///
// coverage:ignore-file
// ignore_for_file: type=lint, unused_import

part of 'strings.g.dart';

// Path: <root>
typedef TranslationsEn = Translations; // ignore: unused_element
class Translations implements BaseTranslations<AppLocale, Translations> {
	/// Returns the current translations of the given [context].
	///
	/// Usage:
	/// final t = Translations.of(context);
	static Translations of(BuildContext context) => InheritedLocaleData.of<AppLocale, Translations>(context).translations;

	/// You can call this constructor and build your own translation instance of this locale.
	/// Constructing via the enum [AppLocale.build] is preferred.
	Translations({Map<String, Node>? overrides, PluralResolver? cardinalResolver, PluralResolver? ordinalResolver, TranslationMetadata<AppLocale, Translations>? meta})
		: assert(overrides == null, 'Set "translation_overrides: true" in order to enable this feature.'),
		  $meta = meta ?? TranslationMetadata(
		    locale: AppLocale.en,
		    overrides: overrides ?? {},
		    cardinalResolver: cardinalResolver,
		    ordinalResolver: ordinalResolver,
		  ) {
		$meta.setFlatMapFunction(_flatMapFunction);
	}

	/// Metadata for the translations of <en>.
	@override final TranslationMetadata<AppLocale, Translations> $meta;

	/// Access flat map
	dynamic operator[](String key) => $meta.getTranslation(key);

	late final Translations _root = this; // ignore: unused_field

	Translations $copyWith({TranslationMetadata<AppLocale, Translations>? meta}) => Translations(meta: meta ?? this.$meta);

	// Translations
	late final TranslationsClientsEn clients = TranslationsClientsEn.internal(_root);
	late final TranslationsCommonEn common = TranslationsCommonEn.internal(_root);
	late final TranslationsCoreEn core = TranslationsCoreEn.internal(_root);
	late final TranslationsErrorsEn errors = TranslationsErrorsEn.internal(_root);
	late final TranslationsOrdersEn orders = TranslationsOrdersEn.internal(_root);
	late final TranslationsPartsEn parts = TranslationsPartsEn.internal(_root);
	late final TranslationsServicesEn services = TranslationsServicesEn.internal(_root);
	late final TranslationsSettingsEn settings = TranslationsSettingsEn.internal(_root);
	late final TranslationsVehiclesEn vehicles = TranslationsVehiclesEn.internal(_root);
}

// Path: clients
class TranslationsClientsEn {
	TranslationsClientsEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get screenTitle => 'Clients';
	String get add => 'Add Client';
	String get edit => 'Edit Client';
	String get name => 'Name';
	String get type => 'Client Type';
	String get contactInfo => 'Contact Info';
	String get additionalInfo => 'Additional Info';
	late final TranslationsClientsTypesEn types = TranslationsClientsTypesEn.internal(_root);
	String get filterByClient => 'Filter by Client';
	String get allClients => 'All Clients';
	String get noClientsAvailable => 'No clients available';
	String get emptyList => 'The clients list is empty. Add a client by clicking the \'+\' button';
	String get code => 'Code';
	String get codeRequired => 'Client code is required';
	String get codeNotUnique => 'Code must be unique';
	String get personName => 'Person\'s name';
	String get companyName => 'Company name';
	String get nameRequired => 'Client name is required';
	String get contactInfoRequired => 'Contact info is required';
	String get contactInfoHint => 'Phone, email, address';
	String get additionalInfoHint => 'Notes, special conditions, etc.';
	String get search => 'Search clients';
	String get startTyping => 'Start typing to search';
	String get noClientsFound => 'No clients found';
	String clientAdded({required Object name}) => 'Client ${name} added';
	String clientUpdated({required Object name}) => 'Client ${name} updated';
	String clientDeleted({required Object name}) => 'Client ${name} deleted';
	String clientRestored({required Object name}) => 'Client ${name} restored';
	String get undoDelete => 'Undo';
	String deleteError({required Object error}) => 'Error deleting client: ${error}';
	String addError({required Object error}) => 'Error adding client: ${error}';
	String updateError({required Object error}) => 'Error updating client: ${error}';
	String confirmDelete({required Object name}) => 'Are you sure you want to delete client ${name}?';
	String get clientNotFound => 'Client not found';
	String get clientNotSelected => 'Client not selected';
	String get clientLoadError => 'Error loading client data';
	String get client => 'Client';
	String get typeRequired => 'Client type is required';
	String restoreError({required Object error}) => 'Error restoring client: ${error}';
	String get clientRequired => 'Please select a client';
}

// Path: common
class TranslationsCommonEn {
	TranslationsCommonEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get edit => 'Edit';
	String get delete => 'Delete';
	String get cancel => 'Cancel';
	String get confirm => 'Confirm';
	String get save => 'Save';
	String get confirmDeletion => 'Confirm Deletion';
	String createdAtDate({required Object date}) => 'Created: ${date}';
	String scheduledForDate({required Object date}) => 'Scheduled for: ${date}';
	String completedAtDate({required Object date}) => 'Completed: ${date}';
	String get dataLoadingError => 'Error loading data';
	String get add => 'Add';
	String get loading => 'Loading...';
	String get filter => 'Filter';
	String get noResultsFound => 'No results found';
	String get resetFilter => 'Reset filter';
	String get resetButtonLabel => 'Reset';
	String get closeButtonLabel => 'Close';
	String get noDataAvailable => 'No data available';
	String get createdAt => 'Created at';
	String get modifiedAt => 'Modified at';
	String get confirmationTitle => 'Confirmation';
	String get remove => 'Remove';
	String get cancelButtonLabel => 'Cancel';
	String get saveButtonLabel => 'Save';
	String featureNotImplemented({required Object featureName}) => '"${featureName}" feature is not implemented';
	String editingNotImplemented({required Object itemType}) => 'Editing "${itemType}" is not implemented';
	String get undo => 'Undo';
	String get clear => 'Clear';
	String get selectDate => 'Select date';
	String get resetSearch => 'Reset search';
}

// Path: core
class TranslationsCoreEn {
	TranslationsCoreEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get appTitle => 'Part Catalog';
	String get error => 'Error';
	String get delete => 'Delete';
	String get cancel => 'Cancel';
	String get save => 'Save';
	String get resetDatabase => 'Reset Database';
	String get resetDatabaseSuccess => 'Database reset successfully';
	String resetDatabaseError({required Object error}) => 'Error resetting database: ${error}';
	String get dataLoadingError => 'Error loading data';
	String errorLoadingData({required Object error}) => 'Error loading data: ${error}';
	String get resetButtonLabel => 'Reset';
	String get closeButtonLabel => 'Close';
	String get filter => 'Filter';
	String get changeLanguageTooltip => 'Change language';
	String get filterOff => 'Clear Filter';
	String get all => 'All';
	String get filterByClient => 'Filter by Client';
	String get loading => 'Loading...';
	String get confirmResetDatabaseTitle => 'Confirm DB Reset';
	String get confirmResetDatabaseMessage => 'All data will be deleted permanently. Are you sure?';
	String copiedToClipboard({required Object value}) => '${value} copied to clipboard';
	String get noDataAvailable => 'No data available';
}

// Path: errors
class TranslationsErrorsEn {
	TranslationsErrorsEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get dataLoadingError => 'Data loading error';
	String get saveError => 'Error saving data';
	String get fieldRequired => 'This field is required';
}

// Path: orders
class TranslationsOrdersEn {
	TranslationsOrdersEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get screenTitle => 'Work Orders';
	String get add => 'Add Work Order';
	String get searchByNumberOrClient => 'Search by number or client';
	String get noOrdersFound => 'No work orders found';
	String get filterByStatus => 'Filter by Status';
	String get createdSuccess => 'Work order created successfully';
	String get orderDetailsTitle => 'Work Order Details';
	String get clientInfoTitle => 'Client Information';
	String get problemDescription => 'Problem Description';
	String get partsList => 'Parts';
	String get servicesList => 'Services';
	String get noPartsAdded => 'No parts added';
	String get noServicesAdded => 'No services added';
	String get addButtonLabel => 'Add';
	String get totalAmount => 'Total Amount';
	String get orderUpdatedSuccess => 'Work order successfully updated';
	String get orderDeletedSuccess => 'Work order successfully deleted';
	String get orderDeleteError => 'Error deleting work order';
	String get changeStatusTitle => 'Change Status';
	String get statusChangeError => 'Error changing status';
	String get partRemovedSuccess => 'Part successfully removed';
	String get partRemoveError => 'Error removing part';
	String get partOrderedSuccess => 'Part marked as ordered';
	String get partReceivedSuccess => 'Part marked as received';
	String get partUpdateError => 'Error updating part status';
	String get serviceRemovedSuccess => 'Service successfully removed';
	String get serviceRemoveError => 'Error removing service';
	String get serviceCompletedSuccess => 'Service marked as completed';
	String get serviceUpdateError => 'Error updating service status';
	String get startWorkAction => 'Start Work';
	String get markReadyAction => 'Mark as Ready';
	String get resumeWorkAction => 'Resume Work';
	String get completeOrderAction => 'Complete Order';
	String get orderCompletedStatus => 'Order Completed';
	String get orderCancelledStatus => 'Order Cancelled';
	String get confirmOrderDeletion => 'Are you sure you want to delete this work order? This action cannot be undone.';
	String confirmPartDeletion({required Object name}) => 'Are you sure you want to remove part "${name}" from the work order?';
	String confirmServiceDeletion({required Object name}) => 'Are you sure you want to remove service "${name}" from the work order?';
	String get orderNotFound => 'Work order not found';
	String get dataLoadingError => 'Error loading data';
	String orderNumberFormat({required Object number}) => 'Work Order # ${number}';
	String createdAtDate({required Object date}) => 'Created: ${date}';
	String scheduledForDate({required Object date}) => 'Scheduled: ${date}';
	String completedAtDate({required Object date}) => 'Completed: ${date}';
	String get loadingClient => 'Loading client...';
	String get loadingVehicle => 'Loading vehicle...';
	String get addPartFeature => 'Add part';
	String get addServiceFeature => 'Add service';
	String get selectClientFirst => 'Select a client first';
	String get selectClientError => 'Client selection is required';
	String get selectVehicleError => 'Vehicle selection is required';
	String get updatedSuccess => 'Work order updated successfully';
	String get editOrderTitle => 'Edit Work Order';
	String get newOrderTitle => 'New Work Order';
	String get selectClientHint => 'Select a client';
	String get vehicleInfoTitle => 'Vehicle Information';
	String get selectVehicleHint => 'Select a vehicle';
	String get problemDescriptionHint => 'Describe the issue...';
	String get scheduledDate => 'Scheduled Date';
	String get selectClient => 'Select Client';
	String get selectVehicle => 'Select Vehicle';
	String get addService => 'Add Service';
	String get editService => 'Edit Service';
	String get addPart => 'Add Part';
	String get editPart => 'Edit Part';
	String get scheduledShort => 'Sched';
}

// Path: parts
class TranslationsPartsEn {
	TranslationsPartsEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get statusReceived => 'Received';
	String get statusOrdered => 'Ordered';
	String get statusNotOrdered => 'Not ordered';
	String get partNumberLabel => 'Part Number';
	String get brandLabel => 'Brand';
	String get pcs => 'pcs';
}

// Path: services
class TranslationsServicesEn {
	TranslationsServicesEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get statusCompleted => 'Completed';
	String get statusNotCompleted => 'Not completed';
}

// Path: settings
class TranslationsSettingsEn {
	TranslationsSettingsEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	late final TranslationsSettingsApiControlCenterEn apiControlCenter = TranslationsSettingsApiControlCenterEn.internal(_root);
	late final TranslationsSettingsArmtekSettingsEn armtekSettings = TranslationsSettingsArmtekSettingsEn.internal(_root);
}

// Path: vehicles
class TranslationsVehiclesEn {
	TranslationsVehiclesEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get screenTitle => 'Vehicles';
	String get add => 'Add Vehicle';
	String get edit => 'Edit Vehicle';
	String get make => 'Make';
	String get model => 'Model';
	String get year => 'Year';
	String get vin => 'VIN';
	String get licensePlate => 'License Plate';
	String get owner => 'Owner';
	String get noCarsAvailable => 'No vehicles available';
	String get emptyList => 'The vehicles list is empty. Add a vehicle by clicking the \'+\' button';
	String deleted({required Object make, required Object model}) => '${make} ${model} deleted';
	String get carHistory => 'Vehicle History';
	String get selectVehiclePrompt => 'Please select a vehicle from the list';
	String get databaseError => 'Database access error';
	String get resetDatabase => 'Reset database';
	String get resetDatabaseSuccess => 'Database successfully reset';
	String get carDetailTitle => 'Vehicle Details';
	String get additionalInfo => 'Additional Information';
	String get requiredField => 'This field is required';
	String get invalidYear => 'Invalid year';
	String get vinRequirement => 'VIN must be 17 characters long';
	String get cancel => 'Cancel';
	String get save => 'Save';
	String get deleteConfirmTitle => 'Delete vehicle?';
	String deleteConfirmMessage({required Object make, required Object model, required Object vin}) => 'Are you sure you want to delete the ${make} ${model} (VIN: ${vin})?';
	String get makeHint => 'For example: Toyota';
	String get modelHint => 'For example: Camry';
	String get yearHint => 'For example: 2022';
	String get vinHint => '17 characters';
	String get licensePlateHint => 'Vehicle registration number';
	String get additionalInfoHint => 'Equipment, features, etc.';
	String get orderHistoryComingSoon => 'Order history will be added later';
	String get vehicleNotFound => 'Vehicle not found';
	String get vehicleNotSelected => 'Vehicle not selected';
	String get vehicleLoadError => 'Error loading vehicle data';
	String get vehicle => 'Vehicle';
	String restoreError({required Object error}) => 'Error restoring vehicle: ${error}';
	String deleteError({required Object error}) => 'Error deleting vehicle: ${error}';
	String addError({required Object error}) => 'Error adding vehicle: ${error}';
	String updateError({required Object error}) => 'Error updating vehicle: ${error}';
	String get vinNotUnique => 'A vehicle with this VIN already exists';
	String restored({required Object name}) => 'Vehicle "${name}" restored';
	String added({required Object name}) => 'Vehicle "${name}" added';
	String updated({required Object name}) => 'Vehicle "${name}" updated';
	String get vinCheckError => 'VIN check error';
}

// Path: clients.types
class TranslationsClientsTypesEn {
	TranslationsClientsTypesEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get physical => 'Person';
	String get legal => 'Company';
	String get entrepreneur => 'Entrepreneur';
	String get other => 'Other';
}

// Path: settings.apiControlCenter
class TranslationsSettingsApiControlCenterEn {
	TranslationsSettingsApiControlCenterEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get screenTitle => 'API Control Center';
	String get apiConnectionMode => 'API Connection Mode';
	String get directMode => 'Direct';
	String get proxyMode => 'Via Proxy';
	String get proxyUrlLabel => 'Proxy Server URL';
	String get proxyUrlHint => 'e.g., http://localhost:8080';
	String get suppliersListTitle => 'Suppliers';
	String get configureButton => 'Configure';
}

// Path: settings.armtekSettings
class TranslationsSettingsArmtekSettingsEn {
	TranslationsSettingsArmtekSettingsEn.internal(this._root);

	final Translations _root; // ignore: unused_field

	// Translations
	String get screenTitle => 'Armtek Settings';
	String get credentialsSectionTitle => 'Credentials';
	String get loginLabel => 'Login';
	String get passwordLabel => 'Password';
	String get loginRequiredError => 'Login is required';
	String get passwordRequiredError => 'Password is required for new connection';
	String get checkAndSaveButton => 'Check and Save';
	String get supplierInfoSectionTitle => 'Supplier Information';
	String get vkorgLabel => 'Sales Organization (VKORG)';
	String get clientInfoTitle => 'Client Information';
	String get clientStructureKUNAG => 'Client No. (KUNAG)';
	String get clientStructureVKORG => 'Sales Org. (VKORG)';
	String get clientStructureSNAME => 'Name';
	String get clientStructureADRESS => 'Address';
	String get userInfoUnavailable => 'Client information unavailable';
}

/// Flat map(s) containing all translations.
/// Only for edge cases! For simple maps, use the map function of this library.
extension on Translations {
	dynamic _flatMapFunction(String path) {
		switch (path) {
			case 'clients.screenTitle': return 'Clients';
			case 'clients.add': return 'Add Client';
			case 'clients.edit': return 'Edit Client';
			case 'clients.name': return 'Name';
			case 'clients.type': return 'Client Type';
			case 'clients.contactInfo': return 'Contact Info';
			case 'clients.additionalInfo': return 'Additional Info';
			case 'clients.types.physical': return 'Person';
			case 'clients.types.legal': return 'Company';
			case 'clients.types.entrepreneur': return 'Entrepreneur';
			case 'clients.types.other': return 'Other';
			case 'clients.filterByClient': return 'Filter by Client';
			case 'clients.allClients': return 'All Clients';
			case 'clients.noClientsAvailable': return 'No clients available';
			case 'clients.emptyList': return 'The clients list is empty. Add a client by clicking the \'+\' button';
			case 'clients.code': return 'Code';
			case 'clients.codeRequired': return 'Client code is required';
			case 'clients.codeNotUnique': return 'Code must be unique';
			case 'clients.personName': return 'Person\'s name';
			case 'clients.companyName': return 'Company name';
			case 'clients.nameRequired': return 'Client name is required';
			case 'clients.contactInfoRequired': return 'Contact info is required';
			case 'clients.contactInfoHint': return 'Phone, email, address';
			case 'clients.additionalInfoHint': return 'Notes, special conditions, etc.';
			case 'clients.search': return 'Search clients';
			case 'clients.startTyping': return 'Start typing to search';
			case 'clients.noClientsFound': return 'No clients found';
			case 'clients.clientAdded': return ({required Object name}) => 'Client ${name} added';
			case 'clients.clientUpdated': return ({required Object name}) => 'Client ${name} updated';
			case 'clients.clientDeleted': return ({required Object name}) => 'Client ${name} deleted';
			case 'clients.clientRestored': return ({required Object name}) => 'Client ${name} restored';
			case 'clients.undoDelete': return 'Undo';
			case 'clients.deleteError': return ({required Object error}) => 'Error deleting client: ${error}';
			case 'clients.addError': return ({required Object error}) => 'Error adding client: ${error}';
			case 'clients.updateError': return ({required Object error}) => 'Error updating client: ${error}';
			case 'clients.confirmDelete': return ({required Object name}) => 'Are you sure you want to delete client ${name}?';
			case 'clients.clientNotFound': return 'Client not found';
			case 'clients.clientNotSelected': return 'Client not selected';
			case 'clients.clientLoadError': return 'Error loading client data';
			case 'clients.client': return 'Client';
			case 'clients.typeRequired': return 'Client type is required';
			case 'clients.restoreError': return ({required Object error}) => 'Error restoring client: ${error}';
			case 'clients.clientRequired': return 'Please select a client';
			case 'common.edit': return 'Edit';
			case 'common.delete': return 'Delete';
			case 'common.cancel': return 'Cancel';
			case 'common.confirm': return 'Confirm';
			case 'common.save': return 'Save';
			case 'common.confirmDeletion': return 'Confirm Deletion';
			case 'common.createdAtDate': return ({required Object date}) => 'Created: ${date}';
			case 'common.scheduledForDate': return ({required Object date}) => 'Scheduled for: ${date}';
			case 'common.completedAtDate': return ({required Object date}) => 'Completed: ${date}';
			case 'common.dataLoadingError': return 'Error loading data';
			case 'common.add': return 'Add';
			case 'common.loading': return 'Loading...';
			case 'common.filter': return 'Filter';
			case 'common.noResultsFound': return 'No results found';
			case 'common.resetFilter': return 'Reset filter';
			case 'common.resetButtonLabel': return 'Reset';
			case 'common.closeButtonLabel': return 'Close';
			case 'common.noDataAvailable': return 'No data available';
			case 'common.createdAt': return 'Created at';
			case 'common.modifiedAt': return 'Modified at';
			case 'common.confirmationTitle': return 'Confirmation';
			case 'common.remove': return 'Remove';
			case 'common.cancelButtonLabel': return 'Cancel';
			case 'common.saveButtonLabel': return 'Save';
			case 'common.featureNotImplemented': return ({required Object featureName}) => '"${featureName}" feature is not implemented';
			case 'common.editingNotImplemented': return ({required Object itemType}) => 'Editing "${itemType}" is not implemented';
			case 'common.undo': return 'Undo';
			case 'common.clear': return 'Clear';
			case 'common.selectDate': return 'Select date';
			case 'common.resetSearch': return 'Reset search';
			case 'core.appTitle': return 'Part Catalog';
			case 'core.error': return 'Error';
			case 'core.delete': return 'Delete';
			case 'core.cancel': return 'Cancel';
			case 'core.save': return 'Save';
			case 'core.resetDatabase': return 'Reset Database';
			case 'core.resetDatabaseSuccess': return 'Database reset successfully';
			case 'core.resetDatabaseError': return ({required Object error}) => 'Error resetting database: ${error}';
			case 'core.dataLoadingError': return 'Error loading data';
			case 'core.errorLoadingData': return ({required Object error}) => 'Error loading data: ${error}';
			case 'core.resetButtonLabel': return 'Reset';
			case 'core.closeButtonLabel': return 'Close';
			case 'core.filter': return 'Filter';
			case 'core.changeLanguageTooltip': return 'Change language';
			case 'core.filterOff': return 'Clear Filter';
			case 'core.all': return 'All';
			case 'core.filterByClient': return 'Filter by Client';
			case 'core.loading': return 'Loading...';
			case 'core.confirmResetDatabaseTitle': return 'Confirm DB Reset';
			case 'core.confirmResetDatabaseMessage': return 'All data will be deleted permanently. Are you sure?';
			case 'core.copiedToClipboard': return ({required Object value}) => '${value} copied to clipboard';
			case 'core.noDataAvailable': return 'No data available';
			case 'errors.dataLoadingError': return 'Data loading error';
			case 'errors.saveError': return 'Error saving data';
			case 'errors.fieldRequired': return 'This field is required';
			case 'orders.screenTitle': return 'Work Orders';
			case 'orders.add': return 'Add Work Order';
			case 'orders.searchByNumberOrClient': return 'Search by number or client';
			case 'orders.noOrdersFound': return 'No work orders found';
			case 'orders.filterByStatus': return 'Filter by Status';
			case 'orders.createdSuccess': return 'Work order created successfully';
			case 'orders.orderDetailsTitle': return 'Work Order Details';
			case 'orders.clientInfoTitle': return 'Client Information';
			case 'orders.problemDescription': return 'Problem Description';
			case 'orders.partsList': return 'Parts';
			case 'orders.servicesList': return 'Services';
			case 'orders.noPartsAdded': return 'No parts added';
			case 'orders.noServicesAdded': return 'No services added';
			case 'orders.addButtonLabel': return 'Add';
			case 'orders.totalAmount': return 'Total Amount';
			case 'orders.orderUpdatedSuccess': return 'Work order successfully updated';
			case 'orders.orderDeletedSuccess': return 'Work order successfully deleted';
			case 'orders.orderDeleteError': return 'Error deleting work order';
			case 'orders.changeStatusTitle': return 'Change Status';
			case 'orders.statusChangeError': return 'Error changing status';
			case 'orders.partRemovedSuccess': return 'Part successfully removed';
			case 'orders.partRemoveError': return 'Error removing part';
			case 'orders.partOrderedSuccess': return 'Part marked as ordered';
			case 'orders.partReceivedSuccess': return 'Part marked as received';
			case 'orders.partUpdateError': return 'Error updating part status';
			case 'orders.serviceRemovedSuccess': return 'Service successfully removed';
			case 'orders.serviceRemoveError': return 'Error removing service';
			case 'orders.serviceCompletedSuccess': return 'Service marked as completed';
			case 'orders.serviceUpdateError': return 'Error updating service status';
			case 'orders.startWorkAction': return 'Start Work';
			case 'orders.markReadyAction': return 'Mark as Ready';
			case 'orders.resumeWorkAction': return 'Resume Work';
			case 'orders.completeOrderAction': return 'Complete Order';
			case 'orders.orderCompletedStatus': return 'Order Completed';
			case 'orders.orderCancelledStatus': return 'Order Cancelled';
			case 'orders.confirmOrderDeletion': return 'Are you sure you want to delete this work order? This action cannot be undone.';
			case 'orders.confirmPartDeletion': return ({required Object name}) => 'Are you sure you want to remove part "${name}" from the work order?';
			case 'orders.confirmServiceDeletion': return ({required Object name}) => 'Are you sure you want to remove service "${name}" from the work order?';
			case 'orders.orderNotFound': return 'Work order not found';
			case 'orders.dataLoadingError': return 'Error loading data';
			case 'orders.orderNumberFormat': return ({required Object number}) => 'Work Order # ${number}';
			case 'orders.createdAtDate': return ({required Object date}) => 'Created: ${date}';
			case 'orders.scheduledForDate': return ({required Object date}) => 'Scheduled: ${date}';
			case 'orders.completedAtDate': return ({required Object date}) => 'Completed: ${date}';
			case 'orders.loadingClient': return 'Loading client...';
			case 'orders.loadingVehicle': return 'Loading vehicle...';
			case 'orders.addPartFeature': return 'Add part';
			case 'orders.addServiceFeature': return 'Add service';
			case 'orders.selectClientFirst': return 'Select a client first';
			case 'orders.selectClientError': return 'Client selection is required';
			case 'orders.selectVehicleError': return 'Vehicle selection is required';
			case 'orders.updatedSuccess': return 'Work order updated successfully';
			case 'orders.editOrderTitle': return 'Edit Work Order';
			case 'orders.newOrderTitle': return 'New Work Order';
			case 'orders.selectClientHint': return 'Select a client';
			case 'orders.vehicleInfoTitle': return 'Vehicle Information';
			case 'orders.selectVehicleHint': return 'Select a vehicle';
			case 'orders.problemDescriptionHint': return 'Describe the issue...';
			case 'orders.scheduledDate': return 'Scheduled Date';
			case 'orders.selectClient': return 'Select Client';
			case 'orders.selectVehicle': return 'Select Vehicle';
			case 'orders.addService': return 'Add Service';
			case 'orders.editService': return 'Edit Service';
			case 'orders.addPart': return 'Add Part';
			case 'orders.editPart': return 'Edit Part';
			case 'orders.scheduledShort': return 'Sched';
			case 'parts.statusReceived': return 'Received';
			case 'parts.statusOrdered': return 'Ordered';
			case 'parts.statusNotOrdered': return 'Not ordered';
			case 'parts.partNumberLabel': return 'Part Number';
			case 'parts.brandLabel': return 'Brand';
			case 'parts.pcs': return 'pcs';
			case 'services.statusCompleted': return 'Completed';
			case 'services.statusNotCompleted': return 'Not completed';
			case 'settings.apiControlCenter.screenTitle': return 'API Control Center';
			case 'settings.apiControlCenter.apiConnectionMode': return 'API Connection Mode';
			case 'settings.apiControlCenter.directMode': return 'Direct';
			case 'settings.apiControlCenter.proxyMode': return 'Via Proxy';
			case 'settings.apiControlCenter.proxyUrlLabel': return 'Proxy Server URL';
			case 'settings.apiControlCenter.proxyUrlHint': return 'e.g., http://localhost:8080';
			case 'settings.apiControlCenter.suppliersListTitle': return 'Suppliers';
			case 'settings.apiControlCenter.configureButton': return 'Configure';
			case 'settings.armtekSettings.screenTitle': return 'Armtek Settings';
			case 'settings.armtekSettings.credentialsSectionTitle': return 'Credentials';
			case 'settings.armtekSettings.loginLabel': return 'Login';
			case 'settings.armtekSettings.passwordLabel': return 'Password';
			case 'settings.armtekSettings.loginRequiredError': return 'Login is required';
			case 'settings.armtekSettings.passwordRequiredError': return 'Password is required for new connection';
			case 'settings.armtekSettings.checkAndSaveButton': return 'Check and Save';
			case 'settings.armtekSettings.supplierInfoSectionTitle': return 'Supplier Information';
			case 'settings.armtekSettings.vkorgLabel': return 'Sales Organization (VKORG)';
			case 'settings.armtekSettings.clientInfoTitle': return 'Client Information';
			case 'settings.armtekSettings.clientStructureKUNAG': return 'Client No. (KUNAG)';
			case 'settings.armtekSettings.clientStructureVKORG': return 'Sales Org. (VKORG)';
			case 'settings.armtekSettings.clientStructureSNAME': return 'Name';
			case 'settings.armtekSettings.clientStructureADRESS': return 'Address';
			case 'settings.armtekSettings.userInfoUnavailable': return 'Client information unavailable';
			case 'vehicles.screenTitle': return 'Vehicles';
			case 'vehicles.add': return 'Add Vehicle';
			case 'vehicles.edit': return 'Edit Vehicle';
			case 'vehicles.make': return 'Make';
			case 'vehicles.model': return 'Model';
			case 'vehicles.year': return 'Year';
			case 'vehicles.vin': return 'VIN';
			case 'vehicles.licensePlate': return 'License Plate';
			case 'vehicles.owner': return 'Owner';
			case 'vehicles.noCarsAvailable': return 'No vehicles available';
			case 'vehicles.emptyList': return 'The vehicles list is empty. Add a vehicle by clicking the \'+\' button';
			case 'vehicles.deleted': return ({required Object make, required Object model}) => '${make} ${model} deleted';
			case 'vehicles.carHistory': return 'Vehicle History';
			case 'vehicles.selectVehiclePrompt': return 'Please select a vehicle from the list';
			case 'vehicles.databaseError': return 'Database access error';
			case 'vehicles.resetDatabase': return 'Reset database';
			case 'vehicles.resetDatabaseSuccess': return 'Database successfully reset';
			case 'vehicles.carDetailTitle': return 'Vehicle Details';
			case 'vehicles.additionalInfo': return 'Additional Information';
			case 'vehicles.requiredField': return 'This field is required';
			case 'vehicles.invalidYear': return 'Invalid year';
			case 'vehicles.vinRequirement': return 'VIN must be 17 characters long';
			case 'vehicles.cancel': return 'Cancel';
			case 'vehicles.save': return 'Save';
			case 'vehicles.deleteConfirmTitle': return 'Delete vehicle?';
			case 'vehicles.deleteConfirmMessage': return ({required Object make, required Object model, required Object vin}) => 'Are you sure you want to delete the ${make} ${model} (VIN: ${vin})?';
			case 'vehicles.makeHint': return 'For example: Toyota';
			case 'vehicles.modelHint': return 'For example: Camry';
			case 'vehicles.yearHint': return 'For example: 2022';
			case 'vehicles.vinHint': return '17 characters';
			case 'vehicles.licensePlateHint': return 'Vehicle registration number';
			case 'vehicles.additionalInfoHint': return 'Equipment, features, etc.';
			case 'vehicles.orderHistoryComingSoon': return 'Order history will be added later';
			case 'vehicles.vehicleNotFound': return 'Vehicle not found';
			case 'vehicles.vehicleNotSelected': return 'Vehicle not selected';
			case 'vehicles.vehicleLoadError': return 'Error loading vehicle data';
			case 'vehicles.vehicle': return 'Vehicle';
			case 'vehicles.restoreError': return ({required Object error}) => 'Error restoring vehicle: ${error}';
			case 'vehicles.deleteError': return ({required Object error}) => 'Error deleting vehicle: ${error}';
			case 'vehicles.addError': return ({required Object error}) => 'Error adding vehicle: ${error}';
			case 'vehicles.updateError': return ({required Object error}) => 'Error updating vehicle: ${error}';
			case 'vehicles.vinNotUnique': return 'A vehicle with this VIN already exists';
			case 'vehicles.restored': return ({required Object name}) => 'Vehicle "${name}" restored';
			case 'vehicles.added': return ({required Object name}) => 'Vehicle "${name}" added';
			case 'vehicles.updated': return ({required Object name}) => 'Vehicle "${name}" updated';
			case 'vehicles.vinCheckError': return 'VIN check error';
			default: return null;
		}
	}
}


```

## lib\core\i18n\strings_ru.g.dart
```dart
///
/// Generated file. Do not edit.
///
// coverage:ignore-file
// ignore_for_file: type=lint, unused_import

import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';
import 'package:slang/generated.dart';
import 'strings.g.dart';

// Path: <root>
class TranslationsRu extends Translations {
	/// You can call this constructor and build your own translation instance of this locale.
	/// Constructing via the enum [AppLocale.build] is preferred.
	TranslationsRu({Map<String, Node>? overrides, PluralResolver? cardinalResolver, PluralResolver? ordinalResolver, TranslationMetadata<AppLocale, Translations>? meta})
		: assert(overrides == null, 'Set "translation_overrides: true" in order to enable this feature.'),
		  $meta = meta ?? TranslationMetadata(
		    locale: AppLocale.ru,
		    overrides: overrides ?? {},
		    cardinalResolver: cardinalResolver,
		    ordinalResolver: ordinalResolver,
		  ),
		  super(cardinalResolver: cardinalResolver, ordinalResolver: ordinalResolver) {
		super.$meta.setFlatMapFunction($meta.getTranslation); // copy base translations to super.$meta
		$meta.setFlatMapFunction(_flatMapFunction);
	}

	/// Metadata for the translations of <ru>.
	@override final TranslationMetadata<AppLocale, Translations> $meta;

	/// Access flat map
	@override dynamic operator[](String key) => $meta.getTranslation(key) ?? super.$meta.getTranslation(key);

	late final TranslationsRu _root = this; // ignore: unused_field

	@override 
	TranslationsRu $copyWith({TranslationMetadata<AppLocale, Translations>? meta}) => TranslationsRu(meta: meta ?? this.$meta);

	// Translations
	@override late final TranslationsClientsRu clients = TranslationsClientsRu._(_root);
	@override late final TranslationsCommonRu common = TranslationsCommonRu._(_root);
	@override late final TranslationsCoreRu core = TranslationsCoreRu._(_root);
	@override late final TranslationsErrorsRu errors = TranslationsErrorsRu._(_root);
	@override late final TranslationsOrdersRu orders = TranslationsOrdersRu._(_root);
	@override late final TranslationsPartsRu parts = TranslationsPartsRu._(_root);
	@override late final TranslationsServicesRu services = TranslationsServicesRu._(_root);
	@override late final TranslationsSettingsRu settings = TranslationsSettingsRu._(_root);
	@override late final TranslationsVehiclesRu vehicles = TranslationsVehiclesRu._(_root);
}

// Path: clients
class TranslationsClientsRu extends TranslationsClientsEn {
	TranslationsClientsRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get screenTitle => 'Клиенты';
	@override String get add => 'Добавить клиента';
	@override String get edit => 'Редактировать клиента';
	@override String get name => 'Имя/Название';
	@override String get type => 'Тип клиента';
	@override String get contactInfo => 'Контактная информация';
	@override String get additionalInfo => 'Дополнительная информация';
	@override late final TranslationsClientsTypesRu types = TranslationsClientsTypesRu._(_root);
	@override String get filterByClient => 'Фильтр по клиенту';
	@override String get allClients => 'Все клиенты';
	@override String get noClientsAvailable => 'Нет доступных клиентов';
	@override String get emptyList => 'Список клиентов пуст. Добавьте клиента, нажав на кнопку \'+\'';
	@override String get code => 'Код';
	@override String get codeRequired => 'Введите код клиента';
	@override String get codeNotUnique => 'Код должен быть уникальным';
	@override String get personName => 'ФИО клиента';
	@override String get companyName => 'Наименование организации';
	@override String get nameRequired => 'Введите имя клиента';
	@override String get contactInfoRequired => 'Введите контактную информацию';
	@override String get contactInfoHint => 'Телефон, email, адрес';
	@override String get additionalInfoHint => 'Примечания, особые условия и т.д.';
	@override String get search => 'Поиск клиентов';
	@override String get startTyping => 'Начните вводить для поиска';
	@override String get noClientsFound => 'Клиенты не найдены';
	@override String clientAdded({required Object name}) => 'Клиент ${name} добавлен';
	@override String clientUpdated({required Object name}) => 'Клиент ${name} обновлен';
	@override String clientDeleted({required Object name}) => 'Клиент ${name} удален';
	@override String clientRestored({required Object name}) => 'Клиент ${name} восстановлен';
	@override String get undoDelete => 'Отменить';
	@override String deleteError({required Object error}) => 'Ошибка при удалении клиента: ${error}';
	@override String addError({required Object error}) => 'Ошибка при добавлении клиента: ${error}';
	@override String updateError({required Object error}) => 'Ошибка при обновлении клиента: ${error}';
	@override String confirmDelete({required Object name}) => 'Вы действительно хотите удалить клиента ${name}?';
	@override String get clientNotFound => 'Клиент не найден';
	@override String get clientNotSelected => 'Клиент не выбран';
	@override String get clientLoadError => 'Ошибка загрузки данных клиента';
	@override String get client => 'Клиент';
	@override String get typeRequired => 'Выберите тип клиента';
	@override String restoreError({required Object error}) => 'Ошибка при восстановлении клиента: ${error}';
	@override String get clientRequired => 'Выберите клиента';
}

// Path: common
class TranslationsCommonRu extends TranslationsCommonEn {
	TranslationsCommonRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get edit => 'Редактировать';
	@override String get delete => 'Удалить';
	@override String get cancel => 'Отмена';
	@override String get confirm => 'Подтвердить';
	@override String get save => 'Сохранить';
	@override String get confirmDeletion => 'Подтверждение удаления';
	@override String createdAtDate({required Object date}) => 'Создан: ${date}';
	@override String scheduledForDate({required Object date}) => 'Запланирован на: ${date}';
	@override String completedAtDate({required Object date}) => 'Завершен: ${date}';
	@override String get dataLoadingError => 'Ошибка при загрузке данных';
	@override String get add => 'Добавить';
	@override String get loading => 'Загрузка...';
	@override String get filter => 'Фильтр';
	@override String get noResultsFound => 'Ничего не найдено';
	@override String get resetFilter => 'Сбросить фильтр';
	@override String get resetButtonLabel => 'Сбросить';
	@override String get closeButtonLabel => 'Закрыть';
	@override String get noDataAvailable => 'Нет доступных данных';
	@override String get createdAt => 'Создано';
	@override String get modifiedAt => 'Изменено';
	@override String get confirmationTitle => 'Подтверждение';
	@override String get remove => 'Удалить';
	@override String get cancelButtonLabel => 'Отмена';
	@override String get saveButtonLabel => 'Сохранить';
	@override String featureNotImplemented({required Object featureName}) => 'Функция "${featureName}" не реализована';
	@override String editingNotImplemented({required Object itemType}) => 'Редактирование "${itemType}" не реализовано';
	@override String get undo => 'Отменить';
	@override String get clear => 'Очистить';
	@override String get selectDate => 'Выберите дату';
	@override String get resetSearch => 'Сбросить поиск';
}

// Path: core
class TranslationsCoreRu extends TranslationsCoreEn {
	TranslationsCoreRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get appTitle => 'Каталог запчастей';
	@override String get error => 'Ошибка';
	@override String get delete => 'Удалить';
	@override String get cancel => 'Отмена';
	@override String get save => 'Сохранить';
	@override String get resetDatabase => 'Сбросить базу данных';
	@override String get resetDatabaseSuccess => 'База данных успешно сброшена';
	@override String resetDatabaseError({required Object error}) => 'Ошибка сброса базы данных: ${error}';
	@override String get dataLoadingError => 'Ошибка при загрузке данных';
	@override String errorLoadingData({required Object error}) => 'Ошибка загрузки данных: ${error}';
	@override String get resetButtonLabel => 'Сбросить';
	@override String get closeButtonLabel => 'Закрыть';
	@override String get filter => 'Фильтр';
	@override String get changeLanguageTooltip => 'Сменить язык';
	@override String get filterOff => 'Сбросить фильтр';
	@override String get all => 'Все';
	@override String get filterByClient => 'Фильтр по клиенту';
	@override String get loading => 'Загрузка...';
	@override String get confirmResetDatabaseTitle => 'Подтвердите сброс БД';
	@override String get confirmResetDatabaseMessage => 'Все данные будут удалены без возможности восстановления. Вы уверены?';
	@override String copiedToClipboard({required Object value}) => '${value} скопировано в буфер обмена';
	@override String get noDataAvailable => 'Нет данных для отображения';
}

// Path: errors
class TranslationsErrorsRu extends TranslationsErrorsEn {
	TranslationsErrorsRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get dataLoadingError => 'Ошибка загрузки данных';
	@override String get saveError => 'Ошибка сохранения данных';
	@override String get fieldRequired => 'Это поле обязательно для заполнения';
}

// Path: orders
class TranslationsOrdersRu extends TranslationsOrdersEn {
	TranslationsOrdersRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get screenTitle => 'Заказ-наряды';
	@override String get add => 'Добавить заказ-наряд';
	@override String get searchByNumberOrClient => 'Поиск по номеру или клиенту';
	@override String get noOrdersFound => 'Заказ-наряды не найдены';
	@override String get filterByStatus => 'Фильтр по статусу';
	@override String get createdSuccess => 'Заказ-наряд успешно создан';
	@override String get orderDetailsTitle => 'Информация о заказ-наряде';
	@override String get clientInfoTitle => 'Информация о клиенте';
	@override String get problemDescription => 'Описание проблемы';
	@override String get partsList => 'Запчасти';
	@override String get servicesList => 'Услуги';
	@override String get noPartsAdded => 'Запчасти не добавлены';
	@override String get noServicesAdded => 'Услуги не добавлены';
	@override String get addButtonLabel => 'Добавить';
	@override String get totalAmount => 'Итого:';
	@override String get orderUpdatedSuccess => 'Заказ-наряд успешно обновлен';
	@override String get orderDeletedSuccess => 'Заказ-наряд успешно удален';
	@override String get orderDeleteError => 'Ошибка при удалении заказ-наряда';
	@override String get changeStatusTitle => 'Изменение статуса';
	@override String get statusChangeError => 'Ошибка при изменении статуса';
	@override String get partRemovedSuccess => 'Запчасть успешно удалена';
	@override String get partRemoveError => 'Ошибка при удалении запчасти';
	@override String get partOrderedSuccess => 'Запчасть отмечена как заказанная';
	@override String get partReceivedSuccess => 'Запчасть отмечена как полученная';
	@override String get partUpdateError => 'Ошибка при обновлении статуса запчасти';
	@override String get serviceRemovedSuccess => 'Услуга успешно удалена';
	@override String get serviceRemoveError => 'Ошибка при удалении услуги';
	@override String get serviceCompletedSuccess => 'Услуга отмечена как выполненная';
	@override String get serviceUpdateError => 'Ошибка при обновлении статуса услуги';
	@override String get startWorkAction => 'Начать работу';
	@override String get markReadyAction => 'Готов к выдаче';
	@override String get resumeWorkAction => 'Возобновить работу';
	@override String get completeOrderAction => 'Завершить заказ';
	@override String get orderCompletedStatus => 'Заказ завершен';
	@override String get orderCancelledStatus => 'Заказ отменен';
	@override String get confirmOrderDeletion => 'Вы уверены, что хотите удалить этот заказ-наряд? Это действие нельзя отменить.';
	@override String confirmPartDeletion({required Object name}) => 'Вы уверены, что хотите удалить запчасть "${name}" из заказ-наряда?';
	@override String confirmServiceDeletion({required Object name}) => 'Вы уверены, что хотите удалить услугу "${name}" из заказ-наряда?';
	@override String get orderNotFound => 'Заказ-наряд не найден';
	@override String get dataLoadingError => 'Ошибка при загрузке данных';
	@override String orderNumberFormat({required Object number}) => 'Заказ-наряд № ${number}';
	@override String createdAtDate({required Object date}) => 'Создан: ${date}';
	@override String scheduledForDate({required Object date}) => 'Запланирован: ${date}';
	@override String completedAtDate({required Object date}) => 'Завершен: ${date}';
	@override String get loadingClient => 'Загрузка клиента...';
	@override String get loadingVehicle => 'Загрузка автомобиля...';
	@override String get addPartFeature => 'Добавление запчасти';
	@override String get addServiceFeature => 'Добавление услуги';
	@override String get selectClientFirst => 'Сначала выберите клиента';
	@override String get selectClientError => 'Необходимо выбрать клиента';
	@override String get selectVehicleError => 'Необходимо выбрать автомобиль';
	@override String get updatedSuccess => 'Заказ-наряд успешно обновлен';
	@override String get editOrderTitle => 'Редактирование заказ-наряда';
	@override String get newOrderTitle => 'Новый заказ-наряд';
	@override String get selectClientHint => 'Выберите клиента';
	@override String get vehicleInfoTitle => 'Информация об автомобиле';
	@override String get selectVehicleHint => 'Выберите автомобиль';
	@override String get problemDescriptionHint => 'Опишите причину обращения...';
	@override String get scheduledDate => 'Запланированная дата';
	@override String get selectClient => 'Выбор клиента';
	@override String get selectVehicle => 'Выбор автомобиля';
	@override String get addService => 'Добавить услугу';
	@override String get editService => 'Редактировать услугу';
	@override String get addPart => 'Добавить запчасть';
	@override String get editPart => 'Редактировать запчасть';
	@override String get scheduledShort => 'План';
}

// Path: parts
class TranslationsPartsRu extends TranslationsPartsEn {
	TranslationsPartsRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get statusReceived => 'Получено';
	@override String get statusOrdered => 'Заказано';
	@override String get statusNotOrdered => 'Не заказано';
	@override String get partNumberLabel => 'Артикул';
	@override String get brandLabel => 'Бренд';
	@override String get pcs => 'шт.';
}

// Path: services
class TranslationsServicesRu extends TranslationsServicesEn {
	TranslationsServicesRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get statusCompleted => 'Выполнено';
	@override String get statusNotCompleted => 'Не выполнено';
}

// Path: settings
class TranslationsSettingsRu extends TranslationsSettingsEn {
	TranslationsSettingsRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override late final TranslationsSettingsApiControlCenterRu apiControlCenter = TranslationsSettingsApiControlCenterRu._(_root);
	@override late final TranslationsSettingsArmtekSettingsRu armtekSettings = TranslationsSettingsArmtekSettingsRu._(_root);
}

// Path: vehicles
class TranslationsVehiclesRu extends TranslationsVehiclesEn {
	TranslationsVehiclesRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get screenTitle => 'Автомобили';
	@override String get add => 'Добавить автомобиль';
	@override String get edit => 'Редактировать автомобиль';
	@override String get make => 'Марка';
	@override String get model => 'Модель';
	@override String get year => 'Год';
	@override String get vin => 'VIN';
	@override String get licensePlate => 'Гос. номер';
	@override String get owner => 'Владелец';
	@override String get noCarsAvailable => 'Нет доступных автомобилей';
	@override String get emptyList => 'Список автомобилей пуст. Добавьте автомобиль, нажав на кнопку \'+\'';
	@override String deleted({required Object make, required Object model}) => 'Автомобиль ${make} ${model} удален';
	@override String get carHistory => 'История автомобиля';
	@override String get selectVehiclePrompt => 'Выберите автомобиль из списка слева';
	@override String get databaseError => 'Ошибка доступа к базе данных';
	@override String get resetDatabase => 'Сбросить базу данных';
	@override String get resetDatabaseSuccess => 'База данных успешно сброшена';
	@override String get carDetailTitle => 'Детали автомобиля';
	@override String get additionalInfo => 'Дополнительная информация';
	@override String get requiredField => 'Поле обязательно для заполнения';
	@override String get invalidYear => 'Некорректный год';
	@override String get vinRequirement => 'VIN должен содержать 17 символов';
	@override String get cancel => 'Отмена';
	@override String get save => 'Сохранить';
	@override String get deleteConfirmTitle => 'Удалить автомобиль?';
	@override String deleteConfirmMessage({required Object make, required Object model, required Object vin}) => 'Вы действительно хотите удалить автомобиль ${make} ${model} (VIN: ${vin})?';
	@override String get makeHint => 'Например: Toyota';
	@override String get modelHint => 'Например: Camry';
	@override String get yearHint => 'Например: 2022';
	@override String get vinHint => '17 символов';
	@override String get licensePlateHint => 'Регистрационный номер авто';
	@override String get additionalInfoHint => 'Комплектация, особенности и т.д.';
	@override String get orderHistoryComingSoon => 'История заказ-нарядов будет добавлена позже';
	@override String get vehicleNotFound => 'Автомобиль не найден';
	@override String get vehicleNotSelected => 'Автомобиль не выбран';
	@override String get vehicleLoadError => 'Ошибка загрузки данных автомобиля';
	@override String get vehicle => 'Автомобиль';
	@override String restoreError({required Object error}) => 'Ошибка при восстановлении автомобиля: ${error}';
	@override String deleteError({required Object error}) => 'Ошибка при удалении автомобиля: ${error}';
	@override String addError({required Object error}) => 'Ошибка при добавлении автомобиля: ${error}';
	@override String updateError({required Object error}) => 'Ошибка при обновлении автомобиля: ${error}';
	@override String get vinNotUnique => 'Автомобиль с таким VIN уже существует';
	@override String restored({required Object name}) => 'Автомобиль "${name}" восстановлен';
	@override String added({required Object name}) => 'Автомобиль "${name}" добавлен';
	@override String updated({required Object name}) => 'Автомобиль "${name}" обновлен';
	@override String get vinCheckError => 'Ошибка проверки VIN';
}

// Path: clients.types
class TranslationsClientsTypesRu extends TranslationsClientsTypesEn {
	TranslationsClientsTypesRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get physical => 'Физическое лицо';
	@override String get legal => 'Юридическое лицо';
	@override String get entrepreneur => 'ИП';
	@override String get other => 'Другое';
}

// Path: settings.apiControlCenter
class TranslationsSettingsApiControlCenterRu extends TranslationsSettingsApiControlCenterEn {
	TranslationsSettingsApiControlCenterRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get screenTitle => 'Центр управления API';
	@override String get apiConnectionMode => 'Режим подключения API';
	@override String get directMode => 'Напрямую';
	@override String get proxyMode => 'Через прокси';
	@override String get proxyUrlLabel => 'URL прокси-сервера';
	@override String get proxyUrlHint => 'например, http://localhost:8080';
	@override String get suppliersListTitle => 'Поставщики';
	@override String get configureButton => 'Настроить';
}

// Path: settings.armtekSettings
class TranslationsSettingsArmtekSettingsRu extends TranslationsSettingsArmtekSettingsEn {
	TranslationsSettingsArmtekSettingsRu._(TranslationsRu root) : this._root = root, super.internal(root);

	final TranslationsRu _root; // ignore: unused_field

	// Translations
	@override String get screenTitle => 'Настройки Armtek';
	@override String get credentialsSectionTitle => 'Учетные данные';
	@override String get loginLabel => 'Логин';
	@override String get passwordLabel => 'Пароль';
	@override String get loginRequiredError => 'Логин обязателен';
	@override String get passwordRequiredError => 'Пароль обязателен для нового подключения';
	@override String get checkAndSaveButton => 'Проверить и сохранить';
	@override String get supplierInfoSectionTitle => 'Информация от поставщика';
	@override String get vkorgLabel => 'Сбытовая организация';
	@override String get clientInfoTitle => 'Информация о клиенте';
	@override String get clientStructureKUNAG => 'KUNAG';
	@override String get clientStructureVKORG => 'VKORG';
	@override String get clientStructureSNAME => 'Наименование';
	@override String get clientStructureADRESS => 'Адрес';
	@override String get userInfoUnavailable => 'Информация о клиенте недоступна';
}

/// Flat map(s) containing all translations.
/// Only for edge cases! For simple maps, use the map function of this library.
extension on TranslationsRu {
	dynamic _flatMapFunction(String path) {
		switch (path) {
			case 'clients.screenTitle': return 'Клиенты';
			case 'clients.add': return 'Добавить клиента';
			case 'clients.edit': return 'Редактировать клиента';
			case 'clients.name': return 'Имя/Название';
			case 'clients.type': return 'Тип клиента';
			case 'clients.contactInfo': return 'Контактная информация';
			case 'clients.additionalInfo': return 'Дополнительная информация';
			case 'clients.types.physical': return 'Физическое лицо';
			case 'clients.types.legal': return 'Юридическое лицо';
			case 'clients.types.entrepreneur': return 'ИП';
			case 'clients.types.other': return 'Другое';
			case 'clients.filterByClient': return 'Фильтр по клиенту';
			case 'clients.allClients': return 'Все клиенты';
			case 'clients.noClientsAvailable': return 'Нет доступных клиентов';
			case 'clients.emptyList': return 'Список клиентов пуст. Добавьте клиента, нажав на кнопку \'+\'';
			case 'clients.code': return 'Код';
			case 'clients.codeRequired': return 'Введите код клиента';
			case 'clients.codeNotUnique': return 'Код должен быть уникальным';
			case 'clients.personName': return 'ФИО клиента';
			case 'clients.companyName': return 'Наименование организации';
			case 'clients.nameRequired': return 'Введите имя клиента';
			case 'clients.contactInfoRequired': return 'Введите контактную информацию';
			case 'clients.contactInfoHint': return 'Телефон, email, адрес';
			case 'clients.additionalInfoHint': return 'Примечания, особые условия и т.д.';
			case 'clients.search': return 'Поиск клиентов';
			case 'clients.startTyping': return 'Начните вводить для поиска';
			case 'clients.noClientsFound': return 'Клиенты не найдены';
			case 'clients.clientAdded': return ({required Object name}) => 'Клиент ${name} добавлен';
			case 'clients.clientUpdated': return ({required Object name}) => 'Клиент ${name} обновлен';
			case 'clients.clientDeleted': return ({required Object name}) => 'Клиент ${name} удален';
			case 'clients.clientRestored': return ({required Object name}) => 'Клиент ${name} восстановлен';
			case 'clients.undoDelete': return 'Отменить';
			case 'clients.deleteError': return ({required Object error}) => 'Ошибка при удалении клиента: ${error}';
			case 'clients.addError': return ({required Object error}) => 'Ошибка при добавлении клиента: ${error}';
			case 'clients.updateError': return ({required Object error}) => 'Ошибка при обновлении клиента: ${error}';
			case 'clients.confirmDelete': return ({required Object name}) => 'Вы действительно хотите удалить клиента ${name}?';
			case 'clients.clientNotFound': return 'Клиент не найден';
			case 'clients.clientNotSelected': return 'Клиент не выбран';
			case 'clients.clientLoadError': return 'Ошибка загрузки данных клиента';
			case 'clients.client': return 'Клиент';
			case 'clients.typeRequired': return 'Выберите тип клиента';
			case 'clients.restoreError': return ({required Object error}) => 'Ошибка при восстановлении клиента: ${error}';
			case 'clients.clientRequired': return 'Выберите клиента';
			case 'common.edit': return 'Редактировать';
			case 'common.delete': return 'Удалить';
			case 'common.cancel': return 'Отмена';
			case 'common.confirm': return 'Подтвердить';
			case 'common.save': return 'Сохранить';
			case 'common.confirmDeletion': return 'Подтверждение удаления';
			case 'common.createdAtDate': return ({required Object date}) => 'Создан: ${date}';
			case 'common.scheduledForDate': return ({required Object date}) => 'Запланирован на: ${date}';
			case 'common.completedAtDate': return ({required Object date}) => 'Завершен: ${date}';
			case 'common.dataLoadingError': return 'Ошибка при загрузке данных';
			case 'common.add': return 'Добавить';
			case 'common.loading': return 'Загрузка...';
			case 'common.filter': return 'Фильтр';
			case 'common.noResultsFound': return 'Ничего не найдено';
			case 'common.resetFilter': return 'Сбросить фильтр';
			case 'common.resetButtonLabel': return 'Сбросить';
			case 'common.closeButtonLabel': return 'Закрыть';
			case 'common.noDataAvailable': return 'Нет доступных данных';
			case 'common.createdAt': return 'Создано';
			case 'common.modifiedAt': return 'Изменено';
			case 'common.confirmationTitle': return 'Подтверждение';
			case 'common.remove': return 'Удалить';
			case 'common.cancelButtonLabel': return 'Отмена';
			case 'common.saveButtonLabel': return 'Сохранить';
			case 'common.featureNotImplemented': return ({required Object featureName}) => 'Функция "${featureName}" не реализована';
			case 'common.editingNotImplemented': return ({required Object itemType}) => 'Редактирование "${itemType}" не реализовано';
			case 'common.undo': return 'Отменить';
			case 'common.clear': return 'Очистить';
			case 'common.selectDate': return 'Выберите дату';
			case 'common.resetSearch': return 'Сбросить поиск';
			case 'core.appTitle': return 'Каталог запчастей';
			case 'core.error': return 'Ошибка';
			case 'core.delete': return 'Удалить';
			case 'core.cancel': return 'Отмена';
			case 'core.save': return 'Сохранить';
			case 'core.resetDatabase': return 'Сбросить базу данных';
			case 'core.resetDatabaseSuccess': return 'База данных успешно сброшена';
			case 'core.resetDatabaseError': return ({required Object error}) => 'Ошибка сброса базы данных: ${error}';
			case 'core.dataLoadingError': return 'Ошибка при загрузке данных';
			case 'core.errorLoadingData': return ({required Object error}) => 'Ошибка загрузки данных: ${error}';
			case 'core.resetButtonLabel': return 'Сбросить';
			case 'core.closeButtonLabel': return 'Закрыть';
			case 'core.filter': return 'Фильтр';
			case 'core.changeLanguageTooltip': return 'Сменить язык';
			case 'core.filterOff': return 'Сбросить фильтр';
			case 'core.all': return 'Все';
			case 'core.filterByClient': return 'Фильтр по клиенту';
			case 'core.loading': return 'Загрузка...';
			case 'core.confirmResetDatabaseTitle': return 'Подтвердите сброс БД';
			case 'core.confirmResetDatabaseMessage': return 'Все данные будут удалены без возможности восстановления. Вы уверены?';
			case 'core.copiedToClipboard': return ({required Object value}) => '${value} скопировано в буфер обмена';
			case 'core.noDataAvailable': return 'Нет данных для отображения';
			case 'errors.dataLoadingError': return 'Ошибка загрузки данных';
			case 'errors.saveError': return 'Ошибка сохранения данных';
			case 'errors.fieldRequired': return 'Это поле обязательно для заполнения';
			case 'orders.screenTitle': return 'Заказ-наряды';
			case 'orders.add': return 'Добавить заказ-наряд';
			case 'orders.searchByNumberOrClient': return 'Поиск по номеру или клиенту';
			case 'orders.noOrdersFound': return 'Заказ-наряды не найдены';
			case 'orders.filterByStatus': return 'Фильтр по статусу';
			case 'orders.createdSuccess': return 'Заказ-наряд успешно создан';
			case 'orders.orderDetailsTitle': return 'Информация о заказ-наряде';
			case 'orders.clientInfoTitle': return 'Информация о клиенте';
			case 'orders.problemDescription': return 'Описание проблемы';
			case 'orders.partsList': return 'Запчасти';
			case 'orders.servicesList': return 'Услуги';
			case 'orders.noPartsAdded': return 'Запчасти не добавлены';
			case 'orders.noServicesAdded': return 'Услуги не добавлены';
			case 'orders.addButtonLabel': return 'Добавить';
			case 'orders.totalAmount': return 'Итого:';
			case 'orders.orderUpdatedSuccess': return 'Заказ-наряд успешно обновлен';
			case 'orders.orderDeletedSuccess': return 'Заказ-наряд успешно удален';
			case 'orders.orderDeleteError': return 'Ошибка при удалении заказ-наряда';
			case 'orders.changeStatusTitle': return 'Изменение статуса';
			case 'orders.statusChangeError': return 'Ошибка при изменении статуса';
			case 'orders.partRemovedSuccess': return 'Запчасть успешно удалена';
			case 'orders.partRemoveError': return 'Ошибка при удалении запчасти';
			case 'orders.partOrderedSuccess': return 'Запчасть отмечена как заказанная';
			case 'orders.partReceivedSuccess': return 'Запчасть отмечена как полученная';
			case 'orders.partUpdateError': return 'Ошибка при обновлении статуса запчасти';
			case 'orders.serviceRemovedSuccess': return 'Услуга успешно удалена';
			case 'orders.serviceRemoveError': return 'Ошибка при удалении услуги';
			case 'orders.serviceCompletedSuccess': return 'Услуга отмечена как выполненная';
			case 'orders.serviceUpdateError': return 'Ошибка при обновлении статуса услуги';
			case 'orders.startWorkAction': return 'Начать работу';
			case 'orders.markReadyAction': return 'Готов к выдаче';
			case 'orders.resumeWorkAction': return 'Возобновить работу';
			case 'orders.completeOrderAction': return 'Завершить заказ';
			case 'orders.orderCompletedStatus': return 'Заказ завершен';
			case 'orders.orderCancelledStatus': return 'Заказ отменен';
			case 'orders.confirmOrderDeletion': return 'Вы уверены, что хотите удалить этот заказ-наряд? Это действие нельзя отменить.';
			case 'orders.confirmPartDeletion': return ({required Object name}) => 'Вы уверены, что хотите удалить запчасть "${name}" из заказ-наряда?';
			case 'orders.confirmServiceDeletion': return ({required Object name}) => 'Вы уверены, что хотите удалить услугу "${name}" из заказ-наряда?';
			case 'orders.orderNotFound': return 'Заказ-наряд не найден';
			case 'orders.dataLoadingError': return 'Ошибка при загрузке данных';
			case 'orders.orderNumberFormat': return ({required Object number}) => 'Заказ-наряд № ${number}';
			case 'orders.createdAtDate': return ({required Object date}) => 'Создан: ${date}';
			case 'orders.scheduledForDate': return ({required Object date}) => 'Запланирован: ${date}';
			case 'orders.completedAtDate': return ({required Object date}) => 'Завершен: ${date}';
			case 'orders.loadingClient': return 'Загрузка клиента...';
			case 'orders.loadingVehicle': return 'Загрузка автомобиля...';
			case 'orders.addPartFeature': return 'Добавление запчасти';
			case 'orders.addServiceFeature': return 'Добавление услуги';
			case 'orders.selectClientFirst': return 'Сначала выберите клиента';
			case 'orders.selectClientError': return 'Необходимо выбрать клиента';
			case 'orders.selectVehicleError': return 'Необходимо выбрать автомобиль';
			case 'orders.updatedSuccess': return 'Заказ-наряд успешно обновлен';
			case 'orders.editOrderTitle': return 'Редактирование заказ-наряда';
			case 'orders.newOrderTitle': return 'Новый заказ-наряд';
			case 'orders.selectClientHint': return 'Выберите клиента';
			case 'orders.vehicleInfoTitle': return 'Информация об автомобиле';
			case 'orders.selectVehicleHint': return 'Выберите автомобиль';
			case 'orders.problemDescriptionHint': return 'Опишите причину обращения...';
			case 'orders.scheduledDate': return 'Запланированная дата';
			case 'orders.selectClient': return 'Выбор клиента';
			case 'orders.selectVehicle': return 'Выбор автомобиля';
			case 'orders.addService': return 'Добавить услугу';
			case 'orders.editService': return 'Редактировать услугу';
			case 'orders.addPart': return 'Добавить запчасть';
			case 'orders.editPart': return 'Редактировать запчасть';
			case 'orders.scheduledShort': return 'План';
			case 'parts.statusReceived': return 'Получено';
			case 'parts.statusOrdered': return 'Заказано';
			case 'parts.statusNotOrdered': return 'Не заказано';
			case 'parts.partNumberLabel': return 'Артикул';
			case 'parts.brandLabel': return 'Бренд';
			case 'parts.pcs': return 'шт.';
			case 'services.statusCompleted': return 'Выполнено';
			case 'services.statusNotCompleted': return 'Не выполнено';
			case 'settings.apiControlCenter.screenTitle': return 'Центр управления API';
			case 'settings.apiControlCenter.apiConnectionMode': return 'Режим подключения API';
			case 'settings.apiControlCenter.directMode': return 'Напрямую';
			case 'settings.apiControlCenter.proxyMode': return 'Через прокси';
			case 'settings.apiControlCenter.proxyUrlLabel': return 'URL прокси-сервера';
			case 'settings.apiControlCenter.proxyUrlHint': return 'например, http://localhost:8080';
			case 'settings.apiControlCenter.suppliersListTitle': return 'Поставщики';
			case 'settings.apiControlCenter.configureButton': return 'Настроить';
			case 'settings.armtekSettings.screenTitle': return 'Настройки Armtek';
			case 'settings.armtekSettings.credentialsSectionTitle': return 'Учетные данные';
			case 'settings.armtekSettings.loginLabel': return 'Логин';
			case 'settings.armtekSettings.passwordLabel': return 'Пароль';
			case 'settings.armtekSettings.loginRequiredError': return 'Логин обязателен';
			case 'settings.armtekSettings.passwordRequiredError': return 'Пароль обязателен для нового подключения';
			case 'settings.armtekSettings.checkAndSaveButton': return 'Проверить и сохранить';
			case 'settings.armtekSettings.supplierInfoSectionTitle': return 'Информация от поставщика';
			case 'settings.armtekSettings.vkorgLabel': return 'Сбытовая организация';
			case 'settings.armtekSettings.clientInfoTitle': return 'Информация о клиенте';
			case 'settings.armtekSettings.clientStructureKUNAG': return 'KUNAG';
			case 'settings.armtekSettings.clientStructureVKORG': return 'VKORG';
			case 'settings.armtekSettings.clientStructureSNAME': return 'Наименование';
			case 'settings.armtekSettings.clientStructureADRESS': return 'Адрес';
			case 'settings.armtekSettings.userInfoUnavailable': return 'Информация о клиенте недоступна';
			case 'vehicles.screenTitle': return 'Автомобили';
			case 'vehicles.add': return 'Добавить автомобиль';
			case 'vehicles.edit': return 'Редактировать автомобиль';
			case 'vehicles.make': return 'Марка';
			case 'vehicles.model': return 'Модель';
			case 'vehicles.year': return 'Год';
			case 'vehicles.vin': return 'VIN';
			case 'vehicles.licensePlate': return 'Гос. номер';
			case 'vehicles.owner': return 'Владелец';
			case 'vehicles.noCarsAvailable': return 'Нет доступных автомобилей';
			case 'vehicles.emptyList': return 'Список автомобилей пуст. Добавьте автомобиль, нажав на кнопку \'+\'';
			case 'vehicles.deleted': return ({required Object make, required Object model}) => 'Автомобиль ${make} ${model} удален';
			case 'vehicles.carHistory': return 'История автомобиля';
			case 'vehicles.selectVehiclePrompt': return 'Выберите автомобиль из списка слева';
			case 'vehicles.databaseError': return 'Ошибка доступа к базе данных';
			case 'vehicles.resetDatabase': return 'Сбросить базу данных';
			case 'vehicles.resetDatabaseSuccess': return 'База данных успешно сброшена';
			case 'vehicles.carDetailTitle': return 'Детали автомобиля';
			case 'vehicles.additionalInfo': return 'Дополнительная информация';
			case 'vehicles.requiredField': return 'Поле обязательно для заполнения';
			case 'vehicles.invalidYear': return 'Некорректный год';
			case 'vehicles.vinRequirement': return 'VIN должен содержать 17 символов';
			case 'vehicles.cancel': return 'Отмена';
			case 'vehicles.save': return 'Сохранить';
			case 'vehicles.deleteConfirmTitle': return 'Удалить автомобиль?';
			case 'vehicles.deleteConfirmMessage': return ({required Object make, required Object model, required Object vin}) => 'Вы действительно хотите удалить автомобиль ${make} ${model} (VIN: ${vin})?';
			case 'vehicles.makeHint': return 'Например: Toyota';
			case 'vehicles.modelHint': return 'Например: Camry';
			case 'vehicles.yearHint': return 'Например: 2022';
			case 'vehicles.vinHint': return '17 символов';
			case 'vehicles.licensePlateHint': return 'Регистрационный номер авто';
			case 'vehicles.additionalInfoHint': return 'Комплектация, особенности и т.д.';
			case 'vehicles.orderHistoryComingSoon': return 'История заказ-нарядов будет добавлена позже';
			case 'vehicles.vehicleNotFound': return 'Автомобиль не найден';
			case 'vehicles.vehicleNotSelected': return 'Автомобиль не выбран';
			case 'vehicles.vehicleLoadError': return 'Ошибка загрузки данных автомобиля';
			case 'vehicles.vehicle': return 'Автомобиль';
			case 'vehicles.restoreError': return ({required Object error}) => 'Ошибка при восстановлении автомобиля: ${error}';
			case 'vehicles.deleteError': return ({required Object error}) => 'Ошибка при удалении автомобиля: ${error}';
			case 'vehicles.addError': return ({required Object error}) => 'Ошибка при добавлении автомобиля: ${error}';
			case 'vehicles.updateError': return ({required Object error}) => 'Ошибка при обновлении автомобиля: ${error}';
			case 'vehicles.vinNotUnique': return 'Автомобиль с таким VIN уже существует';
			case 'vehicles.restored': return ({required Object name}) => 'Автомобиль "${name}" восстановлен';
			case 'vehicles.added': return ({required Object name}) => 'Автомобиль "${name}" добавлен';
			case 'vehicles.updated': return ({required Object name}) => 'Автомобиль "${name}" обновлен';
			case 'vehicles.vinCheckError': return 'Ошибка проверки VIN';
			default: return null;
		}
	}
}


```

## lib\core\i18n\vehicles\vehicles_en.i18n.json
```json
{
    "screenTitle": "Vehicles",
    "add": "Add Vehicle",
    "edit": "Edit Vehicle",
    "make": "Make",
    "model": "Model",
    "year": "Year",
    "vin": "VIN",
    "licensePlate": "License Plate",
    "owner": "Owner",
    "noCarsAvailable": "No vehicles available",
    "emptyList": "The vehicles list is empty. Add a vehicle by clicking the '+' button",
    "deleted": "{make} {model} deleted",
    "carHistory": "Vehicle History",
    "selectVehiclePrompt": "Please select a vehicle from the list",
    "databaseError": "Database access error",
    "resetDatabase": "Reset database",
    "resetDatabaseSuccess": "Database successfully reset",
    "carDetailTitle": "Vehicle Details",
    "additionalInfo": "Additional Information",
    "requiredField": "This field is required",
    "invalidYear": "Invalid year",
    "vinRequirement": "VIN must be 17 characters long",
    "cancel": "Cancel",
    "save": "Save",
    "deleteConfirmTitle": "Delete vehicle?",
    "deleteConfirmMessage(make: String, model: String, vin: String)": "Are you sure you want to delete the {make} {model} (VIN: {vin})?",
    "makeHint": "For example: Toyota",
    "modelHint": "For example: Camry",
    "yearHint": "For example: 2022",
    "vinHint": "17 characters",
    "licensePlateHint": "Vehicle registration number",
    "additionalInfoHint": "Equipment, features, etc.",
    "orderHistoryComingSoon": "Order history will be added later",
    "vehicleNotFound": "Vehicle not found",
    "vehicleNotSelected": "Vehicle not selected",
    "vehicleLoadError": "Error loading vehicle data",
    "vehicle": "Vehicle",
    "deleted(make: String, model: String)": "{make} {model} deleted",
    "restoreError(error: String)": "Error restoring vehicle: {error}",
    "deleteError(error: String)": "Error deleting vehicle: {error}",
    "addError(error: String)": "Error adding vehicle: {error}",
    "updateError(error: String)": "Error updating vehicle: {error}",
    "vinNotUnique": "A vehicle with this VIN already exists",
    "restored(name: String)": "Vehicle \"{name}\" restored",
    "added(name: String)": "Vehicle \"{name}\" added",
    "updated(name: String)": "Vehicle \"{name}\" updated",
    "vinCheckError": "VIN check error"
}
```

## lib\core\i18n\vehicles\vehicles_ru.i18n.json
```json
{
    "screenTitle": "Автомобили",
    "add": "Добавить автомобиль",
    "edit": "Редактировать автомобиль",
    "make": "Марка",
    "model": "Модель",
    "year": "Год",
    "vin": "VIN",
    "licensePlate": "Гос. номер",
    "owner": "Владелец",
    "noCarsAvailable": "Нет доступных автомобилей",
    "emptyList": "Список автомобилей пуст. Добавьте автомобиль, нажав на кнопку '+'",
    "deleted": "Автомобиль {make} {model} удален",
    "carHistory": "История автомобиля",
    "selectVehiclePrompt": "Выберите автомобиль из списка слева",
    "databaseError": "Ошибка доступа к базе данных",
    "resetDatabase": "Сбросить базу данных",
    "resetDatabaseSuccess": "База данных успешно сброшена",
    "carDetailTitle": "Детали автомобиля",
    "additionalInfo": "Дополнительная информация",
    "requiredField": "Поле обязательно для заполнения",
    "invalidYear": "Некорректный год",
    "vinRequirement": "VIN должен содержать 17 символов",
    "cancel": "Отмена",
    "save": "Сохранить",
    "deleteConfirmTitle": "Удалить автомобиль?",
    "deleteConfirmMessage(make: String, model: String, vin: String)": "Вы действительно хотите удалить автомобиль {make} {model} (VIN: {vin})?",
    "makeHint": "Например: Toyota",
    "modelHint": "Например: Camry",
    "yearHint": "Например: 2022",
    "vinHint": "17 символов",
    "licensePlateHint": "Регистрационный номер авто",
    "additionalInfoHint": "Комплектация, особенности и т.д.",
    "orderHistoryComingSoon": "История заказ-нарядов будет добавлена позже",
    "vehicleNotFound": "Автомобиль не найден",
    "vehicleNotSelected": "Автомобиль не выбран",
    "vehicleLoadError": "Ошибка загрузки данных автомобиля",
    "vehicle": "Автомобиль",
    "deleted(make: String, model: String)": "Автомобиль {make} {model} удален",
    "restoreError(error: String)": "Ошибка при восстановлении автомобиля: {error}",
    "deleteError(error: String)": "Ошибка при удалении автомобиля: {error}",
    "addError(error: String)": "Ошибка при добавлении автомобиля: {error}",
    "updateError(error: String)": "Ошибка при обновлении автомобиля: {error}",
    "vinNotUnique": "Автомобиль с таким VIN уже существует",
    "restored(name: String)": "Автомобиль \"{name}\" восстановлен",
    "added(name: String)": "Автомобиль \"{name}\" добавлен",
    "updated(name: String)": "Автомобиль \"{name}\" обновлен",
    "vinCheckError": "Ошибка проверки VIN"
}
```

## lib\core\navigation\app_router.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:part_catalog/features/home/screens/home_screen.dart';
import 'package:part_catalog/features/references/clients/screens/clients_screen.dart'; // Пример
import 'package:part_catalog/features/references/vehicles/screens/cars_screen.dart'; // Пример
import 'package:part_catalog/features/documents/orders/screens/orders_screen.dart'; // Пример
// Импортируйте другие экраны...
import 'app_routes.dart';

/// Конфигурация GoRouter для приложения
final GoRouter router = GoRouter(
  initialLocation: AppRoutes.clients, // Начальный экран при запуске
  debugLogDiagnostics: true, // Включить логирование для отладки

  routes: [
    // ShellRoute для основной навигации с BottomNavigationBar/NavigationBar
    ShellRoute(
      builder: (BuildContext context, GoRouterState state, Widget child) {
        // HomeScreen выступает в роли оболочки
        return HomeScreen(child: child);
      },
      routes: <RouteBase>[
        // Маршруты для каждого раздела в Shell
        GoRoute(
          path: AppRoutes.clients,
          builder: (BuildContext context, GoRouterState state) {
            return const ClientsScreen(); // Экран списка клиентов
          },
          // Можно добавить вложенные маршруты для деталей клиента и т.д.
          // routes: <RouteBase>[
          //   GoRoute(
          //     path: 'details/:clientId', // Пример вложенного маршрута
          //     builder: (BuildContext context, GoRouterState state) {
          //       final clientId = state.pathParameters['clientId']!;
          //       return ClientDetailsScreen(clientId: clientId);
          //     },
          //   ),
          // ],
        ),
        GoRoute(
          path: AppRoutes.vehicles,
          builder: (BuildContext context, GoRouterState state) {
            return const CarsScreen(); // Экран списка автомобилей
          },
        ),
        GoRoute(
          path: AppRoutes.orders,
          builder: (BuildContext context, GoRouterState state) {
            return const OrdersScreen(); // Экран списка заказов
          },
        ),
        // Добавьте GoRoute для других разделов здесь
      ],
    ),

    // Можно добавить другие маршруты верхнего уровня,
    // которые не используют ShellRoute (например, экран логина, настроек)
    // GoRoute(
    //   path: '/settings',
    //   builder: (BuildContext context, GoRouterState state) {
    //     return const SettingsScreen();
    //   },
    // ),
  ],

  // Обработка ошибок навигации (опционально)
  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: const Text('Ошибка навигации')),
    body: Center(child: Text('Страница не найдена: ${state.error}')),
  ),
);

```

## lib\core\navigation\app_routes.dart
```dart
class AppRoutes {
  static const String clients = '/clients';
  static const String vehicles = '/vehicles';
  static const String orders = '/orders';
  // Добавьте другие маршруты
}

```

## lib\core\providers\core_providers.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Импортируем базовый Ref
import 'package:logger/logger.dart';
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'core_providers.g.dart';

// --- Провайдеры для логгеров ---

// Общий логгер приложения (для ядра, UI и т.д.)
@Riverpod(keepAlive: true)
Logger coreLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.core;
}

// Логгер для модуля клиентов
@Riverpod(keepAlive: true)
Logger clientsLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.clients;
}

// Логгер для модуля автомобилей
@Riverpod(keepAlive: true)
Logger vehiclesLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.vehicles;
}

// Логгер для модуля заказ-нарядов
@Riverpod(keepAlive: true)
Logger ordersLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.orders;
}

// Логгер для модуля поставщиков
@Riverpod(keepAlive: true)
Logger suppliersLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.suppliers;
}

// Логгер для сетевых операций (если нужен отдельно)
@Riverpod(keepAlive: true)
Logger networkLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.network;
}

// Логгер для базы данных (если нужен отдельно)
@Riverpod(keepAlive: true)
Logger databaseLogger(Ref ref) {
  // Используем базовый Ref
  return AppLoggers.database;
}

// --- Другие общие провайдеры ---
// ...

```

## lib\core\providers\core_providers.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'core_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$coreLoggerHash() => r'5c0b547d7c1399531f59dbd2a361733c46a573a2';

/// See also [coreLogger].
@ProviderFor(coreLogger)
final coreLoggerProvider = Provider<Logger>.internal(
  coreLogger,
  name: r'coreLoggerProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$coreLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef CoreLoggerRef = ProviderRef<Logger>;
String _$clientsLoggerHash() => r'ce8ff0a4b8410ab38d4619eebe61f0273a59abe5';

/// See also [clientsLogger].
@ProviderFor(clientsLogger)
final clientsLoggerProvider = Provider<Logger>.internal(
  clientsLogger,
  name: r'clientsLoggerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$clientsLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ClientsLoggerRef = ProviderRef<Logger>;
String _$vehiclesLoggerHash() => r'51b9b0143cc0467ae1581dfba5f707cadadd5b05';

/// See also [vehiclesLogger].
@ProviderFor(vehiclesLogger)
final vehiclesLoggerProvider = Provider<Logger>.internal(
  vehiclesLogger,
  name: r'vehiclesLoggerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$vehiclesLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef VehiclesLoggerRef = ProviderRef<Logger>;
String _$ordersLoggerHash() => r'296870f8459244ab496815338232e714cdbfef35';

/// See also [ordersLogger].
@ProviderFor(ordersLogger)
final ordersLoggerProvider = Provider<Logger>.internal(
  ordersLogger,
  name: r'ordersLoggerProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$ordersLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef OrdersLoggerRef = ProviderRef<Logger>;
String _$suppliersLoggerHash() => r'1b239a611e115d8875ffc3acdfcd1378e1a69609';

/// See also [suppliersLogger].
@ProviderFor(suppliersLogger)
final suppliersLoggerProvider = Provider<Logger>.internal(
  suppliersLogger,
  name: r'suppliersLoggerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$suppliersLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef SuppliersLoggerRef = ProviderRef<Logger>;
String _$networkLoggerHash() => r'9a7cf6c0f1ca250cf0acc6ee68f42269181d4c3e';

/// See also [networkLogger].
@ProviderFor(networkLogger)
final networkLoggerProvider = Provider<Logger>.internal(
  networkLogger,
  name: r'networkLoggerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$networkLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef NetworkLoggerRef = ProviderRef<Logger>;
String _$databaseLoggerHash() => r'c1746a33772978c4d5f372b412b40f12df7ab44c';

/// See also [databaseLogger].
@ProviderFor(databaseLogger)
final databaseLoggerProvider = Provider<Logger>.internal(
  databaseLogger,
  name: r'databaseLoggerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$databaseLoggerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef DatabaseLoggerRef = ProviderRef<Logger>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

```

## lib\core\schemas\app_schema.json
```json
{
    "definitions": {
        "Client": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Уникальный идентификатор клиента"
                },
                "type": {
                    "type": "string",
                    "description": "Тип клиента (физическое или юридическое лицо)",
                    "enum": [
                        "physical",
                        "legal"
                    ]
                },
                "name": {
                    "type": "string",
                    "description": "ФИО для физического лица или название организации для юридического лица"
                },
                "contactInfo": {
                    "type": "string",
                    "description": "Контактная информация (телефон, email, адрес)"
                },
                "additionalInfo": {
                    "type": "string",
                    "description": "Дополнительная информация"
                }
            },
            "required": [
                "id",
                "type",
                "name",
                "contactInfo"
            ]
        },
        "Car": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Уникальный идентификатор автомобиля"
                },
                "clientId": {
                    "type": "string",
                    "description": "Идентификатор клиента-владельца"
                },
                "vin": {
                    "type": "string",
                    "description": "VIN-код"
                },
                "make": {
                    "type": "string",
                    "description": "Марка автомобиля"
                },
                "model": {
                    "type": "string",
                    "description": "Модель автомобиля"
                },
                "year": {
                    "type": "integer",
                    "description": "Год выпуска"
                },
                "licensePlate": {
                    "type": "string",
                    "description": "Номерной знак"
                },
                "additionalInfo": {
                    "type": "string",
                    "description": "Дополнительная информация"
                }
            },
            "required": [
                "id",
                "clientId",
                "vin",
                "make",
                "model",
                "year"
            ]
        },
        "Order": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Уникальный идентификатор заказ-наряда"
                },
                "clientId": {
                    "type": "string",
                    "description": "Идентификатор клиента"
                },
                "carId": {
                    "type": "string",
                    "description": "Идентификатор автомобиля"
                },
                "date": {
                    "type": "string",
                    "format": "date",
                    "description": "Дата создания заказ-наряда"
                },
                "description": {
                    "type": "string",
                    "description": "Описание проблемы"
                },
                "workItems": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "description": {
                                "type": "string",
                                "description": "Описание работы"
                            },
                            "cost": {
                                "type": "number",
                                "format": "float",
                                "description": "Стоимость работы"
                            }
                        },
                        "required": [
                            "description",
                            "cost"
                        ]
                    },
                    "description": "Список работ (описание и стоимость)"
                },
                "orderItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/OrderItem"
                    },
                    "description": "Список запчастей (с ценами и сроками поставки)"
                },
                "totalCost": {
                    "type": "number",
                    "format": "float",
                    "description": "Общая стоимость"
                },
                "status": {
                    "type": "string",
                    "description": "Статус заказ-наряда",
                    "enum": [
                        "created",
                        "inProgress",
                        "completed"
                    ]
                }
            },
            "required": [
                "id",
                "clientId",
                "carId",
                "date",
                "description",
                "workItems",
                "orderItems",
                "totalCost",
                "status"
            ]
        },
        "OrderItem": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Уникальный идентификатор позиции"
                },
                "orderId": {
                    "type": "string",
                    "description": "Идентификатор заказ-наряда"
                },
                "partNumber": {
                    "type": "string",
                    "description": "Артикул запчасти"
                },
                "partName": {
                    "type": "string",
                    "description": "Название запчасти"
                },
                "quantity": {
                    "type": "integer",
                    "description": "Количество"
                },
                "price": {
                    "type": "number",
                    "format": "float",
                    "description": "Цена за единицу"
                },
                "supplier": {
                    "type": "string",
                    "description": "Поставщик"
                },
                "deliveryTime": {
                    "type": "string",
                    "description": "Срок поставки"
                }
            },
            "required": [
                "id",
                "orderId",
                "partNumber",
                "partName",
                "quantity",
                "price",
                "supplier",
                "deliveryTime"
            ]
        },
        "Supplier": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Уникальный идентификатор поставщика"
                },
                "name": {
                    "type": "string",
                    "description": "Название поставщика"
                },
                "contactInfo": {
                    "type": "string",
                    "description": "Контактная информация"
                }
            },
            "required": [
                "id",
                "name",
                "contactInfo"
            ]
        },
        "PriceOffer": {
            "type": "object",
            "properties": {
                "partNumber": {
                    "type": "string",
                    "description": "Артикул запчасти"
                },
                "price": {
                    "type": "number",
                    "format": "float",
                    "description": "Цена"
                },
                "deliveryTime": {
                    "type": "string",
                    "description": "Срок поставки"
                },
                "supplierId": {
                    "type": "string",
                    "description": "Идентификатор поставщика"
                }
            },
            "required": [
                "partNumber",
                "price",
                "deliveryTime",
                "supplierId"
            ]
        }
    }
}
```

## lib\core\service_locator.dart
```dart
import 'package:dio/dio.dart';
import 'package:get_it/get_it.dart';
import 'package:part_catalog/features/documents/orders/services/order_service.dart';
import 'package:part_catalog/features/parts_catalog/api/api_client_parts_catalogs.dart';
import 'package:part_catalog/features/references/clients/services/client_service.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/features/references/vehicles/services/car_service.dart';
import 'package:part_catalog/features/suppliers/api/api_client_manager.dart';
import 'package:part_catalog/features/suppliers/services/suppliers_service.dart';
import 'package:part_catalog/core/config/global_api_settings_service.dart';

final locator = GetIt.instance;

// Изменяем функцию, чтобы принимать существующий экземпляр базы данных
void setupLocator(AppDatabase database) {
  // Регистрируем Dio
  locator.registerLazySingleton(() => Dio());

  // Регистрируем ApiClientPartsCatalogs
  locator.registerLazySingleton(() => ApiClientPartsCatalogs(locator<Dio>()));

  // Регистрируем существующий экземпляр базы данных
  locator.registerSingleton<AppDatabase>(database);

  // Регистрация сервисов, которые зависят от AppDatabase
  locator.registerLazySingleton<ClientService>(
      () => ClientService(locator<AppDatabase>()));
  locator.registerLazySingleton<CarService>(
      () => CarService(locator<AppDatabase>()));
  locator.registerLazySingleton<OrderService>(
      () => OrderService(locator<AppDatabase>()));

  // Регистрация ApiClientManager и SuppliersService
  locator.registerLazySingleton<ApiClientManager>(() => ApiClientManager());
  locator.registerLazySingleton<SuppliersService>(
      () => SuppliersService(locator<ApiClientManager>()));

  // Регистрация GlobalApiSettingsService
  locator.registerLazySingleton<GlobalApiSettingsService>(
      () => GlobalApiSettingsService());

  // Регистрация SupplierSettingsDao (если он не получается напрямую из AppDatabase.supplierSettingsDao)
  // Обычно DAO доступны через экземпляр AppDatabase, например: locator<AppDatabase>().supplierSettingsDao
  // Если вы хотите зарегистрировать DAO отдельно:
  // locator.registerLazySingleton<SupplierSettingsDao>(
  //   () => locator<AppDatabase>().supplierSettingsDao,
  // );
  // Однако, это может быть избыточным, если DAO всегда доступны через AppDatabase.
}

```

## lib\core\utils\json_converter.dart
```dart
import 'dart:convert';
import 'package:drift/drift.dart';

/// {@template json_converter}
/// Конвертер для преобразования объектов в JSON и обратно для хранения в базе данных.
/// {@endtemplate}
class JsonConverter<T> extends TypeConverter<T, String> {
  /// {@macro json_converter}
  /// [fromJson] - функция, преобразующая JSON-объект в объект типа T
  const JsonConverter(this.fromJson);

  /// Функция для преобразования JSON-объекта в объект типа T
  final T Function(Map<String, dynamic>) fromJson;

  @override
  T fromSql(String fromDb) {
    return fromJson(json.decode(fromDb) as Map<String, dynamic>);
  }

  @override
  String toSql(T value) {
    return json.encode(value);
  }
}

// Примечание: OrderItems должен быть определен в отдельном файле
// например в lib/features/orders/models/order_entity.dart

// Пример использования в таблице:
/*
class OrderItems extends Table {
  // ...другие колонки...

  // Хранение дополнительных опций как JSON
  TextColumn get options => text().map(JsonConverter<Map<String, dynamic>>(
        (json) => json,
      ))();
}
*/

```

## lib\core\utils\log_messages.dart
```dart
/// Константы для сообщений логирования.
/// Централизованное хранение всех сообщений логов позволяет обеспечить их консистентность
/// и упрощает поддержку и обновление.
class LogMessages {
  // Общие сообщения
  static const String error = 'Ошибка: ';

  // Сообщения связанные с базой данных
  static const String databaseResetError = 'Ошибка при сбросе базы данных';
  static const String dataLoadingError = 'Ошибка загрузки данных';
  static const String dbTableMissingError =
      'Ошибка отсутствия таблицы в базе данных';

  // Сообщения для модуля клиентов
  static const String clientAddError = 'Ошибка при добавлении клиента';
  static const String clientUpdateError = 'Ошибка при обновлении клиента';
  static const String clientDeleteError = 'Ошибка при удалении клиента';
  static const String clientRestoreError = 'Ошибка при восстановлении клиента';
  static const String clientValidationError = 'Ошибка валидации данных клиента';
  static const String clientSearchError = 'Ошибка при поиске клиентов';
  static const String clientCodeValidationError =
      'Ошибка проверки уникальности кода клиента';
  static const String clientNotFoundByUuid =
      'Клиент с UUID {uuid} не найден в базе данных';
  static const String clientInserting =
      'Добавление клиента с UUID {uuid} и кодом {code}'; // Обновлено для ясности
  static const String clientUpdating = 'Обновление клиента с UUID {uuid}';
  static const String clientSoftDeleting =
      'Мягкое удаление клиента с UUID {uuid}';
  static const String clientRestoring = 'Восстановление клиента с UUID {uuid}';
  static const String clientGeneratedCode =
      'Сгенерирован новый код клиента: {code}'; // <-- Новая константа

  // --- Новые константы для ClientService ---
  static const String clientWatchActive = 'Наблюдение за активными клиентами';
  static const String clientGetByUuid = 'Получение клиента по UUID {uuid}';
  static const String clientGetByCode = 'Получение клиента по коду {code}';
  static const String clientNotFoundByCode = 'Клиент с кодом {code} не найден';
  static const String clientAddErrorMissingUuid =
      'Ошибка добавления клиента: отсутствует UUID';
  static const String clientCreated = 'Клиент {uuid} успешно создан';
  static const String clientNotFoundForUpdate =
      'Клиент {uuid} не найден для обновления';
  static const String clientUpdated = 'Клиент {uuid} успешно обновлен';
  static const String clientDeleting = 'Удаление клиента {uuid}';
  static const String clientNotFoundForDelete =
      'Клиент {uuid} не найден для удаления';
  static const String clientAlreadyDeleted =
      'Клиент {uuid} уже помечен как удаленный';
  static const String clientDeleted = 'Клиент {uuid} помечен как удаленный';
  static String clientGetAll(bool includeDeleted) =>
      'Получение всех клиентов ${includeDeleted ? " (включая удаленных)" : ""}'; // Метод для динамического сообщения
  static const String clientGetByType = 'Получение клиентов по типу {type}';
  static const String clientNotFoundForRestore =
      'Клиент {uuid} не найден для восстановления';
  static const String clientRestoreAttemptOnNonDeleted =
      'Попытка восстановить не удаленного клиента {uuid}';
  static const String clientRestored = 'Клиент {uuid} успешно восстановлен';
  static const String clientCreatingWithCars =
      'Создание клиента {uuid} с {carCount} автомобилями';
  static const String clientCreatedWithCarsSuccess =
      'Клиент {uuid} и его автомобили успешно созданы';
  static const String clientCreateWithCarsError =
      'Ошибка создания клиента {uuid} с автомобилями';
  static const String clientSearching = 'Поиск клиентов по запросу "{query}"';
  static const String clientCheckingCodeUniqueness =
      'Проверка уникальности кода клиента {code}';
  static const String clientInsertedInTransaction =
      'Клиент {uuid} вставлен в транзакции';
  static const String clientCarAddedInTransaction =
      'Машина {carUuid} добавлена для клиента {clientUuid} в транзакции';

  // Сообщения для модуля автомобилей
  static const String carAddError = 'Ошибка при добавлении автомобиля';
  static const String carUpdateError = 'Ошибка при обновлении автомобиля';
  static const String carDeleteError = 'Ошибка при удалении автомобиля';
  static const String carRestoreError = 'Ошибка при восстановлении автомобиля';
  static const String carNotFoundByUuid = 'Автомобиль с UUID {uuid} не найден';
  static const String carInserting =
      'Добавление автомобиля с UUID {uuid} для клиента ID {clientId}';
  static const String carUpdating = 'Обновление автомобиля с UUID {uuid}';
  static const String carSoftDeleting =
      'Мягкое удаление автомобиля с UUID {uuid}';
  static const String carRestoring = 'Восстановление автомобиля с UUID {uuid}';

  // --- Новые константы для CarService ---
  static const String carWatchActive = 'Наблюдение за активными автомобилями';
  static const String carWatchActiveByClient =
      'Наблюдение за активными автомобилями клиента {uuid}';
  static const String carGetByUuid = 'Получение автомобиля по UUID {uuid}';
  static const String carAddErrorMissingUuid =
      'Ошибка добавления автомобиля: отсутствует UUID';
  static const String carCreated = 'Автомобиль {uuid} успешно создан';
  static const String carNotFoundForUpdate =
      'Автомобиль {uuid} не найден для обновления';
  static const String carUpdated = 'Автомобиль {uuid} успешно обновлен';
  static const String carDeleting = 'Удаление автомобиля {uuid}';
  static const String carNotFoundForDelete =
      'Автомобиль {uuid} не найден для удаления';
  static const String carAlreadyDeleted =
      'Автомобиль {uuid} уже помечен как удаленный';
  static const String carDeleted =
      'Автомобиль {uuid} помечен как удаленный'; // Добавлено
  static const String carNotFoundForRestore =
      'Автомобиль {uuid} не найден для восстановления';
  static const String carRestoreAttemptOnNonDeleted =
      'Попытка восстановить не удаленный автомобиль {uuid}';
  static const String carRestored = 'Автомобиль {uuid} успешно восстановлен';
  static const String carGetWithOwners =
      'Получение списка автомобилей с владельцами';
  static const String carGetWithOwnersError =
      'Ошибка при получении списка автомобилей с владельцами';
  static const String carWatchWithOwners =
      'Наблюдение за списком автомобилей с владельцами';
  static const String carWatchWithOwnersError =
      'Ошибка при наблюдении за списком автомобилей с владельцами';

  // Сообщения для API
  static const String apiRequestError = 'Ошибка запроса к API';
  static const String apiResponseError = 'Ошибка в ответе API';

  // Сообщения для модуля заказ-нарядов
  static const String orderGetError = 'Ошибка при получении заказ-нарядов';
  static const String orderWatchError =
      'Ошибка при наблюдении за заказ-нарядами';
  static const String orderByUuidGetError =
      'Ошибка при получении заказ-наряда по UUID';
  static const String orderByUuidWatchError =
      'Ошибка при наблюдении за заказ-нарядом';
  static const String orderCreateError = 'Ошибка при создании заказ-наряда';
  static const String orderNewCreateError =
      'Ошибка при создании нового заказ-наряда';
  static const String orderUpdateError = 'Ошибка при обновлении заказ-наряда';
  static const String orderStatusChangeError =
      'Ошибка при изменении статуса заказ-наряда';
  static const String orderServiceAddError =
      'Ошибка при добавлении услуги к заказ-наряду';
  static const String orderPartAddError =
      'Ошибка при добавлении запчасти к заказ-наряду';
  static const String orderServiceUpdateError = 'Ошибка при обновлении услуги';
  static const String orderPartUpdateError = 'Ошибка при обновлении запчасти';
  static const String orderServiceRemoveError = 'Ошибка при удалении услуги';
  static const String orderPartRemoveError = 'Ошибка при удалении запчасти';
  static const String orderDeleteError = 'Ошибка при удалении заказ-наряда';
  static const String orderRestoreError =
      'Ошибка при восстановлении заказ-наряда';
  static const String orderServiceCreateAddError =
      'Ошибка при создании и добавлении услуги';
  static const String orderPartCreateAddError =
      'Ошибка при создании и добавлении запчасти';
  static const String orderGetByClientError =
      'Ошибка при получении заказ-нарядов клиента';
  static const String orderGetByCarError =
      'Ошибка при получении заказ-нарядов автомобиля';
  static const String orderGetByStatusError =
      'Ошибка при получении заказ-нарядов по статусу';
  static const String orderSearchError = 'Ошибка при поиске заказ-нарядов';
  static const String orderProvestiError = 'Ошибка при проведении заказ-наряда';
  static const String orderOtmenitError =
      'Ошибка при отмене проведения заказ-наряда';
  static const String orderAddError = 'Ошибка при добавлении заказ-наряда';
  static const String orderStatusUpdateError =
      'Ошибка при обновлении статуса заказ-наряда';
  static const String orderItemAddError =
      'Ошибка при добавлении элемента в заказ-наряд';
  static const String orderItemUpdateError =
      'Ошибка при обновлении элемента заказ-наряда';
  static const String orderItemDeleteError =
      'Ошибка при удалении элемента из заказ-наряда';
  static const String orderNotFoundByUuid =
      'Заказ-наряд с UUID {uuid} не найден';
  static const String orderInserting = 'Добавление заказ-наряда с UUID {uuid}';
  static const String orderUpdating = 'Обновление заказ-наряда с UUID {uuid}';
  static const String orderSoftDeleting =
      'Мягкое удаление заказ-наряда с UUID {uuid}';
  static const String orderRestoring =
      'Восстановление заказ-наряда с UUID {uuid}';
  static const String orderStatusUpdating =
      'Обновление статуса заказ-наряда {uuid} на {status}';
  static const String orderItemInserting =
      'Добавление элемента {itemUuid} в заказ-наряд {orderUuid}';
  static const String orderItemUpdating =
      'Обновление элемента {itemUuid} в заказ-наряде {orderUuid}';
  static const String orderItemDeleting =
      'Удаление элемента {itemUuid} из заказ-наряда {orderUuid}';
  static const String orderCreated = 'Заказ-наряд {uuid} успешно создан';
  static const String orderUpdated = 'Заказ-наряд {uuid} успешно обновлен';
  static const String orderStatusUpdated =
      'Статус заказ-наряда {uuid} обновлен на {status}';
  static const String orderItemAdded =
      'Элемент {itemUuid} добавлен в заказ-наряд {orderUuid}';
  static const String orderItemUpdated =
      'Элемент {itemUuid} обновлен в заказ-наряде {orderUuid}';
  static const String orderItemRemoved =
      'Элемент {itemUuid} удален из заказ-наряда {orderUuid}';
  static const String orderDeleted = 'Заказ-наряд {uuid} помечен как удаленный';
  static const String orderRestored = 'Заказ-наряд {uuid} восстановлен';
  static const String orderServiceCreatedAdd =
      'Услуга {itemUuid} создана и добавлена в заказ-наряд {orderUuid}';
  static const String orderPartCreatedAdd =
      'Запчасть {itemUuid} создана и добавлена в заказ-наряд {orderUuid}';
  static const String orderPosted = 'Заказ-наряд {uuid} проведен';
  static const String orderUnposted = 'Проведение заказ-наряда {uuid} отменено';
  static const String orderItemInvalidData =
      'Некорректные или неполные данные элемента заказа: {itemUuid}'; // Добавлено для _mapDataToComposite
  static const String orderStreamError =
      'Ошибка в потоке данных для заказа {uuid}: {error}'; // Добавлено для _mapStreamDataToComposite
  static const String orderListStreamItemError =
      'Ошибка в потоке заказа {uuid} при просмотре списка'; // Добавлено для watchOrders
  static const String orderSaveError =
      'Ошибка сохранения заказа {uuid}'; // Добавлено для _saveOrder
  static const String orderAddItemError =
      'Ошибка добавления элемента {itemUuid} к заказу {orderUuid}'; // Добавлено для addItemToOrder
  static const String orderUpdateItemError =
      'Ошибка обновления элемента {itemUuid} в заказе {orderUuid}'; // Добавлено для updateOrderItem
  static const String orderRemoveItemError =
      'Ошибка удаления элемента {itemUuid} из заказа {orderUuid}'; // Добавлено для removeItemFromOrder
  static const String orderRestoreAttemptOnNonDeleted =
      'Попытка восстановить не удаленный заказ-наряд {uuid}'; // Добавлено для restoreOrder
  static const String orderPostAttemptOnPosted =
      'Попытка повторно провести заказ-наряд {uuid}'; // Добавлено для provesti
  static const String orderUnpostAttemptOnUnposted =
      'Попытка отменить непроведенный заказ-наряд {uuid}'; // Добавлено для otmenit
  static const String orderDetailsStreamBuilderError =
      'Ошибка в StreamBuilder OrderDetailsScreen'; // <-- Новая константа
  static const String orderDeleteErrorDetails =
      'Ошибка удаления заказ-наряда {uuid}'; // <-- Новая константа
  static const String orderStatusChangeErrorDetails =
      'Ошибка смены статуса заказа {uuid} на {status}'; // <-- Новая константа
  static const String orderAddPartNotImplemented =
      '_addPart не реализован'; // <-- Новая константа
  static const String orderAddServiceNotImplemented =
      '_addService не реализован'; // <-- Новая константа
  static const String orderEditItemNotImplemented =
      '_editItem не реализован для {runtimeType}'; // <-- Новая константа
  static const String orderRemoveItemErrorDetails =
      'Ошибка удаления элемента {itemUuid} из заказа {orderUuid}'; // <-- Новая константа

  // Другие категории сообщений можно добавить по мере необходимости
}

```

## lib\core\utils\logger_config.dart
```dart
import 'package:flutter/foundation.dart'; // Импортируем для kReleaseMode
import 'package:logger/logger.dart';
// import 'package:firebase_crashlytics/firebase_crashlytics.dart'; // Раскомментируйте, если используете Crashlytics

// Определяем уровень по умолчанию в зависимости от режима сборки
final _defaultLogLevel = kReleaseMode ? Level.warning : Level.trace;

// Базовый принтер для консистентности
PrettyPrinter _createPrettyPrinter({
  int methodCount = 1,
  int errorMethodCount = 5,
  int lineLength = 100,
  bool colors = true,
  bool printEmojis = true,
  bool printTime = true, // Включаем время по умолчанию
  DateTimeFormatter dateTimeFormat =
      DateTimeFormat.dateAndTime, // Формат времени
}) {
  return PrettyPrinter(
    methodCount: methodCount,
    errorMethodCount: errorMethodCount,
    lineLength: lineLength,
    colors: colors,
    printEmojis: printEmojis,
    printTime: printTime,
    dateTimeFormat: dateTimeFormat,
    // Можно добавить кастомные цвета и эмодзи, если нужно
  );
}

/// Функция для создания именованного логгера для компонента.
///
/// Пример использования:
/// final _logger = AppLogger('MyClassName');
/// _logger.d('Debug message');
Logger appLogger(String componentName) {
  return Logger(
    printer: _createPrettyPrinter(
        methodCount: 1), // Настройте methodCount по необходимости
    level: _defaultLogLevel,
    // Можно добавить фильтр или вывод, если это глобально для всех компонентных логгеров
    // filter: DevelopmentFilter(),
    // output: MultiOutput([ConsoleOutput(), CrashlyticsOutput()]), // Пример
  );
}

/// Класс для предоставления статических логгеров для общих категорий.
/// Эти логгеры могут быть полезны для логирования событий, не привязанных
/// к конкретному классу, а к более широкой области приложения.
class AppLoggers {
  static final Logger core = Logger(
    printer: _createPrettyPrinter(
        methodCount: 2), // Больше методов для детального лога ядра
    level: _defaultLogLevel,
  );

  static final Logger network = Logger(
    printer: _createPrettyPrinter(methodCount: 1),
    level: kReleaseMode
        ? Level.info
        : Level.debug, // Сеть может быть более многословной в debug
  );

  static final Logger database = Logger(
    printer: _createPrettyPrinter(methodCount: 1),
    level: kReleaseMode ? Level.warning : Level.debug,
  );

  static final Logger ui = Logger(
    printer:
        _createPrettyPrinter(methodCount: 0), // Меньше деталей для UI логов
    level: Level.info, // UI логи обычно менее детальны
  );

  // Логгеры для конкретных модулей/фич, если они нужны как статические
  // В большинстве случаев лучше использовать AppLogger('FeatureNameService')
  static final Logger clients = Logger(
    printer: _createPrettyPrinter(
        methodCount: 1, dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart),
    level: _defaultLogLevel,
  );

  static final Logger vehicles = Logger(
    printer: _createPrettyPrinter(
        methodCount: 1, dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart),
    level: _defaultLogLevel,
  );

  static final Logger suppliers = Logger(
    printer: _createPrettyPrinter(
        methodCount: 1, dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart),
    level: _defaultLogLevel,
  );

  static final Logger orders = Logger(
    printer: _createPrettyPrinter(
        methodCount: 1, dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart),
    level: _defaultLogLevel,
  );

  // Логгер для отправки ошибок в Crashlytics (или другую систему мониторинга)
  // static final Logger crashReporter = Logger(
  //   output: kReleaseMode ? CrashlyticsOutput() : null, // Отправляем только в релизе
  //   // filter: ProductionFilter(), // Можно использовать ProductionFilter, чтобы не дублировать в консоль в релизе, если ConsoleOutput уже есть
  //   level: Level.warning, // Отправляем только предупреждения и выше
  //   printer: _createPrettyPrinter(printTime: true, errorMethodCount: 8), // Больше деталей для ошибок
  // );
}

// Пример кастомного вывода для Crashlytics (нужно реализовать или использовать готовый пакет)
// class CrashlyticsOutput extends LogOutput {
//   @override
//   void output(OutputEvent event) {
//     if (event.level.index >= Level.warning.index) { // Отправляем warning и выше
//       try {
//         final message = event.lines.join('\n');
//         FirebaseCrashlytics.instance.log(message);

//         if (event.origin.error != null) {
//           FirebaseCrashlytics.instance.recordError(
//             event.origin.error,
//             event.origin.stackTrace,
//             reason: 'LOG: $message', // Добавляем сообщение лога как причину
//             fatal: event.level == Level.fatal, // Помечаем как фатальную, если уровень fatal
//           );
//         }
//       } catch (e) {
//         // ignore: avoid_print
//         print('Error sending log to Crashlytics: $e');
//       }
//     }
//   }
// }

```

## lib\core\widgets\language_switcher.dart
```dart
import 'package:flutter/material.dart';
// Импортируем сгенерированный файл slang
import 'package:part_catalog/core/i18n/strings.g.dart';

class LanguageSwitcher extends StatelessWidget {
  const LanguageSwitcher({super.key});

  @override
  Widget build(BuildContext context) {
    // Получаем текущую локаль из Slang (тип AppLocale)
    final currentLocale = LocaleSettings.currentLocale;

    return PopupMenuButton<AppLocale>(
      tooltip: t.core.changeLanguageTooltip, // Используем ключ из Slang
      icon: const Icon(Icons.language),
      itemBuilder: (context) {
        // ----- Переписываем с использованием цикла for -----
        final List<PopupMenuEntry<AppLocale>> menuItems = [];
        // Используем AppLocale.values вместо AppLocaleUtils.supportedLocales
        for (final AppLocale locale in AppLocale.values) {
          final isSelected = locale == currentLocale;
          final localeName = _getLocaleName(locale);

          menuItems.add(
            PopupMenuItem<AppLocale>(
              value: locale,
              child: Row(
                children: [
                  if (isSelected)
                    const Icon(Icons.check, size: 18)
                  else
                    const SizedBox(width: 18), // Пустое место для выравнивания
                  const SizedBox(width: 8),
                  Text(localeName),
                ],
              ),
            ),
          );
        }
        return menuItems;
        // ----- Конец переписывания -----
      },
      onSelected: (AppLocale selectedLocale) {
        // Устанавливаем новую локаль через Slang
        LocaleSettings.setLocale(selectedLocale);
      },
    );
  }

  // Вспомогательный метод для получения имени локали
  String _getLocaleName(AppLocale locale) {
    // Используем switch expression для большей лаконичности
    return switch (locale) {
      AppLocale.ru => 'Русский', // Или t.core.languageNameRu
      AppLocale.en => 'English', // Или t.core.languageNameEn
      // default случай не нужен, так как все значения enum перечислены
    };
  }
}

```

## lib\features\armtek\api\MaterialRestConnection.md
```md
# Armtek API: Правила подключения к REST веб-сервисам

**Общая информация:**

*   **Протокол:** REST
*   **Назначение:** Предоставление возможности информационным системам клиентов (интернет-магазинам, учетным системам) напрямую работать с ЭТП (Электронной Торговой Площадкой) Armtek.
*   **Версия:** 1.1.7 (на момент описания)

**Требования для подключения:**

1.  **Быть клиентом АРМТЕК.**
2.  **Иметь хотя бы один логин для работы в ЭТП.**
3.  **Отправить запрос менеджеру** на подключение к веб-сервисам, указав:
    *   **Логин:** Логин, который будет использоваться для обращений к API. Рекомендуется создать отдельный логин специально для веб-сервисов.
    *   **Список IP-адресов (необязательно):** IP-адреса, с которых будут происходить обращения. Повышает безопасность.

**Аутентификация и безопасность:**

*   **Тип:** Basic Authentication (используется логин и пароль от ЭТП).
*   **Смена пароля:** **Обязательно** после регистрации логина для веб-сервисов необходимо зайти в ЭТП под этим логином и сменить пароль. Иначе API будет возвращать ошибку "Ошибка авторизации пользователя. Необходимо сменить пароль...", и логин может быть автоматически заблокирован.
*   **Статус подключения:** Можно проверить в "Личный кабинет / Структура клиента" в ЭТП.

**Базовые URL:**

*   **Россия:** `http://ws.armtek.ru`
*   **Беларусь:** `http://ws.armtek.by`
*   **Рекомендация:** Использовать URL, соответствующий стране, из которой идет вызов API, для ускорения работы.

**Ограничения:**

*   **Лимит поисковых запросов:** По умолчанию установлено ограничение на общее количество поисковых запросов в сутки (например, 1000). При превышении лимита API вернет соответствующую ошибку.

**Обновления:**

*   Armtek обязуется предварительно оповещать об изменениях, влияющих на поведение веб-сервисов, по e-mail (на адрес, связанный с логином) и на сайте в разделе описания сервисов.

**Доступные сервисы:**

*   Сервисы по работе с фактурами (`/ws_invoice`)
*   Сервисы по работе с заказами (`/ws_order`)
*   Сервисы по пингу системы (`/ws_ping`)
*   Сервисы по работе с отчетностью (`/ws_reports`)
*   Сервисы поиска (`/ws_search`)
*   Сервисы по настройкам пользователя (`/ws_user`)

*(Подробное описание каждого сервиса доступно на соответствующих страницах документации)*

---
```

## lib\features\armtek\api\MaterialRestResponse.md
```md
# Armtek API: Структура ответа веб-сервисов (ver. 1.1.7)

**Общая структура ответа:**

Все веб-сервисы Armtek возвращают ответ в едином формате (JSON по умолчанию или XML), который состоит из трех основных полей:

1.  **`STATUS`** (integer):
    *   Код ответа, соответствующий стандартным HTTP статус кодам.
    *   **Примеры кодов:**
        *   `1xx` (Информационные): `100` (Continue), `101` (Switching Protocols), `102` (Processing)
        *   `2xx` (Успех): `200` (OK - успешное выполнение), `201` (Created), `202` (Accepted), `204` (No Content) и т.д.
        *   `3xx` (Перенаправление): `301` (Moved Permanently), `302` (Found), `304` (Not Modified) и т.д.
        *   `4xx` (Ошибка клиента): `400` (Bad Request), `401` (Unauthorized), `403` (Forbidden), `404` (Not Found), `408` (Request Timeout) и т.д.
        *   `5xx` (Ошибка сервера): `500` (Internal Server Error), `501` (Not Implemented), `502` (Bad Gateway), `503` (Service Unavailable), `504` (Gateway Timeout) и т.д.

2.  **`MESSAGES`** (array):
    *   Список сообщений, связанных с выполнением запроса. Может быть пустым.
    *   Каждое сообщение представляет собой объект со следующими полями:
        *   `TYPE` (string): Тип сообщения:
            *   `A`: Критическая ошибка (Abend)
            *   `E`: Ошибка (Error)
            *   `S`: Успешное сообщение (Success)
            *   `W`: Предупреждение (Warning)
            *   `I`: Информационное сообщение (Information)
        *   `TEXT` (string): Текст сообщения.
        *   `DATE` (string): Дата и время сообщения (формат не указан, предположительно YYYYMMDDHHMMSS или подобный).

3.  **`RESP`** (object/array/null):
    *   Тело ответа, содержащее основные данные, возвращаемые конкретным методом веб-сервиса.
    *   Структура этого поля **индивидуальна для каждого метода** и описана в документации соответствующего сервиса (например, `/ws_search`, `/ws_order` и т.д.).

---
```

## lib\features\armtek\api\MaterialRestRules.md
```md
# Armtek API: Правила работы с веб-сервисами (ver. 1.1.7)

**Общие рекомендации:**

1.  **Ознакомление:** Перед началом работы внимательно изучите настоящие рекомендации и документацию по конкретным веб-сервисам.

---

## 2. Необходимые понятия структуры клиента

*   **Получение структуры:** Полную структуру клиента можно получить через "Сервис получения структуры клиента" в группе "Сервисы по настройкам пользователя".

*   **Сбытовая организация (`VKORG`):**
    *   Определяет текущее место отгрузки товара (откуда товар будет отгружаться по маршруту или забираться при самовывозе).
    *   Характеризуется кодом (`VKORG`) и наименованием (`PROGRAM_NAME`).
    *   В ЭТП отображается в верхнем левом углу.
    *   Список доступных организаций можно получить через "Сервис получения сбытовых организаций клиента".

*   **Клиент:**
    *   Комплексное понятие, объединяющее набор взаимосвязанных объектов, идентифицирующих клиента и правила взаимодействия с Armtek.

*   **Структура клиента (элементы):**
    *   **Головной Клиент (`KUNAG`):**
        *   Код (`KUNAG`) и Наименование (`SNAME`) всей структуры клиента.
        *   В ЭТП отображается в черной панели.
        *   При вызове сервисов **не указывается**, определяется по логину.
    *   **Покупатель (`KUNNR_RG`):**
        *   Организация, ИП или физлицо, осуществляющее покупку и расчеты.
        *   Код (`KUNNR_RG`) и Наименование (`SNAME`).
        *   В ЭТП отображается в черной панели.
        *   Код находится в массиве `RG_TAB`, поле `KUNNR` (в ответе сервиса структуры клиента).
    *   **Грузополучатель (`KUNNR_WE`):**
        *   Подчинен Покупателю.
        *   Код (`KUNNR_WE`) и Наименование (`SNAME`).
        *   Код находится в массиве `WE_TAB`, поле `KUNNR` (в ответе сервиса структуры клиента).
    *   **Адрес доставки или Место получения (`KUNNR_ZA`):**
        *   Подчинен Покупателю. Место, куда доставляется товар (привязан маршрут доставки).
        *   Код (`KUNNR_ZA`) и Наименование (`SNAME`).
        *   Код находится в массиве `ZA_TAB`, поле `KUNNR` (в ответе сервиса структуры клиента).
    *   **Договор (`VBELN`):**
        *   Для ЮЛ и ИП основной документ взаимодействия. Подчинен Покупателю.
        *   Код (`VBELN`).
        *   Код находится в массиве `DOGOVOR_TAB`, поле `VBELN` (в ответе сервиса структуры клиента).
    *   **Контактное лицо (`PARNR`):**
        *   Подчинено Покупателю. Конкретный человек, ответственный за получение товара.
        *   Код (`PARNR`).
        *   Код находится в массиве `CONTACT_TAB`, поле `PARNR` (в ответе сервиса структуры клиента).

---

## 3. Необходимые понятия поиска и заказа

*   **Тип поиска (`QUERY_TYPE` в сервисе поиска):**
    *   Определяет, где система будет искать остатки.
    *   `1`: Поиск только на складе "Места отгрузки" (в ЭТП - зеленый индикатор).
    *   `2`: Поиск на складе "Места отгрузки" + всех доступных складах Armtek (в ЭТП - желтый индикатор).
    *   `3`: Поиск на складе "Места отгрузки" + всех складах Armtek + складах партнеров (в ЭТП - красный индикатор).

*   **Признак Самовывоза (`INCOTERMS` в сервисе создания заказа):**
    *   Сигнализирует, что клиент сам заберет товар.
    *   `1`: Самовывоз.
    *   `0` или пусто: Доставка.
    *   При `INCOTERMS=1` поле `KUNNR_ZA` заполнять **не требуется**.

*   **Артикул (`PIN`):**
    *   Искомый номер детали.

*   **Бренд (`BRAND`):**
    *   Наименование бренда искомой детали.
    *   **Важно:** Использовать только наименование бренда, принятое в Armtek.
    *   Список брендов можно получить через "Сервис получения списка брендов".

*   **Склад (`KEYZAK`):**
    *   Идентифицирует склад, с которого ищутся и заказываются запасы.
    *   В веб-сервисах поиска каждая позиция обязательно имеет `KEYZAK`.
    *   При создании заказов в структуру `ITEMS` **обязательно** транслировать значение `KEYZAK`, полученное при поиске для соответствующей позиции.

---
```

## lib\features\armtek\api\MaterialWsGetOrder2.md
```md
# Armtek API: Сервис Заказов (`/ws_order`) - Метод `getOrder2` (ver. 1.1.7)

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код.
    *   `MESSAGES` (array): Массив сообщений (`TYPE`, `TEXT`, `DATE`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## Метод `getOrder2`

*   **Назначение:** Получение подробной информации по номеру заказа с возможностью получения расшифровки статусов позиций.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_order/getOrder2`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `ORDER` (string, **обязательный**): Номер заказа Armtek.
    *   `STATUS` (integer, *необязательный*): Флаг получения расшифровки статусов (`1` - получать, по умолчанию не передается).
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `HEADER` (object): Заголовок заказа. Поля аналогичны методу `getOrder`.
        *   *... (ORDER, ORDER_DATE, ORDER_TIME, ORDER_TYPE, ORDER_STATUS, KUNRG, KUNRG_TXT, KUNWE, KUNWE_TXT, KUNNR_ZA, ADDRZA, PARNRAP, NAMEAP, BSTKD, KETDT, INCOTERMS, DELIVERY_ADDRESS, DELIVERY_INTERVAL, DELIVERY_METHOD, CONTACT_PERSON, CONTACT_PHONE, BACKORDER, SUBSTITUTION, SUMMA, CURRENCY, ...) ...*
    *   `ITEMS` (array): Массив позиций заказа. Поля аналогичны методу `getOrder`.
        *   *... (POSNR, PIN, BRAND, NAME, KWMENG, KWMENG_CONF, PRICE, SUMMA, NOTE, STATUS, STATUS_DATE, STATUS_TIME, DELIVERY_DATE, DELIVERY_TIME, KEYZAK, ARTSKU, PRICEMAX, DATEMAX, VBELN, POSNR_VL, VBELN_VF, POSNR_VF, ABGRU, ABGRU_TXT, ...) ...*
        *   `KWMENG_ORIG` (number/string): Исходное заказанное количество (может отличаться от `KWMENG` при частичной поставке со складов партнеров).
        *   `REJECTED` (number/string): Общее отклоненное количество, которое не будет поставлено.
        *   `PROCESSING` (number/string): Количество в процессе обработки (на складах партнера и/или Armtek).
        *   `READY` (number/string): Количество, готовое к отгрузке клиенту на складе отгрузки.
        *   `DELIVERED` (number/string): Количество, уже отгруженное клиенту.
        *   `InvoiceNum` (string): Номер фактуры (если отгружено).
        *   `InvoiceDate` (string): Дата фактуры (YYYYMMDD).
        *   `InvoicePos` (string): Номер позиции в фактуре.
        *   `REFUSED` (number/string): Количество, от которого клиент отказался при доставке.
        *   `ReadyToIssue` (number/string): Количество, готовое к выдаче (при самовывозе).
        *   `Issued` (number/string): Количество, выданное клиенту (при самовывозе).
    *   `STATUSES` (array, *только если `STATUS=1`*): Массив объектов с расшифровкой статусов позиций.
        *   `ORDER` (string, max 10): Номер заказа.
        *   `POSNR` (string, max 10): Номер позиции в заказе.
        *   `POSROOT` (string, max 10): Номер корневой позиции (для перезаказанных позиций).
        *   `SUPPLIER` (string, max 10): Код партнера (если позиция со склада партнера).
        *   `SUPPLIER_NAME` (string, max 100): Наименование партнера.
        *   `WERKS` (string, max 4): Код склада Armtek (если статус относится к складу Armtek).
        *   `WERKS_NAME` (string, max 100): Наименование склада Armtek.
        *   `LSEG` (string, max 10): Код сегмента логистики.
        *   `LSEG_ETP` (string, max 100): Описание сегмента логистики (например, "На приемке", "В пути на склад отгрузки", "Ожидаем прибытия от поставщика").
        *   `DATECR` (string, max 14): Дата/время создания записи статуса (ГГГГММДДЧЧММСС).
        *   `DATECH` (string, max 14): Дата/время изменения записи статуса (ГГГГММДДЧЧММСС).
        *   `DATEDEL` (string, max 14): Дата/время ожидаемой поставки (ГГГГММДДЧЧММСС).
        *   `DATEDELNEW` (string, max 14): Дата/время последнего события по товару (ГГГГММДДЧЧММСС).
        *   `SUBSTATUS` (string, max 10): Субстатус позиции:
            *   `WayQuan`: Товар в пути между пунктами логистической цепочки Armtek.
            *   `Planned`: Запланировано к закупке у партнера.
            *   `Waiting`: Ожидание подтверждения от партнера.
            *   `Confirmed`: Партнер подтвердил готовность отгрузить.
            *   `Shipped`: Партнер отгрузил товар в адрес Armtek.
        *   `KWMENG` (number/string): Количество в данном субстатусе.
    *   `ABGRU_ITEMS` (array): Массив объектов с расшифровкой причин отказа (поля `ABGRU`, `TEXT`). Поля аналогичны методу `getOrder`.

---
```

## lib\features\armtek\api\ServiceInvoice.md
```md
# Armtek API: Сервис Фактур (`/ws_invoice`) - Формализованная информация (на основе реального ответа)

**Примечание:** Эта документация основана на фактическом ответе API, полученном через Postman, и может отличаться от официальной документации на сайте `ws.armtek.ru`.

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код (например, `200`).
    *   `MESSAGES` (array): Массив сообщений (в примере пустой `[]`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `getInvoice`

*   **Назначение:** Получение подробной информации по номеру фактуры.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_invoice/getInvoice`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `INVOICE` (string, *обязательный, если `ZZSF` пуст*): Номер фактуры (VBELNF).
    *   `ZZSF` (string, *обязательный, если `INVOICE` пуст*): Номер УПД/товчека.
    *   `REFLAG` (integer, *необязательный*): Флаг для получения данных для возврата (значение `1`).
    *   `NOCOLLAPS` (integer, *необязательный*): Флаг разделения по партиям (значение `1`).
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object - на основе примера):**
    *   `HEADER` (object): Заголовок фактуры.
        *   `INVOICE` (string): Номер Фактуры (например, `"9022197646"`).
        *   `INVDATE` (string): Дата фактуры (YYYYMMDD, например, `"20250422"`).
        *   `KUNWE` (string): Номер грузополучателя (например, `"0043247459"`).
        *   `KUNZA` (string): Номер адреса доставки (например, `"0043247459"`).
        *   `PARNRZP` (string): Контактное лицо (например, `"0000585586"`).
        *   `NUMDOG` (string): Номер договора (например, `"-"`).
        *   `UPD` (string): Номер УПД (например, `"ХП0071935"`).
        *   `TORG12` (string): Номер ТОРГ12 (в примере пустая строка `""`).
        *   `PAYMENT` (string): Вид оплаты (например, `"безналичный"`).
        *   `INCOTERMS_TXT` (string): Вид доставки (например, `"Доставка"`).
        *   `SUMMA` (string): Общая сумма документа (например, `"3650"`).
        *   `CURRENCY` (string): Валюта документа (например, `"RUB"`).
        *   `ERDAT` (string): Дата и время создания (YYYYMMDDHHMMSS, например, `"20250422041459"`).
        *   `VSTELT` (string): Место отгрузки (например, `"Краснодар"`).
        *   `MAX_RET_SUM` (string): Максимальная сумма возврата (в примере пустая строка `""`).
    *   `ITEMS` (array): Массив позиций фактуры.
        *   `POSNR` (integer): Номер позиции (например, `1`).
        *   `MATNR` (string): Код материала Armtek (например, `"5100354_SX"`).
        *   `PIN` (string): Артикул (например, `"51-00354-SX"`).
        *   `BRAND` (string): Бренд (например, `"STELLOX"`).
        *   `GTD` (string): Номер ГТД (например, `"10317120/160924/5046374"`).
        *   `NAME` (string): Наименование (например, `"наконечник рулевой левый!\\ Mitsubishi Pajero V63/65/Montero 99>"`).
        *   `AMOUNT` (string): Количество (например, `"1"`).
        *   `WEIGHT` (string): Вес брутто позиции (например, `"0.953"`).
        *   `VOLUM` (string): Объем позиции (например, `"1.98"`).
        *   `SUMMA` (string): Сумма по позиции без НДС (например, `"960"`).
        *   `PRICE` (string): Цена за единицу без НДС (например, `"960"`).
        *   `RETMG` (string): Доступное количество для возврата (например, `"0"`).
        *   `NORET` (string): Признак невозможности возврата (в примере пустая строка `""`).
        *   `MINBM` (string): Минимальное количество для заказа (например, `"1"`).
        *   `RDPRF` (string): Кратность (например, `"1"`).
        *   `SCAL` (string): Шкала цен (в примере пустая строка `""`).
        *   `DRE` (string): Срок возврата в днях (например, `"30"`).
        *   `ORDER` (string): Номер заказа Armtek (например, `"459793659"`).
        *   `ORDER_POS` (string): Номер позиции в заказе Armtek (например, `"10"`).
        *   `ORDER_NOTE` (string): Комментарий к позиции заказа (например, `"mitsu l200"`).
        *   `COUNTRY` (string): Страна происхождения (например, `"(TR, 792) Турция"`).
        *   `VatRate` (string): Ставка НДС (например, `"20.00"`).
        *   `VatAmount` (string): Сумма НДС по позиции (например, `"160.00"`).
        *   `Ean` (string): Штрих-код EAN (например, `"4057276185203"`).
        *   `Tnved` (string): Код ТН ВЭД (например, `"8708949909"`).
    *   `CASH` (string): Способы возврата денег (в примере пустая строка `""`, вероятно, появляется при `REFLAG=1`).
    *   `AUGRU_OUTPUT` (string): Причины возврата (в примере пустая строка `""`, вероятно, появляется при `REFLAG=1`).

---

## 2. Метод `createReturnInvoice`

*   **Назначение:** Создание возврата по фактуре.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_invoice/createReturnInvoice`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация (из `getInvoice`).
    *   `KUNRG` (string, **обязательный**): Покупатель (из `getInvoice`).
    *   `VBELNF` (string, **обязательный**): Номер фактуры (из `getInvoice`, поле `INVOICE` в JSON).
    *   `AUGRU` (string, **обязательный**): Код причины возврата (из `getInvoice`, поле `AUGRU_OUTPUT` при `REFLAG=1`).
    *   `RESOLUTION` (string, *необязательный*): Описание причины возврата (текст).
    *   `CASH_BACK` (string, *необязательный*): Код способа возврата денег (из `getInvoice`, поле `CASH` при `REFLAG=1`).
    *   `KUNWE` (string, *необязательный*): Грузополучатель (из `getInvoice`, поле `KUNWE` в JSON).
    *   `KUNNR_ZA` / `KUNZA` (string, *необязательный*): Адрес доставки/Пункт выдачи (из `getInvoice`, поле `KUNZA` в JSON).
    *   `INVDATE` (string, *необязательный*): Дата возврата (формат `YYYYMMDD`).
    *   `PARNRZP` (string, *необязательный*): Контактное лицо (из `getInvoice`, поле `PARNRZP` в JSON).
    *   `POSITION_INPUT` (array, **обязательный**): Массив объектов с позициями для возврата.
        *   `POSNR` (string/integer, **обязательный**): Номер позиции из фактуры (из `getInvoice`, поле `POSNR` в JSON).
        *   `MATNR` (string, **обязательный**): Код материала из фактуры (из `getInvoice`, поле `MATNR` в JSON).
        *   `VRKME` (string, **обязательный**): Единица измерения из фактуры (отсутствует в примере JSON, брать из документации или уточнять).
        *   `KWMENG` (number/string, **обязательный**): Количество возвращаемого материала (не должно превышать `RETMG` из `getInvoice`).
*   **Структура успешного ответа (`RESP`, object):**
    *   `VBELNR` (string): Номер созданного документа возврата.

---
```

## lib\features\armtek\api\ServiceOrder.md
```md
# Armtek API: Сервис Заказов (`/ws_order`) - Формализованная информация

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код.
    *   `MESSAGES` (array): Массив сообщений (`TYPE`, `TEXT`, `DATE`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `createOrder`

*   **Назначение:** Создание нового заказа.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_order/createOrder`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `KUNWE` (string, *необязательный*): Номер грузополучателя (KUNNR\_WE).
    *   `KONDA` (string, *необязательный*): Ценовая группа клиента.
    *   `BSTKD` (string, *необязательный*): Номер заказа клиента.
    *   `KETDT` (string, *необязательный*): Желаемая дата поставки (формат `YYYYMMDD`).
    *   `INCOTERMS` (string, *необязательный*): Признак самовывоза (`1` - самовывоз, `0` или пусто - доставка).
    *   `DELIVERY_ADDRESS` (string, *необязательный*): Адрес доставки (текст).
    *   `DELIVERY_INTERVAL` (string, *необязательный*): Интервал доставки (текст).
    *   `DELIVERY_METHOD` (string, *необязательный*): Способ доставки (текст).
    *   `CONTACT_PERSON` (string, *необязательный*): Контактное лицо (текст).
    *   `CONTACT_PHONE` (string, *необязательный*): Телефон контактного лица (текст).
    *   `BACKORDER` (string, *необязательный*): Признак разрешения довоза (`1` - разрешен, `0` или пусто - запрещен).
    *   `SUBSTITUTION` (string, *необязательный*): Признак разрешения замен (`1` - разрешен, `0` или пусто - запрещен).
    *   `CHECK_LEVEL` (integer, *необязательный*, по умолчанию `1`): Уровень проверки остатков (`1` - только основной склад, `2` - все склады Armtek, `3` - все склады Armtek + партнеры).
    *   `ITEMS` (array, **обязательный**): Массив объектов с позициями заказа.
        *   `PIN` (string, **обязательный**): Артикул.
        *   `BRAND` (string, **обязательный**): Наименование бренда.
        *   `KEYZAK` (string, *необязательный*): Код склада Armtek (из ответа сервиса поиска). **Рекомендуется заполнять.**
        *   `KWMENG` (number/string, **обязательный**): Количество.
        *   `PRICEMAX` (string, *необязательный*): Максимальная цена.
        *   `DATEMAX` (string, *необязательный*): Максимальная дата поставки (формат `YYYYMMDD`).
        *   `NOTE` (string, *необязательный*): Комментарий к позиции.
        *   `ARTSKU` (string, *необязательный*): Код материала Armtek (MATNR).
        *   `NAME` (string, *необязательный*): Наименование товара.
*   **Структура успешного ответа (`RESP`, object):**
    *   `ORDER` (string): Номер созданного заказа Armtek.

---

## 2. Метод `createTestOrder`

*   **Назначение:** Создание тестового заказа (без реального размещения).
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_order/createTestOrder`
*   **Параметры запроса (Body - JSON или form-urlencoded):** Аналогичны `createOrder`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `ORDER` (string): Номер созданного тестового заказа Armtek.

---

## 3. Метод `getOrder`

*   **Назначение:** Получение подробной информации по номеру заказа.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_order/getOrder`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `ORDER` (string, **обязательный**): Номер заказа Armtek.
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `HEADER` (object): Заголовок заказа.
        *   `ORDER` (string): Номер заказа Armtek.
        *   `ORDER_DATE` (string): Дата создания заказа (YYYYMMDD).
        *   `ORDER_TIME` (string): Время создания заказа (HHMMSS).
        *   `ORDER_TYPE` (string): Тип заказа (например, "Отгрузка с ОСНОВНЫХ складов АРМТЕК").
        *   `ORDER_STATUS` (string): Статус заказа (например, "Создан", "В работе", "Закрыт", "Отклонен").
        *   `KUNRG` (string): Номер покупателя.
        *   `KUNRG_TXT` (string): Наименование покупателя.
        *   `KUNWE` (string): Номер грузополучателя.
        *   `KUNWE_TXT` (string): Наименование грузополучателя.
        *   `KUNNR_ZA` (string): Номер адреса доставки/пункта выдачи.
        *   `ADDRZA` (string): Адрес доставки (текст).
        *   `PARNRAP` (string): Код создателя заказа.
        *   `NAMEAP` (string): Наименование создателя заказа.
        *   `BSTKD` (string): Номер заказа клиента.
        *   `KETDT` (string): Желаемая дата поставки (YYYYMMDD).
        *   `INCOTERMS` (string): Признак самовывоза (`1` или `0`).
        *   `DELIVERY_ADDRESS` (string): Адрес доставки (текст).
        *   `DELIVERY_INTERVAL` (string): Интервал доставки (текст).
        *   `DELIVERY_METHOD` (string): Способ доставки (текст).
        *   `CONTACT_PERSON` (string): Контактное лицо (текст).
        *   `CONTACT_PHONE` (string): Телефон контактного лица (текст).
        *   `BACKORDER` (string): Признак разрешения довоза (`1` или `0`).
        *   `SUBSTITUTION` (string): Признак разрешения замен (`1` или `0`).
        *   `SUMMA` (number/string): Общая сумма заказа.
        *   `CURRENCY` (string): Валюта заказа.
    *   `ITEMS` (array): Массив позиций заказа.
        *   `POSNR` (string): Номер позиции.
        *   `PIN` (string): Артикул.
        *   `BRAND` (string): Бренд.
        *   `NAME` (string): Наименование.
        *   `KWMENG` (number/string): Количество заказанное.
        *   `KWMENG_CONF` (number/string): Количество подтвержденное.
        *   `PRICE` (number/string): Цена за единицу.
        *   `SUMMA` (number/string): Сумма по позиции.
        *   `NOTE` (string): Комментарий к позиции.
        *   `STATUS` (string): Статус позиции.
        *   `STATUS_DATE` (string): Дата статуса позиции (YYYYMMDD).
        *   `STATUS_TIME` (string): Время статуса позиции (HHMMSS).
        *   `DELIVERY_DATE` (string): Ожидаемая дата поставки (YYYYMMDD).
        *   `DELIVERY_TIME` (string): Ожидаемое время поставки (HHMMSS).
        *   `KEYZAK` (string): Код склада Armtek.
        *   `ARTSKU` (string): Код материала Armtek (MATNR).
        *   `PRICEMAX` (string): Максимальная цена.
        *   `DATEMAX` (string): Максимальная дата поставки (YYYYMMDD).
        *   `VBELN` (string): Номер документа отгрузки (если есть).
        *   `POSNR_VL` (string): Номер позиции в документе отгрузки.
        *   `VBELN_VF` (string): Номер документа фактуры (если есть).
        *   `POSNR_VF` (string): Номер позиции в документе фактуры.
        *   `ABGRU` (string): Причина отказа.
        *   `ABGRU_TXT` (string): Описание причины отказа.

---

## 4. Метод `getOrder2`

*   **Назначение:** Получение подробной информации по номеру заказа (версия 2, с расшифровкой статусов).
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_order/getOrder2`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `ORDER` (string, **обязательный**): Номер заказа Armtek.
    *   `STATUS` (integer, *необязательный*): Флаг получения расшифровки статусов (`1` - получать).
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object):** Аналогична `getOrder`, но дополнительно содержит:
    *   `STATUSES` (array, *только если `STATUS=1`*): Массив объектов с расшифровкой статусов позиций.
        *   `POSNR` (string): Номер позиции.
        *   `STATUS` (string): Код статуса.
        *   `STATUS_DATE` (string): Дата статуса (YYYYMMDD).
        *   `STATUS_TIME` (string): Время статуса (HHMMSS).
        *   `STATUS_TXT` (string): Описание статуса.
        *   `KWMENG` (number/string): Количество в этом статусе.
    *   `ABGRU_ITEMS` (array): Массив объектов с расшифровкой причин отказа.
        *   `ABGRU` (string): Код причины отказа.
        *   `TEXT` (string): Описание причины отказа.

---

## 5. Метод `getRefund`

*   **Назначение:** Получение подробной информации по номеру возврата.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_order/getRefund`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `RETURN` (string, **обязательный**): Номер документа возврата.
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object):** Аналогична `getOrder`, но специфична для документа возврата (требует уточнения структуры по реальному ответу или более детальной документации).

---

## 6. Метод `editOrder`

*   **Назначение:** Редактирование существующего заказа (изменение количества, отмена позиций).
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_order/editOrder`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `ORDER` (string, **обязательный**): Номер заказа Armtek для редактирования.
    *   `ITEMS` (array, **обязательный**): Массив объектов с позициями для редактирования.
        *   `POSNR` (string, **обязательный**): Номер позиции в заказе.
        *   `KWMENG` (number/string, **обязательный**): Новое количество. Если `0`, позиция отменяется.
        *   `ABGRU` (string, *необязательный*): Код причины отказа (обязателен при `KWMENG=0`). Коды берутся из `getOrder2` -> `ABGRU_ITEMS`.
        *   `NOTE` (string, *необязательный*): Комментарий к изменению.
*   **Структура успешного ответа (`RESP`, object):**
    *   `ORDER` (string): Номер отредактированного заказа Armtek (обычно тот же, что и в запросе).

---
```

## lib\features\armtek\api\ServicePing.md
```md
# Armtek API: Сервис Пинга Системы (`/ws_ping`) - Формализованная информация

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Не требуется (судя по отсутствию упоминания и типу сервиса).
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код (например, `200`).
    *   `MESSAGES` (array): Массив сообщений (обычно пустой для пинга).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `index`

*   **Назначение:** Проверка доступности и работоспособности сервиса.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_ping/index`
*   **Параметры запроса (Query):**
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `IP` (string, max 16): IP адрес клиента, с которого пришел запрос.
    *   `TIME` (string, max 20): Время выполнения скрипта на сервере (вероятно, в секундах с микросекундами).

---
```

## lib\features\armtek\api\ServiceReports.md
```md
# Armtek API: Сервис Отчетов (`/ws_reports`) - Формализованная информация

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код.
    *   `MESSAGES` (array): Массив сообщений (`TYPE`, `TEXT`, `DATE`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `getOrderReportByDate`

*   **Назначение:** Получение отчета по заказам (заголовкам) за интервал времени.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_reports/getOrderReportByDate`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, **обязательный**): Сбытовая организация.
    *   `KUNRG` (string, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `SDLDATE` (string, **обязательный**): Дата начала периода (формат `YYYYMMDD`).
    *   `EDLDATE` (string, **обязательный**): Дата окончания периода (формат `YYYYMMDD`).
    *   `TYPEZK_SALE` (string, *необязательный*, '0' или '1'): Включить заказы продаж (по умолчанию `1` - да).
    *   `TYPEZK_RETN` (string, *необязательный*, '0' или '1'): Включить возвраты и количественные разницы (по умолчанию `1` - да).
    *   `KURR_LOGIN` (string, *необязательный*, '0' или '1'): Фильтровать заказы по текущему логину (по умолчанию `0` - нет).
*   **Структура успешного ответа (`RESP`, object):**
    *   `DATA` (array): Массив объектов с данными по заголовкам заказов. Поля аналогичны `HEADER` из ответа `getOrder` сервиса `/ws_order`:
        *   `ORDER` (string): Номер заказа Armtek.
        *   `ORDER_TYPE` (string): Тип заказа.
        *   `ORDER_DATE` (string): Дата создания заказа (YYYYMMDD).
        *   `ORDER_TIME` (string): Время создания заказа (HHMMSS).
        *   `ORDER_STATUS` (string): Статус заказа.
        *   `KUNRG` (string): Номер покупателя.
        *   `KUNRG_TXT` (string): Наименование покупателя.
        *   `KUNWE` (string): Номер грузополучателя.
        *   `KUNWE_TXT` (string): Наименование грузополучателя.
        *   `KUNNR_ZA` (string): Номер адреса доставки/пункта выдачи.
        *   `ADDRZA` (string): Адрес доставки (текст).
        *   `PARNRAP` (string): Код создателя заказа.
        *   `NAMEAP` (string): Наименование создателя заказа.
        *   `BSTKD` (string): Номер заказа клиента.
        *   `KETDT` (string): Желаемая дата поставки (YYYYMMDD).
        *   `INCOTERMS` (string): Признак самовывоза (`1` или `0`).
        *   `DELIVERY_ADDRESS` (string): Адрес доставки (текст).
        *   `DELIVERY_INTERVAL` (string): Интервал доставки (текст).
        *   `DELIVERY_METHOD` (string): Способ доставки (текст).
        *   `CONTACT_PERSON` (string): Контактное лицо (текст).
        *   `CONTACT_PHONE` (string): Телефон контактного лица (текст).
        *   `BACKORDER` (string): Признак разрешения довоза (`1` или `0`).
        *   `SUBSTITUTION` (string): Признак разрешения замен (`1` или `0`).
        *   `SUMMA` (number/string): Общая сумма заказа.
        *   `CURRENCY` (string): Валюта заказа.
        *   *...и другие поля заголовка заказа.*
    *   `INF` (array): Массив с суммарной информацией по выборке.
        *   `SUM` (string/number): Общая сумма по заказам в выборке.
        *   `CURRENCY` (string): Валюта.
        *   `NUM` (string/integer): Количество уникальных номеров заказов в выборке.

---

## 2. Метод `getOrderPositionsReportByDate`

*   **Назначение:** Получение отчета по позициям заказов за интервал времени.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_reports/getOrderPositionsReportByDate`
*   **Параметры запроса (Body - JSON или form-urlencoded):** Аналогичны `getOrderReportByDate`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `DATA` (array): Массив объектов с данными по позициям заказов. Поля аналогичны `ITEMS` из ответа `getOrder` сервиса `/ws_order`:
        *   `ORDER` (string): Номер заказа Armtek.
        *   `POSNR` (string): Номер позиции.
        *   `PIN` (string): Артикул.
        *   `BRAND` (string): Бренд.
        *   `NAME` (string): Наименование.
        *   `KWMENG` (number/string): Количество заказанное.
        *   `KWMENG_CONF` (number/string): Количество подтвержденное.
        *   `PRICE` (number/string): Цена за единицу.
        *   `SUMMA` (number/string): Сумма по позиции.
        *   `NOTE` (string): Комментарий к позиции.
        *   `STATUS` (string): Статус позиции.
        *   `STATUS_DATE` (string): Дата статуса позиции (YYYYMMDD).
        *   `STATUS_TIME` (string): Время статуса позиции (HHMMSS).
        *   `DELIVERY_DATE` (string): Ожидаемая дата поставки (YYYYMMDD).
        *   `DELIVERY_TIME` (string): Ожидаемое время поставки (HHMMSS).
        *   `KEYZAK` (string): Код склада Armtek.
        *   `ARTSKU` (string): Код материала Armtek (MATNR).
        *   `PRICEMAX` (string): Максимальная цена.
        *   `DATEMAX` (string): Максимальная дата поставки (YYYYMMDD).
        *   `VBELN` (string): Номер документа отгрузки (если есть).
        *   `POSNR_VL` (string): Номер позиции в документе отгрузки.
        *   `VBELN_VF` (string): Номер документа фактуры (если есть).
        *   `POSNR_VF` (string): Номер позиции в документе фактуры.
        *   `ABGRU` (string): Причина отказа.
        *   `ABGRU_TXT` (string): Описание причины отказа.
        *   *...и другие поля позиции заказа.*
    *   `INF` (array): Массив с суммарной информацией по выборке (аналогично `getOrderReportByDate`).

---

## 3. Метод `getOrderPositionsReportByDate2`

*   **Назначение:** Получение отчета по позициям заказов за интервал времени (версия 2).
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_reports/getOrderPositionsReportByDate2`
*   **Параметры запроса (Body - JSON или form-urlencoded):** Аналогичны `getOrderReportByDate`.
*   **Структура успешного ответа (`RESP`, object):**
    *   `DATA` (array): Массив объектов с данными по позициям заказов. Поля аналогичны `getOrderPositionsReportByDate`, возможно, с добавлением поля `STATCRED` (Блокировано по кредиту).
        *   *...все поля из `getOrderPositionsReportByDate`...*
        *   `STATCRED` (string): Статус блокировки по кредиту.
    *   `INF` (array): Массив с суммарной информацией по выборке (аналогично `getOrderReportByDate`).

---
```

## lib\features\armtek\api\ServiceSearch.md
```md
# Armtek API: Сервис Поиска (`/ws_search`) - Формализованная информация

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код.
    *   `MESSAGES` (array): Массив сообщений (`TYPE`, `TEXT`, `DATE`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `assortment_search`

*   **Назначение:** Поиск по ассортименту (вероятно, для проверки наличия в каталоге без цен и остатков).
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_search/assortment_search`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, max 4, **обязательный**): Сбытовая организация. (Настройка в "Сервис получения сбытовых организаций клиента").
    *   `KUNNR_RG` (string, max 10, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `KUNNR_ZA` (string, max 10, *необязательный*): Адрес доставки или Пункт выдачи для самовывоза. (Значения из "Сервис получения структуры клиента").
    *   `PIN` (string, max <40, **обязательный**): Номер артикула (строка поиска).
    *   `BRAND` (string, max 40, *необязательный*): Наименование бренда. (Рекомендуется заполнять).
    *   `NAME` (string, max 100, *необязательный*): Наименование.
    *   `PROGRAM` (string, max 2, *необязательный*): Легковая (`LP`), Грузовая (`GP`) программа или пусто.
    *   `QUERY_TYPE` (string, max 1, *необязательный*): Тип поиска (`1`, `2` или пусто). (Если `BRAND` пуст, рекомендуется `1`).
*   **Структура успешного ответа (`RESP`, array - предположительно):**
    *   Массив объектов, представляющих найденные в ассортименте позиции. Точная структура полей не указана в предоставленном контексте, но вероятно включает `PIN`, `BRAND`, `NAME`.

---

## 2. Метод `search`

*   **Назначение:** Поиск предложений (цены, остатки, сроки) по артикулу.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_search/search`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, max 4, **обязательный**): Сбытовая организация.
    *   `KUNNR_RG` (string, max 10, **обязательный**): Номер покупателя (KUNNR\_RG).
    *   `PIN` (string, max <40, **обязательный**): Номер артикула (строка поиска).
    *   `BRAND` (string, max 40, *необязательный*): Наименование бренда. (Рекомендуется заполнять. Влияет на поиск аналогов при `QUERY_TYPE=2`).
    *   `QUERY_TYPE` (string, max 1, *необязательный*): Тип поиска (`1`, `2` или пусто). (Вероятно, `1` - только запрошенный артикул, `2` - артикул и аналоги).
    *   *Примечание: Могут существовать другие параметры, не указанные в предоставленном контексте.*
*   **Структура успешного ответа (`RESP`, array - предположительно):**
    *   Массив объектов, представляющих найденные предложения по запчастям. Каждый объект может содержать поля (на основе контекста):
        *   `PIN` (string): Артикул.
        *   `BRAND` (string): Бренд.
        *   `NAME` (string): Наименование.
        *   `PRICE` (number/string): Цена.
        *   `RVALUE` (string, max 20): Доступное количество.
        *   `DELIVERY_DAY` (number/string): Срок поставки в днях.
        *   `KEYZAK` (string, max 10): Код склада Armtek (используется для заказа).
        *   `PARNR` (string, max 20): Код склада партнера.
        *   `RETDAYS` (number, max 4): Количество дней на возврат.
        *   `RDPRF` (string, max 10): Кратность (минимальное количество для заказа).
        *   *...и другие поля, такие как вес, объем, страна происхождения, информация о производителе и т.д.*

---
```

## lib\features\armtek\api\ServiceUser.md
```md
# Armtek API: Сервис Настроек Пользователя (`/ws_user`) - Формализованная информация

**Общие параметры:**

*   **Базовый URL:** `http://ws.armtek.ru` (или другой региональный)
*   **Аутентификация:** Basic Authentication (логин/пароль)
*   **Формат ответа:** Управляется query-параметром `format` (`json` или `xml`, по умолчанию `json`).
*   **Базовая структура ответа:**
    *   `STATUS` (integer): HTTP статус код.
    *   `MESSAGES` (array): Массив сообщений (`TYPE`, `TEXT`, `DATE`).
    *   `RESP` (object/array/null): Тело ответа, специфичное для метода.

---

## 1. Метод `getUserVkorgList`

*   **Назначение:** Получение списка доступных сбытовых организаций для текущего пользователя.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_user/getUserVkorgList`
*   **Параметры запроса (Query):**
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, array):**
    *   Массив объектов, каждый из которых представляет сбытовую организацию:
        *   `VKORG` (string, max 4): Код сбытовой организации.
        *   `PROGRAM_NAME` (string, max 100): Наименование программы (например, "Легковая", "Грузовая").

---

## 2. Метод `getUserInfo`

*   **Назначение:** Получение подробной информации о структуре клиента (покупатели, адреса, контакты) и данных FTP.
*   **HTTP Метод:** `POST`
*   **Путь:** `/ws_user/getUserInfo`
*   **Параметры запроса (Body - JSON или form-urlencoded):**
    *   `VKORG` (string, max 4, **обязательный**): Сбытовая организация (код из `getUserVkorgList`).
    *   `STRUCTURE` (string, '0' или '1', *необязательный*, по умолчанию '1'): Флаг получения структуры клиента (`1` - получить, `0` - не получать).
    *   `FTPDATA` (string, '0' или '1', *необязательный*, по умолчанию '1'): Флаг получения данных FTP (`1` - получить, `0` - не получать).
*   **Структура успешного ответа (`RESP`, object):**
    *   `STRUCTURE` (array, *если `STRUCTURE=1`*): Массив объектов, представляющих структуру клиента (покупатели/грузополучатели).
        *   `KUNNR` (string, max 10): Номер клиента (покупателя KUNNR_RG или грузополучателя KUNNR_WE).
        *   `NAME1` (string, max 35): Наименование 1.
        *   `NAME2` (string, max 35): Наименование 2.
        *   `ORT01` (string, max 35): Город.
        *   `ORT02` (string, max 35): Район.
        *   `PSTLZ` (string, max 10): Почтовый индекс.
        *   `REGIO` (string, max 3): Регион (код).
        *   `SORTL` (string, max 20): Понятие поиска.
        *   `STRAS` (string, max 60): Улица и номер дома.
        *   `TELF1` (string, max 30): Номер телефона 1.
        *   `TELF2` (string, max 30): Номер телефона 2.
        *   `TELFX` (string, max 30): Номер факса.
        *   `ADDRESS` (string, max 255): Полный адрес.
        *   `INN` (string, max 20): ИНН.
        *   `KPP` (string, max 9): КПП.
        *   `OKPO` (string, max 10): ОКПО.
        *   `OKVED` (string, max 100): ОКВЭД.
        *   `EMAIL` (string, max 241): Адрес электронной почты.
        *   `WWW` (string, max 100): Адрес сайта.
        *   `TYPE` (string, max 1): Тип клиента (`1` - ЮЛ, `2` - ФЛ, `3` - ИП).
        *   `CONTACTS` (array): Массив контактных лиц.
            *   `PARNR` (string, max 10): Код контактного лица.
            *   `DEFAULT` (string, max 1): Признак установки по умолчанию (`X` - да).
            *   `FNAME` (string, max 100): Полное наименование (Имя).
            *   `LNAME` (string, max 100): Фамилия.
            *   `MNAME` (string, max 100): Отчество.
            *   `PHONE` (string, max 30): Телефон.
            *   `EMAIL` (string, max 241): Email.
            *   `POSITION` (string, max 100): Должность.
        *   `DELIVERY_ADDRESSES` (array): Массив адресов доставки (KUNNR_ZA).
            *   `KUNNR` (string, max 10): Код адреса доставки.
            *   `DEFAULT` (string, max 1): Признак установки по умолчанию (`X` - да).
            *   `NAME1` (string, max 35): Наименование 1.
            *   `ORT01` (string, max 35): Город.
            *   `STRAS` (string, max 60): Улица и номер дома.
            *   `ADDRESS` (string, max 255): Полный адрес.
    *   `FTPDATA` (object, *если `FTPDATA=1`*): Объект с данными FTP.
        *   `FTP_HOST` (string, max 100): Хост FTP.
        *   `FTP_USER` (string, max 100): Пользователь FTP.
        *   `FTP_PASS` (string, max 100): Пароль FTP.
        *   `FTP_DIR` (string, max 100): Директория FTP.

---

## 3. Метод `getBrandList`

*   **Назначение:** Получение полного списка брендов, доступных в системе.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_user/getBrandList`
*   **Параметры запроса (Query):**
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, array):**
    *   Массив объектов, каждый из которых представляет бренд:
        *   `BRAND` (string, max 40): Наименование бренда.

---

## 4. Метод `getStoreList`

*   **Назначение:** Получение списка складов, доступных для указанной сбытовой организации.
*   **HTTP Метод:** `GET`
*   **Путь:** `/ws_user/getStoreList`
*   **Параметры запроса (Query):**
    *   `VKORG` (string, max 4, **обязательный**): Сбытовая организация (код из `getUserVkorgList`).
    *   `format` (string, *необязательный*): `json` или `xml`.
*   **Структура успешного ответа (`RESP`, array):**
    *   Массив объектов, каждый из которых представляет склад:
        *   `KEYZAK` (string, max 10): Код склада (используется при поиске и заказе).
        *   `SKLCODE` (string, max 10): Технический идентификатор склада.
        *   `NAME` (string, max 100): Наименование склада.
        *   `ADDRESS` (string, max 255): Адрес склада.
        *   `PHONE` (string, max 30): Телефон склада.
        *   `WORKTIME` (string, max 100): Время работы склада.
        *   `GPS` (string, max 100): Координаты GPS.

---
```

## lib\features\core\base_item_type.dart
```dart
/// Базовый тип для всех типов элементов табличных частей (enum).
enum BaseItemType {
  part('part'),
  service('service'),
  material('material'),
  workStage('workStage'),
  comment('comment'),
  attachment('attachment');
  // Добавляйте другие типы по мере необходимости

  final String type;
  const BaseItemType(this.type);

  /// Получить BaseItemType по строковому идентификатору
  static BaseItemType fromType(String type) {
    return BaseItemType.values.firstWhere(
      (e) => e.type == type,
      orElse: () => throw ArgumentError('Неизвестный тип BaseItemType: $type'),
    );
  }

  @override
  String toString() => type;
}

```

## lib\features\core\document_item_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'document_item_specific_data.freezed.dart';
part 'document_item_specific_data.g.dart';

/// Данные, специфичные для элементов документов
@freezed
abstract class DocumentItemSpecificData with _$DocumentItemSpecificData {
  const factory DocumentItemSpecificData({
    double? price,
    double? quantity,
    @Default(false) bool isCompleted,
  }) = _DocumentItemSpecificData;

  factory DocumentItemSpecificData.fromJson(Map<String, dynamic> json) =>
      _$DocumentItemSpecificDataFromJson(json);
}

```

## lib\features\core\document_item_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'document_item_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$DocumentItemSpecificData {
  double? get price;
  double? get quantity;
  bool get isCompleted;

  /// Create a copy of DocumentItemSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DocumentItemSpecificDataCopyWith<DocumentItemSpecificData> get copyWith =>
      _$DocumentItemSpecificDataCopyWithImpl<DocumentItemSpecificData>(
          this as DocumentItemSpecificData, _$identity);

  /// Serializes this DocumentItemSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DocumentItemSpecificData &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.isCompleted, isCompleted) ||
                other.isCompleted == isCompleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, price, quantity, isCompleted);

  @override
  String toString() {
    return 'DocumentItemSpecificData(price: $price, quantity: $quantity, isCompleted: $isCompleted)';
  }
}

/// @nodoc
abstract mixin class $DocumentItemSpecificDataCopyWith<$Res> {
  factory $DocumentItemSpecificDataCopyWith(DocumentItemSpecificData value,
          $Res Function(DocumentItemSpecificData) _then) =
      _$DocumentItemSpecificDataCopyWithImpl;
  @useResult
  $Res call({double? price, double? quantity, bool isCompleted});
}

/// @nodoc
class _$DocumentItemSpecificDataCopyWithImpl<$Res>
    implements $DocumentItemSpecificDataCopyWith<$Res> {
  _$DocumentItemSpecificDataCopyWithImpl(this._self, this._then);

  final DocumentItemSpecificData _self;
  final $Res Function(DocumentItemSpecificData) _then;

  /// Create a copy of DocumentItemSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? price = freezed,
    Object? quantity = freezed,
    Object? isCompleted = null,
  }) {
    return _then(_self.copyWith(
      price: freezed == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as double?,
      quantity: freezed == quantity
          ? _self.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double?,
      isCompleted: null == isCompleted
          ? _self.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _DocumentItemSpecificData implements DocumentItemSpecificData {
  const _DocumentItemSpecificData(
      {this.price, this.quantity, this.isCompleted = false});
  factory _DocumentItemSpecificData.fromJson(Map<String, dynamic> json) =>
      _$DocumentItemSpecificDataFromJson(json);

  @override
  final double? price;
  @override
  final double? quantity;
  @override
  @JsonKey()
  final bool isCompleted;

  /// Create a copy of DocumentItemSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DocumentItemSpecificDataCopyWith<_DocumentItemSpecificData> get copyWith =>
      __$DocumentItemSpecificDataCopyWithImpl<_DocumentItemSpecificData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DocumentItemSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DocumentItemSpecificData &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.isCompleted, isCompleted) ||
                other.isCompleted == isCompleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, price, quantity, isCompleted);

  @override
  String toString() {
    return 'DocumentItemSpecificData(price: $price, quantity: $quantity, isCompleted: $isCompleted)';
  }
}

/// @nodoc
abstract mixin class _$DocumentItemSpecificDataCopyWith<$Res>
    implements $DocumentItemSpecificDataCopyWith<$Res> {
  factory _$DocumentItemSpecificDataCopyWith(_DocumentItemSpecificData value,
          $Res Function(_DocumentItemSpecificData) _then) =
      __$DocumentItemSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call({double? price, double? quantity, bool isCompleted});
}

/// @nodoc
class __$DocumentItemSpecificDataCopyWithImpl<$Res>
    implements _$DocumentItemSpecificDataCopyWith<$Res> {
  __$DocumentItemSpecificDataCopyWithImpl(this._self, this._then);

  final _DocumentItemSpecificData _self;
  final $Res Function(_DocumentItemSpecificData) _then;

  /// Create a copy of DocumentItemSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? price = freezed,
    Object? quantity = freezed,
    Object? isCompleted = null,
  }) {
    return _then(_DocumentItemSpecificData(
      price: freezed == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as double?,
      quantity: freezed == quantity
          ? _self.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double?,
      isCompleted: null == isCompleted
          ? _self.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

// dart format on

```

## lib\features\core\document_item_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'document_item_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_DocumentItemSpecificData _$DocumentItemSpecificDataFromJson(
        Map<String, dynamic> json) =>
    _DocumentItemSpecificData(
      price: (json['price'] as num?)?.toDouble(),
      quantity: (json['quantity'] as num?)?.toDouble(),
      isCompleted: json['isCompleted'] as bool? ?? false,
    );

Map<String, dynamic> _$DocumentItemSpecificDataToJson(
        _DocumentItemSpecificData instance) =>
    <String, dynamic>{
      'price': instance.price,
      'quantity': instance.quantity,
      'isCompleted': instance.isCompleted,
    };

```

## lib\features\core\document_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/core/document_status.dart';

part 'document_specific_data.freezed.dart';
part 'document_specific_data.g.dart';

/// Данные, специфичные для документов
@freezed
abstract class DocumentSpecificData with _$DocumentSpecificData {
  const factory DocumentSpecificData({
    required DocumentStatus status,
    required DateTime documentDate,
    @Default(false) bool isPosted,
    DateTime? postedAt,
    DateTime? scheduledDate, // Планируемая дата
    DateTime? completedAt, // Дата завершения
    double? totalAmount, // Итоговая сумма
  }) = _DocumentSpecificData;

  factory DocumentSpecificData.fromJson(Map<String, dynamic> json) =>
      _$DocumentSpecificDataFromJson(json);
}

```

## lib\features\core\document_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'document_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$DocumentSpecificData {
  DocumentStatus get status;
  DateTime get documentDate;
  bool get isPosted;
  DateTime? get postedAt;
  DateTime? get scheduledDate; // Планируемая дата
  DateTime? get completedAt; // Дата завершения
  double? get totalAmount;

  /// Create a copy of DocumentSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DocumentSpecificDataCopyWith<DocumentSpecificData> get copyWith =>
      _$DocumentSpecificDataCopyWithImpl<DocumentSpecificData>(
          this as DocumentSpecificData, _$identity);

  /// Serializes this DocumentSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DocumentSpecificData &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.documentDate, documentDate) ||
                other.documentDate == documentDate) &&
            (identical(other.isPosted, isPosted) ||
                other.isPosted == isPosted) &&
            (identical(other.postedAt, postedAt) ||
                other.postedAt == postedAt) &&
            (identical(other.scheduledDate, scheduledDate) ||
                other.scheduledDate == scheduledDate) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.totalAmount, totalAmount) ||
                other.totalAmount == totalAmount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, documentDate, isPosted,
      postedAt, scheduledDate, completedAt, totalAmount);

  @override
  String toString() {
    return 'DocumentSpecificData(status: $status, documentDate: $documentDate, isPosted: $isPosted, postedAt: $postedAt, scheduledDate: $scheduledDate, completedAt: $completedAt, totalAmount: $totalAmount)';
  }
}

/// @nodoc
abstract mixin class $DocumentSpecificDataCopyWith<$Res> {
  factory $DocumentSpecificDataCopyWith(DocumentSpecificData value,
          $Res Function(DocumentSpecificData) _then) =
      _$DocumentSpecificDataCopyWithImpl;
  @useResult
  $Res call(
      {DocumentStatus status,
      DateTime documentDate,
      bool isPosted,
      DateTime? postedAt,
      DateTime? scheduledDate,
      DateTime? completedAt,
      double? totalAmount});
}

/// @nodoc
class _$DocumentSpecificDataCopyWithImpl<$Res>
    implements $DocumentSpecificDataCopyWith<$Res> {
  _$DocumentSpecificDataCopyWithImpl(this._self, this._then);

  final DocumentSpecificData _self;
  final $Res Function(DocumentSpecificData) _then;

  /// Create a copy of DocumentSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? documentDate = null,
    Object? isPosted = null,
    Object? postedAt = freezed,
    Object? scheduledDate = freezed,
    Object? completedAt = freezed,
    Object? totalAmount = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as DocumentStatus,
      documentDate: null == documentDate
          ? _self.documentDate
          : documentDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isPosted: null == isPosted
          ? _self.isPosted
          : isPosted // ignore: cast_nullable_to_non_nullable
              as bool,
      postedAt: freezed == postedAt
          ? _self.postedAt
          : postedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      scheduledDate: freezed == scheduledDate
          ? _self.scheduledDate
          : scheduledDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      totalAmount: freezed == totalAmount
          ? _self.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _DocumentSpecificData implements DocumentSpecificData {
  const _DocumentSpecificData(
      {required this.status,
      required this.documentDate,
      this.isPosted = false,
      this.postedAt,
      this.scheduledDate,
      this.completedAt,
      this.totalAmount});
  factory _DocumentSpecificData.fromJson(Map<String, dynamic> json) =>
      _$DocumentSpecificDataFromJson(json);

  @override
  final DocumentStatus status;
  @override
  final DateTime documentDate;
  @override
  @JsonKey()
  final bool isPosted;
  @override
  final DateTime? postedAt;
  @override
  final DateTime? scheduledDate;
// Планируемая дата
  @override
  final DateTime? completedAt;
// Дата завершения
  @override
  final double? totalAmount;

  /// Create a copy of DocumentSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DocumentSpecificDataCopyWith<_DocumentSpecificData> get copyWith =>
      __$DocumentSpecificDataCopyWithImpl<_DocumentSpecificData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DocumentSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DocumentSpecificData &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.documentDate, documentDate) ||
                other.documentDate == documentDate) &&
            (identical(other.isPosted, isPosted) ||
                other.isPosted == isPosted) &&
            (identical(other.postedAt, postedAt) ||
                other.postedAt == postedAt) &&
            (identical(other.scheduledDate, scheduledDate) ||
                other.scheduledDate == scheduledDate) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.totalAmount, totalAmount) ||
                other.totalAmount == totalAmount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, status, documentDate, isPosted,
      postedAt, scheduledDate, completedAt, totalAmount);

  @override
  String toString() {
    return 'DocumentSpecificData(status: $status, documentDate: $documentDate, isPosted: $isPosted, postedAt: $postedAt, scheduledDate: $scheduledDate, completedAt: $completedAt, totalAmount: $totalAmount)';
  }
}

/// @nodoc
abstract mixin class _$DocumentSpecificDataCopyWith<$Res>
    implements $DocumentSpecificDataCopyWith<$Res> {
  factory _$DocumentSpecificDataCopyWith(_DocumentSpecificData value,
          $Res Function(_DocumentSpecificData) _then) =
      __$DocumentSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {DocumentStatus status,
      DateTime documentDate,
      bool isPosted,
      DateTime? postedAt,
      DateTime? scheduledDate,
      DateTime? completedAt,
      double? totalAmount});
}

/// @nodoc
class __$DocumentSpecificDataCopyWithImpl<$Res>
    implements _$DocumentSpecificDataCopyWith<$Res> {
  __$DocumentSpecificDataCopyWithImpl(this._self, this._then);

  final _DocumentSpecificData _self;
  final $Res Function(_DocumentSpecificData) _then;

  /// Create a copy of DocumentSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? documentDate = null,
    Object? isPosted = null,
    Object? postedAt = freezed,
    Object? scheduledDate = freezed,
    Object? completedAt = freezed,
    Object? totalAmount = freezed,
  }) {
    return _then(_DocumentSpecificData(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as DocumentStatus,
      documentDate: null == documentDate
          ? _self.documentDate
          : documentDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isPosted: null == isPosted
          ? _self.isPosted
          : isPosted // ignore: cast_nullable_to_non_nullable
              as bool,
      postedAt: freezed == postedAt
          ? _self.postedAt
          : postedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      scheduledDate: freezed == scheduledDate
          ? _self.scheduledDate
          : scheduledDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      totalAmount: freezed == totalAmount
          ? _self.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

// dart format on

```

## lib\features\core\document_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'document_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_DocumentSpecificData _$DocumentSpecificDataFromJson(
        Map<String, dynamic> json) =>
    _DocumentSpecificData(
      status: $enumDecode(_$DocumentStatusEnumMap, json['status']),
      documentDate: DateTime.parse(json['documentDate'] as String),
      isPosted: json['isPosted'] as bool? ?? false,
      postedAt: json['postedAt'] == null
          ? null
          : DateTime.parse(json['postedAt'] as String),
      scheduledDate: json['scheduledDate'] == null
          ? null
          : DateTime.parse(json['scheduledDate'] as String),
      completedAt: json['completedAt'] == null
          ? null
          : DateTime.parse(json['completedAt'] as String),
      totalAmount: (json['totalAmount'] as num?)?.toDouble(),
    );

Map<String, dynamic> _$DocumentSpecificDataToJson(
        _DocumentSpecificData instance) =>
    <String, dynamic>{
      'status': _$DocumentStatusEnumMap[instance.status]!,
      'documentDate': instance.documentDate.toIso8601String(),
      'isPosted': instance.isPosted,
      'postedAt': instance.postedAt?.toIso8601String(),
      'scheduledDate': instance.scheduledDate?.toIso8601String(),
      'completedAt': instance.completedAt?.toIso8601String(),
      'totalAmount': instance.totalAmount,
    };

const _$DocumentStatusEnumMap = {
  DocumentStatus.newDoc: 'newDoc',
  DocumentStatus.posted: 'posted',
  DocumentStatus.cancelled: 'cancelled',
  DocumentStatus.inProgress: 'inProgress',
  DocumentStatus.waitingForParts: 'waitingForParts',
  DocumentStatus.readyForPickup: 'readyForPickup',
  DocumentStatus.completed: 'completed',
  DocumentStatus.unknown: 'unknown',
};

```

## lib\features\core\document_status.dart
```dart
import 'package:flutter/material.dart';

/// Статус документа (enum)
enum DocumentStatus {
  newDoc('новый', Colors.blue),
  posted('проведен', Colors.green),
  cancelled('отменен', Colors.red),
  // Добавляем статусы из старого OrderStatus для совместимости
  inProgress('в работе', Colors.orange),
  waitingForParts('ожидание запчастей', Colors.purple),
  readyForPickup('готов к выдаче', Colors.teal),
  completed('завершен', Colors.grey), // Используем цвет posted для завершенного
  unknown('неизвестен', Colors.grey); // Статус по умолчанию

  final String value;
  final Color color;

  const DocumentStatus(this.value, this.color);

  /// Отображаемое имя статуса (для UI)
  String get displayName {
    // Можно добавить логику для локализации, если потребуется
    // Например, используя context.t.documentStatus.newDoc и т.д.
    // Пока просто возвращаем value с заглавной буквы
    if (value.isEmpty) return '';
    return value[0].toUpperCase() + value.substring(1);
  }

  /// Получить статус из строки
  static DocumentStatus fromString(String? value) {
    if (value == null) return DocumentStatus.unknown;
    final lowerValue = value.toLowerCase();
    for (final status in DocumentStatus.values) {
      if (status.value == lowerValue || status.name == lowerValue) {
        return status;
      }
    }
    // Дополнительные проверки для старых значений, если они отличаются
    switch (lowerValue) {
      case 'new':
        return DocumentStatus.newDoc;
      case 'in_progress':
        return DocumentStatus.inProgress;
      case 'waiting_for_parts':
        return DocumentStatus.waitingForParts;
      case 'ready_for_pickup':
        return DocumentStatus.readyForPickup;
    }
    return DocumentStatus.unknown;
  }
}

```

## lib\features\core\entity_core_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'entity_core_data.freezed.dart';
part 'entity_core_data.g.dart';

/// Базовые данные для всех сущностей
@freezed
abstract class EntityCoreData with _$EntityCoreData {
  const factory EntityCoreData({
    required String uuid,
    required String code,
    required String displayName,
    required DateTime createdAt,
    DateTime? modifiedAt,
    DateTime? deletedAt,
    @Default(false) bool isDeleted,
  }) = _EntityCoreData;

  factory EntityCoreData.fromJson(Map<String, dynamic> json) =>
      _$EntityCoreDataFromJson(json);
}

```

## lib\features\core\entity_core_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'entity_core_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$EntityCoreData {
  String get uuid;
  String get code;
  String get displayName;
  DateTime get createdAt;
  DateTime? get modifiedAt;
  DateTime? get deletedAt;
  bool get isDeleted;

  /// Create a copy of EntityCoreData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EntityCoreDataCopyWith<EntityCoreData> get copyWith =>
      _$EntityCoreDataCopyWithImpl<EntityCoreData>(
          this as EntityCoreData, _$identity);

  /// Serializes this EntityCoreData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EntityCoreData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.modifiedAt, modifiedAt) ||
                other.modifiedAt == modifiedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uuid, code, displayName,
      createdAt, modifiedAt, deletedAt, isDeleted);

  @override
  String toString() {
    return 'EntityCoreData(uuid: $uuid, code: $code, displayName: $displayName, createdAt: $createdAt, modifiedAt: $modifiedAt, deletedAt: $deletedAt, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class $EntityCoreDataCopyWith<$Res> {
  factory $EntityCoreDataCopyWith(
          EntityCoreData value, $Res Function(EntityCoreData) _then) =
      _$EntityCoreDataCopyWithImpl;
  @useResult
  $Res call(
      {String uuid,
      String code,
      String displayName,
      DateTime createdAt,
      DateTime? modifiedAt,
      DateTime? deletedAt,
      bool isDeleted});
}

/// @nodoc
class _$EntityCoreDataCopyWithImpl<$Res>
    implements $EntityCoreDataCopyWith<$Res> {
  _$EntityCoreDataCopyWithImpl(this._self, this._then);

  final EntityCoreData _self;
  final $Res Function(EntityCoreData) _then;

  /// Create a copy of EntityCoreData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uuid = null,
    Object? code = null,
    Object? displayName = null,
    Object? createdAt = null,
    Object? modifiedAt = freezed,
    Object? deletedAt = freezed,
    Object? isDeleted = null,
  }) {
    return _then(_self.copyWith(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      modifiedAt: freezed == modifiedAt
          ? _self.modifiedAt
          : modifiedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: null == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _EntityCoreData implements EntityCoreData {
  const _EntityCoreData(
      {required this.uuid,
      required this.code,
      required this.displayName,
      required this.createdAt,
      this.modifiedAt,
      this.deletedAt,
      this.isDeleted = false});
  factory _EntityCoreData.fromJson(Map<String, dynamic> json) =>
      _$EntityCoreDataFromJson(json);

  @override
  final String uuid;
  @override
  final String code;
  @override
  final String displayName;
  @override
  final DateTime createdAt;
  @override
  final DateTime? modifiedAt;
  @override
  final DateTime? deletedAt;
  @override
  @JsonKey()
  final bool isDeleted;

  /// Create a copy of EntityCoreData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EntityCoreDataCopyWith<_EntityCoreData> get copyWith =>
      __$EntityCoreDataCopyWithImpl<_EntityCoreData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EntityCoreDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EntityCoreData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.modifiedAt, modifiedAt) ||
                other.modifiedAt == modifiedAt) &&
            (identical(other.deletedAt, deletedAt) ||
                other.deletedAt == deletedAt) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uuid, code, displayName,
      createdAt, modifiedAt, deletedAt, isDeleted);

  @override
  String toString() {
    return 'EntityCoreData(uuid: $uuid, code: $code, displayName: $displayName, createdAt: $createdAt, modifiedAt: $modifiedAt, deletedAt: $deletedAt, isDeleted: $isDeleted)';
  }
}

/// @nodoc
abstract mixin class _$EntityCoreDataCopyWith<$Res>
    implements $EntityCoreDataCopyWith<$Res> {
  factory _$EntityCoreDataCopyWith(
          _EntityCoreData value, $Res Function(_EntityCoreData) _then) =
      __$EntityCoreDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String uuid,
      String code,
      String displayName,
      DateTime createdAt,
      DateTime? modifiedAt,
      DateTime? deletedAt,
      bool isDeleted});
}

/// @nodoc
class __$EntityCoreDataCopyWithImpl<$Res>
    implements _$EntityCoreDataCopyWith<$Res> {
  __$EntityCoreDataCopyWithImpl(this._self, this._then);

  final _EntityCoreData _self;
  final $Res Function(_EntityCoreData) _then;

  /// Create a copy of EntityCoreData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uuid = null,
    Object? code = null,
    Object? displayName = null,
    Object? createdAt = null,
    Object? modifiedAt = freezed,
    Object? deletedAt = freezed,
    Object? isDeleted = null,
  }) {
    return _then(_EntityCoreData(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      modifiedAt: freezed == modifiedAt
          ? _self.modifiedAt
          : modifiedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      deletedAt: freezed == deletedAt
          ? _self.deletedAt
          : deletedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: null == isDeleted
          ? _self.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

// dart format on

```

## lib\features\core\entity_core_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'entity_core_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_EntityCoreData _$EntityCoreDataFromJson(Map<String, dynamic> json) =>
    _EntityCoreData(
      uuid: json['uuid'] as String,
      code: json['code'] as String,
      displayName: json['displayName'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      modifiedAt: json['modifiedAt'] == null
          ? null
          : DateTime.parse(json['modifiedAt'] as String),
      deletedAt: json['deletedAt'] == null
          ? null
          : DateTime.parse(json['deletedAt'] as String),
      isDeleted: json['isDeleted'] as bool? ?? false,
    );

Map<String, dynamic> _$EntityCoreDataToJson(_EntityCoreData instance) =>
    <String, dynamic>{
      'uuid': instance.uuid,
      'code': instance.code,
      'displayName': instance.displayName,
      'createdAt': instance.createdAt.toIso8601String(),
      'modifiedAt': instance.modifiedAt?.toIso8601String(),
      'deletedAt': instance.deletedAt?.toIso8601String(),
      'isDeleted': instance.isDeleted,
    };

```

## lib\features\core\i_document_entity.dart
```dart
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/core/i_entity.dart';
import 'package:part_catalog/features/core/document_status.dart';
import 'package:part_catalog/features/core/base_item_type.dart';

/// Интерфейс для сущностей типа "Документ"
abstract class IDocumentEntity implements IEntity {
  DocumentStatus get status;
  DateTime get documentDate;
  bool get isPosted;
  DateTime? get postedAt;
  Map<BaseItemType, List<IDocumentItemEntity>>
      get itemsMap; // Используем интерфейс элемента

  List<IDocumentItemEntity> get items;
  List<IDocumentItemEntity> getItemsByType(BaseItemType type);
  List<IDocumentItemEntity> searchItems(String query);

  // Методы для иммутабельного управления элементами
  IDocumentEntity withAddedItem(IDocumentItemEntity item,
      {BaseItemType? itemType});
  IDocumentEntity withUpdatedItem(IDocumentItemEntity item,
      {BaseItemType? itemType});
  IDocumentEntity withRemovedItem(String itemId, {BaseItemType? itemType});

  // Метод для иммутабельного обновления статуса
  IDocumentEntity withStatus(DocumentStatus newStatus);
}

```

## lib\features\core\i_document_item_entity.dart
```dart
import 'package:part_catalog/features/core/i_item_entity.dart';
import 'package:part_catalog/features/core/base_item_type.dart';

/// Интерфейс для элементов табличных частей документов
abstract class IDocumentItemEntity implements IItemEntity {
  double? get price;
  double? get quantity;
  bool get isCompleted;
  BaseItemType get documentItemType; // Конкретный тип элемента документа

  double? get totalPrice;
}

```

## lib\features\core\i_entity.dart
```dart
/// Базовый интерфейс для всех сущностей (Справочники, Документы)
abstract class IEntity {
  String get uuid;
  String get code;
  String get displayName;
  DateTime get createdAt;
  DateTime? get modifiedAt;
  DateTime? get deletedAt;
  bool get isDeleted;

  bool containsSearchText(String searchText);
}

```

## lib\features\core\i_item_entity.dart
```dart
import 'package:part_catalog/features/core/base_item_type.dart';

/// Базовый интерфейс для всех элементов табличных частей
abstract class IItemEntity {
  String get uuid;
  String get name;
  BaseItemType get itemType;
  int get lineNumber;
  Map<String, dynamic> get data;

  bool containsSearchText(String searchText);
  T? getValue<T>(String key);
  // Метод для иммутабельного обновления данных элемента
  IItemEntity withUpdatedData(Map<String, dynamic> newData);
}

```

## lib\features\core\i_reference_entity.dart
```dart
import 'package:part_catalog/features/core/i_entity.dart';
import 'package:part_catalog/features/core/i_reference_item_entity.dart'; // Используем специфичный интерфейс
import 'package:part_catalog/features/core/base_item_type.dart';

/// Интерфейс для сущностей типа "Справочник"
abstract class IReferenceEntity implements IEntity {
  /// Идентификатор родительского элемента (для иерархических справочников)
  String? get parentId;

  /// Признак того, что элемент является группой (папкой)
  bool get isFolder;

  /// Список идентификаторов всех предков (для быстрого построения иерархии)
  List<String> get ancestorIds;

  /// Элементы табличной части (если справочник имеет табличные части)
  /// Используем IReferenceItemEntity для большей специфичности.
  Map<BaseItemType, List<IReferenceItemEntity>> get itemsMap;

  /// Возвращает плоский список всех элементов справочника.
  List<IReferenceItemEntity> get items;

  /// Возвращает список элементов указанного типа.
  List<IReferenceItemEntity> getItemsByType(BaseItemType type);

  /// Выполняет поиск среди элементов справочника.
  List<IReferenceItemEntity> searchItems(String query);

  // Методы для иммутабельного управления элементами (если применимо)
  // Теперь принимают и возвращают IReferenceItemEntity.
  IReferenceEntity withAddedItem(IReferenceItemEntity item,
      {BaseItemType? itemType});
  IReferenceEntity withUpdatedItem(IReferenceItemEntity item,
      {BaseItemType? itemType});
  IReferenceEntity withRemovedItem(String itemId, {BaseItemType? itemType});

  // Метод для иммутабельного обновления родителя
  IReferenceEntity withParentId(String? newParentId);
}

```

## lib\features\core\i_reference_item_entity.dart
```dart
import 'package:part_catalog/features/core/i_item_entity.dart';

/// Интерфейс для элементов табличных частей справочников
/// В базовом варианте может не добавлять специфичных полей/методов,
/// но служит для типизации и возможного будущего расширения.
abstract class IReferenceItemEntity implements IItemEntity {
  // Здесь могут быть добавлены специфичные для элементов справочников
  // свойства или методы, если они понадобятся.
  // Например:
  // String? get referenceSpecificProperty;
  // IReferenceItemEntity withReferenceSpecificProperty(String? value);

  // Пока что он просто наследует контракт IItemEntity.
}

```

## lib\features\core\item_core_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/core/base_item_type.dart';

part 'item_core_data.freezed.dart';
part 'item_core_data.g.dart';

/// Базовые данные для всех элементов табличных частей
@freezed
abstract class ItemCoreData with _$ItemCoreData {
  const factory ItemCoreData({
    required String uuid,
    required String name,
    required BaseItemType itemType,
    @Default(0) int lineNumber,
    @Default(<String, dynamic>{}) Map<String, dynamic> data,
  }) = _ItemCoreData;

  factory ItemCoreData.fromJson(Map<String, dynamic> json) =>
      _$ItemCoreDataFromJson(json);
}

```

## lib\features\core\item_core_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'item_core_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ItemCoreData {
  String get uuid;
  String get name;
  BaseItemType get itemType;
  int get lineNumber;
  Map<String, dynamic> get data;

  /// Create a copy of ItemCoreData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ItemCoreDataCopyWith<ItemCoreData> get copyWith =>
      _$ItemCoreDataCopyWithImpl<ItemCoreData>(
          this as ItemCoreData, _$identity);

  /// Serializes this ItemCoreData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ItemCoreData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.itemType, itemType) ||
                other.itemType == itemType) &&
            (identical(other.lineNumber, lineNumber) ||
                other.lineNumber == lineNumber) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uuid, name, itemType, lineNumber,
      const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'ItemCoreData(uuid: $uuid, name: $name, itemType: $itemType, lineNumber: $lineNumber, data: $data)';
  }
}

/// @nodoc
abstract mixin class $ItemCoreDataCopyWith<$Res> {
  factory $ItemCoreDataCopyWith(
          ItemCoreData value, $Res Function(ItemCoreData) _then) =
      _$ItemCoreDataCopyWithImpl;
  @useResult
  $Res call(
      {String uuid,
      String name,
      BaseItemType itemType,
      int lineNumber,
      Map<String, dynamic> data});
}

/// @nodoc
class _$ItemCoreDataCopyWithImpl<$Res> implements $ItemCoreDataCopyWith<$Res> {
  _$ItemCoreDataCopyWithImpl(this._self, this._then);

  final ItemCoreData _self;
  final $Res Function(ItemCoreData) _then;

  /// Create a copy of ItemCoreData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uuid = null,
    Object? name = null,
    Object? itemType = null,
    Object? lineNumber = null,
    Object? data = null,
  }) {
    return _then(_self.copyWith(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      itemType: null == itemType
          ? _self.itemType
          : itemType // ignore: cast_nullable_to_non_nullable
              as BaseItemType,
      lineNumber: null == lineNumber
          ? _self.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _ItemCoreData implements ItemCoreData {
  const _ItemCoreData(
      {required this.uuid,
      required this.name,
      required this.itemType,
      this.lineNumber = 0,
      final Map<String, dynamic> data = const <String, dynamic>{}})
      : _data = data;
  factory _ItemCoreData.fromJson(Map<String, dynamic> json) =>
      _$ItemCoreDataFromJson(json);

  @override
  final String uuid;
  @override
  final String name;
  @override
  final BaseItemType itemType;
  @override
  @JsonKey()
  final int lineNumber;
  final Map<String, dynamic> _data;
  @override
  @JsonKey()
  Map<String, dynamic> get data {
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_data);
  }

  /// Create a copy of ItemCoreData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ItemCoreDataCopyWith<_ItemCoreData> get copyWith =>
      __$ItemCoreDataCopyWithImpl<_ItemCoreData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ItemCoreDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ItemCoreData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.itemType, itemType) ||
                other.itemType == itemType) &&
            (identical(other.lineNumber, lineNumber) ||
                other.lineNumber == lineNumber) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, uuid, name, itemType, lineNumber,
      const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'ItemCoreData(uuid: $uuid, name: $name, itemType: $itemType, lineNumber: $lineNumber, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$ItemCoreDataCopyWith<$Res>
    implements $ItemCoreDataCopyWith<$Res> {
  factory _$ItemCoreDataCopyWith(
          _ItemCoreData value, $Res Function(_ItemCoreData) _then) =
      __$ItemCoreDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String uuid,
      String name,
      BaseItemType itemType,
      int lineNumber,
      Map<String, dynamic> data});
}

/// @nodoc
class __$ItemCoreDataCopyWithImpl<$Res>
    implements _$ItemCoreDataCopyWith<$Res> {
  __$ItemCoreDataCopyWithImpl(this._self, this._then);

  final _ItemCoreData _self;
  final $Res Function(_ItemCoreData) _then;

  /// Create a copy of ItemCoreData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uuid = null,
    Object? name = null,
    Object? itemType = null,
    Object? lineNumber = null,
    Object? data = null,
  }) {
    return _then(_ItemCoreData(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      itemType: null == itemType
          ? _self.itemType
          : itemType // ignore: cast_nullable_to_non_nullable
              as BaseItemType,
      lineNumber: null == lineNumber
          ? _self.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

// dart format on

```

## lib\features\core\item_core_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'item_core_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ItemCoreData _$ItemCoreDataFromJson(Map<String, dynamic> json) =>
    _ItemCoreData(
      uuid: json['uuid'] as String,
      name: json['name'] as String,
      itemType: $enumDecode(_$BaseItemTypeEnumMap, json['itemType']),
      lineNumber: (json['lineNumber'] as num?)?.toInt() ?? 0,
      data: json['data'] as Map<String, dynamic>? ?? const <String, dynamic>{},
    );

Map<String, dynamic> _$ItemCoreDataToJson(_ItemCoreData instance) =>
    <String, dynamic>{
      'uuid': instance.uuid,
      'name': instance.name,
      'itemType': _$BaseItemTypeEnumMap[instance.itemType]!,
      'lineNumber': instance.lineNumber,
      'data': instance.data,
    };

const _$BaseItemTypeEnumMap = {
  BaseItemType.part: 'part',
  BaseItemType.service: 'service',
  BaseItemType.material: 'material',
  BaseItemType.workStage: 'workStage',
  BaseItemType.comment: 'comment',
  BaseItemType.attachment: 'attachment',
};

```

## lib\features\documents\orders\models\order_model_composite.dart
```dart
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/core/document_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/order_specific_data.dart';
import 'package:part_catalog/features/core/i_document_entity.dart';
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/core/document_status.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:uuid/uuid.dart'; // Для генерации UUID
import 'package:collection/collection.dart'; // Для ListEquality, MapEquality

// Импорты для сериализации элементов (предполагается, что они существуют)
import 'package:part_catalog/features/documents/orders/models/order_part_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_service_model_composite.dart';

/// {@template order_model_composite}
/// Бизнес-модель (композитор) для представления Заказ-наряда.
/// Реализует интерфейс [IDocumentEntity] и композирует модели данных
/// [EntityCoreData], [DocumentSpecificData] и [OrderSpecificData].
/// {@endtemplate}
class OrderModelComposite implements IDocumentEntity {
  /// Базовые данные сущности.
  final EntityCoreData coreData;

  /// Специфичные данные документа.
  final DocumentSpecificData docData;

  /// Специфичные данные заказ-наряда.
  final OrderSpecificData orderData;

  /// Карта элементов документа (запчасти, услуги).
  @override
  final Map<BaseItemType, List<IDocumentItemEntity>> itemsMap;

  /// Приватный конструктор для использования в фабричных методах и `with...`.
  const OrderModelComposite._(
      this.coreData, this.docData, this.orderData, this.itemsMap);

  /// Фабричный конструктор для создания нового Заказ-наряда.
  factory OrderModelComposite.create({
    required String code,
    required String displayName,
    required DateTime documentDate,
    DocumentStatus status = DocumentStatus.newDoc, // Значение по умолчанию
    String? clientId,
    String? carId,
    String? description,
    DateTime? scheduledDate, // <--- Добавляем параметр сюда
    Map<BaseItemType, List<IDocumentItemEntity>> itemsMap = const {},
  }) {
    final now = DateTime.now();
    return OrderModelComposite._(
      EntityCoreData(
        uuid: const Uuid().v4(),
        code: code,
        displayName: displayName,
        createdAt: now,
        modifiedAt: now, // Устанавливаем modifiedAt при создании
        isDeleted: false,
        deletedAt: null,
      ),
      DocumentSpecificData(
        status: status,
        documentDate: documentDate,
        scheduledDate: scheduledDate, // <--- Используем параметр здесь
        isPosted: false, // По умолчанию не проведен
        postedAt: null,
        // completedAt и totalAmount будут null по умолчанию
      ),
      OrderSpecificData(
        clientId: clientId,
        carId: carId,
        description: description,
        // scheduledDate здесь больше не нужен
      ),
      Map.unmodifiable(itemsMap), // Делаем карту неизменяемой
    );
  }

  /// Фабричный конструктор для создания экземпляра из моделей данных.
  /// Используется сервисом при маппинге данных из DAO.
  factory OrderModelComposite.fromData(
    EntityCoreData coreData,
    DocumentSpecificData docData,
    OrderSpecificData orderData,
    Map<BaseItemType, List<IDocumentItemEntity>> itemsMap,
  ) {
    // Убедимся, что карта и списки неизменяемы
    final unmodifiableItemsMap =
        Map<BaseItemType, List<IDocumentItemEntity>>.unmodifiable(
      itemsMap.map(
        (key, value) =>
            MapEntry(key, List<IDocumentItemEntity>.unmodifiable(value)),
      ),
    );
    return OrderModelComposite._(
        coreData, docData, orderData, unmodifiableItemsMap);
  }

  // --- Реализация интерфейса IEntity ---
  @override
  String get uuid => coreData.uuid;
  @override
  String get code => coreData.code;
  @override
  String get displayName => coreData.displayName;
  @override
  DateTime get createdAt => coreData.createdAt;
  @override
  DateTime? get modifiedAt => coreData.modifiedAt;
  @override
  DateTime? get deletedAt => coreData.deletedAt;
  @override
  bool get isDeleted => coreData.isDeleted; // Используем поле из coreData

  @override
  bool containsSearchText(String query) {
    if (query.isEmpty) return true;
    final lowerQuery = query.toLowerCase();

    if (coreData.displayName.toLowerCase().contains(lowerQuery)) return true;
    if (coreData.code.toLowerCase().contains(lowerQuery)) return true;
    if (orderData.description?.toLowerCase().contains(lowerQuery) ?? false) {
      return true;
    }

    // Поиск по элементам
    for (final item in items) {
      if (item.containsSearchText(lowerQuery)) return true;
    }

    return false;
  }

  // --- Реализация интерфейса IDocumentEntity ---
  @override
  DocumentStatus get status => docData.status;
  @override
  DateTime get documentDate => docData.documentDate;
  @override
  bool get isPosted => docData.isPosted;
  @override
  DateTime? get postedAt => docData.postedAt;
  // itemsMap уже реализован как поле класса

  @override
  List<IDocumentItemEntity> get items =>
      itemsMap.values.expand((list) => list).toList();

  @override
  List<IDocumentItemEntity> getItemsByType(BaseItemType type) =>
      List.unmodifiable(
          itemsMap[type] ?? const []); // Возвращаем неизменяемый список

  @override
  List<IDocumentItemEntity> searchItems(String query) {
    if (query.isEmpty) return items;
    final lowerQuery = query.toLowerCase();
    return items.where((item) => item.containsSearchText(lowerQuery)).toList();
  }

  // --- Геттеры для специфичных данных заказ-наряда ---
  String? get clientId => orderData.clientId;
  String? get carId => orderData.carId;
  String? get description => orderData.description;

  // --- Иммутабельные методы обновления ---
  @override
  OrderModelComposite withStatus(DocumentStatus newStatus) {
    // Проверка логики перехода статусов может быть здесь или в сервисе
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData.copyWith(status: newStatus),
      orderData,
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным clientId.
  OrderModelComposite withClient(String? clientId) {
    if (orderData.clientId == clientId) return this;
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData.copyWith(clientId: clientId),
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным carId.
  OrderModelComposite withCar(String? carId) {
    if (orderData.carId == carId) return this;
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData.copyWith(carId: carId),
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным описанием.
  OrderModelComposite withDescription(String? description) {
    if (orderData.description == description) return this;
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData.copyWith(description: description),
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной запланированной датой.
  OrderModelComposite withScheduledDate(DateTime? scheduledDate) {
    if (docData.scheduledDate == scheduledDate) return this;
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData.copyWith(scheduledDate: scheduledDate),
      orderData,
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной картой элементов.
  /// Принимает карту, сгруппированную по BaseItemType.
  OrderModelComposite withItems(
      Map<BaseItemType, List<IDocumentItemEntity>> newItemsMap) {
    // Убедимся, что новая карта и списки неизменяемы
    final unmodifiableNewItemsMap =
        Map<BaseItemType, List<IDocumentItemEntity>>.unmodifiable(
      newItemsMap.map(
        (key, value) =>
            MapEntry(key, List<IDocumentItemEntity>.unmodifiable(value)),
      ),
    );
    // Используем MapEquality для сравнения
    if (const MapEquality().equals(itemsMap, unmodifiableNewItemsMap)) {
      return this;
    }
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData,
      unmodifiableNewItemsMap,
    );
  }

  @override
  OrderModelComposite withAddedItem(IDocumentItemEntity item,
      {BaseItemType? itemType}) {
    final type = itemType ?? item.itemType;
    final updatedItemsMap =
        Map<BaseItemType, List<IDocumentItemEntity>>.from(itemsMap);
    final currentList =
        List<IDocumentItemEntity>.from(updatedItemsMap[type] ?? []);

    // Проверка на дубликат по UUID
    if (currentList.any((existing) => existing.uuid == item.uuid)) {
      return this; // Не добавляем дубликат
    }

    currentList.add(item);
    updatedItemsMap[type] =
        List.unmodifiable(currentList); // Сохраняем неизменяемый список

    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData,
      Map.unmodifiable(updatedItemsMap), // Сохраняем неизменяемую карту
    );
  }

  @override
  OrderModelComposite withUpdatedItem(IDocumentItemEntity item,
      {BaseItemType? itemType}) {
    final type = itemType ?? item.itemType;
    final updatedItemsMap =
        Map<BaseItemType, List<IDocumentItemEntity>>.from(itemsMap);
    final currentList = updatedItemsMap[type];
    if (currentList == null) return this; // Элемента такого типа нет

    final index = currentList.indexWhere((i) => i.uuid == item.uuid);
    if (index == -1) return this; // Элемент не найден

    final newList = List<IDocumentItemEntity>.from(currentList);
    newList[index] = item;
    updatedItemsMap[type] = List.unmodifiable(newList);

    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData,
      Map.unmodifiable(updatedItemsMap),
    );
  }

  @override
  OrderModelComposite withRemovedItem(String itemId, {BaseItemType? itemType}) {
    final updatedItemsMap =
        Map<BaseItemType, List<IDocumentItemEntity>>.from(itemsMap);
    bool itemRemoved = false;

    if (itemType != null) {
      // Удаляем из конкретного типа
      final currentList = updatedItemsMap[itemType];
      if (currentList != null) {
        final newList = currentList.where((i) => i.uuid != itemId).toList();
        if (newList.length < currentList.length) {
          itemRemoved = true;
          if (newList.isEmpty) {
            updatedItemsMap.remove(itemType);
          } else {
            updatedItemsMap[itemType] = List.unmodifiable(newList);
          }
        }
      }
    } else {
      // Ищем и удаляем по всем типам
      for (final type in updatedItemsMap.keys.toList()) {
        // Копируем ключи для безопасного удаления
        final currentList = updatedItemsMap[type]!;
        final newList = currentList.where((i) => i.uuid != itemId).toList();
        if (newList.length < currentList.length) {
          itemRemoved = true;
          if (newList.isEmpty) {
            updatedItemsMap.remove(type);
          } else {
            updatedItemsMap[type] = List.unmodifiable(newList);
          }
          break; // Предполагаем, что UUID уникальны по всем типам
        }
      }
    }

    if (!itemRemoved) return this; // Ничего не удалено

    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      docData,
      orderData,
      Map.unmodifiable(updatedItemsMap),
    );
  }

  /// Возвращает новый экземпляр с обновленной датой модификации.
  OrderModelComposite withModifiedDate(DateTime modifiedDate) {
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: modifiedDate),
      docData,
      orderData,
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр, помеченный как удаленный.
  OrderModelComposite markAsDeleted() {
    if (isDeleted) return this;
    final now = DateTime.now();
    return OrderModelComposite._(
      coreData.copyWith(isDeleted: true, modifiedAt: now, deletedAt: now),
      docData,
      orderData,
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр, восстановленный из удаленных.
  OrderModelComposite restore() {
    if (!isDeleted) return this;
    return OrderModelComposite._(
      coreData.copyWith(
          isDeleted: false, modifiedAt: DateTime.now(), deletedAt: null),
      docData,
      orderData,
      itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным флагом проведения.
  OrderModelComposite withProveden(bool isProveden) {
    final now = DateTime.now();
    return OrderModelComposite._(
      coreData.copyWith(modifiedAt: now),
      docData.copyWith(isPosted: isProveden, postedAt: isProveden ? now : null),
      orderData,
      itemsMap,
    );
  }

  // --- Сериализация/Десериализация (Ручная) ---

  /// Преобразование объекта в JSON.
  Map<String, dynamic> toJson() {
    // Сериализуем карту элементов
    final Map<String, List<Map<String, dynamic>>> serializedItemsMap = {};
    itemsMap.forEach((key, value) {
      serializedItemsMap[key.name] = value.map((item) {
        // Предполагаем, что у IDocumentItemEntity есть метод toJson()
        // или мы можем определить его тип и вызвать соответствующий toJson
        if (item is OrderPartModelComposite) {
          return item.toJson();
        } else if (item is OrderServiceModelComposite) {
          return item.toJson();
        }
        // Добавить обработку других типов, если они появятся
        throw Exception(
            'Неизвестный тип элемента для сериализации: ${item.runtimeType}');
      }).toList();
    });

    return {
      ...coreData.toJson(),
      ...docData.toJson(),
      ...orderData.toJson(),
      'itemsMap': serializedItemsMap,
    };
  }

  /// Создание объекта из JSON.
  factory OrderModelComposite.fromJson(Map<String, dynamic> json) {
    final core = EntityCoreData.fromJson(json);
    final doc = DocumentSpecificData.fromJson(json);
    final order = OrderSpecificData.fromJson(json);

    // Десериализуем карту элементов
    final Map<BaseItemType, List<IDocumentItemEntity>> deserializedItemsMap =
        {};
    final Map<String, dynamic>? rawItemsMap =
        json['itemsMap'] as Map<String, dynamic>?;

    if (rawItemsMap != null) {
      rawItemsMap.forEach((key, value) {
        final itemType =
            BaseItemType.values.byName(key); // Получаем enum по имени
        final List<dynamic> itemsList = value as List<dynamic>;

        deserializedItemsMap[itemType] = itemsList.map((itemJson) {
          final itemMap = itemJson as Map<String, dynamic>;
          // Определяем тип элемента и вызываем соответствующий fromJson
          // Это может потребовать добавления поля 'type' в JSON элемента
          // или другой логики определения типа
          switch (itemType) {
            case BaseItemType.part:
              return OrderPartModelComposite.fromJson(itemMap);
            case BaseItemType.service:
              return OrderServiceModelComposite.fromJson(itemMap);
            // Добавить обработку других типов
            default:
              throw Exception(
                  'Неизвестный тип элемента для десериализации: $itemType');
          }
        }).toList();
      });
    }

    return OrderModelComposite.fromData(core, doc, order, deserializedItemsMap);
  }

  // --- Переопределение стандартных методов ---

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OrderModelComposite &&
          runtimeType == other.runtimeType &&
          coreData == other.coreData &&
          docData == other.docData &&
          orderData == other.orderData &&
          const MapEquality()
              .equals(itemsMap, other.itemsMap); // Сравнение карт

  @override
  int get hashCode =>
      coreData.hashCode ^
      docData.hashCode ^
      orderData.hashCode ^
      const MapEquality().hash(itemsMap); // Хэш карты

  @override
  String toString() {
    return 'OrderModelComposite(uuid: $uuid, code: $code, displayName: $displayName, status: ${status.name})';
  }
}

```

## lib\features\documents\orders\models\order_part_model_composite.dart
```dart
import 'package:part_catalog/features/core/item_core_data.dart';
import 'package:part_catalog/features/core/document_item_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/part_specific_data.dart';
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:uuid/uuid.dart';

class OrderPartModelComposite implements IDocumentItemEntity {
  final ItemCoreData _coreData;
  final DocumentItemSpecificData _docItemData;
  final PartSpecificData _partData;

  OrderPartModelComposite._(this._coreData, this._docItemData, this._partData);

  // Новый публичный фабричный конструктор для создания из данных
  factory OrderPartModelComposite.fromData(
    ItemCoreData coreData,
    DocumentItemSpecificData docItemData,
    PartSpecificData partData,
  ) {
    // Можно добавить проверки на соответствие типов и данных, если нужно
    if (coreData.itemType != BaseItemType.part) {
      throw ArgumentError(
          'ItemCoreData must have itemType BaseItemType.part for OrderPartModelComposite');
    }
    return OrderPartModelComposite._(coreData, docItemData, partData);
  }

  factory OrderPartModelComposite.create({
    required String documentUuid,
    required String name,
    required String partNumber,
    required double price,
    double quantity = 1.0,
    String? brand,
    String? supplierName,
    int? deliveryDays,
    int lineNumber = 0,
    Map<String, dynamic> data = const {},
  }) {
    return OrderPartModelComposite._(
      ItemCoreData(
        uuid: const Uuid().v4(),
        name: name,
        itemType: BaseItemType.part, // Явно указываем тип
        lineNumber: lineNumber,
        data: data,
      ),
      DocumentItemSpecificData(
        price: price,
        quantity: quantity,
        isCompleted: false, // По умолчанию не завершено (не получено)
      ),
      PartSpecificData(
        documentUuid: documentUuid,
        partNumber: partNumber,
        brand: brand,
        supplierName: supplierName,
        deliveryDays: deliveryDays,
        isOrdered: false,
        isReceived: false,
      ),
    );
  }

  // --- Реализация интерфейса IItemEntity ---
  @override
  String get uuid => _coreData.uuid;
  @override
  String get name => _coreData.name;
  @override
  BaseItemType get itemType => _coreData.itemType;
  @override
  int get lineNumber => _coreData.lineNumber;
  @override
  Map<String, dynamic> get data => _coreData.data;

  @override
  bool containsSearchText(String searchText) {
    final lowercaseSearch = searchText.toLowerCase();
    return name.toLowerCase().contains(lowercaseSearch) ||
        _partData.partNumber.toLowerCase().contains(lowercaseSearch) ||
        (_partData.brand?.toLowerCase().contains(lowercaseSearch) ?? false);
  }

  @override
  T? getValue<T>(String key) {
    // Реализация getValue, как была в BaseItemEntity
    final value = data[key];
    if (value == null) return null;
    if (value is T) return value;
    // ... (логика преобразования типов) ...
    return null;
  }

  @override
  OrderPartModelComposite withUpdatedData(Map<String, dynamic> newData) {
    return OrderPartModelComposite._(
      _coreData.copyWith(data: {..._coreData.data, ...newData}),
      _docItemData,
      _partData,
    );
  }

  // --- Реализация интерфейса IDocumentItemEntity ---
  @override
  double? get price => _docItemData.price;
  @override
  double? get quantity => _docItemData.quantity;
  @override
  bool get isCompleted => _partData.isReceived; // Завершено = Получено
  @override
  BaseItemType get documentItemType => BaseItemType.part;

  @override
  double? get totalPrice =>
      (price != null && quantity != null) ? price! * quantity! : price;

  // --- Специфичные геттеры для OrderPart ---
  String get documentUuid => _partData.documentUuid;
  String get partNumber => _partData.partNumber;
  String? get brand => _partData.brand;
  bool get isOrdered => _partData.isOrdered;
  bool get isReceived => _partData.isReceived;

  // --- Публичные геттеры для доступа к внутренним данным ---
  ItemCoreData get coreData => _coreData;
  DocumentItemSpecificData get docItemData => _docItemData;
  PartSpecificData get partData => _partData;

  // --- Иммутабельные методы обновления статусов ---
  OrderPartModelComposite withOrderStatus(bool newIsOrdered) {
    return OrderPartModelComposite._(
      _coreData,
      _docItemData,
      _partData.copyWith(isOrdered: newIsOrdered),
    );
  }

  OrderPartModelComposite withReceiveStatus(bool newIsReceived) {
    return OrderPartModelComposite._(
      _coreData,
      _docItemData.copyWith(
          isCompleted: newIsReceived), // Обновляем и isCompleted
      _partData.copyWith(isReceived: newIsReceived),
    );
  }

  // --- Сериализация/Десериализация ---
  Map<String, dynamic> toJson() {
    // Собрать JSON из _coreData, _docItemData, _partData
    throw UnimplementedError(
        "toJson не реализован для OrderPartModelComposite");
  }

  factory OrderPartModelComposite.fromJson(Map<String, dynamic> json) {
    // Разобрать JSON и создать экземпляры _coreData, _docItemData, _partData
    throw UnimplementedError(
        "fromJson не реализован для OrderPartModelComposite");
  }
}

```

## lib\features\documents\orders\models\order_service_model_composite.dart
```dart
import 'package:part_catalog/features/core/item_core_data.dart';
import 'package:part_catalog/features/core/document_item_specific_data.dart';
import 'package:part_catalog/features/documents/orders/models/service_specific_data.dart'; // Импорт новой модели
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:uuid/uuid.dart';

class OrderServiceModelComposite implements IDocumentItemEntity {
  final ItemCoreData _coreData;
  final DocumentItemSpecificData _docItemData;
  final ServiceSpecificData _serviceData; // Используем новую модель

  // Приватный конструктор
  OrderServiceModelComposite._(
      this._coreData, this._docItemData, this._serviceData);

  // Новый публичный фабричный конструктор для создания из данных
  factory OrderServiceModelComposite.fromData(
    ItemCoreData coreData,
    DocumentItemSpecificData docItemData,
    ServiceSpecificData serviceData,
  ) {
    // Можно добавить проверки на соответствие типов и данных, если нужно
    if (coreData.itemType != BaseItemType.service) {
      throw ArgumentError(
          'ItemCoreData must have itemType BaseItemType.service for OrderServiceModelComposite');
    }
    return OrderServiceModelComposite._(coreData, docItemData, serviceData);
  }

  // Фабричный конструктор для создания новой услуги
  factory OrderServiceModelComposite.create({
    required String documentUuid,
    required String name,
    String? description, // <--- Добавлен параметр
    required double price,
    double quantity =
        1.0, // Услуги тоже могут иметь количество (например, нормо-часы)
    double? duration,
    String? performedBy,
    int lineNumber = 0,
    Map<String, dynamic> data = const {},
  }) {
    return OrderServiceModelComposite._(
      ItemCoreData(
        uuid: const Uuid().v4(),
        name: name,
        itemType: BaseItemType.service, // Явно указываем тип
        lineNumber: lineNumber,
        data: data,
      ),
      DocumentItemSpecificData(
        price: price,
        quantity: quantity,
        isCompleted: false, // По умолчанию не завершено
      ),
      ServiceSpecificData(
        documentUuid: documentUuid,
        description: description, // <--- Используем параметр
        duration: duration,
        performedBy: performedBy,
      ),
    );
  }

  // --- Реализация интерфейса IItemEntity ---
  @override
  String get uuid => _coreData.uuid;
  @override
  String get name => _coreData.name;
  @override
  BaseItemType get itemType => _coreData.itemType;
  @override
  int get lineNumber => _coreData.lineNumber;
  @override
  Map<String, dynamic> get data => _coreData.data;

  @override
  bool containsSearchText(String searchText) {
    final lowercaseSearch = searchText.toLowerCase();
    return name.toLowerCase().contains(lowercaseSearch) ||
        (_serviceData.performedBy?.toLowerCase().contains(lowercaseSearch) ??
            false);
  }

  @override
  T? getValue<T>(String key) {
    final value = data[key];
    if (value == null) return null;
    if (value is T) return value;
    // ... (логика преобразования типов, если нужна) ...
    return null;
  }

  @override
  OrderServiceModelComposite withUpdatedData(Map<String, dynamic> newData) {
    return OrderServiceModelComposite._(
      _coreData.copyWith(data: {..._coreData.data, ...newData}),
      _docItemData,
      _serviceData,
    );
  }

  // --- Реализация интерфейса IDocumentItemEntity ---
  @override
  double? get price => _docItemData.price;
  @override
  double? get quantity => _docItemData.quantity;
  @override
  bool get isCompleted => _docItemData.isCompleted;
  @override
  BaseItemType get documentItemType => BaseItemType.service;

  @override
  double? get totalPrice =>
      (price != null && quantity != null) ? price! * quantity! : price;

  // --- Специфичные геттеры для OrderService ---
  String get documentUuid => _serviceData.documentUuid;
  String? get description => _serviceData.description;
  double? get duration => _serviceData.duration;
  String? get performedBy => _serviceData.performedBy;

  // --- Публичные геттеры для доступа к внутренним данным ---
  ItemCoreData get coreData => _coreData;
  DocumentItemSpecificData get docItemData => _docItemData;
  ServiceSpecificData get serviceData => _serviceData;

  // --- Иммутабельные методы обновления статусов ---
  OrderServiceModelComposite withCompletionStatus(bool newIsCompleted) {
    return OrderServiceModelComposite._(
      _coreData,
      _docItemData.copyWith(isCompleted: newIsCompleted),
      _serviceData,
    );
  }

  // --- Сериализация/Десериализация ---
  Map<String, dynamic> toJson() {
    // Собрать JSON из _coreData, _docItemData, _serviceData
    return {
      ..._coreData.toJson(),
      ..._docItemData.toJson(),
      ..._serviceData.toJson(),
    };
  }

  factory OrderServiceModelComposite.fromJson(Map<String, dynamic> json) {
    // Разобрать JSON и создать экземпляры _coreData, _docItemData, _serviceData
    return OrderServiceModelComposite._(
      ItemCoreData.fromJson(json),
      DocumentItemSpecificData.fromJson(json),
      ServiceSpecificData.fromJson(json),
    );
  }
}

```

## lib\features\documents\orders\models\order_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'order_specific_data.freezed.dart';
part 'order_specific_data.g.dart';

/// Данные, специфичные для Заказ-наряда
@freezed
abstract class OrderSpecificData with _$OrderSpecificData {
  const factory OrderSpecificData({
    String? clientId,
    String? carId,
    String? description,
    // ... другие поля, специфичные для OrderModel ...
  }) = _OrderSpecificData;

  factory OrderSpecificData.fromJson(Map<String, dynamic> json) =>
      _$OrderSpecificDataFromJson(json);
}

```

## lib\features\documents\orders\models\order_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'order_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OrderSpecificData {
  String? get clientId;
  String? get carId;
  String? get description;

  /// Create a copy of OrderSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OrderSpecificDataCopyWith<OrderSpecificData> get copyWith =>
      _$OrderSpecificDataCopyWithImpl<OrderSpecificData>(
          this as OrderSpecificData, _$identity);

  /// Serializes this OrderSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OrderSpecificData &&
            (identical(other.clientId, clientId) ||
                other.clientId == clientId) &&
            (identical(other.carId, carId) || other.carId == carId) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, clientId, carId, description);

  @override
  String toString() {
    return 'OrderSpecificData(clientId: $clientId, carId: $carId, description: $description)';
  }
}

/// @nodoc
abstract mixin class $OrderSpecificDataCopyWith<$Res> {
  factory $OrderSpecificDataCopyWith(
          OrderSpecificData value, $Res Function(OrderSpecificData) _then) =
      _$OrderSpecificDataCopyWithImpl;
  @useResult
  $Res call({String? clientId, String? carId, String? description});
}

/// @nodoc
class _$OrderSpecificDataCopyWithImpl<$Res>
    implements $OrderSpecificDataCopyWith<$Res> {
  _$OrderSpecificDataCopyWithImpl(this._self, this._then);

  final OrderSpecificData _self;
  final $Res Function(OrderSpecificData) _then;

  /// Create a copy of OrderSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clientId = freezed,
    Object? carId = freezed,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      clientId: freezed == clientId
          ? _self.clientId
          : clientId // ignore: cast_nullable_to_non_nullable
              as String?,
      carId: freezed == carId
          ? _self.carId
          : carId // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _OrderSpecificData implements OrderSpecificData {
  const _OrderSpecificData({this.clientId, this.carId, this.description});
  factory _OrderSpecificData.fromJson(Map<String, dynamic> json) =>
      _$OrderSpecificDataFromJson(json);

  @override
  final String? clientId;
  @override
  final String? carId;
  @override
  final String? description;

  /// Create a copy of OrderSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$OrderSpecificDataCopyWith<_OrderSpecificData> get copyWith =>
      __$OrderSpecificDataCopyWithImpl<_OrderSpecificData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$OrderSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OrderSpecificData &&
            (identical(other.clientId, clientId) ||
                other.clientId == clientId) &&
            (identical(other.carId, carId) || other.carId == carId) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, clientId, carId, description);

  @override
  String toString() {
    return 'OrderSpecificData(clientId: $clientId, carId: $carId, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$OrderSpecificDataCopyWith<$Res>
    implements $OrderSpecificDataCopyWith<$Res> {
  factory _$OrderSpecificDataCopyWith(
          _OrderSpecificData value, $Res Function(_OrderSpecificData) _then) =
      __$OrderSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call({String? clientId, String? carId, String? description});
}

/// @nodoc
class __$OrderSpecificDataCopyWithImpl<$Res>
    implements _$OrderSpecificDataCopyWith<$Res> {
  __$OrderSpecificDataCopyWithImpl(this._self, this._then);

  final _OrderSpecificData _self;
  final $Res Function(_OrderSpecificData) _then;

  /// Create a copy of OrderSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? clientId = freezed,
    Object? carId = freezed,
    Object? description = freezed,
  }) {
    return _then(_OrderSpecificData(
      clientId: freezed == clientId
          ? _self.clientId
          : clientId // ignore: cast_nullable_to_non_nullable
              as String?,
      carId: freezed == carId
          ? _self.carId
          : carId // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\documents\orders\models\order_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'order_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_OrderSpecificData _$OrderSpecificDataFromJson(Map<String, dynamic> json) =>
    _OrderSpecificData(
      clientId: json['clientId'] as String?,
      carId: json['carId'] as String?,
      description: json['description'] as String?,
    );

Map<String, dynamic> _$OrderSpecificDataToJson(_OrderSpecificData instance) =>
    <String, dynamic>{
      'clientId': instance.clientId,
      'carId': instance.carId,
      'description': instance.description,
    };

```

## lib\features\documents\orders\models\order_status.dart
```dart

```

## lib\features\documents\orders\models\part_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'part_specific_data.freezed.dart';
part 'part_specific_data.g.dart';

/// Данные, специфичные для Запчасти в Заказ-наряде
@freezed
abstract class PartSpecificData with _$PartSpecificData {
  const factory PartSpecificData({
    required String documentUuid, // ID родительского документа
    required String partNumber,
    String? brand,
    String? supplierName,
    int? deliveryDays,
    @Default(false) bool isOrdered,
    @Default(false) bool isReceived,
  }) = _PartSpecificData;

  factory PartSpecificData.fromJson(Map<String, dynamic> json) =>
      _$PartSpecificDataFromJson(json);
}

```

## lib\features\documents\orders\models\part_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'part_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PartSpecificData {
  String get documentUuid; // ID родительского документа
  String get partNumber;
  String? get brand;
  String? get supplierName;
  int? get deliveryDays;
  bool get isOrdered;
  bool get isReceived;

  /// Create a copy of PartSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartSpecificDataCopyWith<PartSpecificData> get copyWith =>
      _$PartSpecificDataCopyWithImpl<PartSpecificData>(
          this as PartSpecificData, _$identity);

  /// Serializes this PartSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PartSpecificData &&
            (identical(other.documentUuid, documentUuid) ||
                other.documentUuid == documentUuid) &&
            (identical(other.partNumber, partNumber) ||
                other.partNumber == partNumber) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.supplierName, supplierName) ||
                other.supplierName == supplierName) &&
            (identical(other.deliveryDays, deliveryDays) ||
                other.deliveryDays == deliveryDays) &&
            (identical(other.isOrdered, isOrdered) ||
                other.isOrdered == isOrdered) &&
            (identical(other.isReceived, isReceived) ||
                other.isReceived == isReceived));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, documentUuid, partNumber, brand,
      supplierName, deliveryDays, isOrdered, isReceived);

  @override
  String toString() {
    return 'PartSpecificData(documentUuid: $documentUuid, partNumber: $partNumber, brand: $brand, supplierName: $supplierName, deliveryDays: $deliveryDays, isOrdered: $isOrdered, isReceived: $isReceived)';
  }
}

/// @nodoc
abstract mixin class $PartSpecificDataCopyWith<$Res> {
  factory $PartSpecificDataCopyWith(
          PartSpecificData value, $Res Function(PartSpecificData) _then) =
      _$PartSpecificDataCopyWithImpl;
  @useResult
  $Res call(
      {String documentUuid,
      String partNumber,
      String? brand,
      String? supplierName,
      int? deliveryDays,
      bool isOrdered,
      bool isReceived});
}

/// @nodoc
class _$PartSpecificDataCopyWithImpl<$Res>
    implements $PartSpecificDataCopyWith<$Res> {
  _$PartSpecificDataCopyWithImpl(this._self, this._then);

  final PartSpecificData _self;
  final $Res Function(PartSpecificData) _then;

  /// Create a copy of PartSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentUuid = null,
    Object? partNumber = null,
    Object? brand = freezed,
    Object? supplierName = freezed,
    Object? deliveryDays = freezed,
    Object? isOrdered = null,
    Object? isReceived = null,
  }) {
    return _then(_self.copyWith(
      documentUuid: null == documentUuid
          ? _self.documentUuid
          : documentUuid // ignore: cast_nullable_to_non_nullable
              as String,
      partNumber: null == partNumber
          ? _self.partNumber
          : partNumber // ignore: cast_nullable_to_non_nullable
              as String,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      supplierName: freezed == supplierName
          ? _self.supplierName
          : supplierName // ignore: cast_nullable_to_non_nullable
              as String?,
      deliveryDays: freezed == deliveryDays
          ? _self.deliveryDays
          : deliveryDays // ignore: cast_nullable_to_non_nullable
              as int?,
      isOrdered: null == isOrdered
          ? _self.isOrdered
          : isOrdered // ignore: cast_nullable_to_non_nullable
              as bool,
      isReceived: null == isReceived
          ? _self.isReceived
          : isReceived // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PartSpecificData implements PartSpecificData {
  const _PartSpecificData(
      {required this.documentUuid,
      required this.partNumber,
      this.brand,
      this.supplierName,
      this.deliveryDays,
      this.isOrdered = false,
      this.isReceived = false});
  factory _PartSpecificData.fromJson(Map<String, dynamic> json) =>
      _$PartSpecificDataFromJson(json);

  @override
  final String documentUuid;
// ID родительского документа
  @override
  final String partNumber;
  @override
  final String? brand;
  @override
  final String? supplierName;
  @override
  final int? deliveryDays;
  @override
  @JsonKey()
  final bool isOrdered;
  @override
  @JsonKey()
  final bool isReceived;

  /// Create a copy of PartSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartSpecificDataCopyWith<_PartSpecificData> get copyWith =>
      __$PartSpecificDataCopyWithImpl<_PartSpecificData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PartSpecificData &&
            (identical(other.documentUuid, documentUuid) ||
                other.documentUuid == documentUuid) &&
            (identical(other.partNumber, partNumber) ||
                other.partNumber == partNumber) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.supplierName, supplierName) ||
                other.supplierName == supplierName) &&
            (identical(other.deliveryDays, deliveryDays) ||
                other.deliveryDays == deliveryDays) &&
            (identical(other.isOrdered, isOrdered) ||
                other.isOrdered == isOrdered) &&
            (identical(other.isReceived, isReceived) ||
                other.isReceived == isReceived));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, documentUuid, partNumber, brand,
      supplierName, deliveryDays, isOrdered, isReceived);

  @override
  String toString() {
    return 'PartSpecificData(documentUuid: $documentUuid, partNumber: $partNumber, brand: $brand, supplierName: $supplierName, deliveryDays: $deliveryDays, isOrdered: $isOrdered, isReceived: $isReceived)';
  }
}

/// @nodoc
abstract mixin class _$PartSpecificDataCopyWith<$Res>
    implements $PartSpecificDataCopyWith<$Res> {
  factory _$PartSpecificDataCopyWith(
          _PartSpecificData value, $Res Function(_PartSpecificData) _then) =
      __$PartSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String documentUuid,
      String partNumber,
      String? brand,
      String? supplierName,
      int? deliveryDays,
      bool isOrdered,
      bool isReceived});
}

/// @nodoc
class __$PartSpecificDataCopyWithImpl<$Res>
    implements _$PartSpecificDataCopyWith<$Res> {
  __$PartSpecificDataCopyWithImpl(this._self, this._then);

  final _PartSpecificData _self;
  final $Res Function(_PartSpecificData) _then;

  /// Create a copy of PartSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? documentUuid = null,
    Object? partNumber = null,
    Object? brand = freezed,
    Object? supplierName = freezed,
    Object? deliveryDays = freezed,
    Object? isOrdered = null,
    Object? isReceived = null,
  }) {
    return _then(_PartSpecificData(
      documentUuid: null == documentUuid
          ? _self.documentUuid
          : documentUuid // ignore: cast_nullable_to_non_nullable
              as String,
      partNumber: null == partNumber
          ? _self.partNumber
          : partNumber // ignore: cast_nullable_to_non_nullable
              as String,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      supplierName: freezed == supplierName
          ? _self.supplierName
          : supplierName // ignore: cast_nullable_to_non_nullable
              as String?,
      deliveryDays: freezed == deliveryDays
          ? _self.deliveryDays
          : deliveryDays // ignore: cast_nullable_to_non_nullable
              as int?,
      isOrdered: null == isOrdered
          ? _self.isOrdered
          : isOrdered // ignore: cast_nullable_to_non_nullable
              as bool,
      isReceived: null == isReceived
          ? _self.isReceived
          : isReceived // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

// dart format on

```

## lib\features\documents\orders\models\part_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'part_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PartSpecificData _$PartSpecificDataFromJson(Map<String, dynamic> json) =>
    _PartSpecificData(
      documentUuid: json['documentUuid'] as String,
      partNumber: json['partNumber'] as String,
      brand: json['brand'] as String?,
      supplierName: json['supplierName'] as String?,
      deliveryDays: (json['deliveryDays'] as num?)?.toInt(),
      isOrdered: json['isOrdered'] as bool? ?? false,
      isReceived: json['isReceived'] as bool? ?? false,
    );

Map<String, dynamic> _$PartSpecificDataToJson(_PartSpecificData instance) =>
    <String, dynamic>{
      'documentUuid': instance.documentUuid,
      'partNumber': instance.partNumber,
      'brand': instance.brand,
      'supplierName': instance.supplierName,
      'deliveryDays': instance.deliveryDays,
      'isOrdered': instance.isOrdered,
      'isReceived': instance.isReceived,
    };

```

## lib\features\documents\orders\models\service_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'service_specific_data.freezed.dart';
part 'service_specific_data.g.dart';

/// Данные, специфичные для Услуги в Заказ-наряде
@freezed
abstract class ServiceSpecificData with _$ServiceSpecificData {
  const factory ServiceSpecificData({
    required String documentUuid, // ID родительского документа
    double? duration, // Продолжительность в часах
    String? performedBy, // Исполнитель
    String? description,
    // Можно добавить другие специфичные поля для услуг
  }) = _ServiceSpecificData;

  factory ServiceSpecificData.fromJson(Map<String, dynamic> json) =>
      _$ServiceSpecificDataFromJson(json);
}

```

## lib\features\documents\orders\models\service_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'service_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ServiceSpecificData {
  String get documentUuid; // ID родительского документа
  double? get duration; // Продолжительность в часах
  String? get performedBy; // Исполнитель
  String? get description;

  /// Create a copy of ServiceSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ServiceSpecificDataCopyWith<ServiceSpecificData> get copyWith =>
      _$ServiceSpecificDataCopyWithImpl<ServiceSpecificData>(
          this as ServiceSpecificData, _$identity);

  /// Serializes this ServiceSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ServiceSpecificData &&
            (identical(other.documentUuid, documentUuid) ||
                other.documentUuid == documentUuid) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, documentUuid, duration, performedBy, description);

  @override
  String toString() {
    return 'ServiceSpecificData(documentUuid: $documentUuid, duration: $duration, performedBy: $performedBy, description: $description)';
  }
}

/// @nodoc
abstract mixin class $ServiceSpecificDataCopyWith<$Res> {
  factory $ServiceSpecificDataCopyWith(
          ServiceSpecificData value, $Res Function(ServiceSpecificData) _then) =
      _$ServiceSpecificDataCopyWithImpl;
  @useResult
  $Res call(
      {String documentUuid,
      double? duration,
      String? performedBy,
      String? description});
}

/// @nodoc
class _$ServiceSpecificDataCopyWithImpl<$Res>
    implements $ServiceSpecificDataCopyWith<$Res> {
  _$ServiceSpecificDataCopyWithImpl(this._self, this._then);

  final ServiceSpecificData _self;
  final $Res Function(ServiceSpecificData) _then;

  /// Create a copy of ServiceSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? documentUuid = null,
    Object? duration = freezed,
    Object? performedBy = freezed,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      documentUuid: null == documentUuid
          ? _self.documentUuid
          : documentUuid // ignore: cast_nullable_to_non_nullable
              as String,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as double?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _ServiceSpecificData implements ServiceSpecificData {
  const _ServiceSpecificData(
      {required this.documentUuid,
      this.duration,
      this.performedBy,
      this.description});
  factory _ServiceSpecificData.fromJson(Map<String, dynamic> json) =>
      _$ServiceSpecificDataFromJson(json);

  @override
  final String documentUuid;
// ID родительского документа
  @override
  final double? duration;
// Продолжительность в часах
  @override
  final String? performedBy;
// Исполнитель
  @override
  final String? description;

  /// Create a copy of ServiceSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ServiceSpecificDataCopyWith<_ServiceSpecificData> get copyWith =>
      __$ServiceSpecificDataCopyWithImpl<_ServiceSpecificData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ServiceSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ServiceSpecificData &&
            (identical(other.documentUuid, documentUuid) ||
                other.documentUuid == documentUuid) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, documentUuid, duration, performedBy, description);

  @override
  String toString() {
    return 'ServiceSpecificData(documentUuid: $documentUuid, duration: $duration, performedBy: $performedBy, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$ServiceSpecificDataCopyWith<$Res>
    implements $ServiceSpecificDataCopyWith<$Res> {
  factory _$ServiceSpecificDataCopyWith(_ServiceSpecificData value,
          $Res Function(_ServiceSpecificData) _then) =
      __$ServiceSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String documentUuid,
      double? duration,
      String? performedBy,
      String? description});
}

/// @nodoc
class __$ServiceSpecificDataCopyWithImpl<$Res>
    implements _$ServiceSpecificDataCopyWith<$Res> {
  __$ServiceSpecificDataCopyWithImpl(this._self, this._then);

  final _ServiceSpecificData _self;
  final $Res Function(_ServiceSpecificData) _then;

  /// Create a copy of ServiceSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? documentUuid = null,
    Object? duration = freezed,
    Object? performedBy = freezed,
    Object? description = freezed,
  }) {
    return _then(_ServiceSpecificData(
      documentUuid: null == documentUuid
          ? _self.documentUuid
          : documentUuid // ignore: cast_nullable_to_non_nullable
              as String,
      duration: freezed == duration
          ? _self.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as double?,
      performedBy: freezed == performedBy
          ? _self.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\documents\orders\models\service_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'service_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ServiceSpecificData _$ServiceSpecificDataFromJson(Map<String, dynamic> json) =>
    _ServiceSpecificData(
      documentUuid: json['documentUuid'] as String,
      duration: (json['duration'] as num?)?.toDouble(),
      performedBy: json['performedBy'] as String?,
      description: json['description'] as String?,
    );

Map<String, dynamic> _$ServiceSpecificDataToJson(
        _ServiceSpecificData instance) =>
    <String, dynamic>{
      'documentUuid': instance.documentUuid,
      'duration': instance.duration,
      'performedBy': instance.performedBy,
      'description': instance.description,
    };

```

## lib\features\documents\orders\notifiers\order_form_notifier.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/service_locator.dart'; // Временно оставим для логгера
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/documents/orders/services/order_service.dart';
import 'package:part_catalog/features/documents/orders/state/order_form_state.dart';
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/clients/services/client_service.dart';
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/services/car_service.dart';
import 'package:collection/collection.dart';
import 'package:intl/intl.dart';

// Предполагаем наличие этих провайдеров
final orderServiceProvider =
    Provider<OrderService>((ref) => locator<OrderService>());
final clientServiceProvider =
    Provider<ClientService>((ref) => locator<ClientService>());
final carServiceProvider = Provider<CarService>((ref) => locator<CarService>());

// Провайдер для нашего Notifier
final orderFormNotifierProvider = StateNotifierProvider.autoDispose
    .family<OrderFormNotifier, OrderFormState, String?>((ref, orderUuid) {
  return OrderFormNotifier(ref, orderUuid);
});

class OrderFormNotifier extends StateNotifier<OrderFormState> {
  final Ref _ref;
  final String? _orderUuid;
  final _logger = AppLoggers.orders; // Используем логгер

  OrderFormNotifier(this._ref, this._orderUuid)
      : super(OrderFormState(isEditMode: _orderUuid != null)) {
    if (state.isEditMode) {
      _loadExistingOrder();
    } else {
      // Устанавливаем дату по умолчанию для нового заказа
      state = state.copyWith(
          scheduledDate: DateTime.now().add(const Duration(days: 1)));
    }
  }

  Future<void> _loadExistingOrder() async {
    state = state.copyWith(isLoading: true, error: null);
    _logger.i('Загрузка заказа для редактирования: $_orderUuid');
    try {
      final orderService = _ref.read(orderServiceProvider);
      final clientService = _ref.read(clientServiceProvider);
      final carService = _ref.read(carServiceProvider);

      final order = await orderService.getOrderByUuid(_orderUuid!);
      ClientModelComposite? client;
      CarModelComposite? car;

      if (order.clientId != null) {
        try {
          client = await clientService.getClientByUuid(order.clientId!);
        } catch (e, s) {
          _logger.e('Ошибка загрузки клиента ${order.clientId}',
              error: e, stackTrace: s);
          // Не прерываем загрузку, просто клиент будет null
        }
      }
      if (order.carId != null) {
        try {
          car = await carService.getCarByUuid(order.carId!);
        } catch (e, s) {
          _logger.e('Ошибка загрузки автомобиля ${order.carId}',
              error: e, stackTrace: s);
          // Не прерываем загрузку, просто авто будет null
        }
      }

      state = state.copyWith(
        isLoading: false,
        initialOrder: order,
        selectedClient: client,
        selectedCar: car,
        description: order.description ?? '',
        scheduledDate: order.docData.scheduledDate ??
            state.scheduledDate, // Сохраняем дефолт, если null
        itemsMap: Map.from(order.itemsMap), // Копируем карту
      );
    } catch (e, s) {
      _logger.e('Ошибка загрузки заказ-наряда $_orderUuid или заказ не найден',
          error: e, stackTrace: s);
      state = state.copyWith(isLoading: false, error: e.toString());
      // Ошибка будет отображена в UI
    }
  }

  void updateClient(ClientModelComposite? client) {
    _logger.d('Обновление клиента: ${client?.uuid}');
    // Сбрасываем авто, если клиент изменился или стал null
    final shouldResetCar = state.selectedClient?.uuid != client?.uuid;
    state = state.copyWith(
      selectedClient: client,
      selectedCar: shouldResetCar ? null : state.selectedCar,
    );
  }

  void updateCar(CarModelComposite? car) {
    _logger.d('Обновление автомобиля: ${car?.uuid}');
    state = state.copyWith(selectedCar: car);
  }

  void updateScheduledDate(DateTime date) {
    _logger.d('Обновление даты: $date');
    state = state.copyWith(scheduledDate: date);
  }

  void updateDescription(String description) {
    // Не логируем каждое изменение текста для производительности
    state = state.copyWith(description: description);
  }

  void addItem(IDocumentItemEntity item) {
    _logger.d('Добавление/обновление элемента: ${item.uuid}');
    final newMap = Map<String, IDocumentItemEntity>.from(state.itemsMap);
    newMap[item.uuid] = item;
    state = state.copyWith(itemsMap: newMap);
  }

  void removeItem(String itemUuid) {
    _logger.d('Удаление элемента: $itemUuid');
    final newMap = Map<String, IDocumentItemEntity>.from(state.itemsMap);
    newMap.remove(itemUuid);
    state = state.copyWith(itemsMap: newMap);
  }

  Future<bool> saveOrder() async {
    if (state.selectedClient == null || state.selectedCar == null) {
      state = state.copyWith(
          error:
              "Клиент и автомобиль должны быть выбраны"); // TODO: Локализовать
      return false;
    }

    state = state.copyWith(isSaving: true, error: null);
    _logger.i(state.isEditMode
        ? 'Сохранение изменений заказа: $_orderUuid'
        : 'Создание нового заказа');

    try {
      final orderService = _ref.read(orderServiceProvider);
      final Map<BaseItemType, List<IDocumentItemEntity>> groupedItemsMap =
          state.itemsMap.values.groupListsBy((item) => item.itemType);

      OrderModelComposite orderToSave;

      if (state.isEditMode) {
        orderToSave = state.initialOrder!
            .withClient(state.selectedClient!.uuid)
            .withCar(state.selectedCar!.uuid)
            .withDescription(state.description)
            .withScheduledDate(
                state.scheduledDate!) // Дата не может быть null здесь
            .withItems(groupedItemsMap);
      } else {
        orderToSave = OrderModelComposite.create(
          code: 'ЗН-${DateTime.now().millisecondsSinceEpoch}',
          displayName:
              'Заказ-наряд от ${DateFormat('dd.MM.yy').format(DateTime.now())}',
          documentDate: DateTime.now(),
          clientId: state.selectedClient!.uuid,
          carId: state.selectedCar!.uuid,
          description: state.description,
          scheduledDate: state.scheduledDate!, // Дата не может быть null здесь
          itemsMap: groupedItemsMap,
        );
      }

      if (state.isEditMode) {
        await orderService.updateOrder(orderToSave);
        _logger.i('Заказ ${orderToSave.uuid} успешно обновлен.');
      } else {
        await orderService.createOrder(orderToSave);
        _logger.i('Новый заказ ${orderToSave.uuid} успешно создан.');
      }

      state = state.copyWith(isSaving: false);
      return true; // Успех
    } catch (e, s) {
      _logger.e('Ошибка сохранения заказ-наряда', error: e, stackTrace: s);
      state = state.copyWith(isSaving: false, error: e.toString());
      return false; // Ошибка
    }
  }
}

```

## lib\features\documents\orders\notifiers\orders_notifier.dart
```dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart'; // Для OrderService
import 'package:part_catalog/core/providers/core_providers.dart'; // Для appLoggerProvider
import 'package:part_catalog/core/service_locator.dart'; // Для OrderService
import 'package:part_catalog/core/utils/log_messages.dart';
import 'package:part_catalog/features/core/document_status.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/documents/orders/services/order_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'orders_notifier.g.dart';

// Провайдер для OrderService (если еще не определен глобально)
// Если он уже есть в service_locator или другом файле провайдеров, этот можно удалить
@Riverpod(keepAlive: true)
OrderService orderService(Ref ref) {
  // Предполагаем, что AppDatabase доступна через другой провайдер или locator
  //final db =
  //    ref.watch(appDatabaseProvider); // Пример, если есть appDatabaseProvider
  final db = locator<AppDatabase>(); // Или через locator
  return OrderService(db);
}

// Состояние для Notifier'а, включающее фильтры
class OrdersState {
  final AsyncValue<List<OrderModelComposite>> orders;
  final String? searchQuery;
  final DocumentStatus? filterStatus;

  OrdersState({
    this.orders = const AsyncValue.loading(),
    this.searchQuery,
    this.filterStatus,
  });

  OrdersState copyWith({
    AsyncValue<List<OrderModelComposite>>? orders,
    String? searchQuery,
    DocumentStatus? filterStatus,
    // Используем nullable для возможности сброса фильтра/поиска
    bool resetSearchQuery = false,
    bool resetFilterStatus = false,
  }) {
    return OrdersState(
      orders: orders ?? this.orders,
      searchQuery: resetSearchQuery ? null : (searchQuery ?? this.searchQuery),
      filterStatus:
          resetFilterStatus ? null : (filterStatus ?? this.filterStatus),
    );
  }
}

// Notifier для управления списком заказов
@riverpod
class OrdersNotifier extends _$OrdersNotifier {
  StreamSubscription? _ordersSubscription;
  List<OrderModelComposite> _allOrders = []; // Кэш всех заказов

  @override
  OrdersState build() {
    _logger.d('OrdersNotifier: Initial build...');
    // Отписываемся от предыдущей подписки, если она есть
    _ordersSubscription?.cancel();

    // Подписываемся на поток заказов из сервиса
    final stream = ref.watch(orderServiceProvider).watchOrders();
    _ordersSubscription = stream.listen(
      (orders) {
        _logger
            .d('OrdersNotifier: Received ${orders.length} orders from stream.');
        _allOrders = orders; // Обновляем кэш
        _applyFiltersAndSearch(); // Применяем фильтры к новым данным
      },
      onError: (error, stackTrace) {
        _logger.e(LogMessages.orderWatchError,
            error: error, stackTrace: stackTrace);
        state = state.copyWith(orders: AsyncValue.error(error, stackTrace));
      },
    );

    // Управление отменой подписки при уничтожении Notifier'а
    ref.onDispose(() {
      _logger.d('OrdersNotifier: Disposing...');
      _ordersSubscription?.cancel();
    });

    // Начальное состояние - загрузка
    return OrdersState();
  }

  // Метод для применения фильтров и поиска к текущему кэшу _allOrders
  void _applyFiltersAndSearch() {
    var filtered = List<OrderModelComposite>.from(_allOrders);

    // Фильтр по статусу
    if (state.filterStatus != null) {
      filtered = filtered
          .where((order) => order.docData.status == state.filterStatus)
          .toList();
    }

    // Поиск
    if (state.searchQuery != null && state.searchQuery!.isNotEmpty) {
      final query = state.searchQuery!.toLowerCase();
      filtered =
          filtered.where((order) => order.containsSearchText(query)).toList();
    }

    // Сортировка
    filtered.sort(
        (a, b) => b.docData.documentDate.compareTo(a.docData.documentDate));

    _logger
        .d('OrdersNotifier: Applied filters. Result count: ${filtered.length}');
    // Обновляем только часть 'orders' в состоянии
    state = state.copyWith(orders: AsyncValue.data(filtered));
  }

  void setFilterStatus(DocumentStatus? status) {
    _logger.d('OrdersNotifier: Setting filter status to $status');
    // Обновляем состояние фильтра и переприменяем фильтры
    state =
        state.copyWith(filterStatus: status, resetFilterStatus: status == null);
    _applyFiltersAndSearch();
  }

  void setSearchQuery(String? query) {
    final effectiveQuery = (query?.isNotEmpty ?? false) ? query : null;
    _logger.d('OrdersNotifier: Setting search query to "$effectiveQuery"');
    // Обновляем состояние поиска и переприменяем фильтры
    state = state.copyWith(
        searchQuery: effectiveQuery, resetSearchQuery: effectiveQuery == null);
    _applyFiltersAndSearch();
  }

  // Логгер получаем через ref
  Logger get _logger => ref.read(ordersLoggerProvider);
}

```

## lib\features\documents\orders\notifiers\orders_notifier.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'orders_notifier.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$orderServiceHash() => r'75f4f2e8b4de651a03dd3c63a136f9231c0d517c';

/// See also [orderService].
@ProviderFor(orderService)
final orderServiceProvider = Provider<OrderService>.internal(
  orderService,
  name: r'orderServiceProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$orderServiceHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef OrderServiceRef = ProviderRef<OrderService>;
String _$ordersNotifierHash() => r'd484b1bb406e42a0417d8fa760f2ce20433c423c';

/// See also [OrdersNotifier].
@ProviderFor(OrdersNotifier)
final ordersNotifierProvider =
    AutoDisposeNotifierProvider<OrdersNotifier, OrdersState>.internal(
  OrdersNotifier.new,
  name: r'ordersNotifierProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$ordersNotifierHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$OrdersNotifier = AutoDisposeNotifier<OrdersState>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

```

## lib\features\documents\orders\providers\order_providers.dart
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/providers/core_providers.dart';
import 'package:part_catalog/core/service_locator.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/documents/orders/services/order_service.dart';
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/clients/providers/client_providers.dart'; // Импорт для clientServiceProvider
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/providers/car_providers.dart'; // Импорт для carServiceProvider

// Провайдер для OrderService (если еще не определен глобально)
// Используем существующий из service_locator
final orderServiceProvider =
    Provider<OrderService>((ref) => locator<OrderService>());

// Провайдер для отслеживания одного заказа по UUID
final orderDetailsStreamProvider = StreamProvider.autoDispose
    .family<OrderModelComposite, String>((ref, orderUuid) {
  final orderService = ref.watch(orderServiceProvider);
  return orderService.watchOrderByUuid(orderUuid);
});

// Провайдер для получения клиента по UUID (если он есть)
final orderClientProvider = FutureProvider.autoDispose
    .family<ClientModelComposite?, String?>((ref, clientUuid) async {
  if (clientUuid == null) {
    return null;
  }
  // Используем существующий clientServiceProvider
  final clientService = ref.watch(clientServiceProvider);
  try {
    return await clientService.getClientByUuid(clientUuid);
  } catch (e) {
    // Логируем ошибку, но возвращаем null, чтобы не ломать UI деталей заказа
    ref
        .read(ordersLoggerProvider)
        .e('Failed to load client $clientUuid', error: e);
    return null;
  }
});

// Провайдер для получения автомобиля по UUID (если он есть)
final orderCarProvider = FutureProvider.autoDispose
    .family<CarModelComposite?, String?>((ref, carUuid) async {
  if (carUuid == null) {
    return null;
  }
  // Используем существующий carServiceProvider
  final carService = ref.watch(carServiceProvider);
  try {
    return await carService.getCarByUuid(carUuid);
  } catch (e) {
    // Логируем ошибку, но возвращаем null
    ref.read(ordersLoggerProvider).e('Failed to load car $carUuid', error: e);
    return null;
  }
});

// Добавим провайдер логгера, если его еще нет глобально
// final appLoggerProvider = Provider.family<Logger, String>((ref, name) => AppLoggers.getLogger(name));

```

## lib\features\documents\orders\screens\order_details_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Импорт Riverpod
import 'package:intl/intl.dart';
import 'package:logger/logger.dart';
// --- Обновленные импорты ---
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
import 'package:part_catalog/features/core/document_status.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_part_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_service_model_composite.dart';
import 'package:part_catalog/features/documents/orders/screens/order_form_screen.dart';
// Импортируем провайдеры
import 'package:part_catalog/features/documents/orders/providers/order_providers.dart';
import 'package:part_catalog/core/providers/core_providers.dart'; // Для appLoggerProvider

// Преобразуем в ConsumerWidget
class OrderDetailsScreen extends ConsumerWidget {
  final String orderUuid;

  const OrderDetailsScreen({
    super.key,
    required this.orderUuid,
  });

  // Удаляем State, initState, dispose

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Добавляем WidgetRef
    final theme = Theme.of(context);
    final t = context.t; // Для краткости
    // Получаем логгер через ref
    final logger = ref.watch(ordersLoggerProvider);

    // Следим за состоянием заказа через провайдер
    final orderAsyncValue = ref.watch(orderDetailsStreamProvider(orderUuid));

    return Scaffold(
      appBar: AppBar(
        title: Text(t.orders.orderDetailsTitle),
        actions: [
          // Кнопки действий будут доступны только после загрузки данных
          orderAsyncValue.when(
            data: (order) {
              if (order.isDeleted) {
                return const SizedBox
                    .shrink(); // Не показывать кнопки, если удалено
              }
              return Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.edit),
                    tooltip: t.common.edit,
                    onPressed: () =>
                        _editOrder(context, order), // Передаем context
                  ),
                  IconButton(
                    icon: const Icon(Icons.delete),
                    tooltip: t.common.delete,
                    onPressed: () => _confirmDelete(context, ref, order,
                        logger), // Передаем context, ref, logger
                  ),
                ],
              );
            },
            loading: () => const Padding(
              // Показываем заглушку во время загрузки
              padding: EdgeInsets.symmetric(horizontal: 16.0),
              child: SizedBox(
                  width: 24,
                  height: 24,
                  child: CircularProgressIndicator(strokeWidth: 2)),
            ),
            error: (_, __) =>
                const SizedBox.shrink(), // Не показываем кнопки при ошибке
          ),
        ],
      ),
      body: orderAsyncValue.when(
        data: (order) {
          if (order.isDeleted) {
            // Отображение, если заказ удален
            return Center(
              child: Text(
                t.orders.orderNotFound, // Или "Заказ удален"
              ),
            );
          }
          // Основной контент экрана
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Заголовок и статус
                _buildHeader(context, order, theme, t), // Передаем context
                const Divider(height: 32),

                // Информация о клиенте и автомобиле
                _buildClientAndCarInfo(
                    context, ref, order, theme, t), // Передаем context, ref
                const Divider(height: 32),

                // Описание проблемы
                if (order.description != null && order.description!.isNotEmpty)
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        t.orders.problemDescription,
                        style: theme.textTheme.titleMedium,
                      ),
                      const SizedBox(height: 8),
                      Text(order.description!), // Уже проверили на null
                      const Divider(height: 32),
                    ],
                  ),

                // Запчасти
                _buildItemsList(context, ref, order, theme, t,
                    BaseItemType.part, logger), // Передаем context, ref, logger
                const SizedBox(height: 24),

                // Работы/услуги
                _buildItemsList(
                    context,
                    ref,
                    order,
                    theme,
                    t,
                    BaseItemType.service,
                    logger), // Передаем context, ref, logger
                const SizedBox(height: 24),

                // Итого и дата
                _buildTotalAndDates(
                    context, order, theme, t), // Передаем context
              ],
            ),
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) {
          logger.e(LogMessages.orderDetailsStreamBuilderError,
              error: error, stackTrace: stackTrace);
          return Center(
            child: Text(
              t.common.dataLoadingError,
              style: const TextStyle(color: Colors.red),
            ),
          );
        },
      ),
      // Нижняя панель с кнопкой действия
      bottomNavigationBar: orderAsyncValue.maybeWhen(
        data: (order) {
          if (order.isDeleted) {
            return const SizedBox.shrink();
          }
          final nextStatusAction = _getNextStatusAction(order.status, t);
          if (nextStatusAction == null) {
            return const SizedBox.shrink(); // Нет доступных действий
          }

          return Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.cardColor,
              boxShadow: [
                BoxShadow(
                  color: Colors.black12,
                  blurRadius: 8,
                  offset: const Offset(0, -2),
                )
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => _changeStatus(
                        context,
                        ref,
                        order,
                        nextStatusAction.status,
                        logger), // Передаем context, ref, logger
                    style: ElevatedButton.styleFrom(
                      backgroundColor: nextStatusAction.color,
                    ),
                    child: Text(nextStatusAction.text),
                  ),
                ),
              ],
            ),
          );
        },
        orElse: () =>
            const SizedBox.shrink(), // Не показывать панель при загрузке/ошибке
      ),
    );
  }

  // --- Методы построения UI (теперь принимают BuildContext) ---

  Widget _buildHeader(BuildContext context, OrderModelComposite order,
      ThemeData theme, Translations t) {
    final dateFormat = DateFormat(
        'dd.MM.yyyy HH:mm', Localizations.localeOf(context).toString());

    // ... остальной код метода без изменений ...
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: Text(
                // Используем code из coreData
                t.orders.orderNumberFormat(number: order.code),
                style: theme.textTheme.headlineSmall,
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                // Используем color из DocumentStatus
                color: order.status.color.withAlpha((255 * 0.2).round()),
                borderRadius: BorderRadius.circular(16),
              ),
              child: Text(
                // Используем displayName из DocumentStatus
                order.status.displayName,
                style: TextStyle(
                  color: order.status.color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        // Используем documentDate из docData
        Text(
          t.orders.createdAtDate(date: dateFormat.format(order.documentDate)),
          style: theme.textTheme.bodyMedium,
        ),
        // Используем scheduledDate из docData
        if (order.docData.scheduledDate != null)
          Text(
            t.orders.scheduledForDate(
                date: dateFormat.format(order.docData.scheduledDate!)),
            style: theme.textTheme.bodyMedium,
          ),
        // Используем completedAt из docData
        if (order.docData.completedAt != null)
          Text(
            t.orders.completedAtDate(
                date: dateFormat.format(order.docData.completedAt!)),
            style: theme.textTheme.bodyMedium,
          ),
      ],
    );
  }

  // Используем ref для получения данных клиента/авто через провайдеры
  Widget _buildClientAndCarInfo(BuildContext context, WidgetRef ref,
      OrderModelComposite order, ThemeData theme, Translations t) {
    // Получаем данные клиента через провайдер
    final clientAsyncValue = ref.watch(orderClientProvider(order.clientId));
    // Получаем данные автомобиля через провайдер
    final carAsyncValue = ref.watch(orderCarProvider(order.carId));

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          t.orders.clientInfoTitle,
          style: theme.textTheme.titleMedium,
        ),
        const SizedBox(height: 8),
        // Отображение информации о клиенте
        clientAsyncValue.when(
          data: (client) {
            if (client != null) {
              return ListTile(
                leading: const Icon(Icons.person),
                title: Text(client.displayName),
                subtitle: Text(client.contactInfo), // Пример
                dense: true,
                contentPadding: EdgeInsets.zero,
                // TODO: Добавить onTap для перехода к клиенту
              );
            } else if (order.clientId != null) {
              // Клиент был, но не загрузился
              return ListTile(
                leading:
                    const Icon(Icons.person_off_outlined, color: Colors.grey),
                title: Text(t.clients.clientNotFound,
                    style: const TextStyle(color: Colors.grey)),
                dense: true,
                contentPadding: EdgeInsets.zero,
              );
            } else {
              // Клиент не был выбран
              return ListTile(
                leading:
                    const Icon(Icons.person_off_outlined, color: Colors.grey),
                title: Text(t.clients.clientNotSelected,
                    style: const TextStyle(color: Colors.grey)),
                dense: true,
                contentPadding: EdgeInsets.zero,
              );
            }
          },
          loading: () => ListTile(
            leading: const Icon(Icons.person),
            title: Text(t.orders.loadingClient),
            dense: true,
            contentPadding: EdgeInsets.zero,
          ),
          error: (e, s) => ListTile(
            // Отображаем ошибку загрузки клиента
            leading: const Icon(Icons.error_outline, color: Colors.red),
            title: Text(t.errors.dataLoadingError,
                style: const TextStyle(color: Colors.red)),
            dense: true,
            contentPadding: EdgeInsets.zero,
          ),
        ),

        // Отображение информации об автомобиле
        carAsyncValue.when(
          data: (car) {
            if (car != null) {
              return ListTile(
                leading: const Icon(Icons.directions_car),
                title: Text(car.displayName),
                subtitle:
                    Text('${car.vin} / ${car.displayLicensePlate}'), // Пример
                dense: true,
                contentPadding: EdgeInsets.zero,
                // TODO: Добавить onTap для перехода к автомобилю
              );
            } else if (order.carId != null) {
              // Авто было, но не загрузилось
              return ListTile(
                leading:
                    const Icon(Icons.no_transfer_outlined, color: Colors.grey),
                title: Text(t.vehicles.vehicleNotFound,
                    style: const TextStyle(color: Colors.grey)),
                dense: true,
                contentPadding: EdgeInsets.zero,
              );
            } else {
              // Авто не было выбрано
              return ListTile(
                leading:
                    const Icon(Icons.no_transfer_outlined, color: Colors.grey),
                title: Text(t.vehicles.vehicleNotSelected,
                    style: const TextStyle(color: Colors.grey)),
                dense: true,
                contentPadding: EdgeInsets.zero,
              );
            }
          },
          loading: () => ListTile(
            leading: const Icon(Icons.directions_car),
            title: Text(t.orders.loadingVehicle),
            dense: true,
            contentPadding: EdgeInsets.zero,
          ),
          error: (e, s) => ListTile(
            // Отображаем ошибку загрузки авто
            leading: const Icon(Icons.error_outline, color: Colors.red),
            title: Text(t.errors.dataLoadingError,
                style: const TextStyle(color: Colors.red)),
            dense: true,
            contentPadding: EdgeInsets.zero,
          ),
        ),
      ],
    );
  }

  Widget _buildItemsList(
      BuildContext context,
      WidgetRef ref,
      OrderModelComposite order,
      ThemeData theme,
      Translations t,
      BaseItemType itemType,
      Logger logger) {
    // Добавляем ref, logger
    final currencyFormat = NumberFormat.currency(
      locale: Localizations.localeOf(context).toString(),
      symbol: '₽', // TODO: Сделать символ валюты настраиваемым
      decimalDigits: 2,
    );

    final items = order.getItemsByType(itemType);
    final String title = itemType == BaseItemType.part
        ? t.orders.partsList
        : t.orders.servicesList;
    final String noItemsText = itemType == BaseItemType.part
        ? t.orders.noPartsAdded
        : t.orders.noServicesAdded;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              title,
              style: theme.textTheme.titleMedium,
            ),
            TextButton.icon(
              icon: const Icon(Icons.add, size: 18),
              label: Text(t.common.add),
              onPressed: () => itemType == BaseItemType.part
                  ? _addPart(context, order, logger) // Передаем context, logger
                  : _addService(
                      context, order, logger), // Передаем context, logger
            ),
          ],
        ),
        const SizedBox(height: 8),
        if (items.isEmpty)
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16),
            child: Center(
              child: Text(noItemsText, style: theme.textTheme.bodySmall),
            ),
          )
        else
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: items.length,
            itemBuilder: (context, index) {
              final item = items[index];
              // Передаем context, ref, logger в _buildItemTile
              return _buildItemTile(
                  context, ref, order, item, currencyFormat, theme, t, logger);
            },
          ),
      ],
    );
  }

  Widget _buildItemTile(
      BuildContext context,
      WidgetRef ref,
      OrderModelComposite order,
      IDocumentItemEntity item,
      NumberFormat currencyFormat,
      ThemeData theme,
      Translations t,
      Logger logger) {
    // Добавляем ref, logger
    final title = item.name;
    final subtitle = item is OrderPartModelComposite
        ? '${item.partNumber}${item.brand != null ? ' (${item.brand})' : ''}'
        : (item as OrderServiceModelComposite).description ??
            ''; // Описание услуги
    final quantity = item.quantity ?? 1.0;
    final price = item.price ?? 0.0;
    final total = item.totalPrice ?? 0.0;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              currencyFormat.format(total),
              style: theme.textTheme.bodyLarge
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
            if (quantity != 1.0 || price != total)
              Text(
                // Заменяем t.locale на Localizations.localeOf(context).toString()
                '${NumberFormat.decimalPatternDigits(locale: Localizations.localeOf(context).toString(), decimalDigits: 2).format(quantity)} x ${currencyFormat.format(price)}',
                style: theme.textTheme.bodySmall,
              ),
          ],
        ),
        leading: item is OrderPartModelComposite
            ? _buildPartStatusChip(item, t)
            : _buildServiceStatusChip(item as OrderServiceModelComposite, t),
        onTap: () =>
            _editItem(context, order, item, logger), // Передаем context, logger
        onLongPress: () => _confirmRemoveItem(context, ref, order, item, t,
            logger), // Передаем context, ref, logger
      ),
    );
  }

  // _buildPartStatusChip и _buildServiceStatusChip остаются без изменений

  Widget _buildPartStatusChip(OrderPartModelComposite part, Translations t) {
    IconData icon;
    Color color;
    String label;

    if (part.isReceived) {
      icon = Icons.check_circle;
      color = Colors.green;
      label = t.parts.statusReceived;
    } else if (part.isOrdered) {
      icon = Icons.local_shipping;
      color = Colors.orange;
      label = t.parts.statusOrdered;
    } else {
      icon = Icons.hourglass_empty;
      color = Colors.grey;
      label = t.parts.statusNotOrdered;
    }

    return Tooltip(
      message: label,
      child: Icon(icon, color: color, size: 20),
    );
  }

  Widget _buildServiceStatusChip(
      OrderServiceModelComposite service, Translations t) {
    IconData icon;
    Color color;
    String label;

    if (service.isCompleted) {
      icon = Icons.check_circle;
      color = Colors.green;
      label = t.services.statusCompleted;
    } else {
      icon = Icons.build_circle_outlined;
      color = Colors.grey;
      label = t.services.statusNotCompleted;
    }
    return Tooltip(
      message: label,
      child: Icon(icon, color: color, size: 20),
    );
  }

  Widget _buildTotalAndDates(BuildContext context, OrderModelComposite order,
      ThemeData theme, Translations t) {
    final currencyFormat = NumberFormat.currency(
      locale: Localizations.localeOf(context).toString(),
      symbol: '₽',
      decimalDigits: 2,
    );
    final dateFormat = DateFormat(
        'dd.MM.yyyy HH:mm', Localizations.localeOf(context).toString());

    // Расчет общей суммы
    final totalAmount = order.items
        .fold<double>(0.0, (sum, item) => sum + (item.totalPrice ?? 0.0));

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            Text(
              t.orders.totalAmount,
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(width: 16),
            Text(
              currencyFormat.format(totalAmount),
              style: theme.textTheme.titleLarge
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
          ],
        ),
        const SizedBox(height: 16),
        // Используем documentDate из docData
        Text(
          '${t.common.createdAt}: ${dateFormat.format(order.documentDate)}',
          style: theme.textTheme.bodySmall,
        ),
        // Используем modifiedAt из coreData
        if (order.modifiedAt != null)
          Text(
            '${t.common.modifiedAt}: ${dateFormat.format(order.modifiedAt!)}',
            style: theme.textTheme.bodySmall,
          ),
      ],
    );
  }

  // --- Методы действий (теперь принимают BuildContext и WidgetRef) ---

  void _editOrder(BuildContext context, OrderModelComposite order) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => OrderFormScreen(orderUuid: order.uuid),
      ),
    );
  }

  Future<void> _confirmDelete(BuildContext context, WidgetRef ref,
      OrderModelComposite order, Logger logger) async {
    // Получаем сервис через ref
    final orderService = ref.read(orderServiceProvider);
    // Store BuildContext-dependent variables before the async gap.
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final navigator = Navigator.of(context);
    final currentContext = context; // Capture context if needed for t
    final t = currentContext.t; // Use captured context for t

    final confirmed = await showDialog<bool>(
      context: currentContext, // Use captured context
      builder: (context) => AlertDialog(
        title: Text(t.common.confirmationTitle),
        content: Text(t.orders.confirmOrderDeletion),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(t.common.cancel),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(t.common.delete,
                style: const TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );

    // Check mounted after the first await - В ConsumerWidget нет mounted, проверка не нужна
    if (confirmed == true) {
      try {
        await orderService.deleteOrder(order.uuid);

        // Check mounted again - не нужно

        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(t.orders.orderDeletedSuccess),
            backgroundColor: Colors.green,
          ),
        );
        // Закрыть экран после удаления
        navigator.pop(); // Use captured navigator
      } catch (e, s) {
        logger.e(
            LogMessages.orderDeleteErrorDetails
                .replaceAll('{uuid}', order.uuid),
            error: e,
            stackTrace: s);

        // Check mounted in the catch block - не нужно

        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(t.orders.orderDeleteError),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _changeStatus(
      BuildContext context,
      WidgetRef ref,
      OrderModelComposite order,
      DocumentStatus nextStatus,
      Logger logger) async {
    // Store BuildContext-dependent variables before the async gap.
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final currentContext = context; // Capture context if needed for t
    final t = currentContext.t; // Use captured context for t

    // Получаем сервис через ref
    final orderService = ref.read(orderServiceProvider);
    try {
      await orderService.changeOrderStatus(order.uuid, nextStatus);
      // Сообщение об успехе не показываем, т.к. UI обновится через Stream
    } catch (e, s) {
      logger.e(
          LogMessages.orderStatusChangeErrorDetails
              .replaceAll('{uuid}', order.uuid)
              .replaceAll('{status}', nextStatus.toString()),
          error: e,
          stackTrace: s);
      // Check mounted - не нужно в ConsumerWidget
      // Используем сохраненный scaffoldMessenger
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(t.orders.statusChangeError),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  // TODO: Реализовать навигацию или диалоги для добавления/редактирования
  void _addPart(
      BuildContext context, OrderModelComposite order, Logger logger) {
    logger.w(LogMessages.orderAddPartNotImplemented);
    // Navigator.push(context, MaterialPageRoute(builder: (_) => PartFormScreen(orderUuid: order.uuid)));
    final t = context.t;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(t.common
            .featureNotImplemented(featureName: t.orders.addPartFeature))));
  }

  void _addService(
      BuildContext context, OrderModelComposite order, Logger logger) {
    logger.w(LogMessages.orderAddServiceNotImplemented);
    // Navigator.push(context, MaterialPageRoute(builder: (_) => ServiceFormScreen(orderUuid: order.uuid)));
    final t = context.t;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(t.common
            .featureNotImplemented(featureName: t.orders.addServiceFeature))));
  }

  void _editItem(BuildContext context, OrderModelComposite order,
      IDocumentItemEntity item, Logger logger) {
    logger.w(LogMessages.orderEditItemNotImplemented
        .replaceAll('{runtimeType}', item.runtimeType.toString()));
    final t = context.t;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(t.common
            .editingNotImplemented(itemType: item.runtimeType.toString()))));
    // if (item is OrderPartModelComposite) {
    //   Navigator.push(context, MaterialPageRoute(builder: (_) => PartFormScreen(orderUuid: order.uuid, partUuid: item.uuid)));
    // } else if (item is OrderServiceModelComposite) {
    //   Navigator.push(context, MaterialPageRoute(builder: (_) => ServiceFormScreen(orderUuid: order.uuid, serviceUuid: item.uuid)));
    // }
  }

  Future<void> _confirmRemoveItem(
      BuildContext context,
      WidgetRef ref,
      OrderModelComposite order,
      IDocumentItemEntity item,
      Translations t,
      Logger logger) async {
    // Получаем сервис через ref
    final orderService = ref.read(orderServiceProvider);
    // Store BuildContext-dependent variables before the async gap.
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final currentContext = context; // Capture context if needed for t

    final String confirmationText = item is OrderPartModelComposite
        ? t.orders.confirmPartDeletion(name: item.name)
        : t.orders.confirmServiceDeletion(name: item.name);

    final confirmed = await showDialog<bool>(
      context: currentContext, // Use captured context
      builder: (context) => AlertDialog(
        title: Text(t.common.confirmationTitle),
        content: Text(confirmationText),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(t.common.cancel),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(t.common.remove,
                style: const TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );

    // Check mounted - не нужно
    if (confirmed == true) {
      try {
        await orderService.removeItemFromOrder(item.uuid, order.uuid);

        // Check mounted - не нужно

        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(item is OrderPartModelComposite
                ? t.orders.partRemovedSuccess
                : t.orders.serviceRemovedSuccess),
            backgroundColor: Colors.green,
          ),
        );
      } catch (e, s) {
        logger.e(
            LogMessages.orderRemoveItemErrorDetails
                .replaceAll('{itemUuid}', item.uuid)
                .replaceAll('{orderUuid}', order.uuid),
            error: e,
            stackTrace: s);

        // Check mounted - не нужно

        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(item is OrderPartModelComposite
                ? t.orders.partRemoveError
                : t.orders.serviceRemoveError),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // --- Вспомогательные функции (остаются без изменений) ---

  ({String text, Color color, DocumentStatus status})? _getNextStatusAction(
      DocumentStatus currentStatus, Translations t) {
    switch (currentStatus) {
      case DocumentStatus.newDoc:
        return (
          text: t.orders.startWorkAction,
          color: Colors.orange,
          status: DocumentStatus.inProgress
        );
      case DocumentStatus.inProgress:
        // TODO: Добавить логику проверки ожидания запчастей
        return (
          text: t.orders.markReadyAction,
          color: Colors.teal,
          status: DocumentStatus.readyForPickup
        );
      case DocumentStatus.waitingForParts:
        return (
          text: t.orders.resumeWorkAction,
          color: Colors.orange,
          status: DocumentStatus.inProgress
        );
      case DocumentStatus.readyForPickup:
        return (
          text: t.orders.completeOrderAction,
          color: Colors.green,
          status: DocumentStatus.completed
        );
      case DocumentStatus.completed:
      case DocumentStatus.cancelled:
      case DocumentStatus
            .posted: // Считаем проведенный завершенным для UI действий
      case DocumentStatus.unknown:
        return null; // Нет действий для этих статусов
    }
  }
}

```

## lib\features\documents\orders\screens\order_form_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Импорт Riverpod
import 'package:intl/intl.dart';
// --- Обновленные импорты ---
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:part_catalog/features/documents/orders/models/order_part_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_service_model_composite.dart';
// Импортируем Notifier и State
import 'package:part_catalog/features/documents/orders/notifiers/order_form_notifier.dart';
import 'package:part_catalog/features/documents/orders/state/order_form_state.dart';
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
import 'package:part_catalog/core/utils/logger_config.dart';

// Преобразуем в ConsumerStatefulWidget
class OrderFormScreen extends ConsumerStatefulWidget {
  final String? orderUuid;

  const OrderFormScreen({super.key, this.orderUuid});

  @override
  ConsumerState<OrderFormScreen> createState() => _OrderFormScreenState();
}

// Преобразуем State в ConsumerState
class _OrderFormScreenState extends ConsumerState<OrderFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _descriptionController = TextEditingController();
  final _logger = AppLoggers.orders;

  // Notifier provider instance specific to this screen/orderUuid
  // Используем правильный тип AutoDisposeStateNotifierProvider
  late final AutoDisposeStateNotifierProvider<OrderFormNotifier, OrderFormState>
      _provider;

  @override
  void initState() {
    super.initState();
    _provider = orderFormNotifierProvider(widget.orderUuid);

    // Синхронизируем контроллер описания с состоянием Notifier'а
    // Слушаем изменения в Notifier'е, чтобы обновить контроллер, если нужно
    // (например, при загрузке существующих данных)
    ref.listenManual<OrderFormState>(_provider, (previous, next) {
      if (previous?.description != next.description) {
        // Проверяем, чтобы не вызывать setState во время build
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted && _descriptionController.text != next.description) {
            _descriptionController.text = next.description;
          }
        });
      }
      // Показываем ошибки из Notifier'а
      if (previous?.error != next.error && next.error != null) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            _showErrorSnackBar(next.error!);
          }
        });
      }
    });

    // Обновляем состояние Notifier'а при изменении текста в контроллере
    _descriptionController.addListener(() {
      ref
          .read(_provider.notifier)
          .updateDescription(_descriptionController.text);
    });
  }

  @override
  void dispose() {
    _descriptionController.dispose();
    super.dispose();
  }

  // --- Методы для выбора клиента, авто, даты и управления элементами ---
  // Теперь они вызывают методы Notifier'а

  Future<void> _selectClient() async {
    final client = await showDialog<ClientModelComposite>(
      context: context,
      builder: (context) => _ClientSelectionDialog(), // Заглушка
    );
    if (client != null && mounted) {
      ref.read(_provider.notifier).updateClient(client);
    }
  }

  Future<void> _selectCar(String clientUuid) async {
    final car = await showDialog<CarModelComposite>(
      context: context,
      builder: (context) =>
          _CarSelectionDialog(clientUuid: clientUuid), // Заглушка
    );
    if (car != null && mounted) {
      ref.read(_provider.notifier).updateCar(car);
    }
  }

  Future<void> _selectDate(DateTime initialDate) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: initialDate,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && mounted) {
      final currentTime = TimeOfDay.now();
      final newDateTime = DateTime(picked.year, picked.month, picked.day,
          currentTime.hour, currentTime.minute);
      ref.read(_provider.notifier).updateScheduledDate(newDateTime);
    }
  }

  Future<void> _manageService(
      {OrderServiceModelComposite? existingService}) async {
    final service = await showDialog<OrderServiceModelComposite>(
      context: context,
      builder: (context) =>
          _ServiceFormDialog(service: existingService), // Заглушка
    );
    if (service != null && mounted) {
      ref.read(_provider.notifier).addItem(service);
    }
  }

  Future<void> _managePart({OrderPartModelComposite? existingPart}) async {
    final part = await showDialog<OrderPartModelComposite>(
      context: context,
      builder: (context) => _PartFormDialog(part: existingPart), // Заглушка
    );
    if (part != null && mounted) {
      ref.read(_provider.notifier).addItem(part);
    }
  }

  void _removeItem(String itemUuid) {
    final t = context.t;
    final item = ref.read(_provider).itemsMap[itemUuid];
    if (item == null) return;

    ref.read(_provider.notifier).removeItem(itemUuid);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
          content: Text(item is OrderPartModelComposite
              ? t.orders.partRemovedSuccess
              : t.orders.serviceRemovedSuccess)),
    );
  }

  Future<void> _saveOrder() async {
    final t = context.t;
    if (!_formKey.currentState!.validate()) {
      _logger.w('Форма не прошла валидацию.');
      return;
    }

    final success = await ref.read(_provider.notifier).saveOrder();

    if (mounted && success) {
      final isEditMode = ref.read(_provider).isEditMode;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(isEditMode
                ? t.orders.updatedSuccess
                : t.orders.createdSuccess)),
      );
      Navigator.pop(context, true); // Возвращаем true при успехе
    }
    // Ошибки показываются через ref.listen в initState
  }

  void _showErrorSnackBar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Следим за состоянием Notifier'а
    final formState = ref.watch(_provider);

    final theme = Theme.of(context);
    final t = context.t;
    final dateFormat = DateFormat(
        'dd.MM.yyyy HH:mm', Localizations.localeOf(context).toString());
    final currencyFormat = NumberFormat.currency(
      locale: Localizations.localeOf(context).toString(),
      symbol: '₽',
      decimalDigits: 2,
    );

    final total = formState.itemsMap.values
        .fold<double>(0.0, (sum, item) => sum + (item.totalPrice ?? 0.0));
    final services = formState.itemsMap.values
        .whereType<OrderServiceModelComposite>()
        .toList();
    final parts =
        formState.itemsMap.values.whereType<OrderPartModelComposite>().toList();

    // Показываем индикатор загрузки или ошибку на весь экран
    if (formState.isLoading) {
      return Scaffold(
          appBar: AppBar(
              title: Text(formState.isEditMode
                  ? t.orders.editOrderTitle
                  : t.orders.newOrderTitle)),
          body: const Center(child: CircularProgressIndicator()));
    }
    // Показываем ошибку загрузки начальных данных
    // if (formState.error != null && formState.initialOrder == null && formState.isEditMode) {
    //   return Scaffold(
    //       appBar: AppBar(title: Text(formState.isEditMode ? t.orders.editOrderTitle : t.orders.newOrderTitle)),
    //       body: Center(child: Text('${t.errors.dataLoadingError}: ${formState.error}')));
    // }

    return Scaffold(
      appBar: AppBar(
        title: Text(formState.isEditMode
            ? t.orders.editOrderTitle
            : t.orders.newOrderTitle),
        actions: [
          // Блокируем кнопку сохранения во время сохранения
          if (formState.isSaving)
            const Padding(
              padding: EdgeInsets.only(right: 16.0),
              child: SizedBox(
                  width: 24,
                  height: 24,
                  child: CircularProgressIndicator(strokeWidth: 3)),
            )
          else
            IconButton(
              icon: const Icon(Icons.save),
              tooltip: t.common.saveButtonLabel,
              onPressed: _saveOrder,
            ),
        ],
      ),
      // Не блокируем весь UI во время сохранения, только кнопку
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Секция выбора клиента
              _buildSectionTitle(theme, t.orders.clientInfoTitle),
              ListTile(
                contentPadding: EdgeInsets.zero,
                title: Text(formState.selectedClient?.displayName ??
                    t.orders.selectClientHint),
                leading: const Icon(Icons.person),
                trailing: const Icon(Icons.chevron_right),
                onTap: _selectClient,
                subtitle: formState.selectedClient == null
                    ? Text(t.errors.fieldRequired,
                        style: TextStyle(
                            color: theme.colorScheme.error, fontSize: 12))
                    : null,
              ),
              const Divider(),

              // Секция выбора автомобиля
              _buildSectionTitle(theme, t.orders.vehicleInfoTitle),
              ListTile(
                contentPadding: EdgeInsets.zero,
                title: Text(formState.selectedCar != null
                    ? '${formState.selectedCar!.displayName} (${formState.selectedCar!.displayLicensePlate})'
                    : t.orders.selectVehicleHint),
                leading: const Icon(Icons.directions_car),
                trailing: const Icon(Icons.chevron_right),
                onTap: formState.selectedClient != null
                    ? () => _selectCar(formState.selectedClient!.uuid)
                    : null,
                enabled: formState.selectedClient != null,
                subtitle: formState.selectedCar == null
                    ? Text(t.errors.fieldRequired,
                        style: TextStyle(
                            color: theme.colorScheme.error, fontSize: 12))
                    : null,
              ),
              const Divider(),

              // Секция описания проблемы
              _buildSectionTitle(theme, t.orders.problemDescription),
              TextFormField(
                controller:
                    _descriptionController, // Контроллер обновляет Notifier
                decoration: InputDecoration(
                  hintText: t.orders.problemDescriptionHint,
                  border: const OutlineInputBorder(),
                ),
                maxLines: 3,
              ),
              const SizedBox(height: 16),

              // Секция запланированной даты
              _buildSectionTitle(theme, t.orders.scheduledDate),
              ListTile(
                contentPadding: EdgeInsets.zero,
                // Берем дату из состояния
                title: Text(formState.scheduledDate != null
                    ? dateFormat.format(formState.scheduledDate!)
                    : t.common.selectDate), // Используем slang
                leading: const Icon(Icons.calendar_today),
                trailing: const Icon(Icons.chevron_right),
                onTap: () =>
                    _selectDate(formState.scheduledDate ?? DateTime.now()),
              ),
              const Divider(),

              // Секция услуг
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  _buildSectionTitle(theme, t.orders.servicesList),
                  TextButton.icon(
                    icon: const Icon(Icons.add),
                    label: Text(t.common.add),
                    onPressed: () => _manageService(),
                  ),
                ],
              ),
              if (services.isEmpty)
                _buildEmptyPlaceholder(t.orders.noServicesAdded)
              else
                _buildServicesList(services, currencyFormat, t),
              const Divider(),

              // Секция запчастей
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  _buildSectionTitle(theme, t.orders.partsList),
                  TextButton.icon(
                    icon: const Icon(Icons.add),
                    label: Text(t.common.add),
                    onPressed: () => _managePart(),
                  ),
                ],
              ),
              if (parts.isEmpty)
                _buildEmptyPlaceholder(t.orders.noPartsAdded)
              else
                _buildPartsList(parts, currencyFormat, t),
              const Divider(),

              // Итоговая сумма
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 16.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(t.orders.totalAmount,
                        style: theme.textTheme.headlineSmall),
                    Text(
                      currencyFormat.format(total),
                      style: theme.textTheme.headlineSmall
                          ?.copyWith(fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // --- Методы _build... остаются почти без изменений, ---
  // --- только принимают данные из formState или напрямую ---

  Widget _buildSectionTitle(ThemeData theme, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Text(
        title,
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  Widget _buildEmptyPlaceholder(String message) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: Text(
          message,
          style: TextStyle(
            color: Colors.grey.shade600,
            fontStyle: FontStyle.italic,
          ),
        ),
      ),
    );
  }

  Widget _buildServicesList(List<OrderServiceModelComposite> services,
      NumberFormat currencyFormat, Translations t) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: services.length,
      itemBuilder: (context, index) {
        final service = services[index];
        return Card(
          margin: const EdgeInsets.only(bottom: 8.0),
          child: Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(service.name,
                          style: const TextStyle(fontWeight: FontWeight.bold)),
                    ),
                    IconButton(
                      icon: const Icon(Icons.edit, size: 18),
                      tooltip: t.common.edit,
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                      onPressed: () => _manageService(existingService: service),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.delete, size: 18),
                      tooltip: t.common.remove,
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                      color: Colors.red,
                      onPressed: () => _removeItem(service.uuid),
                    ),
                  ],
                ),
                if (service.description != null &&
                    service.description!.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 4.0),
                    child: Text(service.description!),
                  ),
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      if (service.duration != null)
                        Text('${service.duration} ч.'),
                      Text(
                        currencyFormat.format(service.price ?? 0.0),
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildPartsList(List<OrderPartModelComposite> parts,
      NumberFormat currencyFormat, Translations t) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: parts.length,
      itemBuilder: (context, index) {
        final part = parts[index];
        final totalPartPrice = part.totalPrice ?? 0.0;
        return Card(
          margin: const EdgeInsets.only(bottom: 8.0),
          child: Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(part.name,
                          style: const TextStyle(fontWeight: FontWeight.bold)),
                    ),
                    IconButton(
                      icon: const Icon(Icons.edit, size: 18),
                      tooltip: t.common.edit,
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                      onPressed: () => _managePart(existingPart: part),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.delete, size: 18),
                      tooltip: t.common.remove,
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                      color: Colors.red,
                      onPressed: () => _removeItem(part.uuid),
                    ),
                  ],
                ),
                Text('${t.parts.partNumberLabel}: ${part.partNumber}'),
                if (part.brand != null)
                  Text('${t.parts.brandLabel}: ${part.brand}'),
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                          '${part.quantity ?? 1.0} ${t.parts.pcs} × ${currencyFormat.format(part.price ?? 0.0)}'),
                      Text(
                        currencyFormat.format(totalPartPrice),
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// --- Вспомогательные диалоги (Заглушки - ТРЕБУЮТ АДАПТАЦИИ) ---
// Эти диалоги должны быть переделаны для работы с композиторами
// и возвращать соответствующие композиторы (ClientModelComposite, CarModelComposite и т.д.)
// Возможно, их тоже стоит сделать ConsumerWidget'ами для доступа к сервисам через ref

class _ClientSelectionDialog extends ConsumerWidget {
  // Сделаем ConsumerWidget
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Добавляем ref
    final t = context.t;
    // TODO: Адаптировать для работы с ClientService (через ref) и ClientModelComposite
    // final clientsAsync = ref.watch(activeClientsProvider); // Пример
    return AlertDialog(
      title: Text(t.orders.selectClient),
      content: const Text('Здесь будет список клиентов (ClientModelComposite)'),
      // content: clientsAsync.when(
      //   data: (clients) => ListView.builder(...),
      //   loading: () => CircularProgressIndicator(),
      //   error: (e, s) => Text('Error'),
      // ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(t.common.cancelButtonLabel),
        ),
      ],
    );
  }
}

class _CarSelectionDialog extends ConsumerWidget {
  // Сделаем ConsumerWidget
  final String clientUuid;

  const _CarSelectionDialog({required this.clientUuid});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Добавляем ref
    final t = context.t;
    // TODO: Адаптировать для работы с CarService (через ref) и CarModelComposite, используя clientUuid
    // final carsAsync = ref.watch(carsByClientProvider(clientUuid)); // Пример
    return AlertDialog(
      title: Text(t.orders.selectVehicle),
      content: const Text(
          'Здесь будет список автомобилей клиента (CarModelComposite)'),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(t.common.cancelButtonLabel),
        ),
      ],
    );
  }
}

class _ServiceFormDialog extends ConsumerStatefulWidget {
  // Stateful для формы
  final OrderServiceModelComposite? service;

  const _ServiceFormDialog({this.service});

  @override
  ConsumerState<_ServiceFormDialog> createState() => _ServiceFormDialogState();
}

class _ServiceFormDialogState extends ConsumerState<_ServiceFormDialog> {
  // TODO: Адаптировать форму для создания/редактирования OrderServiceModelComposite
  // final _formKey = GlobalKey<FormState>();
  // late TextEditingController _nameController; ...

  @override
  void initState() {
    super.initState();
    // _nameController = TextEditingController(text: widget.service?.name ?? ''); ...
  }

  @override
  void dispose() {
    // _nameController.dispose(); ...
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final t = context.t;
    return AlertDialog(
      title: Text(
          widget.service == null ? t.orders.addService : t.orders.editService),
      content: const Text('Здесь будет форма для OrderServiceModelComposite'),
      // content: Form(key: _formKey, child: Column(...)),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(t.common.cancelButtonLabel),
        ),
        TextButton(
          onPressed: () {
            // TODO: Валидация, создание/обновление OrderServiceModelComposite
            // if (_formKey.currentState!.validate()) {
            //   final updatedService = OrderServiceModelComposite.create(...); // или widget.service.with...
            //   Navigator.pop(context, updatedService);
            // }
            Navigator.pop(context); // Пока просто закрываем
          },
          child: Text(t.common.saveButtonLabel),
        ),
      ],
    );
  }
}

class _PartFormDialog extends ConsumerStatefulWidget {
  // Stateful для формы
  final OrderPartModelComposite? part;

  const _PartFormDialog({this.part});

  @override
  ConsumerState<_PartFormDialog> createState() => _PartFormDialogState();
}

class _PartFormDialogState extends ConsumerState<_PartFormDialog> {
  // TODO: Адаптировать форму для создания/редактирования OrderPartModelComposite
  // final _formKey = GlobalKey<FormState>(); ...

  @override
  Widget build(BuildContext context) {
    final t = context.t;
    return AlertDialog(
      title: Text(widget.part == null ? t.orders.addPart : t.orders.editPart),
      content: const Text('Здесь будет форма для OrderPartModelComposite'),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(t.common.cancelButtonLabel),
        ),
        TextButton(
          onPressed: () {
            // TODO: Валидация, создание/обновление OrderPartModelComposite
            Navigator.pop(context); // Пока просто закрываем
          },
          child: Text(t.common.saveButtonLabel),
        ),
      ],
    );
  }
}

```

## lib\features\documents\orders\screens\orders_screen.dart
```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Импорт Riverpod
// Импортируем сгенерированный файл slang
import 'package:part_catalog/core/i18n/strings.g.dart';
// Импортируем композитор и статус документа
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/core/document_status.dart';
// Импортируем Notifier
import 'package:part_catalog/features/documents/orders/notifiers/orders_notifier.dart';
import 'package:part_catalog/features/documents/orders/screens/order_form_screen.dart';
import 'package:part_catalog/features/documents/orders/screens/order_details_screen.dart';
import 'package:part_catalog/features/documents/orders/widgets/order_list_item.dart';

// Преобразуем в ConsumerStatefulWidget
class OrdersScreen extends ConsumerStatefulWidget {
  const OrdersScreen({super.key});

  @override
  ConsumerState<OrdersScreen> createState() => _OrdersScreenState();
}

// Преобразуем State в ConsumerState
class _OrdersScreenState extends ConsumerState<OrdersScreen> {
  Timer? _debounce; // Таймер для debounce поиска
  final _searchController = TextEditingController(); // Контроллер для поиска

  @override
  void initState() {
    super.initState();
    // Слушатель для контроллера поиска с debounce
    _searchController.addListener(() {
      if (_debounce?.isActive ?? false) _debounce!.cancel();
      _debounce = Timer(const Duration(milliseconds: 500), () {
        // Вызываем метод Notifier'а для обновления поиска
        ref
            .read(ordersNotifierProvider.notifier)
            .setSearchQuery(_searchController.text);
      });
    });
  }

  @override
  void dispose() {
    _debounce?.cancel();
    _searchController.dispose(); // Не забываем освобождать контроллер
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final t = context.t;
    // Следим за состоянием Notifier'а
    final ordersState = ref.watch(ordersNotifierProvider);
    final notifier = ref.read(ordersNotifierProvider.notifier);

    return Scaffold(
      appBar: AppBar(
        title: Text(t.orders.screenTitle),
        actions: [
          // Кнопка сброса фильтра, если он активен
          if (ordersState.filterStatus != null)
            IconButton(
              icon: const Icon(Icons.filter_alt_off),
              tooltip: t.common.resetFilter,
              onPressed: () => notifier.setFilterStatus(null),
            ),
          IconButton(
            icon: const Icon(Icons.filter_list),
            tooltip: t.common.filter,
            onPressed: () => _showFilterDialog(
                ordersState.filterStatus), // Передаем текущий фильтр
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: TextField(
              controller: _searchController, // Используем контроллер
              decoration: InputDecoration(
                hintText: t.orders.searchByNumberOrClient,
                prefixIcon: const Icon(Icons.search),
                // Добавляем кнопку очистки поиска
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        tooltip: t.common.clear,
                        onPressed: () {
                          _searchController.clear();
                          // Сразу обновляем notifier, т.к. очистка - мгновенное действие
                          // notifier.setSearchQuery(null); // Вызовется через listener контроллера
                        },
                      )
                    : null,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 16),
              ),
              // onChanged убран, т.к. используем listener контроллера
            ),
          ),
          // Отображение активного фильтра
          if (ordersState.filterStatus != null)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
              child: Align(
                alignment: Alignment.centerLeft,
                child: Chip(
                  label: Text(
                      '${t.common.filter}: ${ordersState.filterStatus!.displayName}'),
                  backgroundColor: ordersState.filterStatus!.color
                      .withAlpha((255 * 0.1).round()),
                  onDeleted: () => notifier
                      .setFilterStatus(null), // Вызываем метод Notifier'а
                ),
              ),
            ),
          Expanded(
            // Используем AsyncValue из ordersState
            child: ordersState.orders.when(
              data: (orders) {
                // Отображение, если ничего не найдено после фильтрации/поиска
                if (orders.isEmpty &&
                    (ordersState.searchQuery != null ||
                        ordersState.filterStatus != null)) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.search_off,
                            size: 64, color: Colors.grey),
                        const SizedBox(height: 16),
                        Text(
                          t.common.noResultsFound,
                          style: Theme.of(context).textTheme.titleMedium,
                          textAlign: TextAlign.center,
                        ),
                        // Кнопки сброса фильтров/поиска
                        if (ordersState.filterStatus != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: ActionChip(
                              avatar: const Icon(Icons.close, size: 16),
                              label: Text(
                                  '${t.common.resetFilter}: ${ordersState.filterStatus!.displayName}'),
                              onPressed: () => notifier.setFilterStatus(null),
                            ),
                          ),
                        if (ordersState.searchQuery != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: ActionChip(
                              avatar: const Icon(Icons.close, size: 16),
                              label: Text(
                                  '${t.common.resetSearch}: "${ordersState.searchQuery!}"'),
                              onPressed: () => _searchController
                                  .clear(), // Очищаем контроллер
                            ),
                          ),
                      ],
                    ),
                  );
                }
                // Отображение, если вообще нет заказов (не после фильтрации)
                if (orders.isEmpty &&
                    ordersState.searchQuery == null &&
                    ordersState.filterStatus == null) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.assignment_late_outlined,
                            size: 64, color: Colors.grey),
                        const SizedBox(height: 16),
                        Text(
                          t.orders.noOrdersFound,
                          style: Theme.of(context).textTheme.titleMedium,
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  );
                }

                // Отображение списка
                return ListView.builder(
                  itemCount: orders.length,
                  itemBuilder: (context, index) {
                    final order = orders[index];
                    return OrderListItem(
                      order: order,
                      onTap: () => _openOrderDetails(order),
                    );
                  },
                );
              },
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (error, stackTrace) {
                // Логгер уже сработал в Notifier'е
                return Center(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Text(
                      '${t.errors.dataLoadingError}: $error',
                      style: const TextStyle(color: Colors.red),
                      textAlign: TextAlign.center,
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        tooltip: t.orders.add,
        onPressed: _createNewOrder,
        child: const Icon(Icons.add),
      ),
    );
  }

  // Фильтрация и сортировка теперь выполняются в Notifier'е
  // List<OrderModelComposite> _filterOrders(List<OrderModelComposite> orders) { ... } // <--- Удалить

  // Открытие диалога фильтрации
  void _showFilterDialog(DocumentStatus? currentFilter) {
    // Принимаем текущий фильтр
    final t = context.t;
    final notifier =
        ref.read(ordersNotifierProvider.notifier); // Получаем notifier
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(t.orders.filterByStatus),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView(
            shrinkWrap: true,
            children: [
              for (final status in DocumentStatus.values)
                if (status != DocumentStatus.unknown)
                  RadioListTile<DocumentStatus>(
                    title: Text(status.displayName),
                    value: status,
                    groupValue: currentFilter, // Используем переданный фильтр
                    activeColor: status.color,
                    onChanged: (value) {
                      notifier
                          .setFilterStatus(value); // Вызываем метод Notifier'а
                      Navigator.pop(context);
                    },
                  ),
            ],
          ),
        ),
        actions: [
          TextButton(
            child: Text(t.common.resetButtonLabel),
            onPressed: () {
              notifier.setFilterStatus(null); // Вызываем метод Notifier'а
              Navigator.pop(context);
            },
          ),
          TextButton(
            child: Text(t.common.closeButtonLabel),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }

  // Создание нового заказ-наряда
  void _createNewOrder() async {
    final t = context.t;
    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => const OrderFormScreen(), // orderUuid не передаем
      ),
    );

    if (!mounted) return;

    if (result == true) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(t.orders.createdSuccess)),
      );
      // Список обновится автоматически благодаря подписке Notifier'а на stream
      // ref.invalidate(ordersNotifierProvider); // Можно инвалидировать, если watchOrders не используется
    }
  }

  // Открытие экрана деталей заказ-наряда
  void _openOrderDetails(OrderModelComposite order) {
    Navigator.push(
      context,
      MaterialPageRoute(
        // OrderDetailsScreen должен быть адаптирован для приема orderUuid
        // и использования Riverpod для загрузки данных (например, через FutureProvider.family)
        builder: (context) => OrderDetailsScreen(
          orderUuid: order.coreData.uuid,
        ),
      ),
    );
  }
}

```

## lib\features\documents\orders\services\order_service.dart
```dart
import 'package:part_catalog/core/database/daos/cars_dao.dart';
import 'package:part_catalog/core/database/daos/clients_dao.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/daos/orders_dao.dart'; // Содержит OrderHeaderData, FullOrderItemData, Tuple3
import 'package:part_catalog/core/utils/log_messages.dart';
import 'package:part_catalog/core/utils/logger_config.dart';
// --- Новые импорты ---
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:part_catalog/features/core/document_status.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_part_model_composite.dart';
import 'package:part_catalog/features/documents/orders/models/order_service_model_composite.dart';
// --- Импорты @freezed моделей данных (предполагается, что они существуют) ---
import 'package:part_catalog/features/core/item_core_data.dart';
import 'package:part_catalog/features/core/document_item_specific_data.dart';
// --- Остальные импорты ---
import 'package:rxdart/rxdart.dart';

/// Сервис для работы с заказ-нарядами
///
/// Этот сервис обеспечивает бизнес-логику для операций с заказ-нарядами,
/// работает с бизнес-моделями (композиторами) и преобразует их
/// во/из `@freezed` моделей данных для взаимодействия с DAO.
class OrderService {
  final AppDatabase _database;
  final _logger = AppLoggers.orders;

  /// Получение DAO для работы с заказ-нарядами из базы данных
  OrdersDao get _ordersDao => _database.ordersDao;

  /// Получение DAO для работы с клиентами
  ClientsDao get _clientsDao => _database.clientsDao;

  /// Получение DAO для работы с автомобилями
  CarsDao get _carsDao => _database.carsDao;

  /// Создает экземпляр сервиса заказ-нарядов
  ///
  /// @param database Экземпляр базы данных для доступа к данным
  OrderService(this._database);

  // --- Вспомогательный метод для маппинга данных из DAO в композитор ---
  Future<OrderModelComposite> _mapDataToComposite(String uuid) async {
    // 1. Получить заголовок заказа (@freezed) из DAO
    final headerData = await _ordersDao.getOrderHeaderByUuid(uuid);
    if (headerData == null) {
      // Используем константу
      final errorMsg =
          LogMessages.orderNotFoundByUuid.replaceAll('{uuid}', uuid);
      _logger.e(errorMsg);
      throw Exception(errorMsg);
    }
    final coreData = headerData.coreData;
    final docData = headerData.docData;
    final orderData = headerData.orderData;

    // 2. Получить данные элементов заказа (@freezed) из DAO
    final itemsData =
        await _ordersDao.getOrderItems(uuid); // Используем новый метод
    final Map<BaseItemType, List<IDocumentItemEntity>> itemsMap = {};

    for (final fullItemData in itemsData) {
      // Итерируем по FullOrderItemData
      final itemCore = fullItemData.coreData;
      final itemDoc = fullItemData.docItemData;
      final itemType = fullItemData.itemType;
      IDocumentItemEntity itemEntity;

      if (itemType == BaseItemType.part && fullItemData.partData != null) {
        // Используем публичный фабричный конструктор fromData
        itemEntity = OrderPartModelComposite.fromData(
            itemCore, itemDoc, fullItemData.partData!);
      } else if (itemType == BaseItemType.service &&
          fullItemData.serviceData != null) {
        // Используем публичный фабричный конструктор fromData
        itemEntity = OrderServiceModelComposite.fromData(
            itemCore, itemDoc, fullItemData.serviceData!);
      } else {
        // Используем константу
        _logger.w(LogMessages.orderItemInvalidData
            .replaceAll('{itemUuid}', itemCore.uuid));
        continue;
      }
      itemsMap.putIfAbsent(itemType, () => []).add(itemEntity);
    }

    // 3. Создать композитор
    return OrderModelComposite.fromData(coreData, docData, orderData, itemsMap);
  }

  // --- Вспомогательный метод для маппинга данных из DAO в композитор (Stream) ---
  Stream<OrderModelComposite> _mapStreamDataToComposite(String uuid) {
    final baseDataStream =
        _ordersDao.watchOrderHeaderByUuid(uuid); // Используем новый метод
    final itemsDataStream =
        _ordersDao.watchOrderItems(uuid); // Используем новый метод

    return CombineLatestStream.combine2(
      baseDataStream,
      itemsDataStream,
      (OrderHeaderData? baseData, List<FullOrderItemData> itemsData) {
        // Добавляем проверку на null для baseData
        if (baseData == null) {
          // Если заголовок null (заказ удален или не найден), возвращаем null или ошибку
          // В данном случае, чтобы CombineLatestStream продолжал работать,
          // можно либо пробросить ошибку, либо вернуть специальное значение,
          // либо фильтровать null позже. Пробросим ошибку.
          throw Exception(
              LogMessages.orderNotFoundByUuid.replaceAll('{uuid}', uuid));
        }

        final coreData = baseData.coreData;
        final docData = baseData.docData;
        final orderData = baseData.orderData;
        final Map<BaseItemType, List<IDocumentItemEntity>> itemsMap = {};

        for (final fullItemData in itemsData) {
          final itemCore = fullItemData.coreData;
          final itemDoc = fullItemData.docItemData;
          final itemType = fullItemData.itemType;
          IDocumentItemEntity itemEntity;

          if (itemType == BaseItemType.part && fullItemData.partData != null) {
            // Используем публичный фабричный конструктор fromData
            itemEntity = OrderPartModelComposite.fromData(
                itemCore, itemDoc, fullItemData.partData!);
          } else if (itemType == BaseItemType.service &&
              fullItemData.serviceData != null) {
            // Используем публичный фабричный конструктор fromData
            itemEntity = OrderServiceModelComposite.fromData(
                itemCore, itemDoc, fullItemData.serviceData!);
          } else {
            // Используем константу
            _logger.w(LogMessages.orderItemInvalidData
                .replaceAll('{itemUuid}', itemCore.uuid));
            continue;
          }
          itemsMap.putIfAbsent(itemType, () => []).add(itemEntity);
        }
        return OrderModelComposite.fromData(
            coreData, docData, orderData, itemsMap);
      },
    ).handleError((e, stackTrace) {
      // Логируем ошибку из потока
      // Используем константу
      _logger.e(
          LogMessages.orderStreamError
              .replaceAll('{uuid}', uuid)
              .replaceAll('{error}', e.toString()),
          error: e,
          stackTrace: stackTrace);
      // Пробрасываем ошибку дальше, чтобы внешний подписчик мог ее обработать
      throw e;
    });
  }

  /// Получает список всех активных заказ-нарядов
  Future<List<OrderModelComposite>> getOrders() async {
    try {
      final orderUuids = await _ordersDao.getActiveOrderUuids();
      // Фильтруем null UUIDs, если DAO может их вернуть
      final nonNullUuids = orderUuids.whereType<String>().toList();
      if (nonNullUuids.isEmpty) return [];

      final List<Future<OrderModelComposite>> futures =
          nonNullUuids.map((uuid) => _mapDataToComposite(uuid)).toList();
      return await Future.wait(futures);
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderGetError, error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Реактивно наблюдает за списком всех активных заказ-нарядов
  Stream<List<OrderModelComposite>> watchOrders() {
    try {
      return _ordersDao.watchActiveOrderUuids().switchMap((uuids) {
        // Фильтруем null UUIDs
        final nonNullUuids = uuids.whereType<String>().toList();
        if (nonNullUuids.isEmpty) {
          return Stream.value(<OrderModelComposite>[]);
        }
        final List<Stream<OrderModelComposite>> orderStreams = nonNullUuids
            .map((uuid) => _mapStreamDataToComposite(uuid)
                    // Добавляем обработку ошибок для каждого отдельного стрима заказа,
                    // чтобы ошибка в одном не обрушила весь CombineLatestStream
                    .handleError((e, s) {
                  // Используем константу
                  _logger.e(
                      LogMessages.orderListStreamItemError
                          .replaceAll('{uuid}', uuid),
                      error: e,
                      stackTrace: s);
                  // Возвращаем пустой стрим или стрим с ошибкой, чтобы CombineLatest продолжил работу
                  return Stream<OrderModelComposite>.empty();
                  // или return Stream.error(e); - но это остановит CombineLatest
                }))
            .toList();
        // Используем CombineLatestStream.list для объединения потоков
        return CombineLatestStream.list<OrderModelComposite>(orderStreams).map(
            (orders) => orders
                .whereType<OrderModelComposite>()
                .toList()); // Фильтруем возможные null/ошибки
      }).handleError((e, stackTrace) {
        _logger.e(LogMessages.orderWatchError,
            error: e, stackTrace: stackTrace);
        // Возвращаем стрим с ошибкой
        return Stream.error(e);
      });
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderWatchError, error: e, stackTrace: stackTrace);
      // Возвращаем стрим с ошибкой, если исключение возникло синхронно
      return Stream.error(e);
    }
  }

  /// Получает заказ-наряд по UUID
  ///
  /// @param uuid UUID заказ-наряда
  /// @return Бизнес-модель заказ-наряда
  Future<OrderModelComposite> getOrderByUuid(String uuid) async {
    try {
      return await _mapDataToComposite(uuid);
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderByUuidGetError.replaceAll('{uuid}', uuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Реактивно наблюдает за заказ-нарядом по UUID
  ///
  /// @param uuid UUID заказ-наряда
  /// @return Поток с обновлениями бизнес-модели заказ-наряда
  Stream<OrderModelComposite> watchOrderByUuid(String uuid) {
    try {
      return _mapStreamDataToComposite(uuid).handleError((e, stackTrace) {
        // Логируем и пробрасываем ошибку
        _logger.e(LogMessages.orderByUuidWatchError.replaceAll('{uuid}', uuid),
            error: e, stackTrace: stackTrace);
        throw e;
      });
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderByUuidWatchError.replaceAll('{uuid}', uuid),
          error: e, stackTrace: stackTrace);
      // Возвращаем стрим с ошибкой, если исключение синхронное
      return Stream.error(e);
    }
  }

  /// Сохраняет (создает или обновляет) заказ-наряд
  ///
  /// @param order Бизнес-модель заказ-наряда для сохранения
  Future<void> _saveOrder(OrderModelComposite order) async {
    try {
      // Извлекаем @freezed модели из композитора
      final coreData = order.coreData;
      final docData = order.docData;
      final orderData = order.orderData;
      // Используем расширение для получения Tuple3
      final itemsData = order.itemsMap.values
          .expand((list) => list)
          .map((item) => item.getAllData())
          .toList();

      // Вызываем новый метод DAO
      await _ordersDao.saveFullOrderData(
          coreData, docData, orderData, itemsData);
    } catch (e, stackTrace) {
      // Используем константу
      _logger.e(LogMessages.orderSaveError.replaceAll('{uuid}', order.uuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Создает новый заказ-наряд
  ///
  /// @param order Бизнес-модель заказ-наряда для создания
  /// @return UUID созданного заказ-наряда
  Future<String> createOrder(OrderModelComposite order) async {
    try {
      // Можно добавить проверку, что UUID еще не существует в БД, если нужно
      await _saveOrder(order);
      // Используем константу
      _logger.i(LogMessages.orderCreated.replaceAll('{uuid}', order.uuid));
      return order.uuid;
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderCreateError, error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Создает новый заказ-наряд с базовыми параметрами
  ///
  /// @param clientUuid UUID клиента
  /// @param carUuid UUID автомобиля
  /// @param description Описание работ или проблемы
  /// @param scheduledDate Планируемая дата выполнения
  /// @return OrderModelComposite Созданная бизнес-модель заказ-наряда
  Future<OrderModelComposite> createNewOrder({
    required String clientUuid,
    required String carUuid,
    String? description,
    DateTime? scheduledDate,
  }) async {
    try {
      // Получаем базовые данные клиента и автомобиля
      final clientCoreData = await _clientsDao
          .getClientCoreData(clientUuid); // Используем новый метод
      final carCoreData =
          await _carsDao.getCarCoreData(carUuid); // Используем новый метод

      if (clientCoreData == null) {
        final errorMsg =
            LogMessages.clientNotFoundByUuid.replaceAll('{uuid}', clientUuid);
        _logger.e(errorMsg);
        throw Exception(errorMsg);
      }
      if (carCoreData == null) {
        final errorMsg =
            LogMessages.carNotFoundByUuid.replaceAll('{uuid}', carUuid);
        _logger.e(errorMsg);
        throw Exception(errorMsg);
      }

      // Создаем бизнес-модель (композитор)
      final orderModel = OrderModelComposite.create(
        // Используем фабричный конструктор композитора
        code: '', // Генерировать или получать из настроек/DAO
        displayName:
            'Заказ-наряд от ${DateTime.now().toLocal().toString().substring(0, 10)}', // Пример
        documentDate: DateTime.now(),
        clientId: clientUuid,
        carId: carUuid,
        description: description,
        scheduledDate: scheduledDate, // Передаем в конструктор
        // clientName и carInfo больше не нужны как параметры
      );

      // Сохраняем в базу данных
      await _saveOrder(orderModel);
      // Используем константу
      _logger.i(LogMessages.orderCreated.replaceAll('{uuid}', orderModel.uuid));
      return orderModel;
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderNewCreateError,
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Обновляет существующий заказ-наряд
  ///
  /// @param order Бизнес-модель заказ-наряда с обновленными данными
  Future<void> updateOrder(OrderModelComposite order) async {
    try {
      // Обновляем modifiedAt перед сохранением (предполагаем, что метод есть)
      final updatedOrder = order.withModifiedDate(DateTime.now());
      await _saveOrder(updatedOrder);
      // Используем константу
      _logger.d(LogMessages.orderUpdated.replaceAll('{uuid}', order.uuid));
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderUpdateError.replaceAll('{uuid}', order.uuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Изменяет статус заказ-наряда
  ///
  /// @param orderUuid UUID заказ-наряда
  /// @param newStatus Новый статус
  Future<void> changeOrderStatus(
      String orderUuid, DocumentStatus newStatus) async {
    try {
      final order = await getOrderByUuid(orderUuid);
      // Используем метод `with...` композитора для иммутабельного обновления
      // Предполагаем, что метод withStatus существует
      final updatedOrder = order.withStatus(newStatus);
      await updateOrder(updatedOrder);
      // Используем константу
      _logger.i(LogMessages.orderStatusUpdated
          .replaceAll('{uuid}', orderUuid)
          .replaceAll('{status}', newStatus.name));
    } catch (e, stackTrace) {
      _logger.e(
          LogMessages.orderStatusChangeError.replaceAll('{uuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Добавляет элемент (услугу или запчасть) к заказ-наряду
  ///
  /// @param orderUuid UUID заказ-наряда
  /// @param item Бизнес-модель элемента для добавления
  Future<void> addItemToOrder(
      String orderUuid, IDocumentItemEntity item) async {
    try {
      final order = await getOrderByUuid(orderUuid);
      // Предполагаем, что метод withAddedItem существует
      final updatedOrder = order.withAddedItem(item);
      await updateOrder(updatedOrder);
      // Используем константу
      _logger.d(LogMessages.orderItemAdded
          .replaceAll('{itemUuid}', item.uuid)
          .replaceAll('{orderUuid}', orderUuid));
    } catch (e, stackTrace) {
      // Используем константу
      _logger.e(
          LogMessages.orderAddItemError
              .replaceAll('{itemUuid}', item.uuid)
              .replaceAll('{orderUuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Обновляет элемент (услугу или запчасть) в заказ-наряде
  ///
  /// @param orderUuid UUID заказ-наряда
  /// @param item Обновленная бизнес-модель элемента
  Future<void> updateOrderItem(
      String orderUuid, IDocumentItemEntity item) async {
    try {
      final order = await getOrderByUuid(orderUuid);
      // Предполагаем, что метод withUpdatedItem существует
      final updatedOrder = order.withUpdatedItem(item);
      await updateOrder(updatedOrder);
      // Используем константу
      _logger.d(LogMessages.orderItemUpdated
          .replaceAll('{itemUuid}', item.uuid)
          .replaceAll('{orderUuid}', orderUuid));
    } catch (e, stackTrace) {
      // Используем константу
      _logger.e(
          LogMessages.orderUpdateItemError
              .replaceAll('{itemUuid}', item.uuid)
              .replaceAll('{orderUuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Удаляет элемент (услугу или запчасть) из заказ-наряда
  ///
  /// @param itemUuid UUID элемента
  /// @param orderUuid UUID заказ-наряда
  Future<void> removeItemFromOrder(String itemUuid, String orderUuid) async {
    try {
      final order = await getOrderByUuid(orderUuid);
      // Предполагаем, что метод withRemovedItem существует
      final updatedOrder = order.withRemovedItem(itemUuid);
      await updateOrder(updatedOrder);
      // Используем константу
      _logger.i(LogMessages.orderItemRemoved
          .replaceAll('{itemUuid}', itemUuid)
          .replaceAll('{orderUuid}', orderUuid));
    } catch (e, stackTrace) {
      // Используем константу
      _logger.e(
          LogMessages.orderRemoveItemError
              .replaceAll('{itemUuid}', itemUuid)
              .replaceAll('{orderUuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Выполняет мягкое удаление заказ-наряда
  ///
  /// @param orderUuid UUID заказ-наряда
  Future<void> deleteOrder(String orderUuid) async {
    try {
      final order = await getOrderByUuid(orderUuid);
      // Предполагаем, что метод markAsDeleted существует
      final deletedOrder = order.markAsDeleted();
      await updateOrder(deletedOrder);
      // Используем константу
      _logger.i(LogMessages.orderDeleted.replaceAll('{uuid}', orderUuid));
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderDeleteError.replaceAll('{uuid}', orderUuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Восстанавливает удаленный заказ-наряд
  ///
  /// @param orderUuid UUID заказ-наряда
  Future<void> restoreOrder(String orderUuid) async {
    try {
      // Важно: _mapDataToComposite использует getOrderHeaderByUuid, который
      // по умолчанию НЕ возвращает удаленные. Нужно либо изменить DAO,
      // либо предположить, что updateOrder/saveFullOrderData корректно
      // обработает установку deletedAt = null.
      // Пока предполагаем, что updateOrder сработает.
      // Получаем текущие данные (даже если они помечены как удаленные в coreData)
      // Возможно, потребуется метод в DAO для получения удаленных.
      // final order = await _getPotentiallyDeletedOrder(orderUuid); // Гипотетический метод
      final order = await getOrderByUuid(orderUuid); // Попробуем так

      if (order.deletedAt == null) {
        // Используем константу
        _logger.w(LogMessages.orderRestoreAttemptOnNonDeleted
            .replaceAll('{uuid}', orderUuid));
        return;
      }
      // Предполагаем, что метод restore существует
      final restoredOrder = order.restore();
      await updateOrder(restoredOrder);
      // Используем константу
      _logger.i(LogMessages.orderRestored.replaceAll('{uuid}', orderUuid));
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderRestoreError.replaceAll('{uuid}', orderUuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Создает новую услугу и добавляет её в заказ-наряд
  Future<OrderServiceModelComposite> createAndAddService({
    required String orderUuid,
    required String name,
    String? description,
    required double price,
    double? duration,
    String? performedBy,
  }) async {
    try {
      // Создаем бизнес-модель услуги
      final serviceModel = OrderServiceModelComposite.create(
        documentUuid: orderUuid,
        name: name,
        description: description,
        price: price,
        duration: duration,
        performedBy: performedBy,
        // isCompleted: false, // Значение по умолчанию в ServiceSpecificData
      );
      await addItemToOrder(orderUuid, serviceModel);
      // Используем константу
      _logger.d(LogMessages.orderServiceCreatedAdd
          .replaceAll('{itemUuid}', serviceModel.uuid)
          .replaceAll('{orderUuid}', orderUuid));
      return serviceModel;
    } catch (e, stackTrace) {
      _logger.e(
          LogMessages.orderServiceCreateAddError
              .replaceAll('{orderUuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Создает новую запчасть и добавляет её в заказ-наряд
  Future<OrderPartModelComposite> createAndAddPart({
    required String orderUuid,
    required String partNumber,
    required String name,
    required double price,
    String? brand,
    double quantity = 1,
    String? supplierName,
    int? deliveryDays,
  }) async {
    try {
      // Создаем бизнес-модель запчасти
      final partModel = OrderPartModelComposite.create(
        documentUuid: orderUuid,
        partNumber: partNumber,
        name: name,
        brand: brand,
        price: price,
        quantity: quantity,
        supplierName: supplierName,
        deliveryDays: deliveryDays,
      );
      await addItemToOrder(orderUuid, partModel);
      // Используем константу
      _logger.d(LogMessages.orderPartCreatedAdd
          .replaceAll('{itemUuid}', partModel.uuid)
          .replaceAll('{orderUuid}', orderUuid));
      return partModel;
    } catch (e, stackTrace) {
      _logger.e(
          LogMessages.orderPartCreateAddError
              .replaceAll('{orderUuid}', orderUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Получает заказ-наряды по UUID клиента
  Future<List<OrderModelComposite>> getOrdersByClientUuid(
      String clientUuid) async {
    try {
      final orderUuids = await _ordersDao.getOrderUuidsByClientUuid(clientUuid);
      final nonNullUuids = orderUuids.whereType<String>().toList();
      if (nonNullUuids.isEmpty) return [];
      final List<Future<OrderModelComposite>> futures =
          nonNullUuids.map((uuid) => _mapDataToComposite(uuid)).toList();
      return await Future.wait(futures);
    } catch (e, stackTrace) {
      _logger.e(
          LogMessages.orderGetByClientError
              .replaceAll('{clientId}', clientUuid),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Получает заказ-наряды по UUID автомобиля
  Future<List<OrderModelComposite>> getOrdersByCarUuid(String carUuid) async {
    try {
      final orderUuids = await _ordersDao.getOrderUuidsByCarUuid(carUuid);
      final nonNullUuids = orderUuids.whereType<String>().toList();
      if (nonNullUuids.isEmpty) return [];
      final List<Future<OrderModelComposite>> futures =
          nonNullUuids.map((uuid) => _mapDataToComposite(uuid)).toList();
      return await Future.wait(futures);
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderGetByCarError.replaceAll('{carId}', carUuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Получает заказ-наряды по статусу
  Future<List<OrderModelComposite>> getOrdersByStatus(
      DocumentStatus status) async {
    try {
      final orderUuids = await _ordersDao.getOrderUuidsByStatus(status);
      final nonNullUuids = orderUuids.whereType<String>().toList();
      if (nonNullUuids.isEmpty) return [];
      final List<Future<OrderModelComposite>> futures =
          nonNullUuids.map((uuid) => _mapDataToComposite(uuid)).toList();
      return await Future.wait(futures);
    } catch (e, stackTrace) {
      _logger.e(
          LogMessages.orderGetByStatusError.replaceAll('{status}', status.name),
          error: e,
          stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Выполняет поиск заказ-нарядов по строке запроса
  Future<List<OrderModelComposite>> searchOrders(String query) async {
    try {
      final orderUuids = await _ordersDao.searchOrderUuids(query);
      final nonNullUuids = orderUuids.whereType<String>().toList();
      if (nonNullUuids.isEmpty) return [];
      final List<Future<OrderModelComposite>> futures =
          nonNullUuids.map((uuid) => _mapDataToComposite(uuid)).toList();
      return await Future.wait(futures);
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderSearchError.replaceAll('{query}', query),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  // --- Методы `provesti` и `otmenit` ---

  /// Проводит заказ-наряд
  Future<void> provesti(String orderUuid) async {
    try {
      final order = await getOrderByUuid(orderUuid);

      // Проверка статуса и флага проведения
      // TODO: Уточнить логику статуса для проведения. Возможно, нужен статус 'Completed' или 'ReadyForPosting'?
      // if (order.status != DocumentStatus.completed) { // Пример
      //   throw Exception(
      //       'Невозможно провести заказ-наряд. Требуется статус "Completed". Текущий статус: ${order.status.name}');
      // }
      if (order.isPosted) {
        // Используем константу
        _logger.w(LogMessages.orderPostAttemptOnPosted
            .replaceAll('{uuid}', orderUuid));
        return;
      }

      // ... логика создания движений в регистрах (если есть) ...

      // Обновляем флаг isPosted в композиторе (предполагаем, что метод есть)
      final updatedOrder = order.withProveden(true);

      await updateOrder(updatedOrder);
      // Используем константу
      _logger.i(LogMessages.orderPosted.replaceAll('{uuid}', orderUuid));
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderProvestiError.replaceAll('{uuid}', orderUuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Отменяет проведение заказ-наряда
  Future<void> otmenit(String orderUuid) async {
    try {
      final order = await getOrderByUuid(orderUuid);

      if (!order.isPosted) {
        // Используем константу
        _logger.w(LogMessages.orderUnpostAttemptOnUnposted
            .replaceAll('{uuid}', orderUuid));
        return; // Или бросить исключение
      }

      // ... логика удаления движений в регистрах (если есть) ...

      // Обновляем флаг isPosted (предполагаем, что метод есть)
      final updatedOrder = order.withProveden(false);

      await updateOrder(updatedOrder);
      // Используем константу
      _logger.i(LogMessages.orderUnposted.replaceAll('{uuid}', orderUuid));
    } catch (e, stackTrace) {
      _logger.e(LogMessages.orderOtmenitError.replaceAll('{uuid}', orderUuid),
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }
}

// --- Вспомогательные расширения или методы для IDocumentItemEntity ---
// Убедитесь, что это расширение доступно или перенесите его сюда
extension DocumentItemEntityData on IDocumentItemEntity {
  Tuple3<ItemCoreData, DocumentItemSpecificData, dynamic> getAllData() {
    if (this is OrderPartModelComposite) {
      final part = this as OrderPartModelComposite;
      return Tuple3(part.coreData, part.docItemData, part.partData);
    } else if (this is OrderServiceModelComposite) {
      final service = this as OrderServiceModelComposite;
      return Tuple3(service.coreData, service.docItemData, service.serviceData);
    }
    throw Exception('Неизвестный тип IDocumentItemEntity: $runtimeType');
  }
}

// Убедитесь, что класс Tuple3 определен или импортирован
// class Tuple3<T1, T2, T3> { ... }

```

## lib\features\documents\orders\state\order_form_state.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/core/i_document_item_entity.dart';
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart';
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';

part 'order_form_state.freezed.dart';

@freezed
abstract class OrderFormState with _$OrderFormState {
  const factory OrderFormState({
    @Default(false) bool isLoading, // Загрузка начальных данных
    @Default(false) bool isSaving, // Процесс сохранения
    String? error, // Сообщение об ошибке
    OrderModelComposite?
        initialOrder, // Исходный заказ для режима редактирования
    ClientModelComposite? selectedClient,
    CarModelComposite? selectedCar,
    DateTime? scheduledDate,
    @Default('') String description,
    @Default({}) Map<String, IDocumentItemEntity> itemsMap,
    @Default(false) bool isEditMode,
  }) = _OrderFormState;
}

```

## lib\features\documents\orders\state\order_form_state.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'order_form_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OrderFormState {
  bool get isLoading; // Загрузка начальных данных
  bool get isSaving; // Процесс сохранения
  String? get error; // Сообщение об ошибке
  OrderModelComposite?
      get initialOrder; // Исходный заказ для режима редактирования
  ClientModelComposite? get selectedClient;
  CarModelComposite? get selectedCar;
  DateTime? get scheduledDate;
  String get description;
  Map<String, IDocumentItemEntity> get itemsMap;
  bool get isEditMode;

  /// Create a copy of OrderFormState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OrderFormStateCopyWith<OrderFormState> get copyWith =>
      _$OrderFormStateCopyWithImpl<OrderFormState>(
          this as OrderFormState, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OrderFormState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isSaving, isSaving) ||
                other.isSaving == isSaving) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.initialOrder, initialOrder) ||
                other.initialOrder == initialOrder) &&
            (identical(other.selectedClient, selectedClient) ||
                other.selectedClient == selectedClient) &&
            (identical(other.selectedCar, selectedCar) ||
                other.selectedCar == selectedCar) &&
            (identical(other.scheduledDate, scheduledDate) ||
                other.scheduledDate == scheduledDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.itemsMap, itemsMap) &&
            (identical(other.isEditMode, isEditMode) ||
                other.isEditMode == isEditMode));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      isSaving,
      error,
      initialOrder,
      selectedClient,
      selectedCar,
      scheduledDate,
      description,
      const DeepCollectionEquality().hash(itemsMap),
      isEditMode);

  @override
  String toString() {
    return 'OrderFormState(isLoading: $isLoading, isSaving: $isSaving, error: $error, initialOrder: $initialOrder, selectedClient: $selectedClient, selectedCar: $selectedCar, scheduledDate: $scheduledDate, description: $description, itemsMap: $itemsMap, isEditMode: $isEditMode)';
  }
}

/// @nodoc
abstract mixin class $OrderFormStateCopyWith<$Res> {
  factory $OrderFormStateCopyWith(
          OrderFormState value, $Res Function(OrderFormState) _then) =
      _$OrderFormStateCopyWithImpl;
  @useResult
  $Res call(
      {bool isLoading,
      bool isSaving,
      String? error,
      OrderModelComposite? initialOrder,
      ClientModelComposite? selectedClient,
      CarModelComposite? selectedCar,
      DateTime? scheduledDate,
      String description,
      Map<String, IDocumentItemEntity> itemsMap,
      bool isEditMode});
}

/// @nodoc
class _$OrderFormStateCopyWithImpl<$Res>
    implements $OrderFormStateCopyWith<$Res> {
  _$OrderFormStateCopyWithImpl(this._self, this._then);

  final OrderFormState _self;
  final $Res Function(OrderFormState) _then;

  /// Create a copy of OrderFormState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? isSaving = null,
    Object? error = freezed,
    Object? initialOrder = freezed,
    Object? selectedClient = freezed,
    Object? selectedCar = freezed,
    Object? scheduledDate = freezed,
    Object? description = null,
    Object? itemsMap = null,
    Object? isEditMode = null,
  }) {
    return _then(_self.copyWith(
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSaving: null == isSaving
          ? _self.isSaving
          : isSaving // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      initialOrder: freezed == initialOrder
          ? _self.initialOrder
          : initialOrder // ignore: cast_nullable_to_non_nullable
              as OrderModelComposite?,
      selectedClient: freezed == selectedClient
          ? _self.selectedClient
          : selectedClient // ignore: cast_nullable_to_non_nullable
              as ClientModelComposite?,
      selectedCar: freezed == selectedCar
          ? _self.selectedCar
          : selectedCar // ignore: cast_nullable_to_non_nullable
              as CarModelComposite?,
      scheduledDate: freezed == scheduledDate
          ? _self.scheduledDate
          : scheduledDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: null == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      itemsMap: null == itemsMap
          ? _self.itemsMap
          : itemsMap // ignore: cast_nullable_to_non_nullable
              as Map<String, IDocumentItemEntity>,
      isEditMode: null == isEditMode
          ? _self.isEditMode
          : isEditMode // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _OrderFormState implements OrderFormState {
  const _OrderFormState(
      {this.isLoading = false,
      this.isSaving = false,
      this.error,
      this.initialOrder,
      this.selectedClient,
      this.selectedCar,
      this.scheduledDate,
      this.description = '',
      final Map<String, IDocumentItemEntity> itemsMap = const {},
      this.isEditMode = false})
      : _itemsMap = itemsMap;

  @override
  @JsonKey()
  final bool isLoading;
// Загрузка начальных данных
  @override
  @JsonKey()
  final bool isSaving;
// Процесс сохранения
  @override
  final String? error;
// Сообщение об ошибке
  @override
  final OrderModelComposite? initialOrder;
// Исходный заказ для режима редактирования
  @override
  final ClientModelComposite? selectedClient;
  @override
  final CarModelComposite? selectedCar;
  @override
  final DateTime? scheduledDate;
  @override
  @JsonKey()
  final String description;
  final Map<String, IDocumentItemEntity> _itemsMap;
  @override
  @JsonKey()
  Map<String, IDocumentItemEntity> get itemsMap {
    if (_itemsMap is EqualUnmodifiableMapView) return _itemsMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_itemsMap);
  }

  @override
  @JsonKey()
  final bool isEditMode;

  /// Create a copy of OrderFormState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$OrderFormStateCopyWith<_OrderFormState> get copyWith =>
      __$OrderFormStateCopyWithImpl<_OrderFormState>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OrderFormState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isSaving, isSaving) ||
                other.isSaving == isSaving) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.initialOrder, initialOrder) ||
                other.initialOrder == initialOrder) &&
            (identical(other.selectedClient, selectedClient) ||
                other.selectedClient == selectedClient) &&
            (identical(other.selectedCar, selectedCar) ||
                other.selectedCar == selectedCar) &&
            (identical(other.scheduledDate, scheduledDate) ||
                other.scheduledDate == scheduledDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._itemsMap, _itemsMap) &&
            (identical(other.isEditMode, isEditMode) ||
                other.isEditMode == isEditMode));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      isSaving,
      error,
      initialOrder,
      selectedClient,
      selectedCar,
      scheduledDate,
      description,
      const DeepCollectionEquality().hash(_itemsMap),
      isEditMode);

  @override
  String toString() {
    return 'OrderFormState(isLoading: $isLoading, isSaving: $isSaving, error: $error, initialOrder: $initialOrder, selectedClient: $selectedClient, selectedCar: $selectedCar, scheduledDate: $scheduledDate, description: $description, itemsMap: $itemsMap, isEditMode: $isEditMode)';
  }
}

/// @nodoc
abstract mixin class _$OrderFormStateCopyWith<$Res>
    implements $OrderFormStateCopyWith<$Res> {
  factory _$OrderFormStateCopyWith(
          _OrderFormState value, $Res Function(_OrderFormState) _then) =
      __$OrderFormStateCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      bool isSaving,
      String? error,
      OrderModelComposite? initialOrder,
      ClientModelComposite? selectedClient,
      CarModelComposite? selectedCar,
      DateTime? scheduledDate,
      String description,
      Map<String, IDocumentItemEntity> itemsMap,
      bool isEditMode});
}

/// @nodoc
class __$OrderFormStateCopyWithImpl<$Res>
    implements _$OrderFormStateCopyWith<$Res> {
  __$OrderFormStateCopyWithImpl(this._self, this._then);

  final _OrderFormState _self;
  final $Res Function(_OrderFormState) _then;

  /// Create a copy of OrderFormState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isLoading = null,
    Object? isSaving = null,
    Object? error = freezed,
    Object? initialOrder = freezed,
    Object? selectedClient = freezed,
    Object? selectedCar = freezed,
    Object? scheduledDate = freezed,
    Object? description = null,
    Object? itemsMap = null,
    Object? isEditMode = null,
  }) {
    return _then(_OrderFormState(
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSaving: null == isSaving
          ? _self.isSaving
          : isSaving // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      initialOrder: freezed == initialOrder
          ? _self.initialOrder
          : initialOrder // ignore: cast_nullable_to_non_nullable
              as OrderModelComposite?,
      selectedClient: freezed == selectedClient
          ? _self.selectedClient
          : selectedClient // ignore: cast_nullable_to_non_nullable
              as ClientModelComposite?,
      selectedCar: freezed == selectedCar
          ? _self.selectedCar
          : selectedCar // ignore: cast_nullable_to_non_nullable
              as CarModelComposite?,
      scheduledDate: freezed == scheduledDate
          ? _self.scheduledDate
          : scheduledDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: null == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      itemsMap: null == itemsMap
          ? _self._itemsMap
          : itemsMap // ignore: cast_nullable_to_non_nullable
              as Map<String, IDocumentItemEntity>,
      isEditMode: null == isEditMode
          ? _self.isEditMode
          : isEditMode // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

// dart format on

```

## lib\features\documents\orders\widgets\order_list_item.dart
```dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
// --- Обновленные импорты ---
import 'package:part_catalog/core/i18n/strings.g.dart'; // Используем slang
import 'package:part_catalog/features/core/base_item_type.dart'; // Для подсчета типов
import 'package:part_catalog/features/documents/orders/models/order_model_composite.dart'; // Используем композитор
// TODO: Рассмотреть возможность получения Client/Car имен через сервис или ViewModel
// import 'package:part_catalog/features/references/clients/services/client_service.dart';
// import 'package:part_catalog/features/references/vehicles/services/car_service.dart';
// import 'package:part_catalog/core/service_locator.dart';

class OrderListItem extends StatelessWidget {
  final OrderModelComposite order; // Используем композитор
  final VoidCallback? onTap;

  const OrderListItem({
    super.key,
    required this.order,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final t = context.t; // Получаем доступ к slang
    // Используем локаль из контекста для форматирования
    final currentLocale = Localizations.localeOf(context);
    final dateFormat = DateFormat('dd.MM.yyyy', currentLocale.languageCode);
    final currencyFormat = NumberFormat.currency(
      locale: currentLocale.languageCode,
      symbol: '₽', // TODO: Сделать символ валюты настраиваемым
      decimalDigits: 2,
    );

    // Расчет общей суммы и количества элементов из itemsMap
    final totalAmount = order.items
        .fold<double>(0.0, (sum, item) => sum + (item.totalPrice ?? 0.0));
    final partsCount = order.getItemsByType(BaseItemType.part).length;
    final servicesCount = order.getItemsByType(BaseItemType.service).length;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12), // Немного увеличим радиус
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Верхняя часть с номером и статусом
              Row(
                children: [
                  Expanded(
                    child: Text(
                      // Используем code из coreData
                      t.orders.orderNumberFormat(number: order.code),
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      // Используем color и displayName из DocumentStatus
                      color: order.status.color.withAlpha((255 * 0.15).round()),
                      borderRadius:
                          BorderRadius.circular(16), // Сделаем более округлым
                    ),
                    child: Text(
                      order.status.displayName,
                      style: TextStyle(
                        color: order.status.color,
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12), // Увеличим отступ

              // Информация о клиенте и автомобиле (отображаем ID или плейсхолдер)
              // TODO: Загружать и отображать имена клиента/автомобиля
              _buildInfoRow(
                icon: Icons.person_outline,
                // Используем clientId из orderData
                text: order.clientId != null
                    ? '${t.clients.client}: ${order.clientId!.substring(0, 8)}...' // Показываем часть UUID
                    : t.clients.clientNotSelected, // Используем slang
                theme: theme,
                hasData: order.clientId != null,
              ),
              const SizedBox(height: 4),
              _buildInfoRow(
                icon: Icons.directions_car_outlined,
                // Используем carId из orderData
                text: order.carId != null
                    ? '${t.vehicles.vehicle}: ${order.carId!.substring(0, 8)}...' // Показываем часть UUID
                    : t.vehicles.vehicleNotSelected, // Используем slang
                theme: theme,
                hasData: order.carId != null,
              ),
              const SizedBox(height: 12), // Увеличим отступ

              // Дата создания и дата выполнения
              Row(
                children: [
                  Icon(Icons.calendar_today_outlined,
                      size: 16, color: theme.colorScheme.primary),
                  const SizedBox(width: 4),
                  Text(
                    // Используем documentDate из docData
                    '${t.common.createdAt}: ${dateFormat.format(order.documentDate)}', // Используем slang
                    style: theme.textTheme.bodySmall,
                  ),
                  const Spacer(), // Занимаем доступное пространство
                  // Используем scheduledDate из docData
                  if (order.docData.scheduledDate != null) ...[
                    Icon(Icons.event_outlined,
                        size: 16, color: theme.colorScheme.secondary),
                    const SizedBox(width: 4),
                    Text(
                      '${t.orders.scheduledShort}: ${dateFormat.format(order.docData.scheduledDate!)}', // Используем slang
                      style: theme.textTheme.bodySmall,
                    ),
                  ],
                ],
              ),
              const SizedBox(height: 16), // Увеличим отступ

              // Нижняя часть с итоговой стоимостью и счетчиками
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    currencyFormat.format(totalAmount),
                    style: theme.textTheme.titleMedium?.copyWith(
                      // Сделаем крупнее
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  Row(
                    children: [
                      if (partsCount > 0) ...[
                        const Icon(Icons.settings_outlined,
                            size: 16, color: Colors.grey),
                        const SizedBox(width: 4),
                        Text(
                          '$partsCount', // Показываем только число
                          style: theme.textTheme.bodySmall,
                        ),
                        const SizedBox(width: 12),
                      ],
                      if (servicesCount > 0) ...[
                        const Icon(Icons.build_outlined,
                            size: 16, color: Colors.grey),
                        const SizedBox(width: 4),
                        Text(
                          '$servicesCount', // Показываем только число
                          style: theme.textTheme.bodySmall,
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Вспомогательный виджет для отображения строки информации (клиент/авто)
  Widget _buildInfoRow({
    required IconData icon,
    required String text,
    required ThemeData theme,
    bool hasData = true,
  }) {
    return Row(
      children: [
        Icon(icon,
            size: 16,
            color: hasData ? Colors.grey.shade700 : Colors.grey.shade400),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            text,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: hasData ? null : Colors.grey.shade600,
              fontStyle: hasData ? FontStyle.normal : FontStyle.italic,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  // Функция для множественного числа больше не нужна здесь,
  // т.к. отображаем только количество.
  // Локализация форм множественного числа должна быть в slang файлах, если потребуется.
}

```

## lib\features\home\models\navigation_item.dart
```dart
import 'package:flutter/material.dart';

/// Модель, объединяющая экран и его метаданные для навигации
class NavigationItem {
  /// Экран для отображения
  final Widget screen;

  /// Иконка для элемента навигации
  final IconData icon;

  /// Функция для получения заголовка с учетом локализации
  final String? Function(BuildContext) titleGetter;

  const NavigationItem({
    required this.screen,
    required this.icon,
    required this.titleGetter,
  });
}

```

## lib\features\home\screens\home_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:part_catalog/core/navigation/app_routes.dart';
import 'package:part_catalog/core/widgets/language_switcher.dart';
import 'package:part_catalog/core/i18n/strings.g.dart';

class HomeScreen extends StatelessWidget {
  final Widget child;

  const HomeScreen({
    super.key,
    required this.child,
  });

  static final _navigationDestinations = [
    (
      route: AppRoutes.clients,
      icon: Icons.people_alt_outlined,
      selectedIcon: Icons.people, // Добавляем выбранную иконку
      labelKey: t.clients.screenTitle
    ),
    (
      route: AppRoutes.vehicles,
      icon: Icons.directions_car_outlined,
      selectedIcon: Icons.directions_car, // Добавляем выбранную иконку
      labelKey: t.vehicles.screenTitle
    ),
    (
      route: AppRoutes.orders,
      icon: Icons.list_alt_outlined,
      selectedIcon: Icons.list_alt, // Добавляем выбранную иконку
      labelKey: t.orders.screenTitle
    ),
    // Добавьте другие основные разделы здесь
  ];

  @override
  Widget build(BuildContext context) {
    final String location = GoRouterState.of(context).uri.toString();
    final int currentIndex = _calculateSelectedIndex(location);

    // Определяем ширину экрана
    final screenWidth = MediaQuery.of(context).size.width;
    // Устанавливаем точку перехода (breakpoint), например, 600 пикселей
    const double breakpoint = 600;

    // Если экран достаточно широкий, используем NavigationRail
    if (screenWidth >= breakpoint) {
      return Scaffold(
        appBar: AppBar(
          title: Text(_navigationDestinations[currentIndex].labelKey),
          actions: const [
            LanguageSwitcher(),
          ],
        ),
        body: Row(
          children: [
            NavigationRail(
              selectedIndex: currentIndex,
              onDestinationSelected: (index) {
                context.go(_navigationDestinations[index].route);
              },
              labelType: NavigationRailLabelType.all, // Или .selected, .none
              destinations: _navigationDestinations
                  .map(
                    (dest) => NavigationRailDestination(
                      icon: Icon(dest.icon),
                      selectedIcon: Icon(
                          dest.selectedIcon), // Используем выбранную иконку
                      label: Text(dest.labelKey),
                    ),
                  )
                  .toList(),
            ),
            const VerticalDivider(thickness: 1, width: 1),
            // Основной контент занимает оставшееся место
            Expanded(
              child: child, // Отображаем дочерний экран
            ),
          ],
        ),
      );
    } else {
      // Иначе используем NavigationBar (для мобильных)
      return Scaffold(
        appBar: AppBar(
          title: Text(_navigationDestinations[currentIndex].labelKey),
          actions: const [
            LanguageSwitcher(),
          ],
        ),
        body: child, // Отображаем дочерний экран
        bottomNavigationBar: NavigationBar(
          selectedIndex: currentIndex,
          onDestinationSelected: (index) {
            context.go(_navigationDestinations[index].route);
          },
          destinations: _navigationDestinations
              .map(
                (dest) => NavigationDestination(
                  icon: Icon(dest.icon),
                  selectedIcon:
                      Icon(dest.selectedIcon), // Используем выбранную иконку
                  label: dest.labelKey,
                ),
              )
              .toList(),
        ),
      );
    }
  }

  int _calculateSelectedIndex(String location) {
    final index = _navigationDestinations.indexWhere(
      (dest) => location.startsWith(dest.route),
    );
    return index < 0 ? 0 : index;
  }
}

```

## lib\features\parts_catalog\api\PartsCatalogsRestAPI.md
```md
openapi: 3.0.0
info:
  title: Catalogs API
  version: 1.15.0
  description: |
    Open source clients:
    - [pc-client-slim](https://github.com/alex-ello/pc-client-slim) PHP based opensource client
security:
  - ApiKey: []
tags:
  - name: Ip
  - name: Catalogs
  - name: Cars
  - name: Groups
  - name: Parts
  - name: Groups tree
paths:
  /ip/:
    get:
      operationId: getIp
      tags:
        - Ip
      summary: Get user ip
      responses:
        '200':
          description: Id
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Ip'
  /catalogs/:
    get:
      operationId: getCatalogs
      tags:
        - Catalogs
      summary: Get available catalogs
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
      responses:
        '200':
          description: Ok
          content:
            application/json:
              schema:
                title: array
                description: Catalog list
                type: array
                items:
                  $ref: '#/components/schemas/Catalog'
  '/catalogs/{catalogId}/models/':
    get:
      operationId: getModels
      tags:
        - Cars
      summary: Get catalog car models
      security:
        - ApiKey: []
      parameters:
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
      responses:
        '200':
          description: Model list
          content:
            application/json:
              schema:
                title: Array
                type: array
                items:
                  $ref: '#/components/schemas/Model'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
        '404':
          $ref: '#/components/responses/notFound'
  '/catalogs/{catalogId}/cars2/':
    get:
      operationId: getCars2
      tags:
        - Cars
      summary: Get car list of catalog
      description: Attention! Vehicle identifier may change over time.
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: modelId
          in: query
          description: Model id
          required: true
          schema:
            type: string
        - name: parameter
          in: query
          description: Filter cars by car parameter indexes (idx)
          required: false
          style: form
          explode: false
          schema:
            type: array
            items:
              type: array
              items:
                $ref: '#/components/schemas/CarParameterIdx'
        - name: page
          in: query
          required: false
          description: |-
            Page number (pagination). 
            Page number value must be greater than 0. Can output 25 cars on page
          schema:
            type: integer
            minimum: 0
      responses:
        '200':
          description: OK
          headers:
            X-Total-Count:
              schema:
                type: integer
          content:
            application/json:
              schema:
                title: array
                description: Car list
                type: array
                items:
                  $ref: '#/components/schemas/Car2'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
  '/catalogs/{catalogId}/cars2/{carId}':
    get:
      operationId: getCarsById2
      tags:
        - Cars
      summary: GET catalog car by id
      description: Attention! Vehicle identifier may change over time.
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: carId
          in: path
          description: Car id
          required: true
          schema:
            type: string
        - name: criteria
          in: query
          description: criteria
          required: false
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Car2'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
  '/catalogs/{catalogId}/cars-parameters/':
    get:
      operationId: getCarsParameters
      tags:
        - Cars
      summary: Get cars filters of selected catalog
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: modelId
          in: query
          description: Model id
          required: true
          schema:
            type: string
        - name: parameter
          in: query
          description: Filter parameters by idx
          required: false
          style: form
          explode: false
          example: 5651b9c4e2f55b54efe465354b3491e7,59e742688f05ca5ecc71a35cc2ff31c5
          schema:
            type: array
            items:
              type: array
              items:
                $ref: '#/components/schemas/CarParameterIdx'
      responses:
        '200':
          description: Filter
          headers:
            X-Cars-Count:
              description: Cars count filtered by parameters
              schema:
                type: integer
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CarParameterInfo'
        '400':
          $ref: '#/components/responses/badRequest'
        '422':
          $ref: '#/components/responses/parameterMissing'
  '/catalogs/{catalogId}/groups2/':
    get:
      operationId: getGroups
      tags:
        - Groups
      summary: Get catalog groups
      description: >-
        With empty identifier shows main groups of catalog. It is necessary to
        select groups by ID until the "hasParts" value is true. The "hasParts"
        value indicates that the group contains spare parts. The list of spare
        parts can be received by the method parts2.
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: carId
          in: query
          schema:
            type: string
          required: true
        - name: groupId
          in: query
          required: false
          description: Group id
          schema:
            type: string
        - name: criteria
          in: query
          required: false
          description: >-
            Filters outcoming groups depending on criteria string. Criteria
            string can obtain from "car/info" method
          schema:
            type: string
      responses:
        '200':
          description: Catalog groups
          content:
            application/json:
              schema:
                title: Array
                type: array
                items:
                  $ref: '#/components/schemas/Group'
              example:
                - id: "MfCfmoAxMjI4fEE"
                  hasSubgroups: true
                  hasParts: false
                  name: "Accessories"
                  img: "//img.example.com/r/250x250/land_rover_2014_12/1228/A.png"
                  description: ""
                - id: "IzLwn5qAMTIyOHxB8J-agUEwMfCfmoJBMDEwMDV8TFQwMTIwPD4"
                  hasSubgroups: false
                  hasParts: true
                  name: "Auxiliary Lighting-Fog Lamps"
                  img: "//img.example.com/r/250x250/land_rover_2014_12/1228/lt0120().png"
                  description: ""
          links:
            getSubgroups:
              operationId: getGroups
              parameters:
                catalogId: '$request.path.catalogId'
                carId: '$request.query.carId'
                groupId: '$response.body#/0/id'
                criteria: '$request.query.criteria'
              description: >-
                If parameter `hasParts: false`
            getParts:
              operationId: getParts
              parameters:
                catalogId: '$request.path.catalogId'
                carId: '$request.query.carId'
                groupId: '$response.body#/0/id'
                criteria: '$request.query.criteria'
              description: >-
                If parameter `hasParts: true`

        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
        '404':
          $ref: '#/components/responses/notFound'
  /car/info:
    get:
      operationId: getCarInfo
      security:
        - ApiKey: []
      tags:
        - Cars
      summary: Get car info by VIN or FRAME
      description: You may specify VIN or FRAME number in query. Attention! Vehicle identifier may change over time.
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: q
          in: query
          description: >-
            Automatically detects type of input data and performs search of cars
            by VIN or FRAME number depending on input data
          schema:
            type: string
        - name: catalogs
          in: query
          description: List of comma-separated Catalog IDs for search by vin or frame in selected catalogs
          explode: false
          schema:
            type: string
            example: kia,bmw,chevrolet,hyundai

      responses:
        '200':
          description: Ok
          content:
            application/json:
              schema:
                title: Array
                type: array
                items:
                  $ref: '#/components/schemas/CarInfo'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
  '/catalogs/{catalogId}/parts2':
    get:
      operationId: getParts2
      tags:
        - Parts
      summary: Get catalog parts.
      description: >-
        Get catalog parts. In case you receive IDs of groups with the value
        "hasParts=false", you get error 400 (No details found with specified
        parameters).
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/XRedirectTemplate'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: carId
          in: query
          description: Car id
          required: true
          schema:
            type: string
        - name: groupId
          in: query
          description: Group id
          required: true
          schema:
            type: string
        - name: criteria
          in: query
          description: Additional criteria string
          schema:
            type: string
      responses:
        '200':
          description: Parts list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Parts'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
        '404':
          description: No details found with specified parameters
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  '/catalogs/{catalogId}/groups-suggest':
    get:
      operationId: getGroupsSuggest
      tags:
        - Groups
      summary: Get group suggest.
      description: Suggest parts with relative to group id
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: q
          in: query
          description: First letters of searching part
          required: true
          example: 'bat'
          schema:
            type: string
      responses:
        '200':
          description: Suggest list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Suggest'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
        '404':
          description: Search string is empty
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  '/catalogs/{catalogId}/groups-by-sid':
    get:
      deprecated: true
      operationId: getGroupsBySid
      tags:
        - Groups
      summary: Get groups by search id.
      description: Get groups by search id
      security:
        - ApiKey: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - name: catalogId
          in: path
          description: Catalog id
          required: true
          schema:
            type: string
            default: bmw
        - name: sid
          in: query
          description: Search id from group suggest
          required: true
          example: '12345'
          schema:
            type: string
        - name: carId
          in: query
          description: Car id
          required: true
          schema:
            type: string
        - name: criteria
          in: query
          description: Additional criteria string
          schema:
            type: string
        - name: text
          in: query
          description: This field is the name of the part. After searching for groups by sid, we can sort the groups by text, where there may be a part with this name.
          schema:
            type: string
      responses:
        '200':
          description: Suggest list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Group'
        '400':
          $ref: '#/components/responses/badRequest'
        '403':
          $ref: '#/components/responses/accessDeny'
        '404':
          description: Search string is empty
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  /example/prices:
    get:
      operationId: "getExamplePrices"
      summary: "Get prices of part"
      description: |
        This endpoint is a demonstration example showing how to retrieve information about prices and availability of parts by unique product code and brand. It is intended for developers and API architects as an illustration of potential functionality, not as a ready-to-use solution for production environments.
      tags:
        - Example
      parameters:
        - in: "query"
          required: true
          name: "code"
          schema:
            type: "string"
        - in: "query"
          name: "brand"
          required: true
          schema:
            type: "string"
      responses:
        200:
          description: ""
          content:
            application/json:
              schema:
                type: "array"
                items:
                  $ref: "#/components/schemas/ExamplePricesResponse"
        default:
          description: Any error 400 - 500
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  /catalogs/{catalogId}/groups-tree:
    get:
      operationId: "Get groups tree"
      description: "Get groups tree"
      tags:
        - Groups tree
      parameters:
        - in: "path"
          required: true
          name: "catalogId"
          schema:
            type: "string"
        - in: "query"
          name: "carId"
          schema:
            type: "string"
        - in: "query"
          name: "criteria"
          schema:
            type: "string"
        - in: "query"
          name: "cached"
          description: A flag that determines whether the general unfiltered group tree should be retrieved from the cache or filtered tree with increased latency should be retrieved.
          schema:
            type: "boolean"
      responses:
        200:
          description: ""
          content:
            application/json:
              schema:
                type: "array"
                items:
                  $ref: "#/components/schemas/GroupsTreeResponse"
        default:
          description: Any error 400 - 500
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  /catalogs/{catalogId}/schemas:
    get:
      operationId: "Get schemas"
      description: "Get schemas that lead to detail pages."
      tags:
        - Groups tree
      parameters:
        - in: "query"
          required: true
          name: "carId"
          schema:
            type: "string"
        - in: "path"
          required: true
          name: "catalogId"
          schema:
            type: "string"
            example: "toyota"
        - in: "query"
          name: "branchId"
          description: Id for filter schemas by branch id. Branch id it is group id.
          schema:
            type: "string"
        - in: "query"
          name: "criteria"
          schema:
            type: "string"
        - in: "query"
          name: "page"
          description: The page number. One response can contain a maximum of 24 elements.
          schema:
            type: "integer"
            default: 0
            minimum: 0
        - in: "query"
          name: "partNameIds"
          description: Part name ids for filter schemas
          example: "56,85"
          schema:
            type: "string"
        - in: "query"
          name: "partName"
          description: Part name for filter schemas
          example: "Air filter"
          schema:
            type: "string"
      responses:
        200:
          description: ""
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/SchemasResponse"
          headers:
            X-Total-Count:
              schema:
                type: integer
              description: The total number of items available for extraction.
        default:
          description: Any error 400 - 500
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
servers:
  - url: '/v1'
components:
  responses:
    accessDeny:
      description: Access deny
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    parameterMissing:
      description: Unprocessable Entity
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    notFound:
      description: Not Found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    badRequest:
      description: Bad Request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
  securitySchemes:
    ApiKey:
      type: apiKey
      description: Authorization by ApiKey
      name: Authorization
      in: header
  schemas:
    Ip:
      properties:
        ip:
          description: ip value
          type: string
    CarParameterInfo:
      properties:
        key:
          type: string
        name:
          type: string
        values:
          type: array
          items:
            type: object
            properties:
              idx:
                $ref: '#/components/schemas/CarParameterIdx'
              value:
                type: string
        sortOrder:
          type: integer
          description: 'You can sort the parameters in the external interface in the sort order 
                from minimum to maximum. The smaller the sortOrder, the higher the priority of the parameter.'
    CarParameterIdx:
      description: Index of car parameter (idx)
      type: string
    Parts:
      description: Parts description
      required:
        - img
        - partGroups
      properties:
        img:
          description: URL of full-size parts group image
          type: string
        imgDescription:
          description: Parts group description
          type: string
        partGroups:
          description: Parts group list
          type: array
          items:
            $ref: '#/components/schemas/PartsGroup'
        positions:
          description: Positions of blocks with a number on image
          type: array
          items:
            description: Position of block with a part number on image
            type: object
            properties:
              number:
                description: Number on image
                type: string
              coordinates:
                description:
                  Coordinate data<br />
                  X - horizontal coordinate relative to the upper left of the full-size image, in pixels<br />
                  Y - vertical coordinate relative to the upper left of the full-size image, in pixels<br />
                  H - height of block with a part number on the full-size image, in pixels<br />
                  W - width of block with a part number on the full-size image, in pixels
                type: array
                items:
                  description: 'array (X, Y, H, W)'
                  type: number
                minItems: 4
                maxItems: 4
    PartsGroup:
      description: Parts group
      type: object
      required:
        - parts
      properties:
        name:
          description: Part name
          type: string
        number:
          description: Parts group number
          type: string
        positionNumber:
          description: Parts group position number on image
          type: string
        description:
          description: Parts group description. Installation notes, applicability. Description of the part or group of parts.
          type: string
        parts:
          description: Group detail list
          type: array
          items:
            $ref: '#/components/schemas/Part'
    Group:
      description: Group
      required:
        - id
        - name
      properties:
        id:
          description: Group id
          type: string
        parentId:
          description: Parent id. Can be `null` if there is no parent
          type: string
        hasSubgroups:
          description: Indicates that the group has subgroups
          type: boolean
        hasParts:
          description: Indicates that the group has parts
          type: boolean
        name:
          description: Group name
          type: string
        img:
          description: Group image
          type: string
        description:
          description: Group description
          type: string
    Car2:
      description: Car
      required:
        - id
        - catalogId
        - name
      properties:
        id:
          description: |-
            Is a car identifier in the Parts-Catalogs system; 
            this parameter is not constant and can change when updating catalogs
          type: string
        catalogId:
          description: Catalog id
          type: string
        name:
          description: Car name
          type: string
        description:
          description: Car description
          type: string
        modelId:
          description: Car model id
          type: string
          example: 'd3190764f126fabbf56bf3e36efbd56a'
        modelName:
          description: Car model name
          type: string
        modelImg:
          description: Model image URL
          type: string
        vin:
          description: Car vin
          type: string
        frame:
          description: Car frame
          type: string
        criteria:
          description: |-
            Criteria is a parameter, which contains info by VIN taken from the "car/info" method; 
            this parameter is used to filter groups and parts for a specified VIN
          type: string
        brand:
          description: Car brand
          type: string
        groupsTreeAvailable:
          description: Groups tree method availability flag
          type: boolean
        parameters:
          description: Car parameters
          type: array
          items:
            type: object
            properties:
              idx:
                type: string
                description: hash id of car param
              key:
                type: string
              name:
                type: string
              value:
                type: string
              sortOrder:
                type: integer
                description: 'You can sort the parameters in the external interface in the sort order 
                from minimum to maximum. The smaller the sortOrder, the higher the priority of the parameter.'
    CarFilterValues:
      title: Car filter
      description: The values of the specific complectation parameter
      properties:
        name:
          description: Parameter name
          type: object
          properties:
            id:
              description: Parameter id
              type: string
            key:
              description: Inner key of parameter
              type: string
            text:
              description: Parameter text
              type: string
        values:
          description: Parameter value
          type: array
          items:
            type: object
            properties:
              id:
                type: string
                description: Parameter value id
              text:
                type: string
                description: Parameter value text
    Model:
      title: Models
      description: Car model
      required:
        - id
        - name
      properties:
        id:
          description: Model id
          type: string
        name:
          description: Model name
          type: string
        img:
          description: Model image URL
          type: string
    Catalog:
      title: Catalog
      required:
        - id
        - name
        - modelsCount
      properties:
        id:
          description: Catalog id
          type: string
        name:
          description: Catalog name
          type: string
        modelsCount:
          type: integer
    Error:
      title: Error
      description: Error response to request
      required:
        - code
        - message
      properties:
        code:
          description: Response code
          type: integer
          format: int32
        errorCode:
          description: Error code
          type: string
        message:
          description: Text message
          type: string
    CarInfo:
      properties:
        title:
          type: string
        catalogId:
          description: Catalog id
          type: string
        brand:
          description: Car brand
          type: string
        modelId:
          description: Car model id
          type: string
          example: '5bb58a3cab059a189ef92be181380fd5'
        carId:
          description: Car id
          type: string
        criteria:
          description: 'Additional criterias to search in groups, subgroups and parts'
          type: string
        vin:
          description: Car vin
          type: string
        frame:
          description: Car frame
          type: string
        modelName:
          description: Car model name
          type: string
        description:
          description: Car description
          type: string
        groupsTreeAvailable:
          description: Groups tree method availability flag
          type: boolean
        optionCodes:
          description: Car option codes
          type: array
          items:
            properties:
              code:
                type: string
              description:
                type: string
        parameters:
          description: Car parameters
          type: array
          items:
            type: object
            properties:
              idx:
                type: string
                description: hash id of car param
              key:
                type: string
              name:
                type: string
              value:
                type: string
              sortOrder:
                type: integer
                description: 'You can sort the parameters in the external interface in the sort order 
                from minimum to maximum. The smaller the sortOrder, the higher the priority of the parameter.'
    Part:
      description: Part
      type: object
      properties:
        id:
          description: Part id
          type: string
        nameId:
          nullable: true
          description: Name id
          type: string
        name:
          description: Name
          type: string
        number:
          description: Part number
          type: string
        notice:
          type: string
          description: |-
            Short note.
            It can has url for go to sections in gui.
            To get url in this field, you must send header with template for your gui url.
        description:
          description: |-
            Part description. Installation notes, applicability. Replacements. Description and characteristics of the part.
            It can has url for go to sections in gui.
            To get url in this field, you must send header with template for your gui url.
          type: string
        positionNumber:
          description: Position number on image group
          type: string
        url:
          description: Search results URL
          type: string
    Suggest:
      description: suggest
      type: object
      properties:
        sid:
          description: search id
          type: string
          example: '12345'
        name:
          description: Name
          type: string
          example: 'battery'
    ExamplePricesResponse:
      properties:
        id:
          type: "string"
        title:
          type: "string"
        code:
          type: "string"
        brand:
          type: "string"
        price:
          type: "string"
        basketQty:
          type: "string"
        inStockQty:
          type: "string"
        rating:
          type: "string"
        delivery:
          type: "string"
        payload:
          type: "object"
          additionalProperties:
            type: "string"
    SchemasResponse:
      properties:
        group:
          nullable: true
          oneOf:
            - $ref: "#/components/schemas/Group"
        list:
          type: "array"
          items:
            $ref: "#/components/schemas/Schema"
    Schema:
      properties:
        groupId:
          nullable: false
          type: "string"
          example: "IzLwn5qAMDA08J-agTg0RTQyOULwn5SwMjI18J-QkjU4NfCfkIk4NEU0MjlC"
        img:
          nullable: true
          type: "string"
          example: "//img.parts-catalogs.com/toyota_2022_12/usa/84E429B.png"
        name:
          nullable: false
          type: "string"
          example: "ENGINE & TRANSMISSION ILLUST NO. 1 OF 7"
        description:
          nullable: true
          type: "string"
          example: ""
        partNames:
          type: "array"
          items:
            $ref: "#/components/schemas/PartName"
    PartName:
      properties:
        id:
          nullable: false
          type: "string"
        name:
          nullable: false
          type: "string"
    GroupsTreeResponse:
      properties:
        id:
          nullable: false
          type: "string"
        name:
          nullable: false
          type: "string"
        parentId:
          nullable: true
          type: "string"
        subGroups:
          nullable: false
          type: "array"
          items:
            $ref: "#/components/schemas/GroupsTree"
    GroupsTree:
      properties:
        id:
          nullable: false
          type: "string"
        name:
          nullable: false
          type: "string"
        parentId:
          nullable: true
          type: "string"
        subGroups:
          nullable: false
          type: "array"
          example: [ ]
  parameters:
    AcceptLanguage:
      name: Accept-Language
      in: header
      description: Language of return data
      schema:
        type: string
        default: en
        enum: [en, ru, de, bg, fr, es, he]
    XRedirectTemplate:
      name: x-redirect-template
      in: header
      description:  |-
        Template for your gui url.
        In template must be 2 templates separated by commas for go to group list and parts list.
        If vin is not used, then you do not need to pass criteria and vin to the template.
      schema:
        type: string
        example: parts <a href="#/parts?catalogId=%catalogId%&modelId=%modelId%&carId=%carId%&groupId=%groupId%&q=%vin%&criteria=%criteria%">%text%</a>, groups <a href="#/groups?catalogId=%catalogId%&modelId=%modelId%&carId=%carId%&groupsPath=%groupId%&q=%vin%&criteria=%criteria%">%text%</a>
```

## lib\features\parts_catalog\api\api_client_parts_catalogs.dart
```dart
import 'package:dio/dio.dart';
import 'package:retrofit/retrofit.dart';
import 'package:part_catalog/features/parts_catalog/models/catalog.dart';
import 'package:part_catalog/features/parts_catalog/models/model.dart';
import 'package:part_catalog/features/parts_catalog/models/car2.dart';
import 'package:part_catalog/features/parts_catalog/models/car_parameter_info.dart';
import 'package:part_catalog/features/parts_catalog/models/group.dart';
import 'package:part_catalog/features/parts_catalog/models/car_info.dart';
import 'package:part_catalog/features/parts_catalog/models/parts.dart';
import 'package:part_catalog/features/parts_catalog/models/suggest.dart';
import 'package:part_catalog/features/parts_catalog/models/example_prices_response.dart';
import 'package:part_catalog/features/parts_catalog/models/groups_tree_response.dart';
import 'package:part_catalog/features/parts_catalog/models/schemas_response.dart';

part 'api_client_parts_catalogs.g.dart';

/// {@template api_client_parts_catalogs}
/// Клиент для взаимодействия с API каталогов.
/// {@endtemplate}
@RestApi(baseUrl: "https://api.parts-catalogs.com/v1")
abstract class ApiClientPartsCatalogs {
  /// {@macro api_client_parts_catalogs}
  factory ApiClientPartsCatalogs(Dio dio) = _ApiClientPartsCatalogs;

  /// Получает список доступных каталогов.
  ///
  /// Параметры:
  ///   - apiKey: Ключ API для авторизации.
  ///   - language: Язык, на котором нужно получить данные.
  @GET("/catalogs/")
  Future<List<Catalog>> getCatalogs(@Header("Authorization") String apiKey,
      @Header("Accept-Language") String language);

  /// Получает список моделей автомобилей для указанного каталога.
  @GET("/catalogs/{catalogId}/models/")
  Future<List<Model>> getModels(
    @Path("catalogId") String catalogId,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает список автомобилей для указанного каталога и модели.
  @GET("/catalogs/{catalogId}/cars2/")
  Future<List<Car2>> getCars2(
    @Path("catalogId") String catalogId,
    @Query("modelId") String modelId,
    @Query("parameter") List<List<String>>? parameter,
    @Query("page") int? page,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает информацию об автомобиле по ID.
  @GET("/catalogs/{catalogId}/cars2/{carId}")
  Future<Car2> getCarsById2(
    @Path("catalogId") String catalogId,
    @Path("carId") String carId,
    @Query("criteria") String? criteria,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает параметры фильтрации автомобилей для указанного каталога.
  @GET("/catalogs/{catalogId}/cars-parameters/")
  Future<List<CarParameterInfo>> getCarsParameters(
    @Path("catalogId") String catalogId,
    @Query("modelId") String modelId,
    @Query("parameter") List<List<String>>? parameter,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает список групп для указанного каталога и автомобиля.
  @GET("/catalogs/{catalogId}/groups2/")
  Future<List<Group>> getGroups(
    @Path("catalogId") String catalogId,
    @Query("carId") String carId,
    @Query("groupId") String? groupId,
    @Query("criteria") String? criteria,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает информацию об автомобиле по VIN или FRAME.
  @GET("/car/info")
  Future<List<CarInfo>> getCarInfo(
    @Query("q") String q,
    @Query("catalogs") String? catalogs,
    @Header("Authorization") String apiKey, // Added Authorization header
    @Header("Accept-Language") String language,
  );

  /// Получает список запчастей для указанного каталога, автомобиля и группы.
  @GET("/catalogs/{catalogId}/parts2")
  Future<Parts> getParts2(
    @Path("catalogId") String catalogId,
    @Query("carId") String carId,
    @Query("groupId") String groupId,
    @Query("criteria") String? criteria,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
    @Header("x-redirect-template") String? xRedirectTemplate,
  );

  /// Получает список предложений для поиска групп.
  @GET("/catalogs/{catalogId}/groups-suggest")
  Future<List<Suggest>> getGroupsSuggest(
    @Path("catalogId") String catalogId,
    @Query("q") String q,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает список групп по ID поиска.
  @GET("/catalogs/{catalogId}/groups-by-sid")
  Future<List<Group>> getGroupsBySid(
    @Path("catalogId") String catalogId,
    @Query("sid") String sid,
    @Query("carId") String carId,
    @Query("criteria") String? criteria,
    @Query("text") String? text,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );

  /// Получает пример цен на запчасти.
  @GET("/example/prices")
  Future<List<ExamplePricesResponse>> getExamplePrices(
    @Query("code") String code,
    @Query("brand") String brand,
    @Header("Authorization") String apiKey,
  );

  /// Получает дерево групп.
  @GET("/catalogs/{catalogId}/groups-tree")
  Future<List<GroupsTreeResponse>> getGroupsTree(
    @Path("catalogId") String catalogId,
    @Query("carId") String? carId,
    @Query("criteria") String? criteria,
    @Query("cached") bool? cached,
    @Header("Authorization") String apiKey,
  );

  /// Получает схемы, ведущие к страницам деталей.
  @GET("/catalogs/{catalogId}/schemas")
  Future<SchemasResponse> getSchemas(
    @Path("catalogId") String catalogId,
    @Query("carId") String carId,
    @Query("branchId") String? branchId,
    @Query("criteria") String? criteria,
    @Query("page") int? page,
    @Query("partNameIds") String? partNameIds,
    @Query("partName") String? partName,
    @Header("Authorization") String apiKey,
    @Header("Accept-Language") String language,
  );
  // Другие endpoints
}

```

## lib\features\parts_catalog\api\api_client_parts_catalogs.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_client_parts_catalogs.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _ApiClientPartsCatalogs implements ApiClientPartsCatalogs {
  _ApiClientPartsCatalogs(this._dio, {this.baseUrl, this.errorLogger}) {
    baseUrl ??= 'https://api.parts-catalogs.com/v1';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<List<Catalog>> getCatalogs(String apiKey, String language) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{};
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Catalog>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Catalog> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Catalog.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<Model>> getModels(
    String catalogId,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{};
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Model>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/models/',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Model> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Model.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<Car2>> getCars2(
    String catalogId,
    String modelId,
    List<List<String>>? parameter,
    int? page,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'modelId': modelId,
      r'parameter': parameter,
      r'page': page,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Car2>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/cars2/',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Car2> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Car2.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<Car2> getCarsById2(
    String catalogId,
    String carId,
    String? criteria,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'criteria': criteria};
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<Car2>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/cars2/${carId}',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late Car2 _value;
    try {
      _value = Car2.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<CarParameterInfo>> getCarsParameters(
    String catalogId,
    String modelId,
    List<List<String>>? parameter,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'modelId': modelId,
      r'parameter': parameter,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<CarParameterInfo>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/cars-parameters/',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<CarParameterInfo> _value;
    try {
      _value = _result.data!
          .map(
            (dynamic i) => CarParameterInfo.fromJson(i as Map<String, dynamic>),
          )
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<Group>> getGroups(
    String catalogId,
    String carId,
    String? groupId,
    String? criteria,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'carId': carId,
      r'groupId': groupId,
      r'criteria': criteria,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Group>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/groups2/',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Group> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Group.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<CarInfo>> getCarInfo(
    String q,
    String? catalogs,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'q': q, r'catalogs': catalogs};
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<CarInfo>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/car/info',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<CarInfo> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => CarInfo.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<Parts> getParts2(
    String catalogId,
    String carId,
    String groupId,
    String? criteria,
    String apiKey,
    String language,
    String? xRedirectTemplate,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'carId': carId,
      r'groupId': groupId,
      r'criteria': criteria,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
      r'x-redirect-template': xRedirectTemplate,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<Parts>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/parts2',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late Parts _value;
    try {
      _value = Parts.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<Suggest>> getGroupsSuggest(
    String catalogId,
    String q,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'q': q};
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Suggest>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/groups-suggest',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Suggest> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Suggest.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<Group>> getGroupsBySid(
    String catalogId,
    String sid,
    String carId,
    String? criteria,
    String? text,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'sid': sid,
      r'carId': carId,
      r'criteria': criteria,
      r'text': text,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<Group>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/groups-by-sid',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<Group> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => Group.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<ExamplePricesResponse>> getExamplePrices(
    String code,
    String brand,
    String apiKey,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'code': code, r'brand': brand};
    final _headers = <String, dynamic>{r'Authorization': apiKey};
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<ExamplePricesResponse>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/example/prices',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<ExamplePricesResponse> _value;
    try {
      _value = _result.data!
          .map(
            (dynamic i) =>
                ExamplePricesResponse.fromJson(i as Map<String, dynamic>),
          )
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<List<GroupsTreeResponse>> getGroupsTree(
    String catalogId,
    String? carId,
    String? criteria,
    bool? cached,
    String apiKey,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'carId': carId,
      r'criteria': criteria,
      r'cached': cached,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{r'Authorization': apiKey};
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<GroupsTreeResponse>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/groups-tree',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<GroupsTreeResponse> _value;
    try {
      _value = _result.data!
          .map(
            (dynamic i) =>
                GroupsTreeResponse.fromJson(i as Map<String, dynamic>),
          )
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<SchemasResponse> getSchemas(
    String catalogId,
    String carId,
    String? branchId,
    String? criteria,
    int? page,
    String? partNameIds,
    String? partName,
    String apiKey,
    String language,
  ) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'carId': carId,
      r'branchId': branchId,
      r'criteria': criteria,
      r'page': page,
      r'partNameIds': partNameIds,
      r'partName': partName,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{
      r'Authorization': apiKey,
      r'Accept-Language': language,
    };
    _headers.removeWhere((k, v) => v == null);
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<SchemasResponse>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/catalogs/${catalogId}/schemas',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late SchemasResponse _value;
    try {
      _value = SchemasResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(String dioBaseUrl, String? baseUrl) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

```

## lib\features\parts_catalog\models\car2.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'car2.freezed.dart';
part 'car2.g.dart';

/// {@template car2}
/// Модель данных для автомобиля (Car2).
/// {@endtemplate}
@freezed
abstract class Car2 with _$Car2 {
  /// {@macro car2}
  factory Car2({
    /// Идентификатор автомобиля.
    @JsonKey(name: 'id') required String id,

    /// Идентификатор каталога.
    @JsonKey(name: 'catalogId') required String catalogId,

    /// Название автомобиля.
    @JsonKey(name: 'name') required String name,

    /// Описание автомобиля.
    @JsonKey(name: 'description') String? description,

    /// Идентификатор модели автомобиля.
    @JsonKey(name: 'modelId') String? modelId,

    /// Название модели автомобиля.
    @JsonKey(name: 'modelName') String? modelName,

    /// URL изображения модели автомобиля.
    @JsonKey(name: 'modelImg') String? modelImg,

    /// VIN автомобиля.
    @JsonKey(name: 'vin') String? vin,

    /// FRAME автомобиля.
    @JsonKey(name: 'frame') String? frame,

    /// Критерии для фильтрации групп и запчастей.
    @JsonKey(name: 'criteria') String? criteria,

    /// Бренд автомобиля.
    @JsonKey(name: 'brand') String? brand,

    /// Флаг доступности дерева групп.
    @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,

    /// Параметры автомобиля.
    @JsonKey(name: 'parameters') List<CarParameter>? parameters,
  }) = _Car2;

  /// Преобразует JSON в объект [Car2].
  factory Car2.fromJson(Map<String, dynamic> json) => _$Car2FromJson(json);
}

/// {@template car_parameter}
/// Модель данных для параметра автомобиля.
/// {@endtemplate}
@freezed
abstract class CarParameter with _$CarParameter {
  /// {@macro car_parameter}
  factory CarParameter({
    /// Hash ID параметра автомобиля.
    @JsonKey(name: 'idx') String? idx,

    /// Ключ параметра автомобиля.
    @JsonKey(name: 'key') String? key,

    /// Название параметра автомобиля.
    @JsonKey(name: 'name') String? name,

    /// Значение параметра автомобиля.
    @JsonKey(name: 'value') String? value,

    /// Порядок сортировки параметра автомобиля.
    @JsonKey(name: 'sortOrder') int? sortOrder,
  }) = _CarParameter;

  /// Преобразует JSON в объект [CarParameter].
  factory CarParameter.fromJson(Map<String, dynamic> json) =>
      _$CarParameterFromJson(json);
}

```

## lib\features\parts_catalog\models\car2.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car2.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Car2 {
  /// Идентификатор автомобиля.
  @JsonKey(name: 'id')
  String get id;

  /// Идентификатор каталога.
  @JsonKey(name: 'catalogId')
  String get catalogId;

  /// Название автомобиля.
  @JsonKey(name: 'name')
  String get name;

  /// Описание автомобиля.
  @JsonKey(name: 'description')
  String? get description;

  /// Идентификатор модели автомобиля.
  @JsonKey(name: 'modelId')
  String? get modelId;

  /// Название модели автомобиля.
  @JsonKey(name: 'modelName')
  String? get modelName;

  /// URL изображения модели автомобиля.
  @JsonKey(name: 'modelImg')
  String? get modelImg;

  /// VIN автомобиля.
  @JsonKey(name: 'vin')
  String? get vin;

  /// FRAME автомобиля.
  @JsonKey(name: 'frame')
  String? get frame;

  /// Критерии для фильтрации групп и запчастей.
  @JsonKey(name: 'criteria')
  String? get criteria;

  /// Бренд автомобиля.
  @JsonKey(name: 'brand')
  String? get brand;

  /// Флаг доступности дерева групп.
  @JsonKey(name: 'groupsTreeAvailable')
  bool? get groupsTreeAvailable;

  /// Параметры автомобиля.
  @JsonKey(name: 'parameters')
  List<CarParameter>? get parameters;

  /// Create a copy of Car2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $Car2CopyWith<Car2> get copyWith =>
      _$Car2CopyWithImpl<Car2>(this as Car2, _$identity);

  /// Serializes this Car2 to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Car2 &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.catalogId, catalogId) ||
                other.catalogId == catalogId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.modelName, modelName) ||
                other.modelName == modelName) &&
            (identical(other.modelImg, modelImg) ||
                other.modelImg == modelImg) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.frame, frame) || other.frame == frame) &&
            (identical(other.criteria, criteria) ||
                other.criteria == criteria) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.groupsTreeAvailable, groupsTreeAvailable) ||
                other.groupsTreeAvailable == groupsTreeAvailable) &&
            const DeepCollectionEquality()
                .equals(other.parameters, parameters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      catalogId,
      name,
      description,
      modelId,
      modelName,
      modelImg,
      vin,
      frame,
      criteria,
      brand,
      groupsTreeAvailable,
      const DeepCollectionEquality().hash(parameters));

  @override
  String toString() {
    return 'Car2(id: $id, catalogId: $catalogId, name: $name, description: $description, modelId: $modelId, modelName: $modelName, modelImg: $modelImg, vin: $vin, frame: $frame, criteria: $criteria, brand: $brand, groupsTreeAvailable: $groupsTreeAvailable, parameters: $parameters)';
  }
}

/// @nodoc
abstract mixin class $Car2CopyWith<$Res> {
  factory $Car2CopyWith(Car2 value, $Res Function(Car2) _then) =
      _$Car2CopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'catalogId') String catalogId,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'modelId') String? modelId,
      @JsonKey(name: 'modelName') String? modelName,
      @JsonKey(name: 'modelImg') String? modelImg,
      @JsonKey(name: 'vin') String? vin,
      @JsonKey(name: 'frame') String? frame,
      @JsonKey(name: 'criteria') String? criteria,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,
      @JsonKey(name: 'parameters') List<CarParameter>? parameters});
}

/// @nodoc
class _$Car2CopyWithImpl<$Res> implements $Car2CopyWith<$Res> {
  _$Car2CopyWithImpl(this._self, this._then);

  final Car2 _self;
  final $Res Function(Car2) _then;

  /// Create a copy of Car2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? catalogId = null,
    Object? name = null,
    Object? description = freezed,
    Object? modelId = freezed,
    Object? modelName = freezed,
    Object? modelImg = freezed,
    Object? vin = freezed,
    Object? frame = freezed,
    Object? criteria = freezed,
    Object? brand = freezed,
    Object? groupsTreeAvailable = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      catalogId: null == catalogId
          ? _self.catalogId
          : catalogId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _self.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      modelName: freezed == modelName
          ? _self.modelName
          : modelName // ignore: cast_nullable_to_non_nullable
              as String?,
      modelImg: freezed == modelImg
          ? _self.modelImg
          : modelImg // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      frame: freezed == frame
          ? _self.frame
          : frame // ignore: cast_nullable_to_non_nullable
              as String?,
      criteria: freezed == criteria
          ? _self.criteria
          : criteria // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      groupsTreeAvailable: freezed == groupsTreeAvailable
          ? _self.groupsTreeAvailable
          : groupsTreeAvailable // ignore: cast_nullable_to_non_nullable
              as bool?,
      parameters: freezed == parameters
          ? _self.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<CarParameter>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Car2 implements Car2 {
  _Car2(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'catalogId') required this.catalogId,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'modelId') this.modelId,
      @JsonKey(name: 'modelName') this.modelName,
      @JsonKey(name: 'modelImg') this.modelImg,
      @JsonKey(name: 'vin') this.vin,
      @JsonKey(name: 'frame') this.frame,
      @JsonKey(name: 'criteria') this.criteria,
      @JsonKey(name: 'brand') this.brand,
      @JsonKey(name: 'groupsTreeAvailable') this.groupsTreeAvailable,
      @JsonKey(name: 'parameters') final List<CarParameter>? parameters})
      : _parameters = parameters;
  factory _Car2.fromJson(Map<String, dynamic> json) => _$Car2FromJson(json);

  /// Идентификатор автомобиля.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Идентификатор каталога.
  @override
  @JsonKey(name: 'catalogId')
  final String catalogId;

  /// Название автомобиля.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Описание автомобиля.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Идентификатор модели автомобиля.
  @override
  @JsonKey(name: 'modelId')
  final String? modelId;

  /// Название модели автомобиля.
  @override
  @JsonKey(name: 'modelName')
  final String? modelName;

  /// URL изображения модели автомобиля.
  @override
  @JsonKey(name: 'modelImg')
  final String? modelImg;

  /// VIN автомобиля.
  @override
  @JsonKey(name: 'vin')
  final String? vin;

  /// FRAME автомобиля.
  @override
  @JsonKey(name: 'frame')
  final String? frame;

  /// Критерии для фильтрации групп и запчастей.
  @override
  @JsonKey(name: 'criteria')
  final String? criteria;

  /// Бренд автомобиля.
  @override
  @JsonKey(name: 'brand')
  final String? brand;

  /// Флаг доступности дерева групп.
  @override
  @JsonKey(name: 'groupsTreeAvailable')
  final bool? groupsTreeAvailable;

  /// Параметры автомобиля.
  final List<CarParameter>? _parameters;

  /// Параметры автомобиля.
  @override
  @JsonKey(name: 'parameters')
  List<CarParameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of Car2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$Car2CopyWith<_Car2> get copyWith =>
      __$Car2CopyWithImpl<_Car2>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$Car2ToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Car2 &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.catalogId, catalogId) ||
                other.catalogId == catalogId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.modelName, modelName) ||
                other.modelName == modelName) &&
            (identical(other.modelImg, modelImg) ||
                other.modelImg == modelImg) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.frame, frame) || other.frame == frame) &&
            (identical(other.criteria, criteria) ||
                other.criteria == criteria) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.groupsTreeAvailable, groupsTreeAvailable) ||
                other.groupsTreeAvailable == groupsTreeAvailable) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      catalogId,
      name,
      description,
      modelId,
      modelName,
      modelImg,
      vin,
      frame,
      criteria,
      brand,
      groupsTreeAvailable,
      const DeepCollectionEquality().hash(_parameters));

  @override
  String toString() {
    return 'Car2(id: $id, catalogId: $catalogId, name: $name, description: $description, modelId: $modelId, modelName: $modelName, modelImg: $modelImg, vin: $vin, frame: $frame, criteria: $criteria, brand: $brand, groupsTreeAvailable: $groupsTreeAvailable, parameters: $parameters)';
  }
}

/// @nodoc
abstract mixin class _$Car2CopyWith<$Res> implements $Car2CopyWith<$Res> {
  factory _$Car2CopyWith(_Car2 value, $Res Function(_Car2) _then) =
      __$Car2CopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'catalogId') String catalogId,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'modelId') String? modelId,
      @JsonKey(name: 'modelName') String? modelName,
      @JsonKey(name: 'modelImg') String? modelImg,
      @JsonKey(name: 'vin') String? vin,
      @JsonKey(name: 'frame') String? frame,
      @JsonKey(name: 'criteria') String? criteria,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,
      @JsonKey(name: 'parameters') List<CarParameter>? parameters});
}

/// @nodoc
class __$Car2CopyWithImpl<$Res> implements _$Car2CopyWith<$Res> {
  __$Car2CopyWithImpl(this._self, this._then);

  final _Car2 _self;
  final $Res Function(_Car2) _then;

  /// Create a copy of Car2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? catalogId = null,
    Object? name = null,
    Object? description = freezed,
    Object? modelId = freezed,
    Object? modelName = freezed,
    Object? modelImg = freezed,
    Object? vin = freezed,
    Object? frame = freezed,
    Object? criteria = freezed,
    Object? brand = freezed,
    Object? groupsTreeAvailable = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_Car2(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      catalogId: null == catalogId
          ? _self.catalogId
          : catalogId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _self.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      modelName: freezed == modelName
          ? _self.modelName
          : modelName // ignore: cast_nullable_to_non_nullable
              as String?,
      modelImg: freezed == modelImg
          ? _self.modelImg
          : modelImg // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      frame: freezed == frame
          ? _self.frame
          : frame // ignore: cast_nullable_to_non_nullable
              as String?,
      criteria: freezed == criteria
          ? _self.criteria
          : criteria // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      groupsTreeAvailable: freezed == groupsTreeAvailable
          ? _self.groupsTreeAvailable
          : groupsTreeAvailable // ignore: cast_nullable_to_non_nullable
              as bool?,
      parameters: freezed == parameters
          ? _self._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<CarParameter>?,
    ));
  }
}

/// @nodoc
mixin _$CarParameter {
  /// Hash ID параметра автомобиля.
  @JsonKey(name: 'idx')
  String? get idx;

  /// Ключ параметра автомобиля.
  @JsonKey(name: 'key')
  String? get key;

  /// Название параметра автомобиля.
  @JsonKey(name: 'name')
  String? get name;

  /// Значение параметра автомобиля.
  @JsonKey(name: 'value')
  String? get value;

  /// Порядок сортировки параметра автомобиля.
  @JsonKey(name: 'sortOrder')
  int? get sortOrder;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarParameterCopyWith<CarParameter> get copyWith =>
      _$CarParameterCopyWithImpl<CarParameter>(
          this as CarParameter, _$identity);

  /// Serializes this CarParameter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarParameter &&
            (identical(other.idx, idx) || other.idx == idx) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, idx, key, name, value, sortOrder);

  @override
  String toString() {
    return 'CarParameter(idx: $idx, key: $key, name: $name, value: $value, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class $CarParameterCopyWith<$Res> {
  factory $CarParameterCopyWith(
          CarParameter value, $Res Function(CarParameter) _then) =
      _$CarParameterCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'idx') String? idx,
      @JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'value') String? value,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class _$CarParameterCopyWithImpl<$Res> implements $CarParameterCopyWith<$Res> {
  _$CarParameterCopyWithImpl(this._self, this._then);

  final CarParameter _self;
  final $Res Function(CarParameter) _then;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idx = freezed,
    Object? key = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_self.copyWith(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarParameter implements CarParameter {
  _CarParameter(
      {@JsonKey(name: 'idx') this.idx,
      @JsonKey(name: 'key') this.key,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'value') this.value,
      @JsonKey(name: 'sortOrder') this.sortOrder});
  factory _CarParameter.fromJson(Map<String, dynamic> json) =>
      _$CarParameterFromJson(json);

  /// Hash ID параметра автомобиля.
  @override
  @JsonKey(name: 'idx')
  final String? idx;

  /// Ключ параметра автомобиля.
  @override
  @JsonKey(name: 'key')
  final String? key;

  /// Название параметра автомобиля.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Значение параметра автомобиля.
  @override
  @JsonKey(name: 'value')
  final String? value;

  /// Порядок сортировки параметра автомобиля.
  @override
  @JsonKey(name: 'sortOrder')
  final int? sortOrder;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarParameterCopyWith<_CarParameter> get copyWith =>
      __$CarParameterCopyWithImpl<_CarParameter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarParameterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarParameter &&
            (identical(other.idx, idx) || other.idx == idx) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, idx, key, name, value, sortOrder);

  @override
  String toString() {
    return 'CarParameter(idx: $idx, key: $key, name: $name, value: $value, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class _$CarParameterCopyWith<$Res>
    implements $CarParameterCopyWith<$Res> {
  factory _$CarParameterCopyWith(
          _CarParameter value, $Res Function(_CarParameter) _then) =
      __$CarParameterCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'idx') String? idx,
      @JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'value') String? value,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class __$CarParameterCopyWithImpl<$Res>
    implements _$CarParameterCopyWith<$Res> {
  __$CarParameterCopyWithImpl(this._self, this._then);

  final _CarParameter _self;
  final $Res Function(_CarParameter) _then;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? idx = freezed,
    Object? key = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_CarParameter(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\car2.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car2.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Car2 _$Car2FromJson(Map<String, dynamic> json) => _Car2(
      id: json['id'] as String,
      catalogId: json['catalogId'] as String,
      name: json['name'] as String,
      description: json['description'] as String?,
      modelId: json['modelId'] as String?,
      modelName: json['modelName'] as String?,
      modelImg: json['modelImg'] as String?,
      vin: json['vin'] as String?,
      frame: json['frame'] as String?,
      criteria: json['criteria'] as String?,
      brand: json['brand'] as String?,
      groupsTreeAvailable: json['groupsTreeAvailable'] as bool?,
      parameters: (json['parameters'] as List<dynamic>?)
          ?.map((e) => CarParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$Car2ToJson(_Car2 instance) => <String, dynamic>{
      'id': instance.id,
      'catalogId': instance.catalogId,
      'name': instance.name,
      'description': instance.description,
      'modelId': instance.modelId,
      'modelName': instance.modelName,
      'modelImg': instance.modelImg,
      'vin': instance.vin,
      'frame': instance.frame,
      'criteria': instance.criteria,
      'brand': instance.brand,
      'groupsTreeAvailable': instance.groupsTreeAvailable,
      'parameters': instance.parameters,
    };

_CarParameter _$CarParameterFromJson(Map<String, dynamic> json) =>
    _CarParameter(
      idx: json['idx'] as String?,
      key: json['key'] as String?,
      name: json['name'] as String?,
      value: json['value'] as String?,
      sortOrder: (json['sortOrder'] as num?)?.toInt(),
    );

Map<String, dynamic> _$CarParameterToJson(_CarParameter instance) =>
    <String, dynamic>{
      'idx': instance.idx,
      'key': instance.key,
      'name': instance.name,
      'value': instance.value,
      'sortOrder': instance.sortOrder,
    };

```

## lib\features\parts_catalog\models\car_info.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/car_parameter.dart';
import 'package:part_catalog/features/parts_catalog/models/option_code.dart';

part 'car_info.freezed.dart';
part 'car_info.g.dart';

/// {@template car_info}
/// Модель данных для информации об автомобиле.
/// {@endtemplate}
@freezed
abstract class CarInfo with _$CarInfo {
  /// {@macro car_info}
  factory CarInfo({
    /// Заголовок.
    @JsonKey(name: 'title') String? title,

    /// Идентификатор каталога.
    @JsonKey(name: 'catalogId') String? catalogId,

    /// Бренд автомобиля.
    @JsonKey(name: 'brand') String? brand,

    /// Идентификатор модели автомобиля.
    @JsonKey(name: 'modelId') String? modelId,

    /// Идентификатор автомобиля.
    @JsonKey(name: 'carId') String? carId,

    /// Критерии для поиска.
    @JsonKey(name: 'criteria') String? criteria,

    /// VIN автомобиля.
    @JsonKey(name: 'vin') String? vin,

    /// FRAME автомобиля.
    @JsonKey(name: 'frame') String? frame,

    /// Название модели автомобиля.
    @JsonKey(name: 'modelName') String? modelName,

    /// Описание автомобиля.
    @JsonKey(name: 'description') String? description,

    /// Флаг доступности дерева групп.
    @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,

    /// Список кодов опций автомобиля.
    @JsonKey(name: 'optionCodes') List<OptionCode>? optionCodes,

    /// Список параметров автомобиля.
    @JsonKey(name: 'parameters') List<CarParameter>? parameters,
  }) = _CarInfo;

  /// Преобразует JSON в объект [CarInfo].
  factory CarInfo.fromJson(Map<String, dynamic> json) =>
      _$CarInfoFromJson(json);
}

```

## lib\features\parts_catalog\models\car_info.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CarInfo {
  /// Заголовок.
  @JsonKey(name: 'title')
  String? get title;

  /// Идентификатор каталога.
  @JsonKey(name: 'catalogId')
  String? get catalogId;

  /// Бренд автомобиля.
  @JsonKey(name: 'brand')
  String? get brand;

  /// Идентификатор модели автомобиля.
  @JsonKey(name: 'modelId')
  String? get modelId;

  /// Идентификатор автомобиля.
  @JsonKey(name: 'carId')
  String? get carId;

  /// Критерии для поиска.
  @JsonKey(name: 'criteria')
  String? get criteria;

  /// VIN автомобиля.
  @JsonKey(name: 'vin')
  String? get vin;

  /// FRAME автомобиля.
  @JsonKey(name: 'frame')
  String? get frame;

  /// Название модели автомобиля.
  @JsonKey(name: 'modelName')
  String? get modelName;

  /// Описание автомобиля.
  @JsonKey(name: 'description')
  String? get description;

  /// Флаг доступности дерева групп.
  @JsonKey(name: 'groupsTreeAvailable')
  bool? get groupsTreeAvailable;

  /// Список кодов опций автомобиля.
  @JsonKey(name: 'optionCodes')
  List<OptionCode>? get optionCodes;

  /// Список параметров автомобиля.
  @JsonKey(name: 'parameters')
  List<CarParameter>? get parameters;

  /// Create a copy of CarInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarInfoCopyWith<CarInfo> get copyWith =>
      _$CarInfoCopyWithImpl<CarInfo>(this as CarInfo, _$identity);

  /// Serializes this CarInfo to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarInfo &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.catalogId, catalogId) ||
                other.catalogId == catalogId) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.carId, carId) || other.carId == carId) &&
            (identical(other.criteria, criteria) ||
                other.criteria == criteria) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.frame, frame) || other.frame == frame) &&
            (identical(other.modelName, modelName) ||
                other.modelName == modelName) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.groupsTreeAvailable, groupsTreeAvailable) ||
                other.groupsTreeAvailable == groupsTreeAvailable) &&
            const DeepCollectionEquality()
                .equals(other.optionCodes, optionCodes) &&
            const DeepCollectionEquality()
                .equals(other.parameters, parameters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      catalogId,
      brand,
      modelId,
      carId,
      criteria,
      vin,
      frame,
      modelName,
      description,
      groupsTreeAvailable,
      const DeepCollectionEquality().hash(optionCodes),
      const DeepCollectionEquality().hash(parameters));

  @override
  String toString() {
    return 'CarInfo(title: $title, catalogId: $catalogId, brand: $brand, modelId: $modelId, carId: $carId, criteria: $criteria, vin: $vin, frame: $frame, modelName: $modelName, description: $description, groupsTreeAvailable: $groupsTreeAvailable, optionCodes: $optionCodes, parameters: $parameters)';
  }
}

/// @nodoc
abstract mixin class $CarInfoCopyWith<$Res> {
  factory $CarInfoCopyWith(CarInfo value, $Res Function(CarInfo) _then) =
      _$CarInfoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String? title,
      @JsonKey(name: 'catalogId') String? catalogId,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'modelId') String? modelId,
      @JsonKey(name: 'carId') String? carId,
      @JsonKey(name: 'criteria') String? criteria,
      @JsonKey(name: 'vin') String? vin,
      @JsonKey(name: 'frame') String? frame,
      @JsonKey(name: 'modelName') String? modelName,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,
      @JsonKey(name: 'optionCodes') List<OptionCode>? optionCodes,
      @JsonKey(name: 'parameters') List<CarParameter>? parameters});
}

/// @nodoc
class _$CarInfoCopyWithImpl<$Res> implements $CarInfoCopyWith<$Res> {
  _$CarInfoCopyWithImpl(this._self, this._then);

  final CarInfo _self;
  final $Res Function(CarInfo) _then;

  /// Create a copy of CarInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? catalogId = freezed,
    Object? brand = freezed,
    Object? modelId = freezed,
    Object? carId = freezed,
    Object? criteria = freezed,
    Object? vin = freezed,
    Object? frame = freezed,
    Object? modelName = freezed,
    Object? description = freezed,
    Object? groupsTreeAvailable = freezed,
    Object? optionCodes = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_self.copyWith(
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      catalogId: freezed == catalogId
          ? _self.catalogId
          : catalogId // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _self.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      carId: freezed == carId
          ? _self.carId
          : carId // ignore: cast_nullable_to_non_nullable
              as String?,
      criteria: freezed == criteria
          ? _self.criteria
          : criteria // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      frame: freezed == frame
          ? _self.frame
          : frame // ignore: cast_nullable_to_non_nullable
              as String?,
      modelName: freezed == modelName
          ? _self.modelName
          : modelName // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      groupsTreeAvailable: freezed == groupsTreeAvailable
          ? _self.groupsTreeAvailable
          : groupsTreeAvailable // ignore: cast_nullable_to_non_nullable
              as bool?,
      optionCodes: freezed == optionCodes
          ? _self.optionCodes
          : optionCodes // ignore: cast_nullable_to_non_nullable
              as List<OptionCode>?,
      parameters: freezed == parameters
          ? _self.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<CarParameter>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarInfo implements CarInfo {
  _CarInfo(
      {@JsonKey(name: 'title') this.title,
      @JsonKey(name: 'catalogId') this.catalogId,
      @JsonKey(name: 'brand') this.brand,
      @JsonKey(name: 'modelId') this.modelId,
      @JsonKey(name: 'carId') this.carId,
      @JsonKey(name: 'criteria') this.criteria,
      @JsonKey(name: 'vin') this.vin,
      @JsonKey(name: 'frame') this.frame,
      @JsonKey(name: 'modelName') this.modelName,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'groupsTreeAvailable') this.groupsTreeAvailable,
      @JsonKey(name: 'optionCodes') final List<OptionCode>? optionCodes,
      @JsonKey(name: 'parameters') final List<CarParameter>? parameters})
      : _optionCodes = optionCodes,
        _parameters = parameters;
  factory _CarInfo.fromJson(Map<String, dynamic> json) =>
      _$CarInfoFromJson(json);

  /// Заголовок.
  @override
  @JsonKey(name: 'title')
  final String? title;

  /// Идентификатор каталога.
  @override
  @JsonKey(name: 'catalogId')
  final String? catalogId;

  /// Бренд автомобиля.
  @override
  @JsonKey(name: 'brand')
  final String? brand;

  /// Идентификатор модели автомобиля.
  @override
  @JsonKey(name: 'modelId')
  final String? modelId;

  /// Идентификатор автомобиля.
  @override
  @JsonKey(name: 'carId')
  final String? carId;

  /// Критерии для поиска.
  @override
  @JsonKey(name: 'criteria')
  final String? criteria;

  /// VIN автомобиля.
  @override
  @JsonKey(name: 'vin')
  final String? vin;

  /// FRAME автомобиля.
  @override
  @JsonKey(name: 'frame')
  final String? frame;

  /// Название модели автомобиля.
  @override
  @JsonKey(name: 'modelName')
  final String? modelName;

  /// Описание автомобиля.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Флаг доступности дерева групп.
  @override
  @JsonKey(name: 'groupsTreeAvailable')
  final bool? groupsTreeAvailable;

  /// Список кодов опций автомобиля.
  final List<OptionCode>? _optionCodes;

  /// Список кодов опций автомобиля.
  @override
  @JsonKey(name: 'optionCodes')
  List<OptionCode>? get optionCodes {
    final value = _optionCodes;
    if (value == null) return null;
    if (_optionCodes is EqualUnmodifiableListView) return _optionCodes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Список параметров автомобиля.
  final List<CarParameter>? _parameters;

  /// Список параметров автомобиля.
  @override
  @JsonKey(name: 'parameters')
  List<CarParameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of CarInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarInfoCopyWith<_CarInfo> get copyWith =>
      __$CarInfoCopyWithImpl<_CarInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarInfoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarInfo &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.catalogId, catalogId) ||
                other.catalogId == catalogId) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.carId, carId) || other.carId == carId) &&
            (identical(other.criteria, criteria) ||
                other.criteria == criteria) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.frame, frame) || other.frame == frame) &&
            (identical(other.modelName, modelName) ||
                other.modelName == modelName) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.groupsTreeAvailable, groupsTreeAvailable) ||
                other.groupsTreeAvailable == groupsTreeAvailable) &&
            const DeepCollectionEquality()
                .equals(other._optionCodes, _optionCodes) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      catalogId,
      brand,
      modelId,
      carId,
      criteria,
      vin,
      frame,
      modelName,
      description,
      groupsTreeAvailable,
      const DeepCollectionEquality().hash(_optionCodes),
      const DeepCollectionEquality().hash(_parameters));

  @override
  String toString() {
    return 'CarInfo(title: $title, catalogId: $catalogId, brand: $brand, modelId: $modelId, carId: $carId, criteria: $criteria, vin: $vin, frame: $frame, modelName: $modelName, description: $description, groupsTreeAvailable: $groupsTreeAvailable, optionCodes: $optionCodes, parameters: $parameters)';
  }
}

/// @nodoc
abstract mixin class _$CarInfoCopyWith<$Res> implements $CarInfoCopyWith<$Res> {
  factory _$CarInfoCopyWith(_CarInfo value, $Res Function(_CarInfo) _then) =
      __$CarInfoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'title') String? title,
      @JsonKey(name: 'catalogId') String? catalogId,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'modelId') String? modelId,
      @JsonKey(name: 'carId') String? carId,
      @JsonKey(name: 'criteria') String? criteria,
      @JsonKey(name: 'vin') String? vin,
      @JsonKey(name: 'frame') String? frame,
      @JsonKey(name: 'modelName') String? modelName,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'groupsTreeAvailable') bool? groupsTreeAvailable,
      @JsonKey(name: 'optionCodes') List<OptionCode>? optionCodes,
      @JsonKey(name: 'parameters') List<CarParameter>? parameters});
}

/// @nodoc
class __$CarInfoCopyWithImpl<$Res> implements _$CarInfoCopyWith<$Res> {
  __$CarInfoCopyWithImpl(this._self, this._then);

  final _CarInfo _self;
  final $Res Function(_CarInfo) _then;

  /// Create a copy of CarInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? title = freezed,
    Object? catalogId = freezed,
    Object? brand = freezed,
    Object? modelId = freezed,
    Object? carId = freezed,
    Object? criteria = freezed,
    Object? vin = freezed,
    Object? frame = freezed,
    Object? modelName = freezed,
    Object? description = freezed,
    Object? groupsTreeAvailable = freezed,
    Object? optionCodes = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_CarInfo(
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      catalogId: freezed == catalogId
          ? _self.catalogId
          : catalogId // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _self.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      carId: freezed == carId
          ? _self.carId
          : carId // ignore: cast_nullable_to_non_nullable
              as String?,
      criteria: freezed == criteria
          ? _self.criteria
          : criteria // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      frame: freezed == frame
          ? _self.frame
          : frame // ignore: cast_nullable_to_non_nullable
              as String?,
      modelName: freezed == modelName
          ? _self.modelName
          : modelName // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      groupsTreeAvailable: freezed == groupsTreeAvailable
          ? _self.groupsTreeAvailable
          : groupsTreeAvailable // ignore: cast_nullable_to_non_nullable
              as bool?,
      optionCodes: freezed == optionCodes
          ? _self._optionCodes
          : optionCodes // ignore: cast_nullable_to_non_nullable
              as List<OptionCode>?,
      parameters: freezed == parameters
          ? _self._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<CarParameter>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\car_info.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_info.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CarInfo _$CarInfoFromJson(Map<String, dynamic> json) => _CarInfo(
      title: json['title'] as String?,
      catalogId: json['catalogId'] as String?,
      brand: json['brand'] as String?,
      modelId: json['modelId'] as String?,
      carId: json['carId'] as String?,
      criteria: json['criteria'] as String?,
      vin: json['vin'] as String?,
      frame: json['frame'] as String?,
      modelName: json['modelName'] as String?,
      description: json['description'] as String?,
      groupsTreeAvailable: json['groupsTreeAvailable'] as bool?,
      optionCodes: (json['optionCodes'] as List<dynamic>?)
          ?.map((e) => OptionCode.fromJson(e as Map<String, dynamic>))
          .toList(),
      parameters: (json['parameters'] as List<dynamic>?)
          ?.map((e) => CarParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$CarInfoToJson(_CarInfo instance) => <String, dynamic>{
      'title': instance.title,
      'catalogId': instance.catalogId,
      'brand': instance.brand,
      'modelId': instance.modelId,
      'carId': instance.carId,
      'criteria': instance.criteria,
      'vin': instance.vin,
      'frame': instance.frame,
      'modelName': instance.modelName,
      'description': instance.description,
      'groupsTreeAvailable': instance.groupsTreeAvailable,
      'optionCodes': instance.optionCodes,
      'parameters': instance.parameters,
    };

```

## lib\features\parts_catalog\models\car_parameter.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'car_parameter.freezed.dart';
part 'car_parameter.g.dart';

/// {@template car_parameter}
/// Модель данных для параметра автомобиля.
/// {@endtemplate}
@freezed
abstract class CarParameter with _$CarParameter {
  /// {@macro car_parameter}
  factory CarParameter({
    /// Hash ID параметра автомобиля.
    @JsonKey(name: 'idx') String? idx,

    /// Ключ параметра автомобиля.
    @JsonKey(name: 'key') String? key,

    /// Название параметра автомобиля.
    @JsonKey(name: 'name') String? name,

    /// Значение параметра автомобиля.
    @JsonKey(name: 'value') String? value,

    /// Порядок сортировки параметра автомобиля.
    @JsonKey(name: 'sortOrder') int? sortOrder,
  }) = _CarParameter;

  /// Преобразует JSON в объект [CarParameter].
  factory CarParameter.fromJson(Map<String, dynamic> json) =>
      _$CarParameterFromJson(json);
}

```

## lib\features\parts_catalog\models\car_parameter.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car_parameter.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CarParameter {
  /// Hash ID параметра автомобиля.
  @JsonKey(name: 'idx')
  String? get idx;

  /// Ключ параметра автомобиля.
  @JsonKey(name: 'key')
  String? get key;

  /// Название параметра автомобиля.
  @JsonKey(name: 'name')
  String? get name;

  /// Значение параметра автомобиля.
  @JsonKey(name: 'value')
  String? get value;

  /// Порядок сортировки параметра автомобиля.
  @JsonKey(name: 'sortOrder')
  int? get sortOrder;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarParameterCopyWith<CarParameter> get copyWith =>
      _$CarParameterCopyWithImpl<CarParameter>(
          this as CarParameter, _$identity);

  /// Serializes this CarParameter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarParameter &&
            (identical(other.idx, idx) || other.idx == idx) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, idx, key, name, value, sortOrder);

  @override
  String toString() {
    return 'CarParameter(idx: $idx, key: $key, name: $name, value: $value, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class $CarParameterCopyWith<$Res> {
  factory $CarParameterCopyWith(
          CarParameter value, $Res Function(CarParameter) _then) =
      _$CarParameterCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'idx') String? idx,
      @JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'value') String? value,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class _$CarParameterCopyWithImpl<$Res> implements $CarParameterCopyWith<$Res> {
  _$CarParameterCopyWithImpl(this._self, this._then);

  final CarParameter _self;
  final $Res Function(CarParameter) _then;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idx = freezed,
    Object? key = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_self.copyWith(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarParameter implements CarParameter {
  _CarParameter(
      {@JsonKey(name: 'idx') this.idx,
      @JsonKey(name: 'key') this.key,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'value') this.value,
      @JsonKey(name: 'sortOrder') this.sortOrder});
  factory _CarParameter.fromJson(Map<String, dynamic> json) =>
      _$CarParameterFromJson(json);

  /// Hash ID параметра автомобиля.
  @override
  @JsonKey(name: 'idx')
  final String? idx;

  /// Ключ параметра автомобиля.
  @override
  @JsonKey(name: 'key')
  final String? key;

  /// Название параметра автомобиля.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Значение параметра автомобиля.
  @override
  @JsonKey(name: 'value')
  final String? value;

  /// Порядок сортировки параметра автомобиля.
  @override
  @JsonKey(name: 'sortOrder')
  final int? sortOrder;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarParameterCopyWith<_CarParameter> get copyWith =>
      __$CarParameterCopyWithImpl<_CarParameter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarParameterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarParameter &&
            (identical(other.idx, idx) || other.idx == idx) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, idx, key, name, value, sortOrder);

  @override
  String toString() {
    return 'CarParameter(idx: $idx, key: $key, name: $name, value: $value, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class _$CarParameterCopyWith<$Res>
    implements $CarParameterCopyWith<$Res> {
  factory _$CarParameterCopyWith(
          _CarParameter value, $Res Function(_CarParameter) _then) =
      __$CarParameterCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'idx') String? idx,
      @JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'value') String? value,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class __$CarParameterCopyWithImpl<$Res>
    implements _$CarParameterCopyWith<$Res> {
  __$CarParameterCopyWithImpl(this._self, this._then);

  final _CarParameter _self;
  final $Res Function(_CarParameter) _then;

  /// Create a copy of CarParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? idx = freezed,
    Object? key = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_CarParameter(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\car_parameter.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_parameter.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CarParameter _$CarParameterFromJson(Map<String, dynamic> json) =>
    _CarParameter(
      idx: json['idx'] as String?,
      key: json['key'] as String?,
      name: json['name'] as String?,
      value: json['value'] as String?,
      sortOrder: (json['sortOrder'] as num?)?.toInt(),
    );

Map<String, dynamic> _$CarParameterToJson(_CarParameter instance) =>
    <String, dynamic>{
      'idx': instance.idx,
      'key': instance.key,
      'name': instance.name,
      'value': instance.value,
      'sortOrder': instance.sortOrder,
    };

```

## lib\features\parts_catalog\models\car_parameter_idx.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'car_parameter_idx.freezed.dart';
part 'car_parameter_idx.g.dart';

/// {@template car_parameter_idx}
/// Модель данных для индекса параметра автомобиля.
/// {@endtemplate}
@freezed
abstract class CarParameterIdx with _$CarParameterIdx {
  /// {@macro car_parameter_idx}
  factory CarParameterIdx({
    /// Индекс параметра автомобиля.
    @JsonKey(name: 'idx') String? idx,
  }) = _CarParameterIdx;

  /// Преобразует JSON в объект [CarParameterIdx].
  factory CarParameterIdx.fromJson(Map<String, dynamic> json) =>
      _$CarParameterIdxFromJson(json);
}

```

## lib\features\parts_catalog\models\car_parameter_idx.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car_parameter_idx.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CarParameterIdx {
  /// Индекс параметра автомобиля.
  @JsonKey(name: 'idx')
  String? get idx;

  /// Create a copy of CarParameterIdx
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarParameterIdxCopyWith<CarParameterIdx> get copyWith =>
      _$CarParameterIdxCopyWithImpl<CarParameterIdx>(
          this as CarParameterIdx, _$identity);

  /// Serializes this CarParameterIdx to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarParameterIdx &&
            (identical(other.idx, idx) || other.idx == idx));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, idx);

  @override
  String toString() {
    return 'CarParameterIdx(idx: $idx)';
  }
}

/// @nodoc
abstract mixin class $CarParameterIdxCopyWith<$Res> {
  factory $CarParameterIdxCopyWith(
          CarParameterIdx value, $Res Function(CarParameterIdx) _then) =
      _$CarParameterIdxCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'idx') String? idx});
}

/// @nodoc
class _$CarParameterIdxCopyWithImpl<$Res>
    implements $CarParameterIdxCopyWith<$Res> {
  _$CarParameterIdxCopyWithImpl(this._self, this._then);

  final CarParameterIdx _self;
  final $Res Function(CarParameterIdx) _then;

  /// Create a copy of CarParameterIdx
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idx = freezed,
  }) {
    return _then(_self.copyWith(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarParameterIdx implements CarParameterIdx {
  _CarParameterIdx({@JsonKey(name: 'idx') this.idx});
  factory _CarParameterIdx.fromJson(Map<String, dynamic> json) =>
      _$CarParameterIdxFromJson(json);

  /// Индекс параметра автомобиля.
  @override
  @JsonKey(name: 'idx')
  final String? idx;

  /// Create a copy of CarParameterIdx
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarParameterIdxCopyWith<_CarParameterIdx> get copyWith =>
      __$CarParameterIdxCopyWithImpl<_CarParameterIdx>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarParameterIdxToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarParameterIdx &&
            (identical(other.idx, idx) || other.idx == idx));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, idx);

  @override
  String toString() {
    return 'CarParameterIdx(idx: $idx)';
  }
}

/// @nodoc
abstract mixin class _$CarParameterIdxCopyWith<$Res>
    implements $CarParameterIdxCopyWith<$Res> {
  factory _$CarParameterIdxCopyWith(
          _CarParameterIdx value, $Res Function(_CarParameterIdx) _then) =
      __$CarParameterIdxCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'idx') String? idx});
}

/// @nodoc
class __$CarParameterIdxCopyWithImpl<$Res>
    implements _$CarParameterIdxCopyWith<$Res> {
  __$CarParameterIdxCopyWithImpl(this._self, this._then);

  final _CarParameterIdx _self;
  final $Res Function(_CarParameterIdx) _then;

  /// Create a copy of CarParameterIdx
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? idx = freezed,
  }) {
    return _then(_CarParameterIdx(
      idx: freezed == idx
          ? _self.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\car_parameter_idx.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_parameter_idx.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CarParameterIdx _$CarParameterIdxFromJson(Map<String, dynamic> json) =>
    _CarParameterIdx(
      idx: json['idx'] as String?,
    );

Map<String, dynamic> _$CarParameterIdxToJson(_CarParameterIdx instance) =>
    <String, dynamic>{
      'idx': instance.idx,
    };

```

## lib\features\parts_catalog\models\car_parameter_info.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'car_parameter_info.freezed.dart';
part 'car_parameter_info.g.dart';

/// {@template car_parameter_info}
/// Модель данных для информации о параметре автомобиля.
/// {@endtemplate}
@freezed
abstract class CarParameterInfo with _$CarParameterInfo {
  /// {@macro car_parameter_info}
  factory CarParameterInfo({
    /// Ключ параметра.
    @JsonKey(name: 'key') String? key,

    /// Название параметра.
    @JsonKey(name: 'name') String? name,

    /// Список значений параметра.
    @JsonKey(name: 'values') List<CarFilterValues>? values,

    /// Порядок сортировки параметра.
    @JsonKey(name: 'sortOrder') int? sortOrder,
  }) = _CarParameterInfo;

  /// Преобразует JSON в объект [CarParameterInfo].
  factory CarParameterInfo.fromJson(Map<String, dynamic> json) =>
      _$CarParameterInfoFromJson(json);
}

/// {@template car_filter_values}
/// Модель данных для значений фильтра автомобиля.
/// {@endtemplate}
@freezed
abstract class CarFilterValues with _$CarFilterValues {
  /// {@macro car_filter_values}
  factory CarFilterValues({
    /// Идентификатор значения.
    @JsonKey(name: 'id') String? id,

    /// Текст значения.
    @JsonKey(name: 'text') String? text,
  }) = _CarFilterValues;

  /// Преобразует JSON в объект [CarFilterValues].
  factory CarFilterValues.fromJson(Map<String, dynamic> json) =>
      _$CarFilterValuesFromJson(json);
}

```

## lib\features\parts_catalog\models\car_parameter_info.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car_parameter_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CarParameterInfo {
  /// Ключ параметра.
  @JsonKey(name: 'key')
  String? get key;

  /// Название параметра.
  @JsonKey(name: 'name')
  String? get name;

  /// Список значений параметра.
  @JsonKey(name: 'values')
  List<CarFilterValues>? get values;

  /// Порядок сортировки параметра.
  @JsonKey(name: 'sortOrder')
  int? get sortOrder;

  /// Create a copy of CarParameterInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarParameterInfoCopyWith<CarParameterInfo> get copyWith =>
      _$CarParameterInfoCopyWithImpl<CarParameterInfo>(
          this as CarParameterInfo, _$identity);

  /// Serializes this CarParameterInfo to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarParameterInfo &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.values, values) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, name,
      const DeepCollectionEquality().hash(values), sortOrder);

  @override
  String toString() {
    return 'CarParameterInfo(key: $key, name: $name, values: $values, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class $CarParameterInfoCopyWith<$Res> {
  factory $CarParameterInfoCopyWith(
          CarParameterInfo value, $Res Function(CarParameterInfo) _then) =
      _$CarParameterInfoCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'values') List<CarFilterValues>? values,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class _$CarParameterInfoCopyWithImpl<$Res>
    implements $CarParameterInfoCopyWith<$Res> {
  _$CarParameterInfoCopyWithImpl(this._self, this._then);

  final CarParameterInfo _self;
  final $Res Function(CarParameterInfo) _then;

  /// Create a copy of CarParameterInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
    Object? values = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_self.copyWith(
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      values: freezed == values
          ? _self.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<CarFilterValues>?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarParameterInfo implements CarParameterInfo {
  _CarParameterInfo(
      {@JsonKey(name: 'key') this.key,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'values') final List<CarFilterValues>? values,
      @JsonKey(name: 'sortOrder') this.sortOrder})
      : _values = values;
  factory _CarParameterInfo.fromJson(Map<String, dynamic> json) =>
      _$CarParameterInfoFromJson(json);

  /// Ключ параметра.
  @override
  @JsonKey(name: 'key')
  final String? key;

  /// Название параметра.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Список значений параметра.
  final List<CarFilterValues>? _values;

  /// Список значений параметра.
  @override
  @JsonKey(name: 'values')
  List<CarFilterValues>? get values {
    final value = _values;
    if (value == null) return null;
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Порядок сортировки параметра.
  @override
  @JsonKey(name: 'sortOrder')
  final int? sortOrder;

  /// Create a copy of CarParameterInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarParameterInfoCopyWith<_CarParameterInfo> get copyWith =>
      __$CarParameterInfoCopyWithImpl<_CarParameterInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarParameterInfoToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarParameterInfo &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._values, _values) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, name,
      const DeepCollectionEquality().hash(_values), sortOrder);

  @override
  String toString() {
    return 'CarParameterInfo(key: $key, name: $name, values: $values, sortOrder: $sortOrder)';
  }
}

/// @nodoc
abstract mixin class _$CarParameterInfoCopyWith<$Res>
    implements $CarParameterInfoCopyWith<$Res> {
  factory _$CarParameterInfoCopyWith(
          _CarParameterInfo value, $Res Function(_CarParameterInfo) _then) =
      __$CarParameterInfoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'key') String? key,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'values') List<CarFilterValues>? values,
      @JsonKey(name: 'sortOrder') int? sortOrder});
}

/// @nodoc
class __$CarParameterInfoCopyWithImpl<$Res>
    implements _$CarParameterInfoCopyWith<$Res> {
  __$CarParameterInfoCopyWithImpl(this._self, this._then);

  final _CarParameterInfo _self;
  final $Res Function(_CarParameterInfo) _then;

  /// Create a copy of CarParameterInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
    Object? values = freezed,
    Object? sortOrder = freezed,
  }) {
    return _then(_CarParameterInfo(
      key: freezed == key
          ? _self.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      values: freezed == values
          ? _self._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<CarFilterValues>?,
      sortOrder: freezed == sortOrder
          ? _self.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$CarFilterValues {
  /// Идентификатор значения.
  @JsonKey(name: 'id')
  String? get id;

  /// Текст значения.
  @JsonKey(name: 'text')
  String? get text;

  /// Create a copy of CarFilterValues
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarFilterValuesCopyWith<CarFilterValues> get copyWith =>
      _$CarFilterValuesCopyWithImpl<CarFilterValues>(
          this as CarFilterValues, _$identity);

  /// Serializes this CarFilterValues to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarFilterValues &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, text);

  @override
  String toString() {
    return 'CarFilterValues(id: $id, text: $text)';
  }
}

/// @nodoc
abstract mixin class $CarFilterValuesCopyWith<$Res> {
  factory $CarFilterValuesCopyWith(
          CarFilterValues value, $Res Function(CarFilterValues) _then) =
      _$CarFilterValuesCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id, @JsonKey(name: 'text') String? text});
}

/// @nodoc
class _$CarFilterValuesCopyWithImpl<$Res>
    implements $CarFilterValuesCopyWith<$Res> {
  _$CarFilterValuesCopyWithImpl(this._self, this._then);

  final CarFilterValues _self;
  final $Res Function(CarFilterValues) _then;

  /// Create a copy of CarFilterValues
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? text = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarFilterValues implements CarFilterValues {
  _CarFilterValues(
      {@JsonKey(name: 'id') this.id, @JsonKey(name: 'text') this.text});
  factory _CarFilterValues.fromJson(Map<String, dynamic> json) =>
      _$CarFilterValuesFromJson(json);

  /// Идентификатор значения.
  @override
  @JsonKey(name: 'id')
  final String? id;

  /// Текст значения.
  @override
  @JsonKey(name: 'text')
  final String? text;

  /// Create a copy of CarFilterValues
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarFilterValuesCopyWith<_CarFilterValues> get copyWith =>
      __$CarFilterValuesCopyWithImpl<_CarFilterValues>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarFilterValuesToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarFilterValues &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, text);

  @override
  String toString() {
    return 'CarFilterValues(id: $id, text: $text)';
  }
}

/// @nodoc
abstract mixin class _$CarFilterValuesCopyWith<$Res>
    implements $CarFilterValuesCopyWith<$Res> {
  factory _$CarFilterValuesCopyWith(
          _CarFilterValues value, $Res Function(_CarFilterValues) _then) =
      __$CarFilterValuesCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id, @JsonKey(name: 'text') String? text});
}

/// @nodoc
class __$CarFilterValuesCopyWithImpl<$Res>
    implements _$CarFilterValuesCopyWith<$Res> {
  __$CarFilterValuesCopyWithImpl(this._self, this._then);

  final _CarFilterValues _self;
  final $Res Function(_CarFilterValues) _then;

  /// Create a copy of CarFilterValues
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? text = freezed,
  }) {
    return _then(_CarFilterValues(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\car_parameter_info.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_parameter_info.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CarParameterInfo _$CarParameterInfoFromJson(Map<String, dynamic> json) =>
    _CarParameterInfo(
      key: json['key'] as String?,
      name: json['name'] as String?,
      values: (json['values'] as List<dynamic>?)
          ?.map((e) => CarFilterValues.fromJson(e as Map<String, dynamic>))
          .toList(),
      sortOrder: (json['sortOrder'] as num?)?.toInt(),
    );

Map<String, dynamic> _$CarParameterInfoToJson(_CarParameterInfo instance) =>
    <String, dynamic>{
      'key': instance.key,
      'name': instance.name,
      'values': instance.values,
      'sortOrder': instance.sortOrder,
    };

_CarFilterValues _$CarFilterValuesFromJson(Map<String, dynamic> json) =>
    _CarFilterValues(
      id: json['id'] as String?,
      text: json['text'] as String?,
    );

Map<String, dynamic> _$CarFilterValuesToJson(_CarFilterValues instance) =>
    <String, dynamic>{
      'id': instance.id,
      'text': instance.text,
    };

```

## lib\features\parts_catalog\models\catalog.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'catalog.freezed.dart';
part 'catalog.g.dart';

/// {@template catalog}
/// Модель данных для каталога.
/// {@endtemplate}
@freezed
abstract class Catalog with _$Catalog {
  /// {@macro catalog}
  factory Catalog({
    /// Идентификатор каталога.
    @JsonKey(name: 'id') required String id,

    /// Название каталога.
    @JsonKey(name: 'name') required String name,

    /// Количество моделей в каталоге.
    @JsonKey(name: 'models_count') required int modelsCount,
  }) = _Catalog;

  /// Преобразует JSON в объект [Catalog].
  factory Catalog.fromJson(Map<String, dynamic> json) =>
      _$CatalogFromJson(json);
}

```

## lib\features\parts_catalog\models\catalog.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'catalog.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Catalog {
  /// Идентификатор каталога.
  @JsonKey(name: 'id')
  String get id;

  /// Название каталога.
  @JsonKey(name: 'name')
  String get name;

  /// Количество моделей в каталоге.
  @JsonKey(name: 'models_count')
  int get modelsCount;

  /// Create a copy of Catalog
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CatalogCopyWith<Catalog> get copyWith =>
      _$CatalogCopyWithImpl<Catalog>(this as Catalog, _$identity);

  /// Serializes this Catalog to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Catalog &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.modelsCount, modelsCount) ||
                other.modelsCount == modelsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, modelsCount);

  @override
  String toString() {
    return 'Catalog(id: $id, name: $name, modelsCount: $modelsCount)';
  }
}

/// @nodoc
abstract mixin class $CatalogCopyWith<$Res> {
  factory $CatalogCopyWith(Catalog value, $Res Function(Catalog) _then) =
      _$CatalogCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'models_count') int modelsCount});
}

/// @nodoc
class _$CatalogCopyWithImpl<$Res> implements $CatalogCopyWith<$Res> {
  _$CatalogCopyWithImpl(this._self, this._then);

  final Catalog _self;
  final $Res Function(Catalog) _then;

  /// Create a copy of Catalog
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? modelsCount = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      modelsCount: null == modelsCount
          ? _self.modelsCount
          : modelsCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Catalog implements Catalog {
  _Catalog(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'models_count') required this.modelsCount});
  factory _Catalog.fromJson(Map<String, dynamic> json) =>
      _$CatalogFromJson(json);

  /// Идентификатор каталога.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Название каталога.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Количество моделей в каталоге.
  @override
  @JsonKey(name: 'models_count')
  final int modelsCount;

  /// Create a copy of Catalog
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CatalogCopyWith<_Catalog> get copyWith =>
      __$CatalogCopyWithImpl<_Catalog>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CatalogToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Catalog &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.modelsCount, modelsCount) ||
                other.modelsCount == modelsCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, modelsCount);

  @override
  String toString() {
    return 'Catalog(id: $id, name: $name, modelsCount: $modelsCount)';
  }
}

/// @nodoc
abstract mixin class _$CatalogCopyWith<$Res> implements $CatalogCopyWith<$Res> {
  factory _$CatalogCopyWith(_Catalog value, $Res Function(_Catalog) _then) =
      __$CatalogCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'models_count') int modelsCount});
}

/// @nodoc
class __$CatalogCopyWithImpl<$Res> implements _$CatalogCopyWith<$Res> {
  __$CatalogCopyWithImpl(this._self, this._then);

  final _Catalog _self;
  final $Res Function(_Catalog) _then;

  /// Create a copy of Catalog
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? modelsCount = null,
  }) {
    return _then(_Catalog(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      modelsCount: null == modelsCount
          ? _self.modelsCount
          : modelsCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\catalog.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'catalog.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Catalog _$CatalogFromJson(Map<String, dynamic> json) => _Catalog(
      id: json['id'] as String,
      name: json['name'] as String,
      modelsCount: (json['models_count'] as num).toInt(),
    );

Map<String, dynamic> _$CatalogToJson(_Catalog instance) => <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'models_count': instance.modelsCount,
    };

```

## lib\features\parts_catalog\models\error.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'error.freezed.dart';
part 'error.g.dart';

/// {@template error}
/// Модель данных для ошибки.
/// {@endtemplate}
@freezed
abstract class Error with _$Error {
  /// {@macro error}
  factory Error({
    /// Код ошибки.
    @JsonKey(name: 'code') int? code,

    /// Код ошибки (строковый).
    @JsonKey(name: 'errorCode') String? errorCode,

    /// Сообщение об ошибке.
    @JsonKey(name: 'message') String? message,
  }) = _Error;

  /// Преобразует JSON в объект [Error].
  factory Error.fromJson(Map<String, dynamic> json) => _$ErrorFromJson(json);
}

```

## lib\features\parts_catalog\models\error.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Error {
  /// Код ошибки.
  @JsonKey(name: 'code')
  int? get code;

  /// Код ошибки (строковый).
  @JsonKey(name: 'errorCode')
  String? get errorCode;

  /// Сообщение об ошибке.
  @JsonKey(name: 'message')
  String? get message;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorCopyWith<Error> get copyWith =>
      _$ErrorCopyWithImpl<Error>(this as Error, _$identity);

  /// Serializes this Error to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Error &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.errorCode, errorCode) ||
                other.errorCode == errorCode) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, errorCode, message);

  @override
  String toString() {
    return 'Error(code: $code, errorCode: $errorCode, message: $message)';
  }
}

/// @nodoc
abstract mixin class $ErrorCopyWith<$Res> {
  factory $ErrorCopyWith(Error value, $Res Function(Error) _then) =
      _$ErrorCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'code') int? code,
      @JsonKey(name: 'errorCode') String? errorCode,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class _$ErrorCopyWithImpl<$Res> implements $ErrorCopyWith<$Res> {
  _$ErrorCopyWithImpl(this._self, this._then);

  final Error _self;
  final $Res Function(Error) _then;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? errorCode = freezed,
    Object? message = freezed,
  }) {
    return _then(_self.copyWith(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
      errorCode: freezed == errorCode
          ? _self.errorCode
          : errorCode // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Error implements Error {
  _Error(
      {@JsonKey(name: 'code') this.code,
      @JsonKey(name: 'errorCode') this.errorCode,
      @JsonKey(name: 'message') this.message});
  factory _Error.fromJson(Map<String, dynamic> json) => _$ErrorFromJson(json);

  /// Код ошибки.
  @override
  @JsonKey(name: 'code')
  final int? code;

  /// Код ошибки (строковый).
  @override
  @JsonKey(name: 'errorCode')
  final String? errorCode;

  /// Сообщение об ошибке.
  @override
  @JsonKey(name: 'message')
  final String? message;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ErrorCopyWith<_Error> get copyWith =>
      __$ErrorCopyWithImpl<_Error>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Error &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.errorCode, errorCode) ||
                other.errorCode == errorCode) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, errorCode, message);

  @override
  String toString() {
    return 'Error(code: $code, errorCode: $errorCode, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$ErrorCopyWith<$Res> implements $ErrorCopyWith<$Res> {
  factory _$ErrorCopyWith(_Error value, $Res Function(_Error) _then) =
      __$ErrorCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'code') int? code,
      @JsonKey(name: 'errorCode') String? errorCode,
      @JsonKey(name: 'message') String? message});
}

/// @nodoc
class __$ErrorCopyWithImpl<$Res> implements _$ErrorCopyWith<$Res> {
  __$ErrorCopyWithImpl(this._self, this._then);

  final _Error _self;
  final $Res Function(_Error) _then;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = freezed,
    Object? errorCode = freezed,
    Object? message = freezed,
  }) {
    return _then(_Error(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
      errorCode: freezed == errorCode
          ? _self.errorCode
          : errorCode // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\error.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'error.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Error _$ErrorFromJson(Map<String, dynamic> json) => _Error(
      code: (json['code'] as num?)?.toInt(),
      errorCode: json['errorCode'] as String?,
      message: json['message'] as String?,
    );

Map<String, dynamic> _$ErrorToJson(_Error instance) => <String, dynamic>{
      'code': instance.code,
      'errorCode': instance.errorCode,
      'message': instance.message,
    };

```

## lib\features\parts_catalog\models\example_prices_response.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'example_prices_response.freezed.dart';
part 'example_prices_response.g.dart';

/// {@template example_prices_response}
/// Модель данных для ответа с примером цен.
/// {@endtemplate}
@freezed
abstract class ExamplePricesResponse with _$ExamplePricesResponse {
  /// {@macro example_prices_response}
  factory ExamplePricesResponse({
    /// Идентификатор.
    @JsonKey(name: 'id') String? id,

    /// Название.
    @JsonKey(name: 'title') String? title,

    /// Код.
    @JsonKey(name: 'code') String? code,

    /// Бренд.
    @JsonKey(name: 'brand') String? brand,

    /// Цена.
    @JsonKey(name: 'price') String? price,

    /// Количество в корзине.
    @JsonKey(name: 'basketQty') String? basketQty,

    /// Количество в наличии.
    @JsonKey(name: 'inStockQty') String? inStockQty,

    /// Рейтинг.
    @JsonKey(name: 'rating') String? rating,

    /// Доставка.
    @JsonKey(name: 'delivery') String? delivery,

    /// Полезная нагрузка (payload).
    @JsonKey(name: 'payload') Map<String, String>? payload,
  }) = _ExamplePricesResponse;

  /// Преобразует JSON в объект [ExamplePricesResponse].
  factory ExamplePricesResponse.fromJson(Map<String, dynamic> json) =>
      _$ExamplePricesResponseFromJson(json);
}

```

## lib\features\parts_catalog\models\example_prices_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'example_prices_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ExamplePricesResponse {
  /// Идентификатор.
  @JsonKey(name: 'id')
  String? get id;

  /// Название.
  @JsonKey(name: 'title')
  String? get title;

  /// Код.
  @JsonKey(name: 'code')
  String? get code;

  /// Бренд.
  @JsonKey(name: 'brand')
  String? get brand;

  /// Цена.
  @JsonKey(name: 'price')
  String? get price;

  /// Количество в корзине.
  @JsonKey(name: 'basketQty')
  String? get basketQty;

  /// Количество в наличии.
  @JsonKey(name: 'inStockQty')
  String? get inStockQty;

  /// Рейтинг.
  @JsonKey(name: 'rating')
  String? get rating;

  /// Доставка.
  @JsonKey(name: 'delivery')
  String? get delivery;

  /// Полезная нагрузка (payload).
  @JsonKey(name: 'payload')
  Map<String, String>? get payload;

  /// Create a copy of ExamplePricesResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ExamplePricesResponseCopyWith<ExamplePricesResponse> get copyWith =>
      _$ExamplePricesResponseCopyWithImpl<ExamplePricesResponse>(
          this as ExamplePricesResponse, _$identity);

  /// Serializes this ExamplePricesResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ExamplePricesResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.basketQty, basketQty) ||
                other.basketQty == basketQty) &&
            (identical(other.inStockQty, inStockQty) ||
                other.inStockQty == inStockQty) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            (identical(other.delivery, delivery) ||
                other.delivery == delivery) &&
            const DeepCollectionEquality().equals(other.payload, payload));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      code,
      brand,
      price,
      basketQty,
      inStockQty,
      rating,
      delivery,
      const DeepCollectionEquality().hash(payload));

  @override
  String toString() {
    return 'ExamplePricesResponse(id: $id, title: $title, code: $code, brand: $brand, price: $price, basketQty: $basketQty, inStockQty: $inStockQty, rating: $rating, delivery: $delivery, payload: $payload)';
  }
}

/// @nodoc
abstract mixin class $ExamplePricesResponseCopyWith<$Res> {
  factory $ExamplePricesResponseCopyWith(ExamplePricesResponse value,
          $Res Function(ExamplePricesResponse) _then) =
      _$ExamplePricesResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'price') String? price,
      @JsonKey(name: 'basketQty') String? basketQty,
      @JsonKey(name: 'inStockQty') String? inStockQty,
      @JsonKey(name: 'rating') String? rating,
      @JsonKey(name: 'delivery') String? delivery,
      @JsonKey(name: 'payload') Map<String, String>? payload});
}

/// @nodoc
class _$ExamplePricesResponseCopyWithImpl<$Res>
    implements $ExamplePricesResponseCopyWith<$Res> {
  _$ExamplePricesResponseCopyWithImpl(this._self, this._then);

  final ExamplePricesResponse _self;
  final $Res Function(ExamplePricesResponse) _then;

  /// Create a copy of ExamplePricesResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? code = freezed,
    Object? brand = freezed,
    Object? price = freezed,
    Object? basketQty = freezed,
    Object? inStockQty = freezed,
    Object? rating = freezed,
    Object? delivery = freezed,
    Object? payload = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      price: freezed == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as String?,
      basketQty: freezed == basketQty
          ? _self.basketQty
          : basketQty // ignore: cast_nullable_to_non_nullable
              as String?,
      inStockQty: freezed == inStockQty
          ? _self.inStockQty
          : inStockQty // ignore: cast_nullable_to_non_nullable
              as String?,
      rating: freezed == rating
          ? _self.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String?,
      delivery: freezed == delivery
          ? _self.delivery
          : delivery // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _self.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _ExamplePricesResponse implements ExamplePricesResponse {
  _ExamplePricesResponse(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'title') this.title,
      @JsonKey(name: 'code') this.code,
      @JsonKey(name: 'brand') this.brand,
      @JsonKey(name: 'price') this.price,
      @JsonKey(name: 'basketQty') this.basketQty,
      @JsonKey(name: 'inStockQty') this.inStockQty,
      @JsonKey(name: 'rating') this.rating,
      @JsonKey(name: 'delivery') this.delivery,
      @JsonKey(name: 'payload') final Map<String, String>? payload})
      : _payload = payload;
  factory _ExamplePricesResponse.fromJson(Map<String, dynamic> json) =>
      _$ExamplePricesResponseFromJson(json);

  /// Идентификатор.
  @override
  @JsonKey(name: 'id')
  final String? id;

  /// Название.
  @override
  @JsonKey(name: 'title')
  final String? title;

  /// Код.
  @override
  @JsonKey(name: 'code')
  final String? code;

  /// Бренд.
  @override
  @JsonKey(name: 'brand')
  final String? brand;

  /// Цена.
  @override
  @JsonKey(name: 'price')
  final String? price;

  /// Количество в корзине.
  @override
  @JsonKey(name: 'basketQty')
  final String? basketQty;

  /// Количество в наличии.
  @override
  @JsonKey(name: 'inStockQty')
  final String? inStockQty;

  /// Рейтинг.
  @override
  @JsonKey(name: 'rating')
  final String? rating;

  /// Доставка.
  @override
  @JsonKey(name: 'delivery')
  final String? delivery;

  /// Полезная нагрузка (payload).
  final Map<String, String>? _payload;

  /// Полезная нагрузка (payload).
  @override
  @JsonKey(name: 'payload')
  Map<String, String>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableMapView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ExamplePricesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ExamplePricesResponseCopyWith<_ExamplePricesResponse> get copyWith =>
      __$ExamplePricesResponseCopyWithImpl<_ExamplePricesResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ExamplePricesResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ExamplePricesResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.basketQty, basketQty) ||
                other.basketQty == basketQty) &&
            (identical(other.inStockQty, inStockQty) ||
                other.inStockQty == inStockQty) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            (identical(other.delivery, delivery) ||
                other.delivery == delivery) &&
            const DeepCollectionEquality().equals(other._payload, _payload));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      code,
      brand,
      price,
      basketQty,
      inStockQty,
      rating,
      delivery,
      const DeepCollectionEquality().hash(_payload));

  @override
  String toString() {
    return 'ExamplePricesResponse(id: $id, title: $title, code: $code, brand: $brand, price: $price, basketQty: $basketQty, inStockQty: $inStockQty, rating: $rating, delivery: $delivery, payload: $payload)';
  }
}

/// @nodoc
abstract mixin class _$ExamplePricesResponseCopyWith<$Res>
    implements $ExamplePricesResponseCopyWith<$Res> {
  factory _$ExamplePricesResponseCopyWith(_ExamplePricesResponse value,
          $Res Function(_ExamplePricesResponse) _then) =
      __$ExamplePricesResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'title') String? title,
      @JsonKey(name: 'code') String? code,
      @JsonKey(name: 'brand') String? brand,
      @JsonKey(name: 'price') String? price,
      @JsonKey(name: 'basketQty') String? basketQty,
      @JsonKey(name: 'inStockQty') String? inStockQty,
      @JsonKey(name: 'rating') String? rating,
      @JsonKey(name: 'delivery') String? delivery,
      @JsonKey(name: 'payload') Map<String, String>? payload});
}

/// @nodoc
class __$ExamplePricesResponseCopyWithImpl<$Res>
    implements _$ExamplePricesResponseCopyWith<$Res> {
  __$ExamplePricesResponseCopyWithImpl(this._self, this._then);

  final _ExamplePricesResponse _self;
  final $Res Function(_ExamplePricesResponse) _then;

  /// Create a copy of ExamplePricesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? title = freezed,
    Object? code = freezed,
    Object? brand = freezed,
    Object? price = freezed,
    Object? basketQty = freezed,
    Object? inStockQty = freezed,
    Object? rating = freezed,
    Object? delivery = freezed,
    Object? payload = freezed,
  }) {
    return _then(_ExamplePricesResponse(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      brand: freezed == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String?,
      price: freezed == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as String?,
      basketQty: freezed == basketQty
          ? _self.basketQty
          : basketQty // ignore: cast_nullable_to_non_nullable
              as String?,
      inStockQty: freezed == inStockQty
          ? _self.inStockQty
          : inStockQty // ignore: cast_nullable_to_non_nullable
              as String?,
      rating: freezed == rating
          ? _self.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String?,
      delivery: freezed == delivery
          ? _self.delivery
          : delivery // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _self._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\example_prices_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'example_prices_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ExamplePricesResponse _$ExamplePricesResponseFromJson(
        Map<String, dynamic> json) =>
    _ExamplePricesResponse(
      id: json['id'] as String?,
      title: json['title'] as String?,
      code: json['code'] as String?,
      brand: json['brand'] as String?,
      price: json['price'] as String?,
      basketQty: json['basketQty'] as String?,
      inStockQty: json['inStockQty'] as String?,
      rating: json['rating'] as String?,
      delivery: json['delivery'] as String?,
      payload: (json['payload'] as Map<String, dynamic>?)?.map(
        (k, e) => MapEntry(k, e as String),
      ),
    );

Map<String, dynamic> _$ExamplePricesResponseToJson(
        _ExamplePricesResponse instance) =>
    <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'code': instance.code,
      'brand': instance.brand,
      'price': instance.price,
      'basketQty': instance.basketQty,
      'inStockQty': instance.inStockQty,
      'rating': instance.rating,
      'delivery': instance.delivery,
      'payload': instance.payload,
    };

```

## lib\features\parts_catalog\models\group.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'group.freezed.dart';
part 'group.g.dart';

/// {@template group}
/// Модель данных для группы.
/// {@endtemplate}
@freezed
abstract class Group with _$Group {
  /// {@macro group}
  factory Group({
    /// Идентификатор группы.
    @JsonKey(name: 'id') required String id,

    /// Идентификатор родительской группы (может быть null).
    @JsonKey(name: 'parentId') String? parentId,

    /// Признак наличия подгрупп.
    @JsonKey(name: 'hasSubgroups') bool? hasSubgroups,

    /// Признак наличия деталей в группе.
    @JsonKey(name: 'hasParts') bool? hasParts,

    /// Название группы.
    @JsonKey(name: 'name') required String name,

    /// Изображение группы.
    @JsonKey(name: 'img') String? img,

    /// Описание группы.
    @JsonKey(name: 'description') String? description,
  }) = _Group;

  /// Преобразует JSON в объект [Group].
  factory Group.fromJson(Map<String, dynamic> json) => _$GroupFromJson(json);
}

```

## lib\features\parts_catalog\models\group.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'group.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Group {
  /// Идентификатор группы.
  @JsonKey(name: 'id')
  String get id;

  /// Идентификатор родительской группы (может быть null).
  @JsonKey(name: 'parentId')
  String? get parentId;

  /// Признак наличия подгрупп.
  @JsonKey(name: 'hasSubgroups')
  bool? get hasSubgroups;

  /// Признак наличия деталей в группе.
  @JsonKey(name: 'hasParts')
  bool? get hasParts;

  /// Название группы.
  @JsonKey(name: 'name')
  String get name;

  /// Изображение группы.
  @JsonKey(name: 'img')
  String? get img;

  /// Описание группы.
  @JsonKey(name: 'description')
  String? get description;

  /// Create a copy of Group
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $GroupCopyWith<Group> get copyWith =>
      _$GroupCopyWithImpl<Group>(this as Group, _$identity);

  /// Serializes this Group to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Group &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.hasSubgroups, hasSubgroups) ||
                other.hasSubgroups == hasSubgroups) &&
            (identical(other.hasParts, hasParts) ||
                other.hasParts == hasParts) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, parentId, hasSubgroups,
      hasParts, name, img, description);

  @override
  String toString() {
    return 'Group(id: $id, parentId: $parentId, hasSubgroups: $hasSubgroups, hasParts: $hasParts, name: $name, img: $img, description: $description)';
  }
}

/// @nodoc
abstract mixin class $GroupCopyWith<$Res> {
  factory $GroupCopyWith(Group value, $Res Function(Group) _then) =
      _$GroupCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'hasSubgroups') bool? hasSubgroups,
      @JsonKey(name: 'hasParts') bool? hasParts,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'img') String? img,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class _$GroupCopyWithImpl<$Res> implements $GroupCopyWith<$Res> {
  _$GroupCopyWithImpl(this._self, this._then);

  final Group _self;
  final $Res Function(Group) _then;

  /// Create a copy of Group
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? parentId = freezed,
    Object? hasSubgroups = freezed,
    Object? hasParts = freezed,
    Object? name = null,
    Object? img = freezed,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasSubgroups: freezed == hasSubgroups
          ? _self.hasSubgroups
          : hasSubgroups // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasParts: freezed == hasParts
          ? _self.hasParts
          : hasParts // ignore: cast_nullable_to_non_nullable
              as bool?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Group implements Group {
  _Group(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'parentId') this.parentId,
      @JsonKey(name: 'hasSubgroups') this.hasSubgroups,
      @JsonKey(name: 'hasParts') this.hasParts,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'img') this.img,
      @JsonKey(name: 'description') this.description});
  factory _Group.fromJson(Map<String, dynamic> json) => _$GroupFromJson(json);

  /// Идентификатор группы.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Идентификатор родительской группы (может быть null).
  @override
  @JsonKey(name: 'parentId')
  final String? parentId;

  /// Признак наличия подгрупп.
  @override
  @JsonKey(name: 'hasSubgroups')
  final bool? hasSubgroups;

  /// Признак наличия деталей в группе.
  @override
  @JsonKey(name: 'hasParts')
  final bool? hasParts;

  /// Название группы.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Изображение группы.
  @override
  @JsonKey(name: 'img')
  final String? img;

  /// Описание группы.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Create a copy of Group
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$GroupCopyWith<_Group> get copyWith =>
      __$GroupCopyWithImpl<_Group>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$GroupToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Group &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.hasSubgroups, hasSubgroups) ||
                other.hasSubgroups == hasSubgroups) &&
            (identical(other.hasParts, hasParts) ||
                other.hasParts == hasParts) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, parentId, hasSubgroups,
      hasParts, name, img, description);

  @override
  String toString() {
    return 'Group(id: $id, parentId: $parentId, hasSubgroups: $hasSubgroups, hasParts: $hasParts, name: $name, img: $img, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$GroupCopyWith<$Res> implements $GroupCopyWith<$Res> {
  factory _$GroupCopyWith(_Group value, $Res Function(_Group) _then) =
      __$GroupCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'hasSubgroups') bool? hasSubgroups,
      @JsonKey(name: 'hasParts') bool? hasParts,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'img') String? img,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class __$GroupCopyWithImpl<$Res> implements _$GroupCopyWith<$Res> {
  __$GroupCopyWithImpl(this._self, this._then);

  final _Group _self;
  final $Res Function(_Group) _then;

  /// Create a copy of Group
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? parentId = freezed,
    Object? hasSubgroups = freezed,
    Object? hasParts = freezed,
    Object? name = null,
    Object? img = freezed,
    Object? description = freezed,
  }) {
    return _then(_Group(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasSubgroups: freezed == hasSubgroups
          ? _self.hasSubgroups
          : hasSubgroups // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasParts: freezed == hasParts
          ? _self.hasParts
          : hasParts // ignore: cast_nullable_to_non_nullable
              as bool?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\group.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'group.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Group _$GroupFromJson(Map<String, dynamic> json) => _Group(
      id: json['id'] as String,
      parentId: json['parentId'] as String?,
      hasSubgroups: json['hasSubgroups'] as bool?,
      hasParts: json['hasParts'] as bool?,
      name: json['name'] as String,
      img: json['img'] as String?,
      description: json['description'] as String?,
    );

Map<String, dynamic> _$GroupToJson(_Group instance) => <String, dynamic>{
      'id': instance.id,
      'parentId': instance.parentId,
      'hasSubgroups': instance.hasSubgroups,
      'hasParts': instance.hasParts,
      'name': instance.name,
      'img': instance.img,
      'description': instance.description,
    };

```

## lib\features\parts_catalog\models\groups_tree.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'groups_tree.freezed.dart';
part 'groups_tree.g.dart';

/// {@template groups_tree}
/// Модель данных для дерева групп.
/// {@endtemplate}
@freezed
abstract class GroupsTree with _$GroupsTree {
  /// {@macro groups_tree}
  factory GroupsTree({
    /// Идентификатор.
    @JsonKey(name: 'id') required String id,

    /// Название.
    @JsonKey(name: 'name') required String name,

    /// Идентификатор родительской группы (может быть null).
    @JsonKey(name: 'parentId') String? parentId,

    /// Список подгрупп.
    @JsonKey(name: 'subGroups') @Default([]) List<GroupsTree> subGroups,
  }) = _GroupsTree;

  /// Преобразует JSON в объект [GroupsTree].
  factory GroupsTree.fromJson(Map<String, dynamic> json) =>
      _$GroupsTreeFromJson(json);
}

```

## lib\features\parts_catalog\models\groups_tree.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'groups_tree.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$GroupsTree {
  /// Идентификатор.
  @JsonKey(name: 'id')
  String get id;

  /// Название.
  @JsonKey(name: 'name')
  String get name;

  /// Идентификатор родительской группы (может быть null).
  @JsonKey(name: 'parentId')
  String? get parentId;

  /// Список подгрупп.
  @JsonKey(name: 'subGroups')
  List<GroupsTree> get subGroups;

  /// Create a copy of GroupsTree
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $GroupsTreeCopyWith<GroupsTree> get copyWith =>
      _$GroupsTreeCopyWithImpl<GroupsTree>(this as GroupsTree, _$identity);

  /// Serializes this GroupsTree to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GroupsTree &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            const DeepCollectionEquality().equals(other.subGroups, subGroups));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, parentId,
      const DeepCollectionEquality().hash(subGroups));

  @override
  String toString() {
    return 'GroupsTree(id: $id, name: $name, parentId: $parentId, subGroups: $subGroups)';
  }
}

/// @nodoc
abstract mixin class $GroupsTreeCopyWith<$Res> {
  factory $GroupsTreeCopyWith(
          GroupsTree value, $Res Function(GroupsTree) _then) =
      _$GroupsTreeCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'subGroups') List<GroupsTree> subGroups});
}

/// @nodoc
class _$GroupsTreeCopyWithImpl<$Res> implements $GroupsTreeCopyWith<$Res> {
  _$GroupsTreeCopyWithImpl(this._self, this._then);

  final GroupsTree _self;
  final $Res Function(GroupsTree) _then;

  /// Create a copy of GroupsTree
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? parentId = freezed,
    Object? subGroups = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      subGroups: null == subGroups
          ? _self.subGroups
          : subGroups // ignore: cast_nullable_to_non_nullable
              as List<GroupsTree>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _GroupsTree implements GroupsTree {
  _GroupsTree(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'parentId') this.parentId,
      @JsonKey(name: 'subGroups') final List<GroupsTree> subGroups = const []})
      : _subGroups = subGroups;
  factory _GroupsTree.fromJson(Map<String, dynamic> json) =>
      _$GroupsTreeFromJson(json);

  /// Идентификатор.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Название.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Идентификатор родительской группы (может быть null).
  @override
  @JsonKey(name: 'parentId')
  final String? parentId;

  /// Список подгрупп.
  final List<GroupsTree> _subGroups;

  /// Список подгрупп.
  @override
  @JsonKey(name: 'subGroups')
  List<GroupsTree> get subGroups {
    if (_subGroups is EqualUnmodifiableListView) return _subGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subGroups);
  }

  /// Create a copy of GroupsTree
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$GroupsTreeCopyWith<_GroupsTree> get copyWith =>
      __$GroupsTreeCopyWithImpl<_GroupsTree>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$GroupsTreeToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _GroupsTree &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            const DeepCollectionEquality()
                .equals(other._subGroups, _subGroups));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, parentId,
      const DeepCollectionEquality().hash(_subGroups));

  @override
  String toString() {
    return 'GroupsTree(id: $id, name: $name, parentId: $parentId, subGroups: $subGroups)';
  }
}

/// @nodoc
abstract mixin class _$GroupsTreeCopyWith<$Res>
    implements $GroupsTreeCopyWith<$Res> {
  factory _$GroupsTreeCopyWith(
          _GroupsTree value, $Res Function(_GroupsTree) _then) =
      __$GroupsTreeCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'subGroups') List<GroupsTree> subGroups});
}

/// @nodoc
class __$GroupsTreeCopyWithImpl<$Res> implements _$GroupsTreeCopyWith<$Res> {
  __$GroupsTreeCopyWithImpl(this._self, this._then);

  final _GroupsTree _self;
  final $Res Function(_GroupsTree) _then;

  /// Create a copy of GroupsTree
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? parentId = freezed,
    Object? subGroups = null,
  }) {
    return _then(_GroupsTree(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      subGroups: null == subGroups
          ? _self._subGroups
          : subGroups // ignore: cast_nullable_to_non_nullable
              as List<GroupsTree>,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\groups_tree.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'groups_tree.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_GroupsTree _$GroupsTreeFromJson(Map<String, dynamic> json) => _GroupsTree(
      id: json['id'] as String,
      name: json['name'] as String,
      parentId: json['parentId'] as String?,
      subGroups: (json['subGroups'] as List<dynamic>?)
              ?.map((e) => GroupsTree.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
    );

Map<String, dynamic> _$GroupsTreeToJson(_GroupsTree instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'parentId': instance.parentId,
      'subGroups': instance.subGroups,
    };

```

## lib\features\parts_catalog\models\groups_tree_response.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/groups_tree.dart';

part 'groups_tree_response.freezed.dart';
part 'groups_tree_response.g.dart';

/// {@template groups_tree_response}
/// Модель данных для ответа с деревом групп.
/// {@endtemplate}
@freezed
abstract class GroupsTreeResponse with _$GroupsTreeResponse {
  /// {@macro groups_tree_response}
  factory GroupsTreeResponse({
    /// Идентификатор.
    @JsonKey(name: 'id') required String id,

    /// Название.
    @JsonKey(name: 'name') required String name,

    /// Идентификатор родительской группы (может быть null).
    @JsonKey(name: 'parentId') String? parentId,

    /// Список подгрупп.
    @JsonKey(name: 'subGroups') List<GroupsTree>? subGroups,
  }) = _GroupsTreeResponse;

  /// Преобразует JSON в объект [GroupsTreeResponse].
  factory GroupsTreeResponse.fromJson(Map<String, dynamic> json) =>
      _$GroupsTreeResponseFromJson(json);
}

```

## lib\features\parts_catalog\models\groups_tree_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'groups_tree_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$GroupsTreeResponse {
  /// Идентификатор.
  @JsonKey(name: 'id')
  String get id;

  /// Название.
  @JsonKey(name: 'name')
  String get name;

  /// Идентификатор родительской группы (может быть null).
  @JsonKey(name: 'parentId')
  String? get parentId;

  /// Список подгрупп.
  @JsonKey(name: 'subGroups')
  List<GroupsTree>? get subGroups;

  /// Create a copy of GroupsTreeResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $GroupsTreeResponseCopyWith<GroupsTreeResponse> get copyWith =>
      _$GroupsTreeResponseCopyWithImpl<GroupsTreeResponse>(
          this as GroupsTreeResponse, _$identity);

  /// Serializes this GroupsTreeResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GroupsTreeResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            const DeepCollectionEquality().equals(other.subGroups, subGroups));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, parentId,
      const DeepCollectionEquality().hash(subGroups));

  @override
  String toString() {
    return 'GroupsTreeResponse(id: $id, name: $name, parentId: $parentId, subGroups: $subGroups)';
  }
}

/// @nodoc
abstract mixin class $GroupsTreeResponseCopyWith<$Res> {
  factory $GroupsTreeResponseCopyWith(
          GroupsTreeResponse value, $Res Function(GroupsTreeResponse) _then) =
      _$GroupsTreeResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'subGroups') List<GroupsTree>? subGroups});
}

/// @nodoc
class _$GroupsTreeResponseCopyWithImpl<$Res>
    implements $GroupsTreeResponseCopyWith<$Res> {
  _$GroupsTreeResponseCopyWithImpl(this._self, this._then);

  final GroupsTreeResponse _self;
  final $Res Function(GroupsTreeResponse) _then;

  /// Create a copy of GroupsTreeResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? parentId = freezed,
    Object? subGroups = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      subGroups: freezed == subGroups
          ? _self.subGroups
          : subGroups // ignore: cast_nullable_to_non_nullable
              as List<GroupsTree>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _GroupsTreeResponse implements GroupsTreeResponse {
  _GroupsTreeResponse(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'parentId') this.parentId,
      @JsonKey(name: 'subGroups') final List<GroupsTree>? subGroups})
      : _subGroups = subGroups;
  factory _GroupsTreeResponse.fromJson(Map<String, dynamic> json) =>
      _$GroupsTreeResponseFromJson(json);

  /// Идентификатор.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Название.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Идентификатор родительской группы (может быть null).
  @override
  @JsonKey(name: 'parentId')
  final String? parentId;

  /// Список подгрупп.
  final List<GroupsTree>? _subGroups;

  /// Список подгрупп.
  @override
  @JsonKey(name: 'subGroups')
  List<GroupsTree>? get subGroups {
    final value = _subGroups;
    if (value == null) return null;
    if (_subGroups is EqualUnmodifiableListView) return _subGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of GroupsTreeResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$GroupsTreeResponseCopyWith<_GroupsTreeResponse> get copyWith =>
      __$GroupsTreeResponseCopyWithImpl<_GroupsTreeResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$GroupsTreeResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _GroupsTreeResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            const DeepCollectionEquality()
                .equals(other._subGroups, _subGroups));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, parentId,
      const DeepCollectionEquality().hash(_subGroups));

  @override
  String toString() {
    return 'GroupsTreeResponse(id: $id, name: $name, parentId: $parentId, subGroups: $subGroups)';
  }
}

/// @nodoc
abstract mixin class _$GroupsTreeResponseCopyWith<$Res>
    implements $GroupsTreeResponseCopyWith<$Res> {
  factory _$GroupsTreeResponseCopyWith(
          _GroupsTreeResponse value, $Res Function(_GroupsTreeResponse) _then) =
      __$GroupsTreeResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'parentId') String? parentId,
      @JsonKey(name: 'subGroups') List<GroupsTree>? subGroups});
}

/// @nodoc
class __$GroupsTreeResponseCopyWithImpl<$Res>
    implements _$GroupsTreeResponseCopyWith<$Res> {
  __$GroupsTreeResponseCopyWithImpl(this._self, this._then);

  final _GroupsTreeResponse _self;
  final $Res Function(_GroupsTreeResponse) _then;

  /// Create a copy of GroupsTreeResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? parentId = freezed,
    Object? subGroups = freezed,
  }) {
    return _then(_GroupsTreeResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parentId: freezed == parentId
          ? _self.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      subGroups: freezed == subGroups
          ? _self._subGroups
          : subGroups // ignore: cast_nullable_to_non_nullable
              as List<GroupsTree>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\groups_tree_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'groups_tree_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_GroupsTreeResponse _$GroupsTreeResponseFromJson(Map<String, dynamic> json) =>
    _GroupsTreeResponse(
      id: json['id'] as String,
      name: json['name'] as String,
      parentId: json['parentId'] as String?,
      subGroups: (json['subGroups'] as List<dynamic>?)
          ?.map((e) => GroupsTree.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$GroupsTreeResponseToJson(_GroupsTreeResponse instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'parentId': instance.parentId,
      'subGroups': instance.subGroups,
    };

```

## lib\features\parts_catalog\models\ip.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'ip.freezed.dart';
part 'ip.g.dart';

/// {@template ip}
/// Модель данных для IP-адреса.
/// {@endtemplate}
@freezed
abstract class Ip with _$Ip {
  /// {@macro ip}
  factory Ip({
    /// IP-адрес.
    @JsonKey(name: 'ip') String? ip,
  }) = _Ip;

  /// Преобразует JSON в объект [Ip].
  factory Ip.fromJson(Map<String, dynamic> json) => _$IpFromJson(json);
}

```

## lib\features\parts_catalog\models\ip.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ip.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Ip {
  /// IP-адрес.
  @JsonKey(name: 'ip')
  String? get ip;

  /// Create a copy of Ip
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $IpCopyWith<Ip> get copyWith => _$IpCopyWithImpl<Ip>(this as Ip, _$identity);

  /// Serializes this Ip to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Ip &&
            (identical(other.ip, ip) || other.ip == ip));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ip);

  @override
  String toString() {
    return 'Ip(ip: $ip)';
  }
}

/// @nodoc
abstract mixin class $IpCopyWith<$Res> {
  factory $IpCopyWith(Ip value, $Res Function(Ip) _then) = _$IpCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'ip') String? ip});
}

/// @nodoc
class _$IpCopyWithImpl<$Res> implements $IpCopyWith<$Res> {
  _$IpCopyWithImpl(this._self, this._then);

  final Ip _self;
  final $Res Function(Ip) _then;

  /// Create a copy of Ip
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ip = freezed,
  }) {
    return _then(_self.copyWith(
      ip: freezed == ip
          ? _self.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Ip implements Ip {
  _Ip({@JsonKey(name: 'ip') this.ip});
  factory _Ip.fromJson(Map<String, dynamic> json) => _$IpFromJson(json);

  /// IP-адрес.
  @override
  @JsonKey(name: 'ip')
  final String? ip;

  /// Create a copy of Ip
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$IpCopyWith<_Ip> get copyWith => __$IpCopyWithImpl<_Ip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$IpToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Ip &&
            (identical(other.ip, ip) || other.ip == ip));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ip);

  @override
  String toString() {
    return 'Ip(ip: $ip)';
  }
}

/// @nodoc
abstract mixin class _$IpCopyWith<$Res> implements $IpCopyWith<$Res> {
  factory _$IpCopyWith(_Ip value, $Res Function(_Ip) _then) = __$IpCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'ip') String? ip});
}

/// @nodoc
class __$IpCopyWithImpl<$Res> implements _$IpCopyWith<$Res> {
  __$IpCopyWithImpl(this._self, this._then);

  final _Ip _self;
  final $Res Function(_Ip) _then;

  /// Create a copy of Ip
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? ip = freezed,
  }) {
    return _then(_Ip(
      ip: freezed == ip
          ? _self.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\ip.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'ip.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Ip _$IpFromJson(Map<String, dynamic> json) => _Ip(
      ip: json['ip'] as String?,
    );

Map<String, dynamic> _$IpToJson(_Ip instance) => <String, dynamic>{
      'ip': instance.ip,
    };

```

## lib\features\parts_catalog\models\model.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'model.freezed.dart';
part 'model.g.dart';

/// {@template model}
/// Модель данных для модели автомобиля.
/// {@endtemplate}
@freezed
abstract class Model with _$Model {
  /// {@macro model}
  factory Model({
    /// Идентификатор модели.
    @JsonKey(name: 'id') required String id,

    /// Название модели.
    @JsonKey(name: 'name') required String name,

    /// URL изображения модели.
    @JsonKey(name: 'img') String? img,
  }) = _Model;

  /// Преобразует JSON в объект [Model].
  factory Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json);
}

```

## lib\features\parts_catalog\models\model.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Model {
  /// Идентификатор модели.
  @JsonKey(name: 'id')
  String get id;

  /// Название модели.
  @JsonKey(name: 'name')
  String get name;

  /// URL изображения модели.
  @JsonKey(name: 'img')
  String? get img;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModelCopyWith<Model> get copyWith =>
      _$ModelCopyWithImpl<Model>(this as Model, _$identity);

  /// Serializes this Model to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Model &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.img, img) || other.img == img));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, img);

  @override
  String toString() {
    return 'Model(id: $id, name: $name, img: $img)';
  }
}

/// @nodoc
abstract mixin class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) _then) =
      _$ModelCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'img') String? img});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res> implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._self, this._then);

  final Model _self;
  final $Res Function(Model) _then;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? img = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Model implements Model {
  _Model(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'img') this.img});
  factory _Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json);

  /// Идентификатор модели.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Название модели.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// URL изображения модели.
  @override
  @JsonKey(name: 'img')
  final String? img;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModelCopyWith<_Model> get copyWith =>
      __$ModelCopyWithImpl<_Model>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModelToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Model &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.img, img) || other.img == img));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, img);

  @override
  String toString() {
    return 'Model(id: $id, name: $name, img: $img)';
  }
}

/// @nodoc
abstract mixin class _$ModelCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$ModelCopyWith(_Model value, $Res Function(_Model) _then) =
      __$ModelCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'img') String? img});
}

/// @nodoc
class __$ModelCopyWithImpl<$Res> implements _$ModelCopyWith<$Res> {
  __$ModelCopyWithImpl(this._self, this._then);

  final _Model _self;
  final $Res Function(_Model) _then;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? img = freezed,
  }) {
    return _then(_Model(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\model.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Model _$ModelFromJson(Map<String, dynamic> json) => _Model(
      id: json['id'] as String,
      name: json['name'] as String,
      img: json['img'] as String?,
    );

Map<String, dynamic> _$ModelToJson(_Model instance) => <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'img': instance.img,
    };

```

## lib\features\parts_catalog\models\option_code.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'option_code.freezed.dart';
part 'option_code.g.dart';

/// {@template option_code}
/// Модель данных для кода опции автомобиля.
/// {@endtemplate}
@freezed
abstract class OptionCode with _$OptionCode {
  /// {@macro option_code}
  factory OptionCode({
    /// Код опции.
    @JsonKey(name: 'code') String? code,

    /// Описание опции.
    @JsonKey(name: 'description') String? description,
  }) = _OptionCode;

  /// Преобразует JSON в объект [OptionCode].
  factory OptionCode.fromJson(Map<String, dynamic> json) =>
      _$OptionCodeFromJson(json);
}

```

## lib\features\parts_catalog\models\option_code.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'option_code.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OptionCode {
  /// Код опции.
  @JsonKey(name: 'code')
  String? get code;

  /// Описание опции.
  @JsonKey(name: 'description')
  String? get description;

  /// Create a copy of OptionCode
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OptionCodeCopyWith<OptionCode> get copyWith =>
      _$OptionCodeCopyWithImpl<OptionCode>(this as OptionCode, _$identity);

  /// Serializes this OptionCode to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OptionCode &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, description);

  @override
  String toString() {
    return 'OptionCode(code: $code, description: $description)';
  }
}

/// @nodoc
abstract mixin class $OptionCodeCopyWith<$Res> {
  factory $OptionCodeCopyWith(
          OptionCode value, $Res Function(OptionCode) _then) =
      _$OptionCodeCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'code') String? code,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class _$OptionCodeCopyWithImpl<$Res> implements $OptionCodeCopyWith<$Res> {
  _$OptionCodeCopyWithImpl(this._self, this._then);

  final OptionCode _self;
  final $Res Function(OptionCode) _then;

  /// Create a copy of OptionCode
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? description = freezed,
  }) {
    return _then(_self.copyWith(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _OptionCode implements OptionCode {
  _OptionCode(
      {@JsonKey(name: 'code') this.code,
      @JsonKey(name: 'description') this.description});
  factory _OptionCode.fromJson(Map<String, dynamic> json) =>
      _$OptionCodeFromJson(json);

  /// Код опции.
  @override
  @JsonKey(name: 'code')
  final String? code;

  /// Описание опции.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Create a copy of OptionCode
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$OptionCodeCopyWith<_OptionCode> get copyWith =>
      __$OptionCodeCopyWithImpl<_OptionCode>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$OptionCodeToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OptionCode &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, description);

  @override
  String toString() {
    return 'OptionCode(code: $code, description: $description)';
  }
}

/// @nodoc
abstract mixin class _$OptionCodeCopyWith<$Res>
    implements $OptionCodeCopyWith<$Res> {
  factory _$OptionCodeCopyWith(
          _OptionCode value, $Res Function(_OptionCode) _then) =
      __$OptionCodeCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'code') String? code,
      @JsonKey(name: 'description') String? description});
}

/// @nodoc
class __$OptionCodeCopyWithImpl<$Res> implements _$OptionCodeCopyWith<$Res> {
  __$OptionCodeCopyWithImpl(this._self, this._then);

  final _OptionCode _self;
  final $Res Function(_OptionCode) _then;

  /// Create a copy of OptionCode
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = freezed,
    Object? description = freezed,
  }) {
    return _then(_OptionCode(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\option_code.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'option_code.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_OptionCode _$OptionCodeFromJson(Map<String, dynamic> json) => _OptionCode(
      code: json['code'] as String?,
      description: json['description'] as String?,
    );

Map<String, dynamic> _$OptionCodeToJson(_OptionCode instance) =>
    <String, dynamic>{
      'code': instance.code,
      'description': instance.description,
    };

```

## lib\features\parts_catalog\models\part.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'part.freezed.dart';
part 'part.g.dart';

/// {@template part}
/// Модель данных для детали.
/// {@endtemplate}
@freezed
abstract class Part with _$Part {
  /// {@macro part}
  factory Part({
    /// Идентификатор детали.
    @JsonKey(name: 'id') String? id,

    /// Идентификатор названия детали (может быть null).
    @JsonKey(name: 'nameId') String? nameId,

    /// Название детали.
    @JsonKey(name: 'name') String? name,

    /// Номер детали.
    @JsonKey(name: 'number') String? number,

    /// Примечание к детали.
    @JsonKey(name: 'notice') String? notice,

    /// Описание детали.
    @JsonKey(name: 'description') String? description,

    /// Номер позиции на изображении группы.
    @JsonKey(name: 'positionNumber') String? positionNumber,

    /// URL для поиска результатов.
    @JsonKey(name: 'url') String? url,
  }) = _Part;

  /// Преобразует JSON в объект [Part].
  factory Part.fromJson(Map<String, dynamic> json) => _$PartFromJson(json);
}

```

## lib\features\parts_catalog\models\part.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'part.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Part {
  /// Идентификатор детали.
  @JsonKey(name: 'id')
  String? get id;

  /// Идентификатор названия детали (может быть null).
  @JsonKey(name: 'nameId')
  String? get nameId;

  /// Название детали.
  @JsonKey(name: 'name')
  String? get name;

  /// Номер детали.
  @JsonKey(name: 'number')
  String? get number;

  /// Примечание к детали.
  @JsonKey(name: 'notice')
  String? get notice;

  /// Описание детали.
  @JsonKey(name: 'description')
  String? get description;

  /// Номер позиции на изображении группы.
  @JsonKey(name: 'positionNumber')
  String? get positionNumber;

  /// URL для поиска результатов.
  @JsonKey(name: 'url')
  String? get url;

  /// Create a copy of Part
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartCopyWith<Part> get copyWith =>
      _$PartCopyWithImpl<Part>(this as Part, _$identity);

  /// Serializes this Part to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Part &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.nameId, nameId) || other.nameId == nameId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.notice, notice) || other.notice == notice) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, nameId, name, number, notice,
      description, positionNumber, url);

  @override
  String toString() {
    return 'Part(id: $id, nameId: $nameId, name: $name, number: $number, notice: $notice, description: $description, positionNumber: $positionNumber, url: $url)';
  }
}

/// @nodoc
abstract mixin class $PartCopyWith<$Res> {
  factory $PartCopyWith(Part value, $Res Function(Part) _then) =
      _$PartCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'nameId') String? nameId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'notice') String? notice,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'url') String? url});
}

/// @nodoc
class _$PartCopyWithImpl<$Res> implements $PartCopyWith<$Res> {
  _$PartCopyWithImpl(this._self, this._then);

  final Part _self;
  final $Res Function(Part) _then;

  /// Create a copy of Part
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? nameId = freezed,
    Object? name = freezed,
    Object? number = freezed,
    Object? notice = freezed,
    Object? description = freezed,
    Object? positionNumber = freezed,
    Object? url = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      nameId: freezed == nameId
          ? _self.nameId
          : nameId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      notice: freezed == notice
          ? _self.notice
          : notice // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Part implements Part {
  _Part(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'nameId') this.nameId,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'number') this.number,
      @JsonKey(name: 'notice') this.notice,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'positionNumber') this.positionNumber,
      @JsonKey(name: 'url') this.url});
  factory _Part.fromJson(Map<String, dynamic> json) => _$PartFromJson(json);

  /// Идентификатор детали.
  @override
  @JsonKey(name: 'id')
  final String? id;

  /// Идентификатор названия детали (может быть null).
  @override
  @JsonKey(name: 'nameId')
  final String? nameId;

  /// Название детали.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Номер детали.
  @override
  @JsonKey(name: 'number')
  final String? number;

  /// Примечание к детали.
  @override
  @JsonKey(name: 'notice')
  final String? notice;

  /// Описание детали.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Номер позиции на изображении группы.
  @override
  @JsonKey(name: 'positionNumber')
  final String? positionNumber;

  /// URL для поиска результатов.
  @override
  @JsonKey(name: 'url')
  final String? url;

  /// Create a copy of Part
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartCopyWith<_Part> get copyWith =>
      __$PartCopyWithImpl<_Part>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Part &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.nameId, nameId) || other.nameId == nameId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.notice, notice) || other.notice == notice) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, nameId, name, number, notice,
      description, positionNumber, url);

  @override
  String toString() {
    return 'Part(id: $id, nameId: $nameId, name: $name, number: $number, notice: $notice, description: $description, positionNumber: $positionNumber, url: $url)';
  }
}

/// @nodoc
abstract mixin class _$PartCopyWith<$Res> implements $PartCopyWith<$Res> {
  factory _$PartCopyWith(_Part value, $Res Function(_Part) _then) =
      __$PartCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String? id,
      @JsonKey(name: 'nameId') String? nameId,
      @JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'notice') String? notice,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'url') String? url});
}

/// @nodoc
class __$PartCopyWithImpl<$Res> implements _$PartCopyWith<$Res> {
  __$PartCopyWithImpl(this._self, this._then);

  final _Part _self;
  final $Res Function(_Part) _then;

  /// Create a copy of Part
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? nameId = freezed,
    Object? name = freezed,
    Object? number = freezed,
    Object? notice = freezed,
    Object? description = freezed,
    Object? positionNumber = freezed,
    Object? url = freezed,
  }) {
    return _then(_Part(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      nameId: freezed == nameId
          ? _self.nameId
          : nameId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      notice: freezed == notice
          ? _self.notice
          : notice // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\part.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'part.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Part _$PartFromJson(Map<String, dynamic> json) => _Part(
      id: json['id'] as String?,
      nameId: json['nameId'] as String?,
      name: json['name'] as String?,
      number: json['number'] as String?,
      notice: json['notice'] as String?,
      description: json['description'] as String?,
      positionNumber: json['positionNumber'] as String?,
      url: json['url'] as String?,
    );

Map<String, dynamic> _$PartToJson(_Part instance) => <String, dynamic>{
      'id': instance.id,
      'nameId': instance.nameId,
      'name': instance.name,
      'number': instance.number,
      'notice': instance.notice,
      'description': instance.description,
      'positionNumber': instance.positionNumber,
      'url': instance.url,
    };

```

## lib\features\parts_catalog\models\part_name.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'part_name.freezed.dart';
part 'part_name.g.dart';

/// {@template part_name}
/// Модель данных для названия детали.
/// {@endtemplate}
@freezed
abstract class PartName with _$PartName {
  /// {@macro part_name}
  factory PartName({
    /// Идентификатор.
    @JsonKey(name: 'id') required String id,

    /// Название.
    @JsonKey(name: 'name') required String name,
  }) = _PartName;

  /// Преобразует JSON в объект [PartName].
  factory PartName.fromJson(Map<String, dynamic> json) =>
      _$PartNameFromJson(json);
}

```

## lib\features\parts_catalog\models\part_name.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'part_name.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PartName {
  /// Идентификатор.
  @JsonKey(name: 'id')
  String get id;

  /// Название.
  @JsonKey(name: 'name')
  String get name;

  /// Create a copy of PartName
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartNameCopyWith<PartName> get copyWith =>
      _$PartNameCopyWithImpl<PartName>(this as PartName, _$identity);

  /// Serializes this PartName to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PartName &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @override
  String toString() {
    return 'PartName(id: $id, name: $name)';
  }
}

/// @nodoc
abstract mixin class $PartNameCopyWith<$Res> {
  factory $PartNameCopyWith(PartName value, $Res Function(PartName) _then) =
      _$PartNameCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id, @JsonKey(name: 'name') String name});
}

/// @nodoc
class _$PartNameCopyWithImpl<$Res> implements $PartNameCopyWith<$Res> {
  _$PartNameCopyWithImpl(this._self, this._then);

  final PartName _self;
  final $Res Function(PartName) _then;

  /// Create a copy of PartName
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PartName implements PartName {
  _PartName(
      {@JsonKey(name: 'id') required this.id,
      @JsonKey(name: 'name') required this.name});
  factory _PartName.fromJson(Map<String, dynamic> json) =>
      _$PartNameFromJson(json);

  /// Идентификатор.
  @override
  @JsonKey(name: 'id')
  final String id;

  /// Название.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Create a copy of PartName
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartNameCopyWith<_PartName> get copyWith =>
      __$PartNameCopyWithImpl<_PartName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartNameToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PartName &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @override
  String toString() {
    return 'PartName(id: $id, name: $name)';
  }
}

/// @nodoc
abstract mixin class _$PartNameCopyWith<$Res>
    implements $PartNameCopyWith<$Res> {
  factory _$PartNameCopyWith(_PartName value, $Res Function(_PartName) _then) =
      __$PartNameCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') String id, @JsonKey(name: 'name') String name});
}

/// @nodoc
class __$PartNameCopyWithImpl<$Res> implements _$PartNameCopyWith<$Res> {
  __$PartNameCopyWithImpl(this._self, this._then);

  final _PartName _self;
  final $Res Function(_PartName) _then;

  /// Create a copy of PartName
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_PartName(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\part_name.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'part_name.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PartName _$PartNameFromJson(Map<String, dynamic> json) => _PartName(
      id: json['id'] as String,
      name: json['name'] as String,
    );

Map<String, dynamic> _$PartNameToJson(_PartName instance) => <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
    };

```

## lib\features\parts_catalog\models\parts.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/part.dart';

part 'parts.freezed.dart';
part 'parts.g.dart';

/// {@template parts}
/// Модель данных для списка запчастей.
/// {@endtemplate}
@freezed
abstract class Parts with _$Parts {
  /// {@macro parts}
  factory Parts({
    /// URL изображения группы запчастей.
    @JsonKey(name: 'img') String? img,

    /// Описание изображения группы запчастей.
    @JsonKey(name: 'imgDescription') String? imgDescription,

    /// Список групп запчастей.
    @JsonKey(name: 'partGroups') List<PartsGroup>? partGroups,

    /// Список позиций блоков с номерами на изображении.
    @JsonKey(name: 'positions') List<Position>? positions,
  }) = _Parts;

  /// Преобразует JSON в объект [Parts].
  factory Parts.fromJson(Map<String, dynamic> json) => _$PartsFromJson(json);
}

/// {@template parts_group}
/// Модель данных для группы запчастей.
/// {@endtemplate}
@freezed
abstract class PartsGroup with _$PartsGroup {
  /// {@macro parts_group}
  factory PartsGroup({
    /// Название запчасти.
    @JsonKey(name: 'name') String? name,

    /// Номер группы запчастей.
    @JsonKey(name: 'number') String? number,

    /// Номер позиции группы запчастей на изображении.
    @JsonKey(name: 'positionNumber') String? positionNumber,

    /// Описание группы запчастей.
    @JsonKey(name: 'description') String? description,

    /// Список деталей в группе.
    @JsonKey(name: 'parts') List<Part>? parts,
  }) = _PartsGroup;

  /// Преобразует JSON в объект [PartsGroup].
  factory PartsGroup.fromJson(Map<String, dynamic> json) =>
      _$PartsGroupFromJson(json);
}

/// {@template position}
/// Модель данных для позиции блока с номером на изображении.
/// {@endtemplate}
@freezed
abstract class Position with _$Position {
  /// {@macro position}
  factory Position({
    /// Номер на изображении.
    @JsonKey(name: 'number') String? number,

    /// Координаты блока с номером на изображении (X, Y, H, W).
    @JsonKey(name: 'coordinates') List<double>? coordinates,
  }) = _Position;

  /// Преобразует JSON в объект [Position].
  factory Position.fromJson(Map<String, dynamic> json) =>
      _$PositionFromJson(json);
}

```

## lib\features\parts_catalog\models\parts.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'parts.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Parts {
  /// URL изображения группы запчастей.
  @JsonKey(name: 'img')
  String? get img;

  /// Описание изображения группы запчастей.
  @JsonKey(name: 'imgDescription')
  String? get imgDescription;

  /// Список групп запчастей.
  @JsonKey(name: 'partGroups')
  List<PartsGroup>? get partGroups;

  /// Список позиций блоков с номерами на изображении.
  @JsonKey(name: 'positions')
  List<Position>? get positions;

  /// Create a copy of Parts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartsCopyWith<Parts> get copyWith =>
      _$PartsCopyWithImpl<Parts>(this as Parts, _$identity);

  /// Serializes this Parts to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Parts &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.imgDescription, imgDescription) ||
                other.imgDescription == imgDescription) &&
            const DeepCollectionEquality()
                .equals(other.partGroups, partGroups) &&
            const DeepCollectionEquality().equals(other.positions, positions));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      img,
      imgDescription,
      const DeepCollectionEquality().hash(partGroups),
      const DeepCollectionEquality().hash(positions));

  @override
  String toString() {
    return 'Parts(img: $img, imgDescription: $imgDescription, partGroups: $partGroups, positions: $positions)';
  }
}

/// @nodoc
abstract mixin class $PartsCopyWith<$Res> {
  factory $PartsCopyWith(Parts value, $Res Function(Parts) _then) =
      _$PartsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'img') String? img,
      @JsonKey(name: 'imgDescription') String? imgDescription,
      @JsonKey(name: 'partGroups') List<PartsGroup>? partGroups,
      @JsonKey(name: 'positions') List<Position>? positions});
}

/// @nodoc
class _$PartsCopyWithImpl<$Res> implements $PartsCopyWith<$Res> {
  _$PartsCopyWithImpl(this._self, this._then);

  final Parts _self;
  final $Res Function(Parts) _then;

  /// Create a copy of Parts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? img = freezed,
    Object? imgDescription = freezed,
    Object? partGroups = freezed,
    Object? positions = freezed,
  }) {
    return _then(_self.copyWith(
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      imgDescription: freezed == imgDescription
          ? _self.imgDescription
          : imgDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      partGroups: freezed == partGroups
          ? _self.partGroups
          : partGroups // ignore: cast_nullable_to_non_nullable
              as List<PartsGroup>?,
      positions: freezed == positions
          ? _self.positions
          : positions // ignore: cast_nullable_to_non_nullable
              as List<Position>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Parts implements Parts {
  _Parts(
      {@JsonKey(name: 'img') this.img,
      @JsonKey(name: 'imgDescription') this.imgDescription,
      @JsonKey(name: 'partGroups') final List<PartsGroup>? partGroups,
      @JsonKey(name: 'positions') final List<Position>? positions})
      : _partGroups = partGroups,
        _positions = positions;
  factory _Parts.fromJson(Map<String, dynamic> json) => _$PartsFromJson(json);

  /// URL изображения группы запчастей.
  @override
  @JsonKey(name: 'img')
  final String? img;

  /// Описание изображения группы запчастей.
  @override
  @JsonKey(name: 'imgDescription')
  final String? imgDescription;

  /// Список групп запчастей.
  final List<PartsGroup>? _partGroups;

  /// Список групп запчастей.
  @override
  @JsonKey(name: 'partGroups')
  List<PartsGroup>? get partGroups {
    final value = _partGroups;
    if (value == null) return null;
    if (_partGroups is EqualUnmodifiableListView) return _partGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Список позиций блоков с номерами на изображении.
  final List<Position>? _positions;

  /// Список позиций блоков с номерами на изображении.
  @override
  @JsonKey(name: 'positions')
  List<Position>? get positions {
    final value = _positions;
    if (value == null) return null;
    if (_positions is EqualUnmodifiableListView) return _positions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of Parts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartsCopyWith<_Parts> get copyWith =>
      __$PartsCopyWithImpl<_Parts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Parts &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.imgDescription, imgDescription) ||
                other.imgDescription == imgDescription) &&
            const DeepCollectionEquality()
                .equals(other._partGroups, _partGroups) &&
            const DeepCollectionEquality()
                .equals(other._positions, _positions));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      img,
      imgDescription,
      const DeepCollectionEquality().hash(_partGroups),
      const DeepCollectionEquality().hash(_positions));

  @override
  String toString() {
    return 'Parts(img: $img, imgDescription: $imgDescription, partGroups: $partGroups, positions: $positions)';
  }
}

/// @nodoc
abstract mixin class _$PartsCopyWith<$Res> implements $PartsCopyWith<$Res> {
  factory _$PartsCopyWith(_Parts value, $Res Function(_Parts) _then) =
      __$PartsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'img') String? img,
      @JsonKey(name: 'imgDescription') String? imgDescription,
      @JsonKey(name: 'partGroups') List<PartsGroup>? partGroups,
      @JsonKey(name: 'positions') List<Position>? positions});
}

/// @nodoc
class __$PartsCopyWithImpl<$Res> implements _$PartsCopyWith<$Res> {
  __$PartsCopyWithImpl(this._self, this._then);

  final _Parts _self;
  final $Res Function(_Parts) _then;

  /// Create a copy of Parts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? img = freezed,
    Object? imgDescription = freezed,
    Object? partGroups = freezed,
    Object? positions = freezed,
  }) {
    return _then(_Parts(
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      imgDescription: freezed == imgDescription
          ? _self.imgDescription
          : imgDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      partGroups: freezed == partGroups
          ? _self._partGroups
          : partGroups // ignore: cast_nullable_to_non_nullable
              as List<PartsGroup>?,
      positions: freezed == positions
          ? _self._positions
          : positions // ignore: cast_nullable_to_non_nullable
              as List<Position>?,
    ));
  }
}

/// @nodoc
mixin _$PartsGroup {
  /// Название запчасти.
  @JsonKey(name: 'name')
  String? get name;

  /// Номер группы запчастей.
  @JsonKey(name: 'number')
  String? get number;

  /// Номер позиции группы запчастей на изображении.
  @JsonKey(name: 'positionNumber')
  String? get positionNumber;

  /// Описание группы запчастей.
  @JsonKey(name: 'description')
  String? get description;

  /// Список деталей в группе.
  @JsonKey(name: 'parts')
  List<Part>? get parts;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartsGroupCopyWith<PartsGroup> get copyWith =>
      _$PartsGroupCopyWithImpl<PartsGroup>(this as PartsGroup, _$identity);

  /// Serializes this PartsGroup to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PartsGroup &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.parts, parts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, number, positionNumber,
      description, const DeepCollectionEquality().hash(parts));

  @override
  String toString() {
    return 'PartsGroup(name: $name, number: $number, positionNumber: $positionNumber, description: $description, parts: $parts)';
  }
}

/// @nodoc
abstract mixin class $PartsGroupCopyWith<$Res> {
  factory $PartsGroupCopyWith(
          PartsGroup value, $Res Function(PartsGroup) _then) =
      _$PartsGroupCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'parts') List<Part>? parts});
}

/// @nodoc
class _$PartsGroupCopyWithImpl<$Res> implements $PartsGroupCopyWith<$Res> {
  _$PartsGroupCopyWithImpl(this._self, this._then);

  final PartsGroup _self;
  final $Res Function(PartsGroup) _then;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? number = freezed,
    Object? positionNumber = freezed,
    Object? description = freezed,
    Object? parts = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parts: freezed == parts
          ? _self.parts
          : parts // ignore: cast_nullable_to_non_nullable
              as List<Part>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PartsGroup implements PartsGroup {
  _PartsGroup(
      {@JsonKey(name: 'name') this.name,
      @JsonKey(name: 'number') this.number,
      @JsonKey(name: 'positionNumber') this.positionNumber,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'parts') final List<Part>? parts})
      : _parts = parts;
  factory _PartsGroup.fromJson(Map<String, dynamic> json) =>
      _$PartsGroupFromJson(json);

  /// Название запчасти.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Номер группы запчастей.
  @override
  @JsonKey(name: 'number')
  final String? number;

  /// Номер позиции группы запчастей на изображении.
  @override
  @JsonKey(name: 'positionNumber')
  final String? positionNumber;

  /// Описание группы запчастей.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Список деталей в группе.
  final List<Part>? _parts;

  /// Список деталей в группе.
  @override
  @JsonKey(name: 'parts')
  List<Part>? get parts {
    final value = _parts;
    if (value == null) return null;
    if (_parts is EqualUnmodifiableListView) return _parts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartsGroupCopyWith<_PartsGroup> get copyWith =>
      __$PartsGroupCopyWithImpl<_PartsGroup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartsGroupToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PartsGroup &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._parts, _parts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, number, positionNumber,
      description, const DeepCollectionEquality().hash(_parts));

  @override
  String toString() {
    return 'PartsGroup(name: $name, number: $number, positionNumber: $positionNumber, description: $description, parts: $parts)';
  }
}

/// @nodoc
abstract mixin class _$PartsGroupCopyWith<$Res>
    implements $PartsGroupCopyWith<$Res> {
  factory _$PartsGroupCopyWith(
          _PartsGroup value, $Res Function(_PartsGroup) _then) =
      __$PartsGroupCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'parts') List<Part>? parts});
}

/// @nodoc
class __$PartsGroupCopyWithImpl<$Res> implements _$PartsGroupCopyWith<$Res> {
  __$PartsGroupCopyWithImpl(this._self, this._then);

  final _PartsGroup _self;
  final $Res Function(_PartsGroup) _then;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? number = freezed,
    Object? positionNumber = freezed,
    Object? description = freezed,
    Object? parts = freezed,
  }) {
    return _then(_PartsGroup(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parts: freezed == parts
          ? _self._parts
          : parts // ignore: cast_nullable_to_non_nullable
              as List<Part>?,
    ));
  }
}

/// @nodoc
mixin _$Position {
  /// Номер на изображении.
  @JsonKey(name: 'number')
  String? get number;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  @JsonKey(name: 'coordinates')
  List<double>? get coordinates;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PositionCopyWith<Position> get copyWith =>
      _$PositionCopyWithImpl<Position>(this as Position, _$identity);

  /// Serializes this Position to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Position &&
            (identical(other.number, number) || other.number == number) &&
            const DeepCollectionEquality()
                .equals(other.coordinates, coordinates));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, number, const DeepCollectionEquality().hash(coordinates));

  @override
  String toString() {
    return 'Position(number: $number, coordinates: $coordinates)';
  }
}

/// @nodoc
abstract mixin class $PositionCopyWith<$Res> {
  factory $PositionCopyWith(Position value, $Res Function(Position) _then) =
      _$PositionCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'number') String? number,
      @JsonKey(name: 'coordinates') List<double>? coordinates});
}

/// @nodoc
class _$PositionCopyWithImpl<$Res> implements $PositionCopyWith<$Res> {
  _$PositionCopyWithImpl(this._self, this._then);

  final Position _self;
  final $Res Function(Position) _then;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? coordinates = freezed,
  }) {
    return _then(_self.copyWith(
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      coordinates: freezed == coordinates
          ? _self.coordinates
          : coordinates // ignore: cast_nullable_to_non_nullable
              as List<double>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Position implements Position {
  _Position(
      {@JsonKey(name: 'number') this.number,
      @JsonKey(name: 'coordinates') final List<double>? coordinates})
      : _coordinates = coordinates;
  factory _Position.fromJson(Map<String, dynamic> json) =>
      _$PositionFromJson(json);

  /// Номер на изображении.
  @override
  @JsonKey(name: 'number')
  final String? number;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  final List<double>? _coordinates;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  @override
  @JsonKey(name: 'coordinates')
  List<double>? get coordinates {
    final value = _coordinates;
    if (value == null) return null;
    if (_coordinates is EqualUnmodifiableListView) return _coordinates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PositionCopyWith<_Position> get copyWith =>
      __$PositionCopyWithImpl<_Position>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PositionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Position &&
            (identical(other.number, number) || other.number == number) &&
            const DeepCollectionEquality()
                .equals(other._coordinates, _coordinates));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, number, const DeepCollectionEquality().hash(_coordinates));

  @override
  String toString() {
    return 'Position(number: $number, coordinates: $coordinates)';
  }
}

/// @nodoc
abstract mixin class _$PositionCopyWith<$Res>
    implements $PositionCopyWith<$Res> {
  factory _$PositionCopyWith(_Position value, $Res Function(_Position) _then) =
      __$PositionCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'number') String? number,
      @JsonKey(name: 'coordinates') List<double>? coordinates});
}

/// @nodoc
class __$PositionCopyWithImpl<$Res> implements _$PositionCopyWith<$Res> {
  __$PositionCopyWithImpl(this._self, this._then);

  final _Position _self;
  final $Res Function(_Position) _then;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? number = freezed,
    Object? coordinates = freezed,
  }) {
    return _then(_Position(
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      coordinates: freezed == coordinates
          ? _self._coordinates
          : coordinates // ignore: cast_nullable_to_non_nullable
              as List<double>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\parts.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'parts.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Parts _$PartsFromJson(Map<String, dynamic> json) => _Parts(
      img: json['img'] as String?,
      imgDescription: json['imgDescription'] as String?,
      partGroups: (json['partGroups'] as List<dynamic>?)
          ?.map((e) => PartsGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      positions: (json['positions'] as List<dynamic>?)
          ?.map((e) => Position.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$PartsToJson(_Parts instance) => <String, dynamic>{
      'img': instance.img,
      'imgDescription': instance.imgDescription,
      'partGroups': instance.partGroups,
      'positions': instance.positions,
    };

_PartsGroup _$PartsGroupFromJson(Map<String, dynamic> json) => _PartsGroup(
      name: json['name'] as String?,
      number: json['number'] as String?,
      positionNumber: json['positionNumber'] as String?,
      description: json['description'] as String?,
      parts: (json['parts'] as List<dynamic>?)
          ?.map((e) => Part.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$PartsGroupToJson(_PartsGroup instance) =>
    <String, dynamic>{
      'name': instance.name,
      'number': instance.number,
      'positionNumber': instance.positionNumber,
      'description': instance.description,
      'parts': instance.parts,
    };

_Position _$PositionFromJson(Map<String, dynamic> json) => _Position(
      number: json['number'] as String?,
      coordinates: (json['coordinates'] as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList(),
    );

Map<String, dynamic> _$PositionToJson(_Position instance) => <String, dynamic>{
      'number': instance.number,
      'coordinates': instance.coordinates,
    };

```

## lib\features\parts_catalog\models\parts_group.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/part.dart';

part 'parts_group.freezed.dart';
part 'parts_group.g.dart';

/// {@template parts_group}
/// Модель данных для группы запчастей.
/// {@endtemplate}
@freezed
abstract class PartsGroup with _$PartsGroup {
  /// {@macro parts_group}
  factory PartsGroup({
    /// Название запчасти.
    @JsonKey(name: 'name') String? name,

    /// Номер группы запчастей.
    @JsonKey(name: 'number') String? number,

    /// Номер позиции группы запчастей на изображении.
    @JsonKey(name: 'positionNumber') String? positionNumber,

    /// Описание группы запчастей.
    @JsonKey(name: 'description') String? description,

    /// Список деталей в группе.
    @JsonKey(name: 'parts') List<Part>? parts,
  }) = _PartsGroup;

  /// Преобразует JSON в объект [PartsGroup].
  factory PartsGroup.fromJson(Map<String, dynamic> json) =>
      _$PartsGroupFromJson(json);
}

```

## lib\features\parts_catalog\models\parts_group.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'parts_group.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PartsGroup {
  /// Название запчасти.
  @JsonKey(name: 'name')
  String? get name;

  /// Номер группы запчастей.
  @JsonKey(name: 'number')
  String? get number;

  /// Номер позиции группы запчастей на изображении.
  @JsonKey(name: 'positionNumber')
  String? get positionNumber;

  /// Описание группы запчастей.
  @JsonKey(name: 'description')
  String? get description;

  /// Список деталей в группе.
  @JsonKey(name: 'parts')
  List<Part>? get parts;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartsGroupCopyWith<PartsGroup> get copyWith =>
      _$PartsGroupCopyWithImpl<PartsGroup>(this as PartsGroup, _$identity);

  /// Serializes this PartsGroup to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PartsGroup &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.parts, parts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, number, positionNumber,
      description, const DeepCollectionEquality().hash(parts));

  @override
  String toString() {
    return 'PartsGroup(name: $name, number: $number, positionNumber: $positionNumber, description: $description, parts: $parts)';
  }
}

/// @nodoc
abstract mixin class $PartsGroupCopyWith<$Res> {
  factory $PartsGroupCopyWith(
          PartsGroup value, $Res Function(PartsGroup) _then) =
      _$PartsGroupCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'parts') List<Part>? parts});
}

/// @nodoc
class _$PartsGroupCopyWithImpl<$Res> implements $PartsGroupCopyWith<$Res> {
  _$PartsGroupCopyWithImpl(this._self, this._then);

  final PartsGroup _self;
  final $Res Function(PartsGroup) _then;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? number = freezed,
    Object? positionNumber = freezed,
    Object? description = freezed,
    Object? parts = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parts: freezed == parts
          ? _self.parts
          : parts // ignore: cast_nullable_to_non_nullable
              as List<Part>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PartsGroup implements PartsGroup {
  _PartsGroup(
      {@JsonKey(name: 'name') this.name,
      @JsonKey(name: 'number') this.number,
      @JsonKey(name: 'positionNumber') this.positionNumber,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'parts') final List<Part>? parts})
      : _parts = parts;
  factory _PartsGroup.fromJson(Map<String, dynamic> json) =>
      _$PartsGroupFromJson(json);

  /// Название запчасти.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Номер группы запчастей.
  @override
  @JsonKey(name: 'number')
  final String? number;

  /// Номер позиции группы запчастей на изображении.
  @override
  @JsonKey(name: 'positionNumber')
  final String? positionNumber;

  /// Описание группы запчастей.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Список деталей в группе.
  final List<Part>? _parts;

  /// Список деталей в группе.
  @override
  @JsonKey(name: 'parts')
  List<Part>? get parts {
    final value = _parts;
    if (value == null) return null;
    if (_parts is EqualUnmodifiableListView) return _parts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartsGroupCopyWith<_PartsGroup> get copyWith =>
      __$PartsGroupCopyWithImpl<_PartsGroup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartsGroupToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PartsGroup &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.positionNumber, positionNumber) ||
                other.positionNumber == positionNumber) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._parts, _parts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, number, positionNumber,
      description, const DeepCollectionEquality().hash(_parts));

  @override
  String toString() {
    return 'PartsGroup(name: $name, number: $number, positionNumber: $positionNumber, description: $description, parts: $parts)';
  }
}

/// @nodoc
abstract mixin class _$PartsGroupCopyWith<$Res>
    implements $PartsGroupCopyWith<$Res> {
  factory _$PartsGroupCopyWith(
          _PartsGroup value, $Res Function(_PartsGroup) _then) =
      __$PartsGroupCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String? name,
      @JsonKey(name: 'number') String? number,
      @JsonKey(name: 'positionNumber') String? positionNumber,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'parts') List<Part>? parts});
}

/// @nodoc
class __$PartsGroupCopyWithImpl<$Res> implements _$PartsGroupCopyWith<$Res> {
  __$PartsGroupCopyWithImpl(this._self, this._then);

  final _PartsGroup _self;
  final $Res Function(_PartsGroup) _then;

  /// Create a copy of PartsGroup
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? number = freezed,
    Object? positionNumber = freezed,
    Object? description = freezed,
    Object? parts = freezed,
  }) {
    return _then(_PartsGroup(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      positionNumber: freezed == positionNumber
          ? _self.positionNumber
          : positionNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parts: freezed == parts
          ? _self._parts
          : parts // ignore: cast_nullable_to_non_nullable
              as List<Part>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\parts_group.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'parts_group.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PartsGroup _$PartsGroupFromJson(Map<String, dynamic> json) => _PartsGroup(
      name: json['name'] as String?,
      number: json['number'] as String?,
      positionNumber: json['positionNumber'] as String?,
      description: json['description'] as String?,
      parts: (json['parts'] as List<dynamic>?)
          ?.map((e) => Part.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$PartsGroupToJson(_PartsGroup instance) =>
    <String, dynamic>{
      'name': instance.name,
      'number': instance.number,
      'positionNumber': instance.positionNumber,
      'description': instance.description,
      'parts': instance.parts,
    };

```

## lib\features\parts_catalog\models\position.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'position.freezed.dart';
part 'position.g.dart';

/// {@template position}
/// Модель данных для позиции блока с номером на изображении.
/// {@endtemplate}
@freezed
abstract class Position with _$Position {
  /// {@macro position}
  factory Position({
    /// Номер на изображении.
    @JsonKey(name: 'number') String? number,

    /// Координаты блока с номером на изображении (X, Y, H, W).
    @JsonKey(name: 'coordinates') List<double>? coordinates,
  }) = _Position;

  /// Преобразует JSON в объект [Position].
  factory Position.fromJson(Map<String, dynamic> json) =>
      _$PositionFromJson(json);
}

```

## lib\features\parts_catalog\models\position.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'position.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Position {
  /// Номер на изображении.
  @JsonKey(name: 'number')
  String? get number;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  @JsonKey(name: 'coordinates')
  List<double>? get coordinates;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PositionCopyWith<Position> get copyWith =>
      _$PositionCopyWithImpl<Position>(this as Position, _$identity);

  /// Serializes this Position to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Position &&
            (identical(other.number, number) || other.number == number) &&
            const DeepCollectionEquality()
                .equals(other.coordinates, coordinates));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, number, const DeepCollectionEquality().hash(coordinates));

  @override
  String toString() {
    return 'Position(number: $number, coordinates: $coordinates)';
  }
}

/// @nodoc
abstract mixin class $PositionCopyWith<$Res> {
  factory $PositionCopyWith(Position value, $Res Function(Position) _then) =
      _$PositionCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'number') String? number,
      @JsonKey(name: 'coordinates') List<double>? coordinates});
}

/// @nodoc
class _$PositionCopyWithImpl<$Res> implements $PositionCopyWith<$Res> {
  _$PositionCopyWithImpl(this._self, this._then);

  final Position _self;
  final $Res Function(Position) _then;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? coordinates = freezed,
  }) {
    return _then(_self.copyWith(
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      coordinates: freezed == coordinates
          ? _self.coordinates
          : coordinates // ignore: cast_nullable_to_non_nullable
              as List<double>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Position implements Position {
  _Position(
      {@JsonKey(name: 'number') this.number,
      @JsonKey(name: 'coordinates') final List<double>? coordinates})
      : _coordinates = coordinates;
  factory _Position.fromJson(Map<String, dynamic> json) =>
      _$PositionFromJson(json);

  /// Номер на изображении.
  @override
  @JsonKey(name: 'number')
  final String? number;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  final List<double>? _coordinates;

  /// Координаты блока с номером на изображении (X, Y, H, W).
  @override
  @JsonKey(name: 'coordinates')
  List<double>? get coordinates {
    final value = _coordinates;
    if (value == null) return null;
    if (_coordinates is EqualUnmodifiableListView) return _coordinates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PositionCopyWith<_Position> get copyWith =>
      __$PositionCopyWithImpl<_Position>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PositionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Position &&
            (identical(other.number, number) || other.number == number) &&
            const DeepCollectionEquality()
                .equals(other._coordinates, _coordinates));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, number, const DeepCollectionEquality().hash(_coordinates));

  @override
  String toString() {
    return 'Position(number: $number, coordinates: $coordinates)';
  }
}

/// @nodoc
abstract mixin class _$PositionCopyWith<$Res>
    implements $PositionCopyWith<$Res> {
  factory _$PositionCopyWith(_Position value, $Res Function(_Position) _then) =
      __$PositionCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'number') String? number,
      @JsonKey(name: 'coordinates') List<double>? coordinates});
}

/// @nodoc
class __$PositionCopyWithImpl<$Res> implements _$PositionCopyWith<$Res> {
  __$PositionCopyWithImpl(this._self, this._then);

  final _Position _self;
  final $Res Function(_Position) _then;

  /// Create a copy of Position
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? number = freezed,
    Object? coordinates = freezed,
  }) {
    return _then(_Position(
      number: freezed == number
          ? _self.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      coordinates: freezed == coordinates
          ? _self._coordinates
          : coordinates // ignore: cast_nullable_to_non_nullable
              as List<double>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\position.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'position.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Position _$PositionFromJson(Map<String, dynamic> json) => _Position(
      number: json['number'] as String?,
      coordinates: (json['coordinates'] as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList(),
    );

Map<String, dynamic> _$PositionToJson(_Position instance) => <String, dynamic>{
      'number': instance.number,
      'coordinates': instance.coordinates,
    };

```

## lib\features\parts_catalog\models\schema_model.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/part_name.dart';

part 'schema_model.freezed.dart';
part 'schema_model.g.dart';

/// {@template schema_model}
/// Модель данных для схемы.
/// {@endtemplate}
@freezed
abstract class SchemaModel with _$SchemaModel {
  /// {@macro schema_model}
  factory SchemaModel({
    /// Идентификатор группы.
    @JsonKey(name: 'groupId') required String groupId,

    /// URL изображения.
    @JsonKey(name: 'img') String? img,

    /// Название.
    @JsonKey(name: 'name') required String name,

    /// Описание.
    @JsonKey(name: 'description') String? description,

    /// Список названий деталей.
    @JsonKey(name: 'partNames') List<PartName>? partNames,
  }) = _SchemaModel;

  /// Преобразует JSON в объект [SchemaModel].
  factory SchemaModel.fromJson(Map<String, dynamic> json) =>
      _$SchemaModelFromJson(json);
}

```

## lib\features\parts_catalog\models\schema_model.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SchemaModel {
  /// Идентификатор группы.
  @JsonKey(name: 'groupId')
  String get groupId;

  /// URL изображения.
  @JsonKey(name: 'img')
  String? get img;

  /// Название.
  @JsonKey(name: 'name')
  String get name;

  /// Описание.
  @JsonKey(name: 'description')
  String? get description;

  /// Список названий деталей.
  @JsonKey(name: 'partNames')
  List<PartName>? get partNames;

  /// Create a copy of SchemaModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SchemaModelCopyWith<SchemaModel> get copyWith =>
      _$SchemaModelCopyWithImpl<SchemaModel>(this as SchemaModel, _$identity);

  /// Serializes this SchemaModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SchemaModel &&
            (identical(other.groupId, groupId) || other.groupId == groupId) &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.partNames, partNames));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, groupId, img, name, description,
      const DeepCollectionEquality().hash(partNames));

  @override
  String toString() {
    return 'SchemaModel(groupId: $groupId, img: $img, name: $name, description: $description, partNames: $partNames)';
  }
}

/// @nodoc
abstract mixin class $SchemaModelCopyWith<$Res> {
  factory $SchemaModelCopyWith(
          SchemaModel value, $Res Function(SchemaModel) _then) =
      _$SchemaModelCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'groupId') String groupId,
      @JsonKey(name: 'img') String? img,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'partNames') List<PartName>? partNames});
}

/// @nodoc
class _$SchemaModelCopyWithImpl<$Res> implements $SchemaModelCopyWith<$Res> {
  _$SchemaModelCopyWithImpl(this._self, this._then);

  final SchemaModel _self;
  final $Res Function(SchemaModel) _then;

  /// Create a copy of SchemaModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = null,
    Object? img = freezed,
    Object? name = null,
    Object? description = freezed,
    Object? partNames = freezed,
  }) {
    return _then(_self.copyWith(
      groupId: null == groupId
          ? _self.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      partNames: freezed == partNames
          ? _self.partNames
          : partNames // ignore: cast_nullable_to_non_nullable
              as List<PartName>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _SchemaModel implements SchemaModel {
  _SchemaModel(
      {@JsonKey(name: 'groupId') required this.groupId,
      @JsonKey(name: 'img') this.img,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'description') this.description,
      @JsonKey(name: 'partNames') final List<PartName>? partNames})
      : _partNames = partNames;
  factory _SchemaModel.fromJson(Map<String, dynamic> json) =>
      _$SchemaModelFromJson(json);

  /// Идентификатор группы.
  @override
  @JsonKey(name: 'groupId')
  final String groupId;

  /// URL изображения.
  @override
  @JsonKey(name: 'img')
  final String? img;

  /// Название.
  @override
  @JsonKey(name: 'name')
  final String name;

  /// Описание.
  @override
  @JsonKey(name: 'description')
  final String? description;

  /// Список названий деталей.
  final List<PartName>? _partNames;

  /// Список названий деталей.
  @override
  @JsonKey(name: 'partNames')
  List<PartName>? get partNames {
    final value = _partNames;
    if (value == null) return null;
    if (_partNames is EqualUnmodifiableListView) return _partNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of SchemaModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SchemaModelCopyWith<_SchemaModel> get copyWith =>
      __$SchemaModelCopyWithImpl<_SchemaModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SchemaModelToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SchemaModel &&
            (identical(other.groupId, groupId) || other.groupId == groupId) &&
            (identical(other.img, img) || other.img == img) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._partNames, _partNames));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, groupId, img, name, description,
      const DeepCollectionEquality().hash(_partNames));

  @override
  String toString() {
    return 'SchemaModel(groupId: $groupId, img: $img, name: $name, description: $description, partNames: $partNames)';
  }
}

/// @nodoc
abstract mixin class _$SchemaModelCopyWith<$Res>
    implements $SchemaModelCopyWith<$Res> {
  factory _$SchemaModelCopyWith(
          _SchemaModel value, $Res Function(_SchemaModel) _then) =
      __$SchemaModelCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'groupId') String groupId,
      @JsonKey(name: 'img') String? img,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'partNames') List<PartName>? partNames});
}

/// @nodoc
class __$SchemaModelCopyWithImpl<$Res> implements _$SchemaModelCopyWith<$Res> {
  __$SchemaModelCopyWithImpl(this._self, this._then);

  final _SchemaModel _self;
  final $Res Function(_SchemaModel) _then;

  /// Create a copy of SchemaModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? groupId = null,
    Object? img = freezed,
    Object? name = null,
    Object? description = freezed,
    Object? partNames = freezed,
  }) {
    return _then(_SchemaModel(
      groupId: null == groupId
          ? _self.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as String,
      img: freezed == img
          ? _self.img
          : img // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      partNames: freezed == partNames
          ? _self._partNames
          : partNames // ignore: cast_nullable_to_non_nullable
              as List<PartName>?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\schema_model.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schema_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_SchemaModel _$SchemaModelFromJson(Map<String, dynamic> json) => _SchemaModel(
      groupId: json['groupId'] as String,
      img: json['img'] as String?,
      name: json['name'] as String,
      description: json['description'] as String?,
      partNames: (json['partNames'] as List<dynamic>?)
          ?.map((e) => PartName.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$SchemaModelToJson(_SchemaModel instance) =>
    <String, dynamic>{
      'groupId': instance.groupId,
      'img': instance.img,
      'name': instance.name,
      'description': instance.description,
      'partNames': instance.partNames,
    };

```

## lib\features\parts_catalog\models\schemas_response.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/parts_catalog/models/group.dart';
import 'package:part_catalog/features/parts_catalog/models/schema_model.dart';

part 'schemas_response.freezed.dart';
part 'schemas_response.g.dart';

/// {@template schemas_response}
/// Модель данных для ответа со схемами.
/// {@endtemplate}
@freezed
abstract class SchemasResponse with _$SchemasResponse {
  /// {@macro schemas_response}
  factory SchemasResponse({
    /// Группа (может быть null).
    @JsonKey(name: 'group') Group? group,

    /// Список схем.
    @JsonKey(name: 'list') List<SchemaModel>? list,
  }) = _SchemasResponse;

  /// Преобразует JSON в объект [SchemasResponse].
  factory SchemasResponse.fromJson(Map<String, dynamic> json) =>
      _$SchemasResponseFromJson(json);
}

```

## lib\features\parts_catalog\models\schemas_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schemas_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SchemasResponse {
  /// Группа (может быть null).
  @JsonKey(name: 'group')
  Group? get group;

  /// Список схем.
  @JsonKey(name: 'list')
  List<SchemaModel>? get list;

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SchemasResponseCopyWith<SchemasResponse> get copyWith =>
      _$SchemasResponseCopyWithImpl<SchemasResponse>(
          this as SchemasResponse, _$identity);

  /// Serializes this SchemasResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SchemasResponse &&
            (identical(other.group, group) || other.group == group) &&
            const DeepCollectionEquality().equals(other.list, list));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, group, const DeepCollectionEquality().hash(list));

  @override
  String toString() {
    return 'SchemasResponse(group: $group, list: $list)';
  }
}

/// @nodoc
abstract mixin class $SchemasResponseCopyWith<$Res> {
  factory $SchemasResponseCopyWith(
          SchemasResponse value, $Res Function(SchemasResponse) _then) =
      _$SchemasResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'group') Group? group,
      @JsonKey(name: 'list') List<SchemaModel>? list});

  $GroupCopyWith<$Res>? get group;
}

/// @nodoc
class _$SchemasResponseCopyWithImpl<$Res>
    implements $SchemasResponseCopyWith<$Res> {
  _$SchemasResponseCopyWithImpl(this._self, this._then);

  final SchemasResponse _self;
  final $Res Function(SchemasResponse) _then;

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? group = freezed,
    Object? list = freezed,
  }) {
    return _then(_self.copyWith(
      group: freezed == group
          ? _self.group
          : group // ignore: cast_nullable_to_non_nullable
              as Group?,
      list: freezed == list
          ? _self.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<SchemaModel>?,
    ));
  }

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GroupCopyWith<$Res>? get group {
    if (_self.group == null) {
      return null;
    }

    return $GroupCopyWith<$Res>(_self.group!, (value) {
      return _then(_self.copyWith(group: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _SchemasResponse implements SchemasResponse {
  _SchemasResponse(
      {@JsonKey(name: 'group') this.group,
      @JsonKey(name: 'list') final List<SchemaModel>? list})
      : _list = list;
  factory _SchemasResponse.fromJson(Map<String, dynamic> json) =>
      _$SchemasResponseFromJson(json);

  /// Группа (может быть null).
  @override
  @JsonKey(name: 'group')
  final Group? group;

  /// Список схем.
  final List<SchemaModel>? _list;

  /// Список схем.
  @override
  @JsonKey(name: 'list')
  List<SchemaModel>? get list {
    final value = _list;
    if (value == null) return null;
    if (_list is EqualUnmodifiableListView) return _list;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SchemasResponseCopyWith<_SchemasResponse> get copyWith =>
      __$SchemasResponseCopyWithImpl<_SchemasResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SchemasResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SchemasResponse &&
            (identical(other.group, group) || other.group == group) &&
            const DeepCollectionEquality().equals(other._list, _list));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, group, const DeepCollectionEquality().hash(_list));

  @override
  String toString() {
    return 'SchemasResponse(group: $group, list: $list)';
  }
}

/// @nodoc
abstract mixin class _$SchemasResponseCopyWith<$Res>
    implements $SchemasResponseCopyWith<$Res> {
  factory _$SchemasResponseCopyWith(
          _SchemasResponse value, $Res Function(_SchemasResponse) _then) =
      __$SchemasResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'group') Group? group,
      @JsonKey(name: 'list') List<SchemaModel>? list});

  @override
  $GroupCopyWith<$Res>? get group;
}

/// @nodoc
class __$SchemasResponseCopyWithImpl<$Res>
    implements _$SchemasResponseCopyWith<$Res> {
  __$SchemasResponseCopyWithImpl(this._self, this._then);

  final _SchemasResponse _self;
  final $Res Function(_SchemasResponse) _then;

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? group = freezed,
    Object? list = freezed,
  }) {
    return _then(_SchemasResponse(
      group: freezed == group
          ? _self.group
          : group // ignore: cast_nullable_to_non_nullable
              as Group?,
      list: freezed == list
          ? _self._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<SchemaModel>?,
    ));
  }

  /// Create a copy of SchemasResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GroupCopyWith<$Res>? get group {
    if (_self.group == null) {
      return null;
    }

    return $GroupCopyWith<$Res>(_self.group!, (value) {
      return _then(_self.copyWith(group: value));
    });
  }
}

// dart format on

```

## lib\features\parts_catalog\models\schemas_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schemas_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_SchemasResponse _$SchemasResponseFromJson(Map<String, dynamic> json) =>
    _SchemasResponse(
      group: json['group'] == null
          ? null
          : Group.fromJson(json['group'] as Map<String, dynamic>),
      list: (json['list'] as List<dynamic>?)
          ?.map((e) => SchemaModel.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$SchemasResponseToJson(_SchemasResponse instance) =>
    <String, dynamic>{
      'group': instance.group,
      'list': instance.list,
    };

```

## lib\features\parts_catalog\models\suggest.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'suggest.freezed.dart';
part 'suggest.g.dart';

/// {@template suggest}
/// Модель данных для подсказки.
/// {@endtemplate}
@freezed
abstract class Suggest with _$Suggest {
  /// {@macro suggest}
  factory Suggest({
    /// Идентификатор поиска.
    @JsonKey(name: 'sid') String? sid,

    /// Название.
    @JsonKey(name: 'name') String? name,
  }) = _Suggest;

  /// Преобразует JSON в объект [Suggest].
  factory Suggest.fromJson(Map<String, dynamic> json) =>
      _$SuggestFromJson(json);
}

```

## lib\features\parts_catalog\models\suggest.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'suggest.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$Suggest {
  /// Идентификатор поиска.
  @JsonKey(name: 'sid')
  String? get sid;

  /// Название.
  @JsonKey(name: 'name')
  String? get name;

  /// Create a copy of Suggest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SuggestCopyWith<Suggest> get copyWith =>
      _$SuggestCopyWithImpl<Suggest>(this as Suggest, _$identity);

  /// Serializes this Suggest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Suggest &&
            (identical(other.sid, sid) || other.sid == sid) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, sid, name);

  @override
  String toString() {
    return 'Suggest(sid: $sid, name: $name)';
  }
}

/// @nodoc
abstract mixin class $SuggestCopyWith<$Res> {
  factory $SuggestCopyWith(Suggest value, $Res Function(Suggest) _then) =
      _$SuggestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'sid') String? sid, @JsonKey(name: 'name') String? name});
}

/// @nodoc
class _$SuggestCopyWithImpl<$Res> implements $SuggestCopyWith<$Res> {
  _$SuggestCopyWithImpl(this._self, this._then);

  final Suggest _self;
  final $Res Function(Suggest) _then;

  /// Create a copy of Suggest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sid = freezed,
    Object? name = freezed,
  }) {
    return _then(_self.copyWith(
      sid: freezed == sid
          ? _self.sid
          : sid // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _Suggest implements Suggest {
  _Suggest({@JsonKey(name: 'sid') this.sid, @JsonKey(name: 'name') this.name});
  factory _Suggest.fromJson(Map<String, dynamic> json) =>
      _$SuggestFromJson(json);

  /// Идентификатор поиска.
  @override
  @JsonKey(name: 'sid')
  final String? sid;

  /// Название.
  @override
  @JsonKey(name: 'name')
  final String? name;

  /// Create a copy of Suggest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SuggestCopyWith<_Suggest> get copyWith =>
      __$SuggestCopyWithImpl<_Suggest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SuggestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Suggest &&
            (identical(other.sid, sid) || other.sid == sid) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, sid, name);

  @override
  String toString() {
    return 'Suggest(sid: $sid, name: $name)';
  }
}

/// @nodoc
abstract mixin class _$SuggestCopyWith<$Res> implements $SuggestCopyWith<$Res> {
  factory _$SuggestCopyWith(_Suggest value, $Res Function(_Suggest) _then) =
      __$SuggestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'sid') String? sid, @JsonKey(name: 'name') String? name});
}

/// @nodoc
class __$SuggestCopyWithImpl<$Res> implements _$SuggestCopyWith<$Res> {
  __$SuggestCopyWithImpl(this._self, this._then);

  final _Suggest _self;
  final $Res Function(_Suggest) _then;

  /// Create a copy of Suggest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? sid = freezed,
    Object? name = freezed,
  }) {
    return _then(_Suggest(
      sid: freezed == sid
          ? _self.sid
          : sid // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\parts_catalog\models\suggest.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'suggest.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_Suggest _$SuggestFromJson(Map<String, dynamic> json) => _Suggest(
      sid: json['sid'] as String?,
      name: json['name'] as String?,
    );

Map<String, dynamic> _$SuggestToJson(_Suggest instance) => <String, dynamic>{
      'sid': instance.sid,
      'name': instance.name,
    };

```

## lib\features\parts_catalog\widgets\car_info_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:part_catalog/features/parts_catalog/api/api_client_parts_catalogs.dart'; // Import ApiClientPartsCatalogs
import 'package:part_catalog/features/parts_catalog/models/car_info.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import 'package:get_it/get_it.dart'; // Import get_it

/// {@template car_info_widget}
/// Виджет для отображения информации об автомобиле по VIN или FRAME.
/// {@endtemplate}
class CarInfoWidget extends StatefulWidget {
  /// {@macro car_info_widget}
  const CarInfoWidget({super.key, required this.vinOrFrame});

  /// VIN или FRAME автомобиля.
  final String vinOrFrame;

  @override
  State<CarInfoWidget> createState() => _CarInfoWidgetState();
}

class _CarInfoWidgetState extends State<CarInfoWidget> {
  //late ApiClientPartsCatalogs apiClient; // No need to declare here
  List<CarInfo> carInfos = [];
  String apiKey = dotenv.env['API_KEY'] ?? 'YOUR_API_KEY';
  final String language = 'en';
  final logger = Logger();
  late Future<List<CarInfo>> _carInfoFuture;

  @override
  void initState() {
    super.initState();
    _carInfoFuture = fetchCarInfo();
  }

  /// Получает информацию об автомобиле из API.
  Future<List<CarInfo>> fetchCarInfo() async {
    try {
      final apiClient = GetIt.instance<
          ApiClientPartsCatalogs>(); // Get ApiClientPartsCatalogs from get_it
      return await apiClient.getCarInfo(
          widget.vinOrFrame, null, apiKey, language);
    } catch (e) {
      logger.e('Error fetching car info: $e');
      return Future.error(e); // Пробрасываем ошибку для FutureBuilder
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<CarInfo>>(
      future: _carInfoFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        } else if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        } else if (snapshot.hasData) {
          carInfos = snapshot.data!;
          if (carInfos.isEmpty) {
            return const Center(child: Text('No car info found.'));
          }
          return ListView.builder(
            itemCount: carInfos.length,
            itemBuilder: (context, index) {
              final carInfo = carInfos[index];
              return CarInfoCard(
                  carInfo:
                      carInfo); // Используем отдельный виджет для отображения информации об автомобиле
            },
          );
        } else {
          return const Center(child: Text('No car info available.'));
        }
      },
    );
  }
}

/// {@template car_info_card}
/// Виджет для отображения карточки с информацией об автомобиле.
/// {@endtemplate}
class CarInfoCard extends StatelessWidget {
  /// {@macro car_info_card}
  const CarInfoCard({super.key, required this.carInfo});

  /// Информация об автомобиле.
  final CarInfo carInfo;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Title: ${carInfo.title ?? 'N/A'}'),
            Text('Catalog ID: ${carInfo.catalogId ?? 'N/A'}'),
            Text('Brand: ${carInfo.brand ?? 'N/A'}'),
            Text('Model ID: ${carInfo.modelId ?? 'N/A'}'),
            Text('Car ID: ${carInfo.carId ?? 'N/A'}'),
            Text('VIN: ${carInfo.vin ?? 'N/A'}'),
            Text('Frame: ${carInfo.frame ?? 'N/A'}'),
          ],
        ),
      ),
    );
  }
}

```

## lib\features\parts_catalog\widgets\schema_list_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:part_catalog/features/parts_catalog/api/api_client_parts_catalogs.dart'; // Import ApiClientPartsCatalogs
import 'package:part_catalog/features/parts_catalog/models/schemas_response.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import 'package:get_it/get_it.dart'; // Import get_it

/// {@template schema_list_widget}
/// Виджет для отображения списка схем.
/// {@endtemplate}
class SchemaListWidget extends StatefulWidget {
  /// {@macro schema_list_widget}
  const SchemaListWidget({
    super.key,
    required this.catalogId,
    required this.carId,
  });

  /// Идентификатор каталога.
  final String catalogId;

  /// Идентификатор автомобиля.
  final String carId;

  @override
  State<SchemaListWidget> createState() => _SchemaListWidgetState();
}

class _SchemaListWidgetState extends State<SchemaListWidget> {
  //late ApiClientPartsCatalogs apiClient; // Больше не нужно объявлять здесь
  SchemasResponse? schemasResponse;
  String apiKey = dotenv.env['API_KEY'] ?? 'YOUR_API_KEY';
  final String language = 'en';
  final logger = Logger();
  late Future<SchemasResponse?> _schemasFuture; // Future for schemas

  @override
  void initState() {
    super.initState();
    _schemasFuture = fetchSchemas(); // Initialize the future
  }

  /// Получает схемы из API.
  Future<SchemasResponse?> fetchSchemas() async {
    try {
      final apiClient = GetIt.instance<
          ApiClientPartsCatalogs>(); // Get ApiClientPartsCatalogs from get_it
      return await apiClient.getSchemas(
        widget.catalogId,
        widget.carId,
        null,
        null,
        null,
        null,
        null,
        apiKey,
        language,
      );
    } catch (e) {
      logger.e('Error fetching schemas: $e');
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<SchemasResponse?>(
      future: _schemasFuture, // Use the initialized future
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        } else if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        } else if (snapshot.hasData) {
          final schemas = snapshot.data?.list;
          if (schemas == null || schemas.isEmpty) {
            return const Center(child: Text('No schemas available.'));
          }
          return ListView.builder(
            itemCount: schemas.length,
            itemBuilder: (context, index) {
              final schema = schemas[index];
              return ListTile(
                title: Text(schema.name),
                subtitle: Text(schema.description ?? ''),
              );
            },
          );
        } else {
          return const Center(child: Text('No schemas available.'));
        }
      },
    );
  }
}

```

## lib\features\references\clients\models\client_model_composite.dart
```dart
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/references/clients/models/client_specific_data.dart';
import 'package:part_catalog/features/references/clients/models/client_type.dart';
import 'package:part_catalog/features/core/i_reference_entity.dart'; // Используем IReferenceEntity
// import 'package:part_catalog/features/core/i_item_entity.dart'; // Больше не нужен базовый
import 'package:part_catalog/features/core/i_reference_item_entity.dart'; // Используем специфичный
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:uuid/uuid.dart';
import 'package:collection/collection.dart'; // Для unmodifiable map/list

/// {@template client_model_composite}
/// Бизнес-модель (композитор) для представления клиента.
/// Реализует интерфейс [IReferenceEntity] и композирует модели данных
/// [EntityCoreData] и [ClientSpecificData].
/// {@endtemplate}
class ClientModelComposite implements IReferenceEntity {
  /// Базовые данные сущности.
  final EntityCoreData coreData;

  /// Специфичные данные клиента.
  final ClientSpecificData clientData;

  // --- Поля из IReferenceEntity ---

  @override
  final String? parentId; // Клиенты обычно не имеют родителя

  @override
  final bool isFolder; // Клиенты не являются папками

  @override
  final List<String> ancestorIds; // У клиентов нет предков в иерархии

  @override
  final Map<BaseItemType, List<IReferenceItemEntity>> // Обновлен тип
      itemsMap; // Клиенты обычно не имеют элементов

  /// Приватный конструктор для использования в фабричных методах и `with...`.
  const ClientModelComposite._(
    this.coreData,
    this.clientData, {
    this.parentId, // Инициализация полей IReferenceEntity
    this.isFolder = false,
    List<String>? ancestorIds,
    Map<BaseItemType, List<IReferenceItemEntity>>? itemsMap, // Обновлен тип
  })  : ancestorIds = ancestorIds ?? const [],
        itemsMap = itemsMap ?? const {};

  /// Фабричный конструктор для создания нового экземпляра клиента.
  factory ClientModelComposite.create({
    required String code,
    required String
        name, // Имя/название теперь часть EntityCoreData.displayName
    required ClientType type,
    required String contactInfo,
    String? additionalInfo,
    String? parentId, // Можно передать, если нужна иерархия
  }) {
    final now = DateTime.now();
    final core = EntityCoreData(
      uuid: const Uuid().v4(),
      code: code,
      displayName: name, // Используем displayName
      createdAt: now,
      modifiedAt: now,
      isDeleted: false,
      deletedAt: null, // Явно указываем null при создании
    );
    final specific = ClientSpecificData(
      type: type,
      contactInfo: contactInfo,
      additionalInfo: additionalInfo,
    );
    // Для клиентов parentId, isFolder, ancestorIds, itemsMap обычно имеют значения по умолчанию
    return ClientModelComposite._(
      core,
      specific,
      parentId: parentId,
      isFolder: false,
      ancestorIds: const [], // Или вычислить, если parentId задан
      itemsMap: const {}, // Тип Map<BaseItemType, List<IReferenceItemEntity>>
    );
  }

  /// Фабричный конструктор для создания экземпляра из моделей данных.
  /// Используется сервисом при маппинге данных из DAO.
  factory ClientModelComposite.fromData(
    EntityCoreData coreData,
    ClientSpecificData clientData, {
    String? parentId, // Получаем из DAO, если есть
    bool isFolder = false, // Получаем из DAO, если есть
    List<String>? ancestorIds, // Получаем из DAO, если есть
    Map<BaseItemType, List<IReferenceItemEntity>>? // Обновлен тип
        itemsMap, // Получаем из DAO, если есть
  }) {
    // Убедимся, что карта и списки неизменяемы, если они переданы
    final unmodifiableItemsMap = itemsMap == null
        ? const <BaseItemType, List<IReferenceItemEntity>>{}
        : Map<BaseItemType, List<IReferenceItemEntity>>.unmodifiable(
            itemsMap.map(
              (key, value) =>
                  MapEntry(key, List<IReferenceItemEntity>.unmodifiable(value)),
            ),
          );

    return ClientModelComposite._(
      coreData,
      clientData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: unmodifiableItemsMap, // Используем неизменяемую карту
    );
  }

  // --- Реализация интерфейса IEntity ---

  @override
  String get uuid => coreData.uuid;

  @override
  String get code => coreData.code;

  @override
  String get displayName => coreData.displayName; // Используем displayName

  @override
  DateTime get createdAt => coreData.createdAt;

  @override
  DateTime? get modifiedAt => coreData.modifiedAt;

  @override
  bool get isDeleted => coreData.isDeleted;

  @override
  DateTime? get deletedAt => coreData.deletedAt; // Реализация getter deletedAt

  @override
  bool containsSearchText(String query) {
    if (query.isEmpty) return true;
    final lowerQuery = query.toLowerCase();

    // Проверяем основные поля
    if (coreData.displayName.toLowerCase().contains(lowerQuery)) return true;
    if (coreData.code.toLowerCase().contains(lowerQuery)) return true;
    if (clientData.contactInfo.toLowerCase().contains(lowerQuery)) return true;
    if (clientData.additionalInfo?.toLowerCase().contains(lowerQuery) ??
        false) {
      return true;
    }

    // Поиск по элементам (если они есть)
    for (final item in items) {
      // Предполагаем, что у IReferenceItemEntity есть метод containsSearchText
      // или доступ к coreData
      if (item.containsSearchText(lowerQuery)) return true;
    }

    return false;
  }

  // --- Геттеры для специфичных данных клиента ---

  /// Тип клиента.
  ClientType get type => clientData.type;

  /// Контактная информация.
  String get contactInfo => clientData.contactInfo;

  /// Дополнительная информация.
  String? get additionalInfo => clientData.additionalInfo;

  // --- Реализация интерфейса IReferenceEntity (дополнительные методы) ---

  @override
  List<IReferenceItemEntity> get items => // Обновлен тип
      itemsMap.values.expand((list) => list).toList();

  @override
  List<IReferenceItemEntity> getItemsByType(BaseItemType type) {
    // Обновлен тип
    return List.unmodifiable(itemsMap[type] ?? const []);
  }

  @override
  List<IReferenceItemEntity> searchItems(String query) {
    // Обновлен тип
    if (query.isEmpty) return items;
    final lowerQuery = query.toLowerCase();
    // Предполагаем, что у IReferenceItemEntity есть coreData или containsSearchText
    return items.where((item) => item.containsSearchText(lowerQuery)).toList();
  }

  // --- Методы для иммутабельного обновления ---

  /// Возвращает новый экземпляр с обновленными базовыми данными.
  /// Принимает функцию, которая получает текущий coreData и возвращает новый.
  ClientModelComposite copyWithCoreData(
      EntityCoreData Function(EntityCoreData core) update) {
    final newCoreData = update(coreData);
    // Убедимся, что дата модификации обновлена, если не обновлена вручную
    final finalCoreData = newCoreData.modifiedAt == coreData.modifiedAt
        ? newCoreData.copyWith(modifiedAt: DateTime.now())
        : newCoreData;
    return ClientModelComposite._(
      finalCoreData,
      clientData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленными специфичными данными клиента.
  /// Принимает функцию, которая получает текущий clientData и возвращает новый.
  ClientModelComposite copyWithClientData(
      ClientSpecificData Function(ClientSpecificData client) update) {
    return ClientModelComposite._(
      coreData.copyWith(
          modifiedAt: DateTime.now()), // Обновляем дату модификации
      update(clientData),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным типом.
  ClientModelComposite withType(ClientType newType) {
    return copyWithClientData((client) => client.copyWith(type: newType));
  }

  /// Возвращает новый экземпляр с обновленным именем/названием.
  ClientModelComposite withName(String newName) {
    return copyWithCoreData((core) => core.copyWith(displayName: newName));
  }

  /// Возвращает новый экземпляр с обновленной контактной информацией.
  ClientModelComposite withContactInfo(String newContactInfo) {
    return copyWithClientData(
        (client) => client.copyWith(contactInfo: newContactInfo));
  }

  /// Возвращает новый экземпляр с обновленной дополнительной информацией.
  ClientModelComposite withAdditionalInfo(String? newAdditionalInfo) {
    return copyWithClientData(
        (client) => client.copyWith(additionalInfo: newAdditionalInfo));
  }

  /// Возвращает новый экземпляр, помеченный как удаленный.
  ClientModelComposite markAsDeleted() {
    if (isDeleted) return this;
    final now = DateTime.now();
    return copyWithCoreData((core) => core.copyWith(
          isDeleted: true,
          modifiedAt: now,
          deletedAt: now, // Устанавливаем deletedAt
        ));
  }

  /// Возвращает новый экземпляр, восстановленный из удаленных.
  ClientModelComposite restore() {
    if (!isDeleted) return this;
    return copyWithCoreData((core) => core.copyWith(
          isDeleted: false,
          modifiedAt: DateTime.now(),
          deletedAt: null, // Сбрасываем deletedAt
        ));
  }

  /// Возвращает новый экземпляр с обновленной датой модификации.
  /// Используется перед сохранением.
  ClientModelComposite withModifiedDate(DateTime modifiedDate) {
    return copyWithCoreData((core) => core.copyWith(modifiedAt: modifiedDate));
  }

  // --- Методы для иммутабельного обновления из IReferenceEntity ---

  @override
  ClientModelComposite withParentId(String? newParentId) {
    // Здесь можно добавить логику обновления ancestorIds, если необходимо
    return ClientModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      clientData,
      parentId: newParentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds, // Потребуется пересчет, если parentId изменился
      itemsMap: itemsMap,
    );
  }

  // Методы для работы с itemsMap. Для клиентов они могут быть не нужны
  // или выбрасывать исключение, если клиенты не должны иметь элементов.
  @override
  ClientModelComposite withAddedItem(IReferenceItemEntity item, // Обновлен тип
      {BaseItemType? itemType}) {
    // Пример реализации, если клиенты могут иметь элементы
    final type = itemType ?? item.itemType;
    final updatedItems = Map<BaseItemType, List<IReferenceItemEntity>>.from(
        itemsMap); // Обновлен тип
    final list = updatedItems.putIfAbsent(type, () => []);
    // Проверка на дубликат по UUID
    if (list.any((existing) => existing.uuid == item.uuid)) {
      return this; // Или обновить существующий? Зависит от логики.
    }
    updatedItems[type] = List.unmodifiable([...list, item]);

    return ClientModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      clientData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: Map.unmodifiable(updatedItems),
    );
    // Или: throw UnsupportedError('Клиенты не могут содержать элементы');
  }

  @override
  ClientModelComposite withUpdatedItem(
      IReferenceItemEntity item, // Обновлен тип
      {BaseItemType? itemType}) {
    final type = itemType ?? item.itemType;
    if (!itemsMap.containsKey(type)) return this;

    final updatedItems = Map<BaseItemType, List<IReferenceItemEntity>>.from(
        itemsMap); // Обновлен тип
    final list = updatedItems[type]!;
    final index = list.indexWhere((existing) => existing.uuid == item.uuid);

    if (index == -1) return this; // Элемент не найден

    final newList = List<IReferenceItemEntity>.from(list); // Обновлен тип
    newList[index] = item;
    updatedItems[type] = List.unmodifiable(newList);

    return ClientModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      clientData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: Map.unmodifiable(updatedItems),
    );
    // Или: throw UnsupportedError('Клиенты не могут содержать элементы');
  }

  @override
  ClientModelComposite withRemovedItem(String itemId,
      {BaseItemType? itemType}) {
    BaseItemType? typeToRemoveFrom = itemType;

    // Если тип не указан, ищем элемент во всех типах
    if (typeToRemoveFrom == null) {
      for (final entry in itemsMap.entries) {
        if (entry.value.any((item) => item.uuid == itemId)) {
          typeToRemoveFrom = entry.key;
          break;
        }
      }
    }

    if (typeToRemoveFrom == null || !itemsMap.containsKey(typeToRemoveFrom)) {
      return this; // Тип не найден или элемент не найден в этом типе
    }

    final updatedItems = Map<BaseItemType, List<IReferenceItemEntity>>.from(
        itemsMap); // Обновлен тип
    final list = updatedItems[typeToRemoveFrom]!;
    final newList = list.where((item) => item.uuid != itemId).toList();

    if (newList.length == list.length) return this; // Элемент не найден

    if (newList.isEmpty) {
      updatedItems.remove(typeToRemoveFrom); // Удаляем ключ, если список пуст
    } else {
      updatedItems[typeToRemoveFrom] = List.unmodifiable(newList);
    }

    return ClientModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      clientData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: Map.unmodifiable(updatedItems),
    );
    // Или: throw UnsupportedError('Клиенты не могут содержать элементы');
  }

  // --- Сериализация/Десериализация (Ручная) ---

  /// Преобразование объекта в JSON.
  /// Объединяет JSON из `coreData` и `clientData`.
  /// Поля IReferenceEntity (parentId, isFolder, ancestorIds, itemsMap) пока не сериализуются.
  Map<String, dynamic> toJson() {
    // Сериализация itemsMap потребует знания конкретных типов IReferenceItemEntity
    // и их методов toJson(). Пока оставляем заглушку.
    // final Map<String, List<Map<String, dynamic>>> serializedItemsMap = {};
    // itemsMap.forEach((key, value) {
    //   serializedItemsMap[key.name] = value.map((item) => item.toJson()).toList();
    // });

    return {
      ...coreData.toJson(),
      ...clientData.toJson(),
      // Добавить сериализацию полей IReferenceEntity, если нужно
      // 'parentId': parentId,
      // 'isFolder': isFolder,
      // 'ancestorIds': ancestorIds,
      // 'itemsMap': serializedItemsMap,
    };
  }

  /// Создание объекта из JSON.
  /// Разделяет JSON и создает `coreData` и `clientData`.
  /// Поля IReferenceEntity пока не десериализуются.
  factory ClientModelComposite.fromJson(Map<String, dynamic> json) {
    final core = EntityCoreData.fromJson(json);
    final specific = ClientSpecificData.fromJson(json);

    // Десериализация itemsMap потребует знания конкретных типов IReferenceItemEntity
    // и их конструкторов fromJson(). Пока оставляем заглушку.
    // final Map<BaseItemType, List<IReferenceItemEntity>> deserializedItemsMap = {};
    // final Map<String, dynamic>? rawItemsMap = json['itemsMap'] as Map<String, dynamic>?;
    // if (rawItemsMap != null) { ... }

    return ClientModelComposite._(
      core,
      specific,
      // parentId: json['parentId'] as String?,
      // isFolder: json['isFolder'] as bool? ?? false,
      // ancestorIds: (json['ancestorIds'] as List?)?.cast<String>(),
      // itemsMap: deserializedItemsMap,
    );
  }

  // --- Переопределение стандартных методов ---

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientModelComposite &&
          runtimeType == other.runtimeType &&
          coreData == other.coreData && // Сравнение по данным
          clientData == other.clientData &&
          parentId == other.parentId && // Сравнение по полям IReferenceEntity
          isFolder == other.isFolder &&
          const ListEquality().equals(ancestorIds, other.ancestorIds) &&
          const MapEquality<BaseItemType,
                  List<IReferenceItemEntity>>() // Уточнен тип
              .equals(itemsMap, other.itemsMap);

  @override
  int get hashCode =>
      coreData.hashCode ^
      clientData.hashCode ^
      parentId.hashCode ^
      isFolder.hashCode ^
      const ListEquality().hash(ancestorIds) ^
      const MapEquality<BaseItemType,
              List<IReferenceItemEntity>>() // Уточнен тип
          .hash(itemsMap);

  @override
  String toString() {
    return 'ClientModelComposite(uuid: $uuid, name: $displayName, type: ${type.name})';
  }
}

```

## lib\features\references\clients\models\client_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/references/clients/models/client_type.dart';

part 'client_specific_data.freezed.dart';
part 'client_specific_data.g.dart';

/// {@template client_specific_data}
/// Специфичные данные для сущности "Клиент".
/// Содержит поля, уникальные для клиентов.
/// {@endtemplate}
@freezed
abstract class ClientSpecificData with _$ClientSpecificData {
  /// {@macro client_specific_data}
  const factory ClientSpecificData({
    /// Тип клиента (physical, legal, individualEntrepreneur, other).
    @JsonKey(name: 'type') required ClientType type,

    /// Контактная информация (телефон, email, адрес).
    /// Может быть строкой или отдельной моделью Value Object.
    @JsonKey(name: 'contactInfo') required String contactInfo,

    /// Дополнительная информация.
    @JsonKey(name: 'additionalInfo') String? additionalInfo,

    // Другие специфичные поля для клиента, если нужны
    // Например:
    // String? inn;
    // String? kpp;
    // String? legalAddress;
    // String? actualAddress;
  }) = _ClientSpecificData;

  /// Преобразование JSON в объект `ClientSpecificData`.
  factory ClientSpecificData.fromJson(Map<String, dynamic> json) =>
      _$ClientSpecificDataFromJson(json);
}

```

## lib\features\references\clients\models\client_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'client_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ClientSpecificData {
  /// Тип клиента (physical, legal, individualEntrepreneur, other).
  @JsonKey(name: 'type')
  ClientType get type;

  /// Контактная информация (телефон, email, адрес).
  /// Может быть строкой или отдельной моделью Value Object.
  @JsonKey(name: 'contactInfo')
  String get contactInfo;

  /// Дополнительная информация.
  @JsonKey(name: 'additionalInfo')
  String? get additionalInfo;

  /// Create a copy of ClientSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ClientSpecificDataCopyWith<ClientSpecificData> get copyWith =>
      _$ClientSpecificDataCopyWithImpl<ClientSpecificData>(
          this as ClientSpecificData, _$identity);

  /// Serializes this ClientSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ClientSpecificData &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.contactInfo, contactInfo) ||
                other.contactInfo == contactInfo) &&
            (identical(other.additionalInfo, additionalInfo) ||
                other.additionalInfo == additionalInfo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, contactInfo, additionalInfo);

  @override
  String toString() {
    return 'ClientSpecificData(type: $type, contactInfo: $contactInfo, additionalInfo: $additionalInfo)';
  }
}

/// @nodoc
abstract mixin class $ClientSpecificDataCopyWith<$Res> {
  factory $ClientSpecificDataCopyWith(
          ClientSpecificData value, $Res Function(ClientSpecificData) _then) =
      _$ClientSpecificDataCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'type') ClientType type,
      @JsonKey(name: 'contactInfo') String contactInfo,
      @JsonKey(name: 'additionalInfo') String? additionalInfo});
}

/// @nodoc
class _$ClientSpecificDataCopyWithImpl<$Res>
    implements $ClientSpecificDataCopyWith<$Res> {
  _$ClientSpecificDataCopyWithImpl(this._self, this._then);

  final ClientSpecificData _self;
  final $Res Function(ClientSpecificData) _then;

  /// Create a copy of ClientSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? contactInfo = null,
    Object? additionalInfo = freezed,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ClientType,
      contactInfo: null == contactInfo
          ? _self.contactInfo
          : contactInfo // ignore: cast_nullable_to_non_nullable
              as String,
      additionalInfo: freezed == additionalInfo
          ? _self.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _ClientSpecificData implements ClientSpecificData {
  const _ClientSpecificData(
      {@JsonKey(name: 'type') required this.type,
      @JsonKey(name: 'contactInfo') required this.contactInfo,
      @JsonKey(name: 'additionalInfo') this.additionalInfo});
  factory _ClientSpecificData.fromJson(Map<String, dynamic> json) =>
      _$ClientSpecificDataFromJson(json);

  /// Тип клиента (physical, legal, individualEntrepreneur, other).
  @override
  @JsonKey(name: 'type')
  final ClientType type;

  /// Контактная информация (телефон, email, адрес).
  /// Может быть строкой или отдельной моделью Value Object.
  @override
  @JsonKey(name: 'contactInfo')
  final String contactInfo;

  /// Дополнительная информация.
  @override
  @JsonKey(name: 'additionalInfo')
  final String? additionalInfo;

  /// Create a copy of ClientSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ClientSpecificDataCopyWith<_ClientSpecificData> get copyWith =>
      __$ClientSpecificDataCopyWithImpl<_ClientSpecificData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ClientSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClientSpecificData &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.contactInfo, contactInfo) ||
                other.contactInfo == contactInfo) &&
            (identical(other.additionalInfo, additionalInfo) ||
                other.additionalInfo == additionalInfo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, contactInfo, additionalInfo);

  @override
  String toString() {
    return 'ClientSpecificData(type: $type, contactInfo: $contactInfo, additionalInfo: $additionalInfo)';
  }
}

/// @nodoc
abstract mixin class _$ClientSpecificDataCopyWith<$Res>
    implements $ClientSpecificDataCopyWith<$Res> {
  factory _$ClientSpecificDataCopyWith(
          _ClientSpecificData value, $Res Function(_ClientSpecificData) _then) =
      __$ClientSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'type') ClientType type,
      @JsonKey(name: 'contactInfo') String contactInfo,
      @JsonKey(name: 'additionalInfo') String? additionalInfo});
}

/// @nodoc
class __$ClientSpecificDataCopyWithImpl<$Res>
    implements _$ClientSpecificDataCopyWith<$Res> {
  __$ClientSpecificDataCopyWithImpl(this._self, this._then);

  final _ClientSpecificData _self;
  final $Res Function(_ClientSpecificData) _then;

  /// Create a copy of ClientSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? contactInfo = null,
    Object? additionalInfo = freezed,
  }) {
    return _then(_ClientSpecificData(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ClientType,
      contactInfo: null == contactInfo
          ? _self.contactInfo
          : contactInfo // ignore: cast_nullable_to_non_nullable
              as String,
      additionalInfo: freezed == additionalInfo
          ? _self.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\references\clients\models\client_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'client_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ClientSpecificData _$ClientSpecificDataFromJson(Map<String, dynamic> json) =>
    _ClientSpecificData(
      type: $enumDecode(_$ClientTypeEnumMap, json['type']),
      contactInfo: json['contactInfo'] as String,
      additionalInfo: json['additionalInfo'] as String?,
    );

Map<String, dynamic> _$ClientSpecificDataToJson(_ClientSpecificData instance) =>
    <String, dynamic>{
      'type': _$ClientTypeEnumMap[instance.type]!,
      'contactInfo': instance.contactInfo,
      'additionalInfo': instance.additionalInfo,
    };

const _$ClientTypeEnumMap = {
  ClientType.physical: 'physical',
  ClientType.legal: 'legal',
  ClientType.individualEntrepreneur: 'individualEntrepreneur',
  ClientType.other: 'other',
};

```

## lib\features\references\clients\models\client_type.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart'; // Добавить импорт

/// {@template client_type}
/// Тип клиента.
/// {@endtemplate}
enum ClientType {
  /// {@macro client_type}
  @JsonValue('physical') // Добавить JsonValue
  physical,

  /// {@macro client_type}
  @JsonValue('legal') // Добавить JsonValue
  legal,

  /// {@macro client_type}
  @JsonValue('individualEntrepreneur') // Добавить JsonValue
  individualEntrepreneur,

  /// {@macro client_type}
  @JsonValue('other') // Добавить JsonValue
  other,
}

/// {@template client_type_extension}
/// Расширение для перечисления ClientType.
/// {@endtemplate}
extension ClientTypeExtension on ClientType {
  /// {@macro client_type_extension}
  String get displayName {
    switch (this) {
      case ClientType.physical:
        return 'Физическое лицо';
      case ClientType.legal:
        return 'Юридическое лицо';
      case ClientType.individualEntrepreneur:
        return 'Индивидуальный предприниматель';
      case ClientType.other:
        return 'Другое';
    }
  }

  // Метод fromString больше не нужен, т.к. @freezed/json_serializable справятся
  // static ClientType fromString(String value) { ... }
}

// Расширение ParseToString тоже больше не нужно, т.к. @JsonValue используется
// extension ParseToString on ClientType { ... }

```

## lib\features\references\clients\providers\client_providers.dart
```dart
import 'dart:async';

import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/providers/core_providers.dart';
import 'package:part_catalog/core/service_locator.dart'; // Используем для AppDatabase и Logger
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/clients/services/client_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

part 'client_providers.g.dart'; // Сгенерированный файл

// Провайдер для ClientService
// Используем keepAlive, чтобы сервис не пересоздавался без необходимости
@Riverpod(keepAlive: true)
ClientService clientService(Ref ref) {
  // Получаем AppDatabase через существующий locator или через другой Riverpod провайдер
  final db = locator<AppDatabase>();
  return ClientService(db);
}

// AsyncNotifier для управления списком клиентов
@riverpod
class ClientsNotifier extends _$ClientsNotifier {
  // Получаем логгер и сервис для использования в методах
  Logger get _logger => ref.read(clientsLoggerProvider);
  ClientService get _clientService => ref.read(clientServiceProvider);

  @override
  FutureOr<List<ClientModelComposite>> build() async {
    _logger.d('ClientsNotifier: Initial build loading clients...');
    // Начальная загрузка всех активных клиентов
    // Используем watch, чтобы перестроиться, если сам сервис изменится (маловероятно, но возможно)
    return ref.watch(clientServiceProvider).getAllClients();
  }

  /// Добавляет нового клиента
  Future<void> addClient(ClientModelComposite client) async {
    _logger.d('ClientsNotifier: Attempting to add client: ${client.code}');
    try {
      await _clientService.addClient(client);
      ref.invalidateSelf(); // Инвалидируем, чтобы build() перезагрузил список
      _logger.i('ClientsNotifier: Client added successfully: ${client.code}');
    } catch (e, s) {
      _logger.e('ClientsNotifier: Error adding client: ${client.code}',
          error: e, stackTrace: s);
      // Пробрасываем ошибку для обработки в UI (например, для SnackBar)
      rethrow;
    }
  }

  /// Обновляет существующего клиента
  Future<void> updateClient(ClientModelComposite client) async {
    _logger.d('ClientsNotifier: Attempting to update client: ${client.uuid}');
    try {
      await _clientService.updateClient(client);
      ref.invalidateSelf(); // Перезагружаем список
      _logger.i('ClientsNotifier: Client updated successfully: ${client.uuid}');
    } catch (e, s) {
      _logger.e('ClientsNotifier: Error updating client: ${client.uuid}',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Мягко удаляет клиента
  Future<void> deleteClient(String clientUuid) async {
    _logger.d('ClientsNotifier: Attempting to delete client: $clientUuid');
    try {
      await _clientService.deleteClient(clientUuid);
      ref.invalidateSelf(); // Перезагружаем список
      _logger.i('ClientsNotifier: Client deleted successfully: $clientUuid');
    } catch (e, s) {
      _logger.e('ClientsNotifier: Error deleting client: $clientUuid',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Восстанавливает мягко удаленного клиента
  Future<void> restoreClient(String clientUuid) async {
    _logger.d('ClientsNotifier: Attempting to restore client: $clientUuid');
    try {
      await _clientService.restoreClient(clientUuid);
      ref.invalidateSelf(); // Перезагружаем список
      _logger.i('ClientsNotifier: Client restored successfully: $clientUuid');
    } catch (e, s) {
      _logger.e('ClientsNotifier: Error restoring client: $clientUuid',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Выполняет поиск клиентов или загружает всех, если запрос пуст
  Future<void> searchClients(String? query) async {
    _logger.d('ClientsNotifier: Searching clients with query: "$query"');
    // Устанавливаем состояние загрузки перед выполнением запроса
    state = const AsyncValue.loading();
    // Используем AsyncValue.guard для автоматической обработки try/catch
    state = await AsyncValue.guard(() async {
      if (query == null || query.trim().isEmpty) {
        _logger.d('ClientsNotifier: Empty query, loading all clients.');
        // Если запрос пуст, загружаем всех клиентов (как в build)
        return _clientService.getAllClients();
      } else {
        _logger.d('ClientsNotifier: Executing search.');
        // Иначе выполняем поиск
        return _clientService.searchClients(query.trim());
      }
    });
    _logger.d('ClientsNotifier: Search finished. State updated.');
  }
}

// Провайдер для проверки уникальности кода (асинхронный)
// Используем family для передачи параметров
@riverpod
Future<bool> isClientCodeUnique(Ref ref,
    {required String code, String? excludeUuid}) async {
  final logger = ref.read(clientsLoggerProvider);
  logger.d(
      'isClientCodeUniqueProvider: Checking code "$code", excluding "$excludeUuid"');
  final clientService = ref.watch(clientServiceProvider);
  try {
    final isUnique =
        await clientService.isCodeUnique(code, excludeUuid: excludeUuid);
    logger.d('isClientCodeUniqueProvider: Code "$code" is unique: $isUnique');
    return isUnique;
  } catch (e, s) {
    logger.e(
        'isClientCodeUniqueProvider: Error checking code uniqueness for "$code"',
        error: e,
        stackTrace: s);
    // В случае ошибки считаем код не уникальным, чтобы предотвратить сохранение
    return false;
  }
}

// Провайдер для получения одного клиента по UUID (семейство)
// Добавляем сюда
@riverpod
Future<ClientModelComposite?> client(Ref ref, String uuid) async {
  final logger = ref.read(clientsLoggerProvider);
  logger.d('clientProvider: Fetching client with UUID: $uuid');
  try {
    final clientService = ref.watch(clientServiceProvider);
    final client = await clientService.getClientByUuid(uuid);
    if (client == null) {
      logger.w('clientProvider: Client with UUID $uuid not found.');
    }
    return client;
  } catch (e, s) {
    logger.e('clientProvider: Error fetching client $uuid',
        error: e, stackTrace: s);
    // Можно пробросить ошибку или вернуть null/состояние ошибки
    return null; // Или throw e;
  }
}

```

## lib\features\references\clients\providers\client_providers.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'client_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$clientServiceHash() => r'f489375515b8dbd4c64745719ca027a5f5aa3389';

/// See also [clientService].
@ProviderFor(clientService)
final clientServiceProvider = Provider<ClientService>.internal(
  clientService,
  name: r'clientServiceProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$clientServiceHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ClientServiceRef = ProviderRef<ClientService>;
String _$isClientCodeUniqueHash() =>
    r'6745b43e615febaa7a723783b067ff304a05acd0';

/// Copied from Dart SDK
class _SystemHash {
  _SystemHash._();

  static int combine(int hash, int value) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + value);
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
  }

  static int finish(int hash) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    // ignore: parameter_assignments
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
  }
}

/// See also [isClientCodeUnique].
@ProviderFor(isClientCodeUnique)
const isClientCodeUniqueProvider = IsClientCodeUniqueFamily();

/// See also [isClientCodeUnique].
class IsClientCodeUniqueFamily extends Family<AsyncValue<bool>> {
  /// See also [isClientCodeUnique].
  const IsClientCodeUniqueFamily();

  /// See also [isClientCodeUnique].
  IsClientCodeUniqueProvider call({
    required String code,
    String? excludeUuid,
  }) {
    return IsClientCodeUniqueProvider(
      code: code,
      excludeUuid: excludeUuid,
    );
  }

  @override
  IsClientCodeUniqueProvider getProviderOverride(
    covariant IsClientCodeUniqueProvider provider,
  ) {
    return call(
      code: provider.code,
      excludeUuid: provider.excludeUuid,
    );
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'isClientCodeUniqueProvider';
}

/// See also [isClientCodeUnique].
class IsClientCodeUniqueProvider extends AutoDisposeFutureProvider<bool> {
  /// See also [isClientCodeUnique].
  IsClientCodeUniqueProvider({
    required String code,
    String? excludeUuid,
  }) : this._internal(
          (ref) => isClientCodeUnique(
            ref as IsClientCodeUniqueRef,
            code: code,
            excludeUuid: excludeUuid,
          ),
          from: isClientCodeUniqueProvider,
          name: r'isClientCodeUniqueProvider',
          debugGetCreateSourceHash:
              const bool.fromEnvironment('dart.vm.product')
                  ? null
                  : _$isClientCodeUniqueHash,
          dependencies: IsClientCodeUniqueFamily._dependencies,
          allTransitiveDependencies:
              IsClientCodeUniqueFamily._allTransitiveDependencies,
          code: code,
          excludeUuid: excludeUuid,
        );

  IsClientCodeUniqueProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.code,
    required this.excludeUuid,
  }) : super.internal();

  final String code;
  final String? excludeUuid;

  @override
  Override overrideWith(
    FutureOr<bool> Function(IsClientCodeUniqueRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: IsClientCodeUniqueProvider._internal(
        (ref) => create(ref as IsClientCodeUniqueRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        code: code,
        excludeUuid: excludeUuid,
      ),
    );
  }

  @override
  AutoDisposeFutureProviderElement<bool> createElement() {
    return _IsClientCodeUniqueProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is IsClientCodeUniqueProvider &&
        other.code == code &&
        other.excludeUuid == excludeUuid;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, code.hashCode);
    hash = _SystemHash.combine(hash, excludeUuid.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin IsClientCodeUniqueRef on AutoDisposeFutureProviderRef<bool> {
  /// The parameter `code` of this provider.
  String get code;

  /// The parameter `excludeUuid` of this provider.
  String? get excludeUuid;
}

class _IsClientCodeUniqueProviderElement
    extends AutoDisposeFutureProviderElement<bool> with IsClientCodeUniqueRef {
  _IsClientCodeUniqueProviderElement(super.provider);

  @override
  String get code => (origin as IsClientCodeUniqueProvider).code;
  @override
  String? get excludeUuid => (origin as IsClientCodeUniqueProvider).excludeUuid;
}

String _$clientHash() => r'78b74cf864f54b46433f6976bf0fa5512cab6ac0';

/// See also [client].
@ProviderFor(client)
const clientProvider = ClientFamily();

/// See also [client].
class ClientFamily extends Family<AsyncValue<ClientModelComposite?>> {
  /// See also [client].
  const ClientFamily();

  /// See also [client].
  ClientProvider call(
    String uuid,
  ) {
    return ClientProvider(
      uuid,
    );
  }

  @override
  ClientProvider getProviderOverride(
    covariant ClientProvider provider,
  ) {
    return call(
      provider.uuid,
    );
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'clientProvider';
}

/// See also [client].
class ClientProvider extends AutoDisposeFutureProvider<ClientModelComposite?> {
  /// See also [client].
  ClientProvider(
    String uuid,
  ) : this._internal(
          (ref) => client(
            ref as ClientRef,
            uuid,
          ),
          from: clientProvider,
          name: r'clientProvider',
          debugGetCreateSourceHash:
              const bool.fromEnvironment('dart.vm.product')
                  ? null
                  : _$clientHash,
          dependencies: ClientFamily._dependencies,
          allTransitiveDependencies: ClientFamily._allTransitiveDependencies,
          uuid: uuid,
        );

  ClientProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.uuid,
  }) : super.internal();

  final String uuid;

  @override
  Override overrideWith(
    FutureOr<ClientModelComposite?> Function(ClientRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: ClientProvider._internal(
        (ref) => create(ref as ClientRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        uuid: uuid,
      ),
    );
  }

  @override
  AutoDisposeFutureProviderElement<ClientModelComposite?> createElement() {
    return _ClientProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is ClientProvider && other.uuid == uuid;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, uuid.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin ClientRef on AutoDisposeFutureProviderRef<ClientModelComposite?> {
  /// The parameter `uuid` of this provider.
  String get uuid;
}

class _ClientProviderElement
    extends AutoDisposeFutureProviderElement<ClientModelComposite?>
    with ClientRef {
  _ClientProviderElement(super.provider);

  @override
  String get uuid => (origin as ClientProvider).uuid;
}

String _$clientsNotifierHash() => r'9d955a0bb2911b57ec27d231e53369a6d8b250a8';

/// See also [ClientsNotifier].
@ProviderFor(ClientsNotifier)
final clientsNotifierProvider = AutoDisposeAsyncNotifierProvider<
    ClientsNotifier, List<ClientModelComposite>>.internal(
  ClientsNotifier.new,
  name: r'clientsNotifierProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$clientsNotifierHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$ClientsNotifier
    = AutoDisposeAsyncNotifier<List<ClientModelComposite>>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

```

## lib\features\references\clients\screens\clients_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:part_catalog/core/providers/core_providers.dart';
import 'package:part_catalog/core/service_locator.dart';
// Импортируем бизнес-модель (композитор)
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/clients/models/client_type.dart';
// Импортируем провайдеры
import 'package:part_catalog/features/references/clients/providers/client_providers.dart';
import 'package:part_catalog/features/references/clients/services/client_service.dart';
// Импортируем сервисы для обновления в service_locator при сбросе БД
import 'package:part_catalog/features/references/vehicles/services/car_service.dart';
import 'package:logger/logger.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
import 'dart:async'; // Для Timer

// Преобразуем в ConsumerStatefulWidget
class ClientsScreen extends ConsumerStatefulWidget {
  const ClientsScreen({super.key});

  @override
  ConsumerState<ClientsScreen> createState() => _ClientsScreenState();
}

// Преобразуем State в ConsumerState
class _ClientsScreenState extends ConsumerState<ClientsScreen> {
  // Удаляем прямое получение сервиса, будем использовать ref
  // final ClientService _clientService = locator<ClientService>();

  // Объявляем логгер как late final и инициализируем в initState
  late final Logger _logger;

  // Удаляем _isDbError, состояние ошибки будет в AsyncValue
  // bool _isDbError = false;
  final TextEditingController _searchController = TextEditingController();
  // Удаляем BehaviorSubject и подписку
  // final _searchSubject = BehaviorSubject<String?>.seeded(null);
  // StreamSubscription? _searchSubscription;
  Timer? _debounce;

  @override
  void initState() {
    super.initState();
    // Инициализируем логгер здесь, где ref доступен
    _logger = ref.read(clientsLoggerProvider);
    _searchController.addListener(_onSearchChanged);
    // Удаляем подписку на BehaviorSubject
  }

  @override
  void dispose() {
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _debounce?.cancel();
    // Удаляем закрытие BehaviorSubject и отмену подписки
    super.dispose();
  }

  void _onSearchChanged() {
    _debounce?.cancel();
    _debounce = Timer(const Duration(milliseconds: 300), () {
      final query = _searchController.text;
      // Вызываем метод поиска у Notifier'а
      ref.read(clientsNotifierProvider.notifier).searchClients(query);
    });
  }

  // Удаляем _getClientStream, будем использовать ref.watch(clientsNotifierProvider)

  @override
  Widget build(BuildContext context) {
    final t = context.t;
    // Получаем состояние списка клиентов через ref.watch
    final clientsAsyncValue = ref.watch(clientsNotifierProvider);

    // Обработка ошибки БД (если она приводит к ошибке в Notifier)
    // Можно сделать более специфично, проверяя тип ошибки в .when()
    // if (_isDbError) { ... } - Удаляем этот блок

    return Scaffold(
      appBar: AppBar(
        title: Text(t.clients.screenTitle),
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {
              showSearch(
                context: context,
                // Передаем ref в делегат
                delegate: ClientSearchDelegate(ref, _editClient),
              );
            },
          ),
          // Кнопка сброса БД (можно оставить или перенести в настройки)
          IconButton(
            icon: const Icon(Icons.delete_forever, color: Colors.red),
            tooltip: t.core.resetDatabase,
            onPressed: () => _showResetConfirmation(context),
          ),
        ],
      ),
      body: Column(
        children: [
          // Поле поиска
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                labelText: t.clients.search,
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          _searchController.clear();
                          // Вызываем поиск с пустой строкой
                          ref
                              .read(clientsNotifierProvider.notifier)
                              .searchClients(null);
                        },
                      )
                    : null,
                border: const OutlineInputBorder(),
              ),
            ),
          ),

          // Список клиентов
          Expanded(
            // Используем .when для обработки состояний AsyncValue
            child: clientsAsyncValue.when(
              data: (clients) {
                if (clients.isEmpty) {
                  return Center(
                    child: Text(_searchController.text.isEmpty
                        ? t.clients.emptyList
                        : t.clients.noClientsFound),
                  );
                }

                // Используем ListView.separated для разделителей
                return ListView.separated(
                  itemCount: clients.length,
                  separatorBuilder: (context, index) =>
                      const Divider(height: 1),
                  itemBuilder: (context, index) {
                    final client = clients[index];
                    return Dismissible(
                      key: Key(client.uuid), // Используем UUID как ключ
                      background: Container(
                        color: Colors.red,
                        alignment: Alignment.centerRight,
                        padding: const EdgeInsets.only(right: 16.0),
                        child: const Icon(Icons.delete, color: Colors.white),
                      ),
                      direction: DismissDirection.endToStart,
                      confirmDismiss: (direction) =>
                          _confirmDeletion(context, client),
                      onDismissed: (direction) =>
                          _deleteClient(context, client),
                      child: ListTile(
                        leading: CircleAvatar(
                          backgroundColor: _getClientTypeColor(client.type),
                          child: Icon(
                            _getClientTypeIcon(client.type),
                            color: Colors.white,
                          ),
                        ),
                        title: Text(client.displayName),
                        subtitle:
                            Text('${client.code} · ${client.contactInfo}'),
                        trailing: const Icon(Icons.chevron_right),
                        onTap: () => _editClient(client),
                      ),
                    );
                  },
                );
              },
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (error, stackTrace) {
                _logger.e(LogMessages.dataLoadingError,
                    error: error, stackTrace: stackTrace);
                // Проверяем ошибку БД (если она специфична)
                if (error.toString().contains('no such table')) {
                  // Можно показать кнопку сброса прямо здесь
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(t.core.dataLoadingError),
                        const SizedBox(height: 20),
                        ElevatedButton(
                          onPressed: () => _resetDatabase(context),
                          child: Text(t.core.resetDatabase),
                        )
                      ],
                    ),
                  );
                }
                // Показываем общую ошибку загрузки данных
                return Center(
                  child: Text(
                    t.core.errorLoadingData(error: error.toString()),
                    style:
                        TextStyle(color: Theme.of(context).colorScheme.error),
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _addClient,
        tooltip: t.clients.add,
        child: const Icon(Icons.add),
      ),
    );
  }

  // --- Методы для действий ---

  Future<void> _showResetConfirmation(BuildContext context) async {
    final t = context.t;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text(t.core.confirmResetDatabaseTitle),
          content: Text(t.core.confirmResetDatabaseMessage),
          actions: <Widget>[
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(false),
              child: Text(t.common.cancel),
            ),
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(true),
              child: Text(t.core.resetDatabase,
                  style: TextStyle(color: Theme.of(context).colorScheme.error)),
            ),
          ],
        );
      },
    );

    if (confirmed == true) {
      await _resetDatabase(context);
    }
  }

  Future<void> _resetDatabase(BuildContext context) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = context.t;

    try {
      final db = locator<AppDatabase>();
      await db.resetDatabase();

      // Обновляем экземпляры в сервис-локаторе
      locator.unregister<AppDatabase>();
      locator.registerSingleton<AppDatabase>(AppDatabase());

      locator.unregister<ClientService>();
      locator.unregister<CarService>();
      locator.registerLazySingleton<ClientService>(
          () => ClientService(locator<AppDatabase>()));
      locator.registerLazySingleton<CarService>(
          () => CarService(locator<AppDatabase>()));

      // Инвалидируем провайдеры Riverpod
      ref.invalidate(clientServiceProvider);
      ref.invalidate(clientsNotifierProvider);
      // Инвалидируйте другие связанные провайдеры, если они есть

      if (mounted) {
        scaffoldMessenger
            .showSnackBar(SnackBar(content: Text(t.core.resetDatabaseSuccess)));
        // Не нужно делать setState, Riverpod обновит UI
      }
    } catch (e, s) {
      _logger.e(LogMessages.databaseResetError, error: e, stackTrace: s);
      if (mounted) {
        scaffoldMessenger.showSnackBar(SnackBar(
            content: Text(t.core.resetDatabaseError(error: e.toString()))));
      }
    }
  }

  Future<bool?> _confirmDeletion(
      BuildContext context, ClientModelComposite client) async {
    final t = context.t;
    return await showDialog<bool>(
          context: context,
          builder: (BuildContext dialogContext) {
            return AlertDialog(
              title: Text(t.common.confirmDeletion),
              content: Text(t.clients.confirmDelete(name: client.displayName)),
              actions: <Widget>[
                TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(false),
                  child: Text(t.common.cancel),
                ),
                TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(true),
                  child: Text(t.common.delete,
                      style: TextStyle(
                          color: Theme.of(context).colorScheme.error)),
                ),
              ],
            );
          },
        ) ??
        false;
  }

  Future<void> _deleteClient(
      BuildContext context, ClientModelComposite client) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = context.t;
    final clientUuid = client.uuid;
    final displayName = client.displayName; // Сохраняем для Snackbar

    try {
      // Вызываем метод Notifier'а
      await ref.read(clientsNotifierProvider.notifier).deleteClient(clientUuid);

      // Показываем Snackbar об успехе с отменой
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(t.clients.clientDeleted(name: displayName)),
            action: SnackBarAction(
              label: t.common.undo,
              onPressed: () => _restoreClient(
                  context, clientUuid, displayName), // Передаем UUID и имя
            ),
          ),
        );
      }
    } catch (e, s) {
      // Ошибки теперь обрабатываются здесь, т.к. Notifier их пробрасывает
      _logger.e(LogMessages.clientDeleteError.replaceAll('{uuid}', clientUuid),
          error: e, stackTrace: s);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(t.clients.deleteError(error: e.toString()))),
        );
      }
    }
  }

  Future<void> _restoreClient(
      BuildContext context, String clientUuid, String displayName) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = context.t;

    try {
      // Вызываем метод Notifier'а
      await ref
          .read(clientsNotifierProvider.notifier)
          .restoreClient(clientUuid);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(t.clients.clientRestored(name: displayName))),
        );
      }
    } catch (e, s) {
      _logger.e(LogMessages.clientRestoreError.replaceAll('{uuid}', clientUuid),
          error: e, stackTrace: s);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(t.clients.restoreError(error: e.toString()))),
        );
      }
    }
  }

  Future<void> _addClient() async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = context.t;

    // Показываем диалог и ждем результат
    // Передаем ref в диалог
    final newClient = await _showClientDialog(context, ref: ref);
    if (newClient != null) {
      try {
        // Вызываем метод Notifier'а
        await ref.read(clientsNotifierProvider.notifier).addClient(newClient);
        // Сообщение об успехе можно показать здесь
        if (mounted) {
          scaffoldMessenger.showSnackBar(SnackBar(
              content:
                  Text(t.clients.clientAdded(name: newClient.displayName))));
        }
      } catch (e, s) {
        _logger.e(LogMessages.clientAddError, error: e, stackTrace: s);
        if (mounted) {
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text(t.clients.addError(error: e.toString()))),
          );
        }
      }
    }
  }

  Future<void> _editClient(ClientModelComposite client) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = context.t;

    // Показываем диалог с существующим клиентом, передаем ref
    final updatedClient =
        await _showClientDialog(context, client: client, ref: ref);
    if (updatedClient != null) {
      try {
        // Вызываем метод Notifier'а
        await ref
            .read(clientsNotifierProvider.notifier)
            .updateClient(updatedClient);
        // Сообщение об успехе
        if (mounted) {
          scaffoldMessenger.showSnackBar(SnackBar(
              content: Text(
                  t.clients.clientUpdated(name: updatedClient.displayName))));
        }
      } catch (e, s) {
        _logger.e(
            LogMessages.clientUpdateError.replaceAll('{uuid}', client.uuid),
            error: e,
            stackTrace: s);
        if (mounted) {
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text(t.clients.updateError(error: e.toString()))),
          );
        }
      }
    }
  }

  // --- Вспомогательные методы ---

  Color _getClientTypeColor(ClientType type) {
    switch (type) {
      case ClientType.physical:
        return Colors.blue;
      case ClientType.legal:
        return Colors.orange;
      case ClientType.individualEntrepreneur:
        return Colors.green;
      case ClientType.other:
        return Colors.grey;
    }
  }

  IconData _getClientTypeIcon(ClientType type) {
    switch (type) {
      case ClientType.physical:
        return Icons.person;
      case ClientType.legal:
        return Icons.business;
      case ClientType.individualEntrepreneur:
        return Icons.business_center;
      case ClientType.other:
        return Icons.help_outline;
    }
  }

  /// Показывает диалог для добавления/редактирования клиента.
  /// Принимает [WidgetRef] для доступа к провайдерам.
  Future<ClientModelComposite?> _showClientDialog(BuildContext context,
      {ClientModelComposite? client, required WidgetRef ref}) async {
    // Добавляем ref
    final t = context.t;
    final bool isEditing = client != null;

    final nameController = TextEditingController(text: client?.displayName);
    final codeController = TextEditingController(text: client?.code);
    final contactInfoController =
        TextEditingController(text: client?.contactInfo);
    final additionalInfoController =
        TextEditingController(text: client?.additionalInfo);
    ClientType selectedType = client?.type ?? ClientType.physical;

    final formKey = GlobalKey<FormState>();
    // Локальное состояние для асинхронной валидации кода
    bool codeCheckLoading = false;
    bool isCodeUnique = true;

    return showDialog<ClientModelComposite>(
      context: context,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(builder: (context, setStateDialog) {
          // Асинхронная валидация уникальности кода с использованием isClientCodeUniqueProvider
          Future<void> checkCodeUniqueness(String value) async {
            if (value.isNotEmpty && value != client?.code) {
              setStateDialog(() {
                codeCheckLoading = true; // Показываем индикатор
                isCodeUnique = true; // Сбрасываем предыдущую ошибку
              });
              try {
                // Используем ref для доступа к провайдеру
                final unique = await ref.read(isClientCodeUniqueProvider(
                  code: value,
                  excludeUuid: client?.uuid,
                ).future);
                if (mounted) {
                  // Проверяем mounted перед setStateDialog
                  setStateDialog(() {
                    isCodeUnique = unique;
                    codeCheckLoading = false;
                  });
                }
              } catch (e) {
                if (mounted) {
                  setStateDialog(() {
                    isCodeUnique = false; // Считаем не уникальным при ошибке
                    codeCheckLoading = false;
                  });
                }
                // Логируем ошибку проверки
                _logger.e('Error checking code uniqueness', error: e);
              }
            } else {
              if (mounted) {
                setStateDialog(() {
                  isCodeUnique = true;
                  codeCheckLoading = false;
                });
              }
            }
          }

          // Валидация всей формы
          bool validateFullForm() {
            return (formKey.currentState?.validate() ?? false) &&
                isCodeUnique &&
                !codeCheckLoading;
          }

          return AlertDialog(
            title: Text(isEditing ? t.clients.edit : t.clients.add),
            content: Form(
              key: formKey,
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // --- Тип клиента ---
                    DropdownButtonFormField<ClientType>(
                      value: selectedType,
                      decoration: InputDecoration(
                        labelText: t.clients.type,
                        prefixIcon: Icon(_getClientTypeIcon(selectedType),
                            color: _getClientTypeColor(selectedType)),
                        border: const OutlineInputBorder(),
                      ),
                      items: ClientType.values.map((type) {
                        return DropdownMenuItem<ClientType>(
                          value: type,
                          child: Row(
                            children: [
                              Icon(_getClientTypeIcon(type),
                                  color: _getClientTypeColor(type), size: 20),
                              const SizedBox(width: 8),
                              Text(_getClientTypeDisplayName(context, type)),
                            ],
                          ),
                        );
                      }).toList(),
                      onChanged: (ClientType? value) {
                        if (value != null) {
                          setStateDialog(() {
                            selectedType = value;
                          });
                        }
                      },
                      validator: (value) =>
                          value == null ? t.clients.typeRequired : null,
                    ),
                    const SizedBox(height: 16),

                    // --- Код клиента ---
                    TextFormField(
                      controller: codeController,
                      decoration: InputDecoration(
                        labelText: t.clients.code,
                        prefixIcon: const Icon(Icons.qr_code),
                        border: const OutlineInputBorder(),
                        // Показываем индикатор загрузки или ошибку
                        suffixIcon: codeCheckLoading
                            ? const Padding(
                                padding: EdgeInsets.all(10.0),
                                child: SizedBox(
                                    width: 20,
                                    height: 20,
                                    child: CircularProgressIndicator(
                                        strokeWidth: 2.0)),
                              )
                            : (!isCodeUnique
                                ? const Icon(Icons.error, color: Colors.red)
                                : null),
                        errorText:
                            !isCodeUnique ? t.clients.codeNotUnique : null,
                        // Убираем errorMaxLines, т.к. используем suffixIcon для индикации ошибки
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return t.clients.codeRequired;
                        }
                        return null;
                      },
                      onChanged: (value) async {
                        // Добавляем debounce для проверки кода
                        _debounce?.cancel();
                        _debounce =
                            Timer(const Duration(milliseconds: 400), () async {
                          await checkCodeUniqueness(value);
                          // Обновляем состояние кнопки после проверки
                          setStateDialog(() {});
                        });
                        // Обновляем состояние кнопки сразу при изменении
                        setStateDialog(() {});
                      },
                      textInputAction: TextInputAction.next,
                    ),
                    const SizedBox(height: 16),

                    // --- Имя/Наименование ---
                    TextFormField(
                      controller: nameController,
                      decoration: InputDecoration(
                        labelText: selectedType == ClientType.physical
                            ? t.clients.personName
                            : t.clients.companyName,
                        prefixIcon: Icon(selectedType == ClientType.physical
                            ? Icons.person
                            : Icons.business),
                        border: const OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return t.clients.nameRequired;
                        }
                        return null;
                      },
                      onChanged: (_) => setStateDialog(() {}),
                      textInputAction: TextInputAction.next,
                    ),
                    const SizedBox(height: 16),

                    // --- Контактная информация ---
                    TextFormField(
                      controller: contactInfoController,
                      decoration: InputDecoration(
                        labelText: t.clients.contactInfo,
                        prefixIcon: const Icon(Icons.contact_phone),
                        hintText: t.clients.contactInfoHint,
                        border: const OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return t.clients.contactInfoRequired;
                        }
                        return null;
                      },
                      onChanged: (_) => setStateDialog(() {}),
                      textInputAction: TextInputAction.next,
                    ),
                    const SizedBox(height: 16),

                    // --- Дополнительная информация ---
                    TextFormField(
                      controller: additionalInfoController,
                      decoration: InputDecoration(
                        labelText: t.clients.additionalInfo,
                        prefixIcon: const Icon(Icons.info_outline),
                        hintText: t.clients.additionalInfoHint,
                        border: const OutlineInputBorder(),
                      ),
                      maxLines: 2,
                      onChanged: (_) => setStateDialog(() {}),
                    ),
                  ],
                ),
              ),
            ),
            actions: <Widget>[
              TextButton(
                onPressed: () => Navigator.of(dialogContext).pop(),
                child: Text(t.common.cancel),
              ),
              TextButton(
                onPressed: validateFullForm()
                    ? () {
                        final result = isEditing
                            ? client
                                .copyWithCoreData(
                                  // Используем лямбда-функцию для обновления coreData
                                  (core) => core.copyWith(
                                    code: codeController.text.trim(),
                                    displayName: nameController.text.trim(),
                                    modifiedAt: DateTime.now(),
                                  ),
                                )
                                .copyWithClientData(
                                  // Используем лямбда-функцию для обновления clientData
                                  (clientSpecific) => clientSpecific.copyWith(
                                    type: selectedType,
                                    contactInfo:
                                        contactInfoController.text.trim(),
                                    additionalInfo: additionalInfoController
                                            .text
                                            .trim()
                                            .isEmpty
                                        ? null
                                        : additionalInfoController.text.trim(),
                                  ),
                                )
                            : ClientModelComposite.create(
                                code: codeController.text.trim(),
                                name: nameController.text.trim(),
                                type: selectedType,
                                contactInfo: contactInfoController.text.trim(),
                                additionalInfo:
                                    additionalInfoController.text.trim().isEmpty
                                        ? null
                                        : additionalInfoController.text.trim(),
                              );
                        Navigator.of(dialogContext).pop(result);
                      }
                    : null,
                child: Text(isEditing ? t.common.save : t.common.add),
              ),
            ],
          );
        });
      },
    );
  }

  /// Получает локализованное имя типа клиента
  String _getClientTypeDisplayName(BuildContext context, ClientType type) {
    final t = context.t;
    switch (type) {
      case ClientType.physical:
        return t.clients.types.physical;
      case ClientType.legal:
        return t.clients.types.legal;
      case ClientType.individualEntrepreneur:
        return t.clients.types.entrepreneur;
      case ClientType.other:
        return t.clients.types.other;
    }
  }
}

// --- Делегат поиска ---

/// Делегат для поиска клиентов с помощью search delegate
class ClientSearchDelegate extends SearchDelegate<ClientModelComposite?> {
  // Принимаем WidgetRef вместо ClientService
  final WidgetRef ref;
  final Function(ClientModelComposite) _onClientSelected;

  ClientSearchDelegate(this.ref, this._onClientSelected);

  // Получаем логгер через ref
  Logger get _logger => ref.read(clientsLoggerProvider);

  @override
  String get searchFieldLabel => t.clients.search;

  @override
  List<Widget> buildActions(BuildContext context) {
    return [
      if (query.isNotEmpty)
        IconButton(
          icon: const Icon(Icons.clear),
          tooltip: t.common.clear,
          onPressed: () {
            query = '';
            showSuggestions(context);
          },
        ),
    ];
  }

  @override
  Widget buildLeading(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.arrow_back),
      tooltip: MaterialLocalizations.of(context).backButtonTooltip,
      onPressed: () {
        close(context, null);
      },
    );
  }

  // Результаты поиска
  @override
  Widget buildResults(BuildContext context) {
    // Используем FutureBuilder и получаем сервис через ref.read
    return FutureBuilder<List<ClientModelComposite>>(
      // Вызываем поиск через сервис, полученный из провайдера
      future: ref.read(clientServiceProvider).searchClients(query),
      builder: (context, snapshot) {
        final t = context.t;

        if (query.isEmpty) {
          return Center(child: Text(t.clients.startTyping));
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          _logger.e(LogMessages.clientSearchError.replaceAll('{query}', query),
              error: snapshot.error, stackTrace: snapshot.stackTrace);
          return Center(
            child: Text(
              t.core.errorLoadingData(error: snapshot.error.toString()),
              style: TextStyle(color: Theme.of(context).colorScheme.error),
            ),
          );
        }

        final clients = snapshot.data ?? [];

        if (clients.isEmpty) {
          return Center(child: Text(t.clients.noClientsFound));
        }

        return ListView.separated(
          itemCount: clients.length,
          separatorBuilder: (context, index) => const Divider(height: 1),
          itemBuilder: (context, index) {
            final client = clients[index];
            return ListTile(
              leading: CircleAvatar(
                backgroundColor: _getClientTypeColor(client.type),
                child:
                    Icon(_getClientTypeIcon(client.type), color: Colors.white),
              ),
              title: Text(client.displayName),
              subtitle: Text('${client.code} · ${client.contactInfo}'),
              onTap: () {
                close(context, client);
                _onClientSelected(client);
              },
            );
          },
        );
      },
    );
  }

  // Подсказки во время ввода
  @override
  Widget buildSuggestions(BuildContext context) {
    if (query.isEmpty) {
      return Center(child: Text(context.t.clients.startTyping));
    }
    // Можно добавить логику показа недавних запросов или сразу результаты
    return buildResults(context);
  }

  // --- Вспомогательные методы для иконок/цветов ---
  Color _getClientTypeColor(ClientType type) {
    switch (type) {
      case ClientType.physical:
        return Colors.blue;
      case ClientType.legal:
        return Colors.orange;
      case ClientType.individualEntrepreneur:
        return Colors.green;
      case ClientType.other:
        return Colors.grey;
    }
  }

  IconData _getClientTypeIcon(ClientType type) {
    switch (type) {
      case ClientType.physical:
        return Icons.person;
      case ClientType.legal:
        return Icons.business;
      case ClientType.individualEntrepreneur:
        return Icons.business_center;
      case ClientType.other:
        return Icons.help_outline;
    }
  }
}

// Удаляем расширение ClientModelCompositeCopyWith, т.к. оно уже должно быть
// в файле client_model_composite.dart или сгенерировано @freezed, если используется.
// Если его там нет, его нужно добавить в соответствующий файл.

```

## lib\features\references\clients\services\client_service.dart
```dart
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/daos/clients_dao.dart'; // Содержит ClientFullData
import 'package:part_catalog/core/database/daos/cars_dao.dart'; // Нужен для транзакции с машинами
// Импорт бизнес-модели (композитора)
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
// Импорт интерфейса и других необходимых типов
import 'package:part_catalog/features/references/clients/models/client_type.dart';
// Логгер и сообщения
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
// Импорт композитора для машин (предполагается, что он существует)
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';

/// {@template client_service}
/// Сервис для управления клиентами.
/// Работает с бизнес-моделью [ClientModelComposite] и взаимодействует
/// с DAO для получения/сохранения данных в виде @freezed моделей.
/// {@endtemplate}
class ClientService {
  /// {@macro client_service}
  ClientService(this._db)
      : _logger = AppLoggers.clients; // Используем настроенный логгер

  final AppDatabase _db;
  final Logger _logger;

  /// Получение DAO для работы с клиентами
  ClientsDao get _clientsDao => _db.clientsDao;

  /// Получение DAO для работы с машинами (для транзакций)
  CarsDao get _carsDao => _db.carsDao;

  // --- Приватный метод маппинга из @freezed в Композитор ---
  ClientModelComposite _mapDataToComposite(ClientFullData data) {
    // Используем фабричный конструктор fromData композитора
    return ClientModelComposite.fromData(
      data.coreData,
      data.clientData,
      // parentId, isFolder, ancestorIds, itemsMap пока не поддерживаются DAO
    );
  }

  /// Возвращает поток списка активных клиентов [ClientModelComposite].
  Stream<List<ClientModelComposite>> watchClients() {
    _logger.i(LogMessages.clientWatchActive);
    return _clientsDao.watchActiveClients().map(
          (dataList) => dataList.map(_mapDataToComposite).toList(),
        );
  }

  /// Получает клиента [ClientModelComposite] по UUID.
  Future<ClientModelComposite?> getClientByUuid(String uuid) async {
    _logger.i(LogMessages.clientGetByUuid.replaceAll('{uuid}', uuid));
    final clientData = await _clientsDao.getClientByUuid(uuid);
    if (clientData == null) {
      _logger.w(LogMessages.clientNotFoundByUuid.replaceAll('{uuid}', uuid));
      return null;
    }
    return _mapDataToComposite(clientData);
  }

  /// Получает клиента [ClientModelComposite] по коду.
  Future<ClientModelComposite?> getClientByCode(String code) async {
    _logger.i(LogMessages.clientGetByCode.replaceAll('{code}', code));
    final clientData = await _clientsDao.getClientByCode(code);
    if (clientData == null) {
      _logger.w(LogMessages.clientNotFoundByCode.replaceAll('{code}', code));
      return null;
    }
    return _mapDataToComposite(clientData);
  }

  /// Добавляет нового клиента.
  /// Принимает [ClientModelComposite].
  /// Возвращает UUID созданного клиента.
  Future<String> addClient(ClientModelComposite client) async {
    // Если UUID не задан в композиторе, он должен быть сгенерирован при создании композитора
    if (client.uuid.isEmpty) {
      // Этого не должно происходить, если композитор создан через .create()
      _logger.e(LogMessages.clientAddErrorMissingUuid);
      throw Exception(LogMessages.clientAddErrorMissingUuid);
    }

    // Извлекаем @freezed модели из композитора
    final coreData = client.coreData;
    final clientData = client.clientData;

    try {
      await _clientsDao.insertClient(coreData, clientData);
      _logger.i(LogMessages.clientCreated.replaceAll('{uuid}', client.uuid));
      return client.uuid;
    } catch (e, s) {
      _logger.e(LogMessages.clientAddError, error: e, stackTrace: s);
      rethrow; // Пробрасываем ошибку дальше
    }
  }

  /// Обновляет существующего клиента.
  /// Принимает [ClientModelComposite] с обновленными данными.
  Future<void> updateClient(ClientModelComposite client) async {
    // Обновляем дату модификации перед сохранением
    final updatedClient = client.withModifiedDate(DateTime.now());

    // Извлекаем @freezed модели из обновленного композитора
    final coreData = updatedClient.coreData;
    final clientData = updatedClient.clientData;

    _logger.i(LogMessages.clientUpdating.replaceAll('{uuid}', client.uuid));
    try {
      final updatedRows =
          await _clientsDao.updateClientByUuid(coreData, clientData);
      if (updatedRows == 0) {
        _logger.w(LogMessages.clientNotFoundForUpdate
            .replaceAll('{uuid}', client.uuid));
        // Можно бросить исключение или просто завершить
        // throw Exception(LogMessages.clientNotFoundForUpdate.replaceAll('{uuid}', client.uuid));
      } else {
        _logger.d(LogMessages.clientUpdated.replaceAll('{uuid}', client.uuid));
      }
    } catch (e, s) {
      _logger.e(LogMessages.clientUpdateError.replaceAll('{uuid}', client.uuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Удаляет клиента (мягкое удаление).
  Future<void> deleteClient(String uuid) async {
    _logger.i(LogMessages.clientDeleting.replaceAll('{uuid}', uuid));
    try {
      // Можно сначала получить клиента, чтобы убедиться, что он существует
      final client = await getClientByUuid(uuid);
      if (client == null) {
        _logger
            .w(LogMessages.clientNotFoundForDelete.replaceAll('{uuid}', uuid));
        return; // Клиент не найден или уже удален
      }
      if (client.isDeleted) {
        _logger.w(LogMessages.clientAlreadyDeleted.replaceAll('{uuid}', uuid));
        return; // Уже удален
      }
      // Помечаем как удаленный и обновляем
      final deletedClient = client.markAsDeleted();
      await updateClient(deletedClient); // Используем общий метод обновления
      _logger.i(LogMessages.clientDeleted.replaceAll('{uuid}', uuid));
    } catch (e, s) {
      _logger.e(LogMessages.clientDeleteError.replaceAll('{uuid}', uuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Возвращает список всех клиентов [ClientModelComposite].
  Future<List<ClientModelComposite>> getAllClients(
      {bool includeDeleted = false}) async {
    _logger.i(LogMessages.clientGetAll(includeDeleted));
    final clientDataList =
        await _clientsDao.getAllClients(includeDeleted: includeDeleted);
    return clientDataList.map(_mapDataToComposite).toList();
  }

  /// Фильтрует клиентов по типу.
  Future<List<ClientModelComposite>> getClientsByType(ClientType type) async {
    _logger.i(LogMessages.clientGetByType.replaceAll('{type}', type.name));
    final clientDataList = await _clientsDao.getClientsByType(type);
    return clientDataList.map(_mapDataToComposite).toList();
  }

  /// Восстанавливает удалённого клиента.
  Future<void> restoreClient(String uuid) async {
    _logger.i(LogMessages.clientRestoring.replaceAll('{uuid}', uuid));
    try {
      // Получаем текущие данные (DAO должен уметь получать удаленных для восстановления)
      // TODO: Убедиться, что getClientByUuid или специальный метод DAO может получить удаленного
      final clientData = await _clientsDao
          .getClientByUuid(uuid); // Предполагаем, что может вернуть удаленного
      if (clientData == null) {
        _logger
            .w(LogMessages.clientNotFoundForRestore.replaceAll('{uuid}', uuid));
        return;
      }
      final client = _mapDataToComposite(clientData);

      if (!client.isDeleted) {
        _logger.w(LogMessages.clientRestoreAttemptOnNonDeleted
            .replaceAll('{uuid}', uuid));
        return; // Не удален
      }

      // Восстанавливаем и обновляем
      final restoredClient = client.restore();
      await updateClient(restoredClient); // Используем общий метод обновления
      _logger.i(LogMessages.clientRestored.replaceAll('{uuid}', uuid));
    } catch (e, s) {
      _logger.e(LogMessages.clientRestoreError.replaceAll('{uuid}', uuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Создаёт нового клиента вместе с его автомобилями в одной транзакции.
  /// Принимает [ClientModelComposite] и список [CarModelComposite].
  Future<String> createClientWithCars(
      ClientModelComposite client, List<CarModelComposite> cars) async {
    if (client.uuid.isEmpty) {
      _logger.e(LogMessages.clientAddErrorMissingUuid);
      throw Exception(LogMessages.clientAddErrorMissingUuid);
    }

    _logger.i(LogMessages.clientCreatingWithCars
        .replaceAll('{uuid}', client.uuid)
        .replaceAll('{carCount}', cars.length.toString()));

    final clientCore = client.coreData;
    final clientSpecific = client.clientData;

    try {
      await _db.transaction(() async {
        // 1. Вставляем клиента
        // DAO клиента возвращает int ID вставленной записи, но он нам здесь не нужен
        await _clientsDao.insertClient(clientCore, clientSpecific);
        _logger.d(LogMessages.clientInsertedInTransaction
            .replaceAll('{uuid}', client.uuid));

        // 2. Вставляем автомобили, связанные с этим клиентом
        for (final car in cars) {
          // Обновляем carSpecificData, добавляя clientId (UUID)
          final carSpecificWithClient = car.carData
              .copyWith(clientId: client.uuid); // Связываем по UUID клиента
          // Обновляем carCoreData с датой модификации
          final carCoreWithModified =
              car.coreData.copyWith(modifiedAt: DateTime.now());

          // Вызываем DAO для вставки машины.
          // CarsDao.insertCar сам найдет int ID клиента по UUID из carSpecificWithClient.
          await _carsDao.insertCar(carCoreWithModified, carSpecificWithClient);
          _logger.d(LogMessages.clientCarAddedInTransaction
              .replaceAll('{carUuid}', car.uuid)
              .replaceAll('{clientUuid}', client.uuid));
        }
      });
      _logger.i(LogMessages.clientCreatedWithCarsSuccess
          .replaceAll('{uuid}', client.uuid));
      return client.uuid;
    } catch (e, s) {
      _logger.e(
          LogMessages.clientCreateWithCarsError
              .replaceAll('{uuid}', client.uuid),
          error: e,
          stackTrace: s);
      rethrow;
    }
  }

  /// Поиск клиентов [ClientModelComposite] по имени, коду или контактной информации.
  Future<List<ClientModelComposite>> searchClients(String query) async {
    _logger.i(LogMessages.clientSearching.replaceAll('{query}', query));
    final clientDataList = await _clientsDao.searchClients(query);
    return clientDataList.map(_mapDataToComposite).toList();
  }

  /// Проверяет уникальность кода клиента.
  Future<bool> isCodeUnique(String code, {String? excludeUuid}) async {
    _logger
        .i(LogMessages.clientCheckingCodeUniqueness.replaceAll('{code}', code));
    return _clientsDao.isCodeUnique(code, excludeUuid: excludeUuid);
  }

  // Старые методы _mapToModel и _mapToCompanion больше не нужны
}

```

## lib\features\references\suppliers\models\price_offer.dart
```dart
import 'package:json_annotation/json_annotation.dart';

part 'price_offer.g.dart';

/// {@template price_offer}
/// Модель данных для представления предложения цены.
/// {@endtemplate}
@JsonSerializable()
class PriceOffer {
  /// {@macro price_offer}
  PriceOffer({
    required this.partNumber,
    required this.price,
    required this.deliveryTime,
    required this.supplierId,
  });

  /// Артикул запчасти.
  @JsonKey(name: 'partNumber')
  final String partNumber;

  /// Цена.
  @JsonKey(name: 'price')
  final double price;

  /// Срок поставки.
  @JsonKey(name: 'deliveryTime')
  final String deliveryTime;

  /// Идентификатор поставщика.
  @JsonKey(name: 'supplierId')
  final String supplierId;

  /// Преобразование JSON в объект `PriceOffer`.
  factory PriceOffer.fromJson(Map<String, dynamic> json) =>
      _$PriceOfferFromJson(json);

  /// Преобразование объекта `PriceOffer` в JSON.
  Map<String, dynamic> toJson() => _$PriceOfferToJson(this);
}

```

## lib\features\references\suppliers\models\price_offer.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'price_offer.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

PriceOffer _$PriceOfferFromJson(Map<String, dynamic> json) => PriceOffer(
      partNumber: json['partNumber'] as String,
      price: (json['price'] as num).toDouble(),
      deliveryTime: json['deliveryTime'] as String,
      supplierId: json['supplierId'] as String,
    );

Map<String, dynamic> _$PriceOfferToJson(PriceOffer instance) =>
    <String, dynamic>{
      'partNumber': instance.partNumber,
      'price': instance.price,
      'deliveryTime': instance.deliveryTime,
      'supplierId': instance.supplierId,
    };

```

## lib\features\references\suppliers\models\supplier.dart
```dart
import 'package:json_annotation/json_annotation.dart';

part 'supplier.g.dart';

/// {@template supplier}
/// Модель данных для представления поставщика.
/// {@endtemplate}
@JsonSerializable()
class Supplier {
  /// {@macro supplier}
  Supplier({
    required this.id,
    required this.name,
    required this.contactInfo,
  });

  /// Уникальный идентификатор поставщика.
  @JsonKey(name: 'id')
  final String id;

  /// Название поставщика.
  @JsonKey(name: 'name')
  final String name;

  /// Контактная информация.
  @JsonKey(name: 'contactInfo')
  final String contactInfo;

  /// Преобразование JSON в объект `Supplier`.
  factory Supplier.fromJson(Map<String, dynamic> json) =>
      _$SupplierFromJson(json);

  /// Преобразование объекта `Supplier` в JSON.
  Map<String, dynamic> toJson() => _$SupplierToJson(this);
}

```

## lib\features\references\suppliers\models\supplier.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'supplier.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Supplier _$SupplierFromJson(Map<String, dynamic> json) => Supplier(
      id: json['id'] as String,
      name: json['name'] as String,
      contactInfo: json['contactInfo'] as String,
    );

Map<String, dynamic> _$SupplierToJson(Supplier instance) => <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'contactInfo': instance.contactInfo,
    };

```

## lib\features\references\vehicles\models\car_model_composite.dart
```dart
import 'package:part_catalog/features/core/entity_core_data.dart';
import 'package:part_catalog/features/references/vehicles/models/car_specific_data.dart';
import 'package:part_catalog/features/core/i_reference_entity.dart';
import 'package:part_catalog/features/core/i_reference_item_entity.dart';
import 'package:part_catalog/features/core/base_item_type.dart';
import 'package:uuid/uuid.dart';
import 'package:collection/collection.dart'; // Для ListEquality, MapEquality

/// {@template car_model_composite}
/// Бизнес-модель (композитор) для представления автомобиля.
/// Реализует интерфейс [IReferenceEntity] и композирует модели данных
/// [EntityCoreData] и [CarSpecificData].
/// {@endtemplate}
class CarModelComposite implements IReferenceEntity {
  /// Базовые данные сущности.
  final EntityCoreData coreData;

  /// Специфичные данные автомобиля.
  final CarSpecificData carData;

  // --- Поля из IReferenceEntity ---

  @override
  final String? parentId; // Автомобили обычно не имеют родителя

  @override
  final bool isFolder; // Автомобили не являются папками

  @override
  final List<String> ancestorIds; // У автомобилей нет предков в иерархии

  @override
  final Map<BaseItemType, List<IReferenceItemEntity>>
      itemsMap; // Автомобили обычно не имеют элементов

  /// Приватный конструктор для использования в фабричных методах и `with...`.
  const CarModelComposite._(
    this.coreData,
    this.carData, {
    this.parentId,
    this.isFolder = false,
    List<String>? ancestorIds,
    Map<BaseItemType, List<IReferenceItemEntity>>? itemsMap,
  })  : ancestorIds = ancestorIds ?? const [],
        itemsMap = itemsMap ?? const {};

  /// Фабричный конструктор для создания нового экземпляра автомобиля.
  factory CarModelComposite.create({
    required String code, // Код может быть VIN или другим уникальным значением
    required String make,
    required String model,
    required int year,
    required String vin,
    required String clientId,
    String? licensePlate,
    String? additionalInfo,
    String? parentId, // Можно передать, если нужна иерархия
  }) {
    final now = DateTime.now();
    // Используем комбинацию марки и модели для displayName
    final displayName = '$make $model ($year)';
    final core = EntityCoreData(
      uuid: const Uuid().v4(),
      code: code, // Используем переданный код
      displayName: displayName,
      createdAt: now,
      modifiedAt: now,
      isDeleted: false,
      deletedAt: null,
    );
    final specific = CarSpecificData(
      clientId: clientId,
      vin: vin,
      make: make,
      model: model,
      year: year,
      licensePlate: licensePlate,
      additionalInfo: additionalInfo,
    );
    return CarModelComposite._(
      core,
      specific,
      parentId: parentId,
      isFolder: false,
      ancestorIds: const [], // Или вычислить, если parentId задан
      itemsMap: const {},
    );
  }

  /// Фабричный конструктор для создания экземпляра из моделей данных.
  /// Используется сервисом при маппинге данных из DAO.
  factory CarModelComposite.fromData(
    EntityCoreData coreData,
    CarSpecificData carData, {
    String? parentId,
    bool isFolder = false,
    List<String>? ancestorIds,
    Map<BaseItemType, List<IReferenceItemEntity>>? itemsMap,
  }) {
    // Убедимся, что карта и списки неизменяемы, если они переданы
    final unmodifiableItemsMap = itemsMap == null
        ? const <BaseItemType, List<IReferenceItemEntity>>{}
        : Map<BaseItemType, List<IReferenceItemEntity>>.unmodifiable(
            itemsMap.map(
              (key, value) =>
                  MapEntry(key, List<IReferenceItemEntity>.unmodifiable(value)),
            ),
          );

    return CarModelComposite._(
      coreData,
      carData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: unmodifiableItemsMap,
    );
  }

  // --- Реализация интерфейса IEntity ---

  @override
  String get uuid => coreData.uuid;

  @override
  String get code => coreData.code;

  @override
  String get displayName => coreData.displayName;

  @override
  DateTime get createdAt => coreData.createdAt;

  @override
  DateTime? get modifiedAt => coreData.modifiedAt;

  @override
  bool get isDeleted => coreData.isDeleted;

  @override
  DateTime? get deletedAt => coreData.deletedAt;

  @override
  bool containsSearchText(String query) {
    if (query.isEmpty) return true;
    final lowerQuery = query.toLowerCase();

    // Проверяем основные поля
    if (coreData.displayName.toLowerCase().contains(lowerQuery)) return true;
    if (coreData.code.toLowerCase().contains(lowerQuery)) {
      return true; // Поиск по коду (может быть VIN)
    }
    if (carData.vin.toLowerCase().contains(lowerQuery)) {
      return true; // Явный поиск по VIN
    }
    if (carData.make.toLowerCase().contains(lowerQuery)) return true;
    if (carData.model.toLowerCase().contains(lowerQuery)) return true;
    if (carData.licensePlate?.toLowerCase().contains(lowerQuery) ?? false) {
      return true;
    }
    if (carData.additionalInfo?.toLowerCase().contains(lowerQuery) ?? false) {
      return true;
    }

    // Поиск по элементам (если они есть)
    for (final item in items) {
      if (item.containsSearchText(lowerQuery)) return true;
    }

    return false;
  }

  // --- Геттеры для специфичных данных автомобиля ---

  String get clientId => carData.clientId;
  String get vin => carData.vin;
  String get make => carData.make;
  String get model => carData.model;
  int get year => carData.year;
  String? get licensePlate => carData.licensePlate;
  String? get additionalInfo => carData.additionalInfo;

  /// Возвращает номерной знак или прочерк, если он не указан
  String get displayLicensePlate => licensePlate ?? '—';

  // --- Реализация интерфейса IReferenceEntity (дополнительные методы) ---

  @override
  List<IReferenceItemEntity> get items =>
      itemsMap.values.expand((list) => list).toList();

  @override
  List<IReferenceItemEntity> getItemsByType(BaseItemType type) {
    return List.unmodifiable(itemsMap[type] ?? const []);
  }

  @override
  List<IReferenceItemEntity> searchItems(String query) {
    if (query.isEmpty) return items;
    final lowerQuery = query.toLowerCase();
    return items.where((item) => item.containsSearchText(lowerQuery)).toList();
  }

  // --- Методы для иммутабельного обновления ---

  /// Возвращает новый экземпляр с обновленным кодом.
  CarModelComposite withCode(String newCode) {
    return CarModelComposite._(
      coreData.copyWith(code: newCode, modifiedAt: DateTime.now()),
      carData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным VIN.
  /// Также обновляет code, если он совпадает с VIN.
  CarModelComposite withVin(String newVin) {
    final newCoreData = coreData.code == carData.vin
        ? coreData.copyWith(code: newVin, modifiedAt: DateTime.now())
        : coreData.copyWith(modifiedAt: DateTime.now());
    return CarModelComposite._(
      newCoreData,
      carData.copyWith(vin: newVin),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной маркой.
  /// Обновляет displayName.
  CarModelComposite withMake(String newMake) {
    final newDisplayName = '$newMake ${carData.model} (${carData.year})';
    return CarModelComposite._(
      coreData.copyWith(
          displayName: newDisplayName, modifiedAt: DateTime.now()),
      carData.copyWith(make: newMake),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной моделью.
  /// Обновляет displayName.
  CarModelComposite withModel(String newModel) {
    final newDisplayName = '${carData.make} $newModel (${carData.year})';
    return CarModelComposite._(
      coreData.copyWith(
          displayName: newDisplayName, modifiedAt: DateTime.now()),
      carData.copyWith(model: newModel),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным годом.
  /// Обновляет displayName.
  CarModelComposite withYear(int newYear) {
    final newDisplayName = '${carData.make} ${carData.model} ($newYear)';
    return CarModelComposite._(
      coreData.copyWith(
          displayName: newDisplayName, modifiedAt: DateTime.now()),
      carData.copyWith(year: newYear),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным номерным знаком.
  CarModelComposite withLicensePlate(String? newLicensePlate) {
    return CarModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      carData.copyWith(licensePlate: newLicensePlate),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной доп. информацией.
  CarModelComposite withAdditionalInfo(String? newAdditionalInfo) {
    return CarModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      carData.copyWith(additionalInfo: newAdditionalInfo),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленным владельцем.
  CarModelComposite withOwner(String newClientId) {
    return CarModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      carData.copyWith(clientId: newClientId),
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр, помеченный как удаленный.
  CarModelComposite markAsDeleted() {
    if (isDeleted) return this;
    final now = DateTime.now();
    return CarModelComposite._(
      coreData.copyWith(isDeleted: true, modifiedAt: now, deletedAt: now),
      carData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр, восстановленный из удаленных.
  CarModelComposite restore() {
    if (!isDeleted) return this;
    return CarModelComposite._(
      coreData.copyWith(
          isDeleted: false, modifiedAt: DateTime.now(), deletedAt: null),
      carData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  /// Возвращает новый экземпляр с обновленной датой модификации.
  CarModelComposite withModifiedDate(DateTime modifiedDate) {
    return CarModelComposite._(
      coreData.copyWith(modifiedAt: modifiedDate),
      carData,
      parentId: parentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds,
      itemsMap: itemsMap,
    );
  }

  // --- Методы для иммутабельного обновления из IReferenceEntity ---

  @override
  CarModelComposite withParentId(String? newParentId) {
    // Логика обновления ancestorIds, если необходимо
    return CarModelComposite._(
      coreData.copyWith(modifiedAt: DateTime.now()),
      carData,
      parentId: newParentId,
      isFolder: isFolder,
      ancestorIds: ancestorIds, // Потребуется пересчет
      itemsMap: itemsMap,
    );
  }

  // Методы для работы с itemsMap. Для автомобилей они обычно не нужны.
  @override
  CarModelComposite withAddedItem(IReferenceItemEntity item,
      {BaseItemType? itemType}) {
    throw UnsupportedError('Автомобили не могут содержать элементы');
  }

  @override
  CarModelComposite withUpdatedItem(IReferenceItemEntity item,
      {BaseItemType? itemType}) {
    throw UnsupportedError('Автомобили не могут содержать элементы');
  }

  @override
  CarModelComposite withRemovedItem(String itemId, {BaseItemType? itemType}) {
    throw UnsupportedError('Автомобили не могут содержать элементы');
  }

  // --- Сериализация/Десериализация (Ручная) ---

  Map<String, dynamic> toJson() {
    // Сериализация itemsMap не нужна, т.к. они не используются
    return {
      ...coreData.toJson(),
      ...carData.toJson(),
      // Добавить сериализацию полей IReferenceEntity, если нужно
      // 'parentId': parentId,
      // 'isFolder': isFolder,
      // 'ancestorIds': ancestorIds,
    };
  }

  factory CarModelComposite.fromJson(Map<String, dynamic> json) {
    final core = EntityCoreData.fromJson(json);
    final specific = CarSpecificData.fromJson(json);
    // Десериализация itemsMap не нужна
    return CarModelComposite._(
      core,
      specific,
      // parentId: json['parentId'] as String?,
      // isFolder: json['isFolder'] as bool? ?? false,
      // ancestorIds: (json['ancestorIds'] as List?)?.cast<String>(),
      // itemsMap: const {},
    );
  }

  // --- Переопределение стандартных методов ---

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CarModelComposite &&
          runtimeType == other.runtimeType &&
          coreData == other.coreData &&
          carData == other.carData &&
          parentId == other.parentId &&
          isFolder == other.isFolder &&
          const ListEquality().equals(ancestorIds, other.ancestorIds) &&
          const MapEquality<BaseItemType, List<IReferenceItemEntity>>()
              .equals(itemsMap, other.itemsMap);

  @override
  int get hashCode =>
      coreData.hashCode ^
      carData.hashCode ^
      parentId.hashCode ^
      isFolder.hashCode ^
      const ListEquality().hash(ancestorIds) ^
      const MapEquality<BaseItemType, List<IReferenceItemEntity>>()
          .hash(itemsMap);

  @override
  String toString() {
    return 'CarModelComposite(uuid: $uuid, displayName: $displayName, vin: $vin)';
  }
}

```

## lib\features\references\vehicles\models\car_specific_data.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'car_specific_data.freezed.dart';
part 'car_specific_data.g.dart';

/// {@template car_specific_data}
/// Специфичные данные для сущности "Автомобиль".
/// Содержит поля, уникальные для автомобилей.
/// {@endtemplate}
@freezed
abstract class CarSpecificData with _$CarSpecificData {
  /// {@macro car_specific_data}
  const factory CarSpecificData({
    /// Идентификатор клиента-владельца (UUID).
    @JsonKey(name: 'clientId') required String clientId,

    /// VIN-код. Должен быть уникальным.
    @JsonKey(name: 'vin') required String vin,

    /// Марка автомобиля.
    @JsonKey(name: 'make') required String make,

    /// Модель автомобиля.
    @JsonKey(name: 'model') required String model,

    /// Год выпуска.
    @JsonKey(name: 'year') required int year,

    /// Номерной знак (опционально).
    @JsonKey(name: 'licensePlate') String? licensePlate,

    /// Дополнительная информация (опционально).
    @JsonKey(name: 'additionalInfo') String? additionalInfo,
  }) = _CarSpecificData;

  /// Преобразование JSON в объект `CarSpecificData`.
  factory CarSpecificData.fromJson(Map<String, dynamic> json) =>
      _$CarSpecificDataFromJson(json);
}

```

## lib\features\references\vehicles\models\car_specific_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'car_specific_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CarSpecificData {
  /// Идентификатор клиента-владельца (UUID).
  @JsonKey(name: 'clientId')
  String get clientId;

  /// VIN-код. Должен быть уникальным.
  @JsonKey(name: 'vin')
  String get vin;

  /// Марка автомобиля.
  @JsonKey(name: 'make')
  String get make;

  /// Модель автомобиля.
  @JsonKey(name: 'model')
  String get model;

  /// Год выпуска.
  @JsonKey(name: 'year')
  int get year;

  /// Номерной знак (опционально).
  @JsonKey(name: 'licensePlate')
  String? get licensePlate;

  /// Дополнительная информация (опционально).
  @JsonKey(name: 'additionalInfo')
  String? get additionalInfo;

  /// Create a copy of CarSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CarSpecificDataCopyWith<CarSpecificData> get copyWith =>
      _$CarSpecificDataCopyWithImpl<CarSpecificData>(
          this as CarSpecificData, _$identity);

  /// Serializes this CarSpecificData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CarSpecificData &&
            (identical(other.clientId, clientId) ||
                other.clientId == clientId) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.make, make) || other.make == make) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.year, year) || other.year == year) &&
            (identical(other.licensePlate, licensePlate) ||
                other.licensePlate == licensePlate) &&
            (identical(other.additionalInfo, additionalInfo) ||
                other.additionalInfo == additionalInfo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, clientId, vin, make, model, year,
      licensePlate, additionalInfo);

  @override
  String toString() {
    return 'CarSpecificData(clientId: $clientId, vin: $vin, make: $make, model: $model, year: $year, licensePlate: $licensePlate, additionalInfo: $additionalInfo)';
  }
}

/// @nodoc
abstract mixin class $CarSpecificDataCopyWith<$Res> {
  factory $CarSpecificDataCopyWith(
          CarSpecificData value, $Res Function(CarSpecificData) _then) =
      _$CarSpecificDataCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'clientId') String clientId,
      @JsonKey(name: 'vin') String vin,
      @JsonKey(name: 'make') String make,
      @JsonKey(name: 'model') String model,
      @JsonKey(name: 'year') int year,
      @JsonKey(name: 'licensePlate') String? licensePlate,
      @JsonKey(name: 'additionalInfo') String? additionalInfo});
}

/// @nodoc
class _$CarSpecificDataCopyWithImpl<$Res>
    implements $CarSpecificDataCopyWith<$Res> {
  _$CarSpecificDataCopyWithImpl(this._self, this._then);

  final CarSpecificData _self;
  final $Res Function(CarSpecificData) _then;

  /// Create a copy of CarSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clientId = null,
    Object? vin = null,
    Object? make = null,
    Object? model = null,
    Object? year = null,
    Object? licensePlate = freezed,
    Object? additionalInfo = freezed,
  }) {
    return _then(_self.copyWith(
      clientId: null == clientId
          ? _self.clientId
          : clientId // ignore: cast_nullable_to_non_nullable
              as String,
      vin: null == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String,
      make: null == make
          ? _self.make
          : make // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      year: null == year
          ? _self.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      licensePlate: freezed == licensePlate
          ? _self.licensePlate
          : licensePlate // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInfo: freezed == additionalInfo
          ? _self.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _CarSpecificData implements CarSpecificData {
  const _CarSpecificData(
      {@JsonKey(name: 'clientId') required this.clientId,
      @JsonKey(name: 'vin') required this.vin,
      @JsonKey(name: 'make') required this.make,
      @JsonKey(name: 'model') required this.model,
      @JsonKey(name: 'year') required this.year,
      @JsonKey(name: 'licensePlate') this.licensePlate,
      @JsonKey(name: 'additionalInfo') this.additionalInfo});
  factory _CarSpecificData.fromJson(Map<String, dynamic> json) =>
      _$CarSpecificDataFromJson(json);

  /// Идентификатор клиента-владельца (UUID).
  @override
  @JsonKey(name: 'clientId')
  final String clientId;

  /// VIN-код. Должен быть уникальным.
  @override
  @JsonKey(name: 'vin')
  final String vin;

  /// Марка автомобиля.
  @override
  @JsonKey(name: 'make')
  final String make;

  /// Модель автомобиля.
  @override
  @JsonKey(name: 'model')
  final String model;

  /// Год выпуска.
  @override
  @JsonKey(name: 'year')
  final int year;

  /// Номерной знак (опционально).
  @override
  @JsonKey(name: 'licensePlate')
  final String? licensePlate;

  /// Дополнительная информация (опционально).
  @override
  @JsonKey(name: 'additionalInfo')
  final String? additionalInfo;

  /// Create a copy of CarSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CarSpecificDataCopyWith<_CarSpecificData> get copyWith =>
      __$CarSpecificDataCopyWithImpl<_CarSpecificData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CarSpecificDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CarSpecificData &&
            (identical(other.clientId, clientId) ||
                other.clientId == clientId) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.make, make) || other.make == make) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.year, year) || other.year == year) &&
            (identical(other.licensePlate, licensePlate) ||
                other.licensePlate == licensePlate) &&
            (identical(other.additionalInfo, additionalInfo) ||
                other.additionalInfo == additionalInfo));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, clientId, vin, make, model, year,
      licensePlate, additionalInfo);

  @override
  String toString() {
    return 'CarSpecificData(clientId: $clientId, vin: $vin, make: $make, model: $model, year: $year, licensePlate: $licensePlate, additionalInfo: $additionalInfo)';
  }
}

/// @nodoc
abstract mixin class _$CarSpecificDataCopyWith<$Res>
    implements $CarSpecificDataCopyWith<$Res> {
  factory _$CarSpecificDataCopyWith(
          _CarSpecificData value, $Res Function(_CarSpecificData) _then) =
      __$CarSpecificDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'clientId') String clientId,
      @JsonKey(name: 'vin') String vin,
      @JsonKey(name: 'make') String make,
      @JsonKey(name: 'model') String model,
      @JsonKey(name: 'year') int year,
      @JsonKey(name: 'licensePlate') String? licensePlate,
      @JsonKey(name: 'additionalInfo') String? additionalInfo});
}

/// @nodoc
class __$CarSpecificDataCopyWithImpl<$Res>
    implements _$CarSpecificDataCopyWith<$Res> {
  __$CarSpecificDataCopyWithImpl(this._self, this._then);

  final _CarSpecificData _self;
  final $Res Function(_CarSpecificData) _then;

  /// Create a copy of CarSpecificData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? clientId = null,
    Object? vin = null,
    Object? make = null,
    Object? model = null,
    Object? year = null,
    Object? licensePlate = freezed,
    Object? additionalInfo = freezed,
  }) {
    return _then(_CarSpecificData(
      clientId: null == clientId
          ? _self.clientId
          : clientId // ignore: cast_nullable_to_non_nullable
              as String,
      vin: null == vin
          ? _self.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String,
      make: null == make
          ? _self.make
          : make // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      year: null == year
          ? _self.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      licensePlate: freezed == licensePlate
          ? _self.licensePlate
          : licensePlate // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInfo: freezed == additionalInfo
          ? _self.additionalInfo
          : additionalInfo // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\references\vehicles\models\car_specific_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_specific_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_CarSpecificData _$CarSpecificDataFromJson(Map<String, dynamic> json) =>
    _CarSpecificData(
      clientId: json['clientId'] as String,
      vin: json['vin'] as String,
      make: json['make'] as String,
      model: json['model'] as String,
      year: (json['year'] as num).toInt(),
      licensePlate: json['licensePlate'] as String?,
      additionalInfo: json['additionalInfo'] as String?,
    );

Map<String, dynamic> _$CarSpecificDataToJson(_CarSpecificData instance) =>
    <String, dynamic>{
      'clientId': instance.clientId,
      'vin': instance.vin,
      'make': instance.make,
      'model': instance.model,
      'year': instance.year,
      'licensePlate': instance.licensePlate,
      'additionalInfo': instance.additionalInfo,
    };

```

## lib\features\references\vehicles\providers\car_providers.dart
```dart
import 'dart:async';

import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/providers/core_providers.dart';
import 'package:part_catalog/core/service_locator.dart';
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/features/references/clients/providers/client_providers.dart'; // Для clientServiceProvider
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/services/car_service.dart'; // Содержит CarWithOwnerModel
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

part 'car_providers.g.dart'; // Сгенерированный файл

// Провайдер для CarService
@Riverpod(keepAlive: true)
CarService carService(Ref ref) {
  final db = locator<AppDatabase>();
  return CarService(db);
}

// Провайдер для получения списка клиентов для фильтра
@riverpod
Future<List<ClientModelComposite>> clientsForFilter(Ref ref) async {
  final clientService = ref.watch(clientServiceProvider);
  return clientService.getAllClients();
}

// AsyncNotifier для управления списком автомобилей с владельцами
@riverpod
class CarsNotifier extends _$CarsNotifier {
  Logger get _logger => ref.read(vehiclesLoggerProvider);
  CarService get _carService => ref.read(carServiceProvider);

  // Фильтр по UUID клиента (оставляем приватным)
  String? _clientFilterUuid;

  // Публичный геттер для текущего фильтра
  String? get currentClientFilterUuid => _clientFilterUuid;

  @override
  FutureOr<List<CarWithOwnerModel>> build() async {
    _logger.d('CarsNotifier: Initial build loading cars...');
    // Используем watch для подписки на изменения
    // Передаем текущий фильтр в сервис (если сервис его поддерживает)
    // Или фильтруем здесь после получения всех данных
    final allCars = await _carService.getCarsWithOwners();
    return _filterCars(allCars);
  }

  // Внутренний метод для фильтрации
  List<CarWithOwnerModel> _filterCars(List<CarWithOwnerModel> allCars) {
    if (_clientFilterUuid == null) {
      return allCars;
    } else {
      return allCars
          .where((cwo) => cwo.owner.uuid == _clientFilterUuid)
          .toList();
    }
  }

  /// Устанавливает фильтр по клиенту и перезагружает данные
  Future<void> setClientFilter(String? clientUuid) async {
    _logger.d('CarsNotifier: Setting client filter to: $clientUuid');
    // Проверяем, изменился ли фильтр, чтобы избежать лишних перестроений
    if (_clientFilterUuid == clientUuid) return;

    _clientFilterUuid = clientUuid;
    // Перезагружаем данные с новым фильтром
    ref.invalidateSelf();
    // Ждем завершения перестроения (опционально, если нужно дождаться)
    await future;
  }

  /// Добавляет новый автомобиль
  Future<void> addCar(CarModelComposite car) async {
    _logger.d('CarsNotifier: Attempting to add car: ${car.vin}');
    try {
      await _carService.addCar(car);
      ref.invalidateSelf(); // Перезагружаем список
      await future; // Дожидаемся обновления
      _logger.i('CarsNotifier: Car added successfully: ${car.vin}');
    } catch (e, s) {
      _logger.e('CarsNotifier: Error adding car: ${car.vin}',
          error: e, stackTrace: s);
      rethrow; // Пробрасываем для UI
    }
  }

  /// Обновляет существующий автомобиль
  Future<void> updateCar(CarModelComposite car) async {
    _logger.d('CarsNotifier: Attempting to update car: ${car.uuid}');
    try {
      await _carService.updateCar(car);
      ref.invalidateSelf(); // Перезагружаем список
      await future; // Дожидаемся обновления
      _logger.i('CarsNotifier: Car updated successfully: ${car.uuid}');
    } catch (e, s) {
      _logger.e('CarsNotifier: Error updating car: ${car.uuid}',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Мягко удаляет автомобиль
  Future<void> deleteCar(String carUuid) async {
    _logger.d('CarsNotifier: Attempting to delete car: $carUuid');
    try {
      await _carService.deleteCar(carUuid);
      ref.invalidateSelf(); // Перезагружаем список
      await future; // Дожидаемся обновления
      _logger.i('CarsNotifier: Car deleted successfully: $carUuid');
    } catch (e, s) {
      _logger.e('CarsNotifier: Error deleting car: $carUuid',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Восстанавливает мягко удаленный автомобиль
  Future<void> restoreCar(String carUuid) async {
    _logger.d('CarsNotifier: Attempting to restore car: $carUuid');
    try {
      await _carService.restoreCar(carUuid);
      ref.invalidateSelf(); // Перезагружаем список
      await future; // Дожидаемся обновления
      _logger.i('CarsNotifier: Car restored successfully: $carUuid');
    } catch (e, s) {
      _logger.e('CarsNotifier: Error restoring car: $carUuid',
          error: e, stackTrace: s);
      rethrow;
    }
  }

  // Метод поиска (если нужен)
  // Future<void> searchCars(String query) async { ... }
}

// Провайдер для проверки уникальности VIN (асинхронный)
@riverpod
Future<bool> isVinUnique(Ref ref,
    {required String vin, String? excludeUuid}) async {
  final logger = ref.read(vehiclesLoggerProvider);
  logger
      .d('isVinUniqueProvider: Checking VIN "$vin", excluding "$excludeUuid"');
  final carService = ref.watch(carServiceProvider);
  try {
    final isUnique =
        await carService.isVinUnique(vin, excludeUuid: excludeUuid);
    logger.d('isVinUniqueProvider: VIN "$vin" is unique: $isUnique');
    return isUnique;
  } catch (e, s) {
    logger.e('isVinUniqueProvider: Error checking VIN uniqueness for "$vin"',
        error: e, stackTrace: s);
    return false; // Считаем не уникальным при ошибке
  }
}

```

## lib\features\references\vehicles\providers\car_providers.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'car_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$carServiceHash() => r'1a9f3982a691d68166c48b8aa36dd6c91c967724';

/// See also [carService].
@ProviderFor(carService)
final carServiceProvider = Provider<CarService>.internal(
  carService,
  name: r'carServiceProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$carServiceHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef CarServiceRef = ProviderRef<CarService>;
String _$clientsForFilterHash() => r'f7e2a682ff1c9c06fb4a9b663f259f02a18adcd3';

/// See also [clientsForFilter].
@ProviderFor(clientsForFilter)
final clientsForFilterProvider =
    AutoDisposeFutureProvider<List<ClientModelComposite>>.internal(
  clientsForFilter,
  name: r'clientsForFilterProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$clientsForFilterHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ClientsForFilterRef
    = AutoDisposeFutureProviderRef<List<ClientModelComposite>>;
String _$isVinUniqueHash() => r'9264ef84a1792da1f4980bbc302fb3cd07d71f91';

/// Copied from Dart SDK
class _SystemHash {
  _SystemHash._();

  static int combine(int hash, int value) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + value);
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
  }

  static int finish(int hash) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    // ignore: parameter_assignments
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
  }
}

/// See also [isVinUnique].
@ProviderFor(isVinUnique)
const isVinUniqueProvider = IsVinUniqueFamily();

/// See also [isVinUnique].
class IsVinUniqueFamily extends Family<AsyncValue<bool>> {
  /// See also [isVinUnique].
  const IsVinUniqueFamily();

  /// See also [isVinUnique].
  IsVinUniqueProvider call({
    required String vin,
    String? excludeUuid,
  }) {
    return IsVinUniqueProvider(
      vin: vin,
      excludeUuid: excludeUuid,
    );
  }

  @override
  IsVinUniqueProvider getProviderOverride(
    covariant IsVinUniqueProvider provider,
  ) {
    return call(
      vin: provider.vin,
      excludeUuid: provider.excludeUuid,
    );
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'isVinUniqueProvider';
}

/// See also [isVinUnique].
class IsVinUniqueProvider extends AutoDisposeFutureProvider<bool> {
  /// See also [isVinUnique].
  IsVinUniqueProvider({
    required String vin,
    String? excludeUuid,
  }) : this._internal(
          (ref) => isVinUnique(
            ref as IsVinUniqueRef,
            vin: vin,
            excludeUuid: excludeUuid,
          ),
          from: isVinUniqueProvider,
          name: r'isVinUniqueProvider',
          debugGetCreateSourceHash:
              const bool.fromEnvironment('dart.vm.product')
                  ? null
                  : _$isVinUniqueHash,
          dependencies: IsVinUniqueFamily._dependencies,
          allTransitiveDependencies:
              IsVinUniqueFamily._allTransitiveDependencies,
          vin: vin,
          excludeUuid: excludeUuid,
        );

  IsVinUniqueProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.vin,
    required this.excludeUuid,
  }) : super.internal();

  final String vin;
  final String? excludeUuid;

  @override
  Override overrideWith(
    FutureOr<bool> Function(IsVinUniqueRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: IsVinUniqueProvider._internal(
        (ref) => create(ref as IsVinUniqueRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        vin: vin,
        excludeUuid: excludeUuid,
      ),
    );
  }

  @override
  AutoDisposeFutureProviderElement<bool> createElement() {
    return _IsVinUniqueProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is IsVinUniqueProvider &&
        other.vin == vin &&
        other.excludeUuid == excludeUuid;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, vin.hashCode);
    hash = _SystemHash.combine(hash, excludeUuid.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin IsVinUniqueRef on AutoDisposeFutureProviderRef<bool> {
  /// The parameter `vin` of this provider.
  String get vin;

  /// The parameter `excludeUuid` of this provider.
  String? get excludeUuid;
}

class _IsVinUniqueProviderElement extends AutoDisposeFutureProviderElement<bool>
    with IsVinUniqueRef {
  _IsVinUniqueProviderElement(super.provider);

  @override
  String get vin => (origin as IsVinUniqueProvider).vin;
  @override
  String? get excludeUuid => (origin as IsVinUniqueProvider).excludeUuid;
}

String _$carsNotifierHash() => r'a8131c331555b29522f45c36d8ae9a0b6a43f1f2';

/// See also [CarsNotifier].
@ProviderFor(CarsNotifier)
final carsNotifierProvider = AutoDisposeAsyncNotifierProvider<CarsNotifier,
    List<CarWithOwnerModel>>.internal(
  CarsNotifier.new,
  name: r'carsNotifierProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$carsNotifierHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$CarsNotifier = AutoDisposeAsyncNotifier<List<CarWithOwnerModel>>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

```

## lib\features\references\vehicles\screens\cars_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart'; // Для сброса БД (оставим пока)
import 'package:part_catalog/core/providers/core_providers.dart';
import 'package:part_catalog/core/service_locator.dart';
import 'package:part_catalog/features/core/entity_core_data.dart';
// --- Обновленные импорты ---
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
import 'package:part_catalog/features/references/vehicles/models/car_specific_data.dart';
import 'package:part_catalog/features/references/vehicles/services/car_service.dart'; // Содержит CarWithOwnerModel
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
import 'dart:async'; // Для Timer и Future
import 'package:collection/collection.dart';
// --- Импорт провайдеров ---
import 'package:part_catalog/features/references/vehicles/providers/car_providers.dart';
import 'package:part_catalog/features/references/clients/providers/client_providers.dart';
import 'package:uuid/uuid.dart'; // Для clientServiceProvider и appLoggerProvider

// Преобразуем в ConsumerStatefulWidget
class CarsScreen extends ConsumerStatefulWidget {
  const CarsScreen({super.key});

  @override
  ConsumerState<CarsScreen> createState() => _CarsScreenState();
}

// Преобразуем State в ConsumerState
class _CarsScreenState extends ConsumerState<CarsScreen> {
  // Удаляем прямые зависимости, будем использовать ref
  // final _carService = locator<CarService>();
  // final _clientService = locator<ClientService>();
  late final Logger _logger; // Инициализируем в initState
  // bool _isDbError = false; // Управляется через AsyncValue

  // Фильтр по UUID клиента (теперь управляется через Notifier)
  // String? _selectedClientUuid;

  // Состояние для выбранного автомобиля (композитор) в десктоп режиме
  CarModelComposite? _selectedCar;

  @override
  void initState() {
    super.initState();
    _logger = ref.read(vehiclesLoggerProvider); // Инициализация логгера
  }

  // Определяем, является ли устройство десктопом
  bool _isDesktop(BuildContext context) {
    final platform = Theme.of(context).platform;
    return platform == TargetPlatform.windows ||
        platform == TargetPlatform.macOS ||
        platform == TargetPlatform.linux;
  }

  // Определяем размер экрана
  bool _isLargeScreen(BuildContext context) {
    return MediaQuery.of(context).size.width >= 900;
  }

  @override
  Widget build(BuildContext context) {
    final t = Translations.of(context);
    // Получаем текущий фильтр из Notifier'а (если нужно отображать его где-то)
    // final currentFilterUuid = ref.watch(carsNotifierProvider.select((state) => state.value?.clientFilterUuid)); // Пример, если бы фильтр был в состоянии

    // Получаем состояние списка автомобилей
    final carsAsyncValue = ref.watch(carsNotifierProvider);

    // Обработка ошибки БД перенесена в .when()

    final isDesktop = _isDesktop(context);
    final isLargeScreen = _isLargeScreen(context);

    // Получаем текущий UUID фильтра для UI
    // Мы не можем напрямую получить _clientFilterUuid из Notifier'а,
    // поэтому будем хранить его локально в State для UI целей (Dropdown, иконка фильтра)
    // или передавать его как параметр в build/провайдеры, если это возможно.
    // Проще всего - читать его из Notifier'а при необходимости действий.
    // Для отображения текущего значения в Dropdown/иконке - храним локально.
    // Но лучше, если Notifier будет предоставлять это значение.
    // Пока оставим локальное управление для UI фильтра.

    // Получаем текущий UUID фильтра для UI через публичный геттер Notifier'а
    String? currentClientFilterUuid =
        ref.watch(carsNotifierProvider.notifier).currentClientFilterUuid;

    if (isDesktop && isLargeScreen) {
      // --- Десктопный макет (Row) ---
      return Scaffold(
        appBar: AppBar(
          title: Text(t.vehicles.screenTitle),
          actions: [
            // Кнопка сброса фильтра
            if (currentClientFilterUuid != null)
              IconButton(
                icon: const Icon(Icons.filter_alt_off),
                onPressed: () {
                  ref.read(carsNotifierProvider.notifier).setClientFilter(null);
                  setState(() => _selectedCar = null); // Сброс деталей
                },
                tooltip: t.core.filterOff,
              ),
            // Кнопка добавления
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: _addCar,
              tooltip: t.vehicles.add,
            ),
          ],
        ),
        body: Row(
          children: [
            // Левая панель: Фильтр и Список
            Expanded(
              flex: 2,
              child: Column(
                children: [
                  // Виджет фильтра по клиентам
                  _buildClientFilter(
                      currentClientFilterUuid), // Передаем текущий фильтр
                  const Divider(),
                  // Список автомобилей
                  Expanded(
                    child: _buildCarsList(
                      carsAsyncValue: carsAsyncValue, // Передаем AsyncValue
                      selectedCarUuid: _selectedCar?.uuid,
                      onCarSelected: (car) {
                        setState(() {
                          _selectedCar = car;
                        });
                      },
                    ),
                  ),
                ],
              ),
            ),
            const VerticalDivider(width: 1),
            // Правая панель: Детали или заглушка
            Expanded(
              flex: 3,
              child: _selectedCar == null
                  ? Center(child: Text(t.vehicles.selectVehiclePrompt))
                  : Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: _buildCarDetails(_selectedCar!),
                    ),
            ),
          ],
        ),
      );
    } else {
      // --- Мобильный макет (Scaffold с FAB) ---
      return Scaffold(
        appBar: AppBar(
          title: Text(t.vehicles.screenTitle),
          actions: [
            // Кнопка фильтра
            IconButton(
              icon: Icon(currentClientFilterUuid == null
                  ? Icons.filter_alt_outlined
                  : Icons.filter_alt),
              onPressed: () => _showClientFilterDialog(
                  currentClientFilterUuid), // Передаем текущий фильтр
              tooltip: t.core.filter,
            ),
          ],
        ),
        // Список автомобилей
        body: _buildCarsList(
          carsAsyncValue: carsAsyncValue, // Передаем AsyncValue
          onCarSelected: (car) => _editCar(car),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: _addCar,
          child: const Icon(Icons.add),
        ),
      );
    }
  }

  // --- Виджет фильтра по клиентам (для десктопа) ---
  Widget _buildClientFilter(String? currentFilterUuid) {
    final t = Translations.of(context);
    // Используем ref.watch для получения списка клиентов
    final clientsAsyncValue = ref.watch(clientsForFilterProvider);

    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: clientsAsyncValue.when(
        data: (clients) {
          final items = [
            DropdownMenuItem<String?>(
              value: null,
              child: Text(t.core.all),
            ),
            ...clients.map((client) => DropdownMenuItem<String?>(
                  value: client.uuid,
                  child: Text(client.displayName),
                )),
          ];

          return DropdownButtonFormField<String?>(
            value: currentFilterUuid, // Используем переданное значение
            decoration: InputDecoration(
              labelText: t.clients.client,
              border: const OutlineInputBorder(),
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            ),
            items: items,
            onChanged: (value) {
              // Вызываем метод Notifier'а для установки фильтра
              ref.read(carsNotifierProvider.notifier).setClientFilter(value);
              setState(() {
                _selectedCar =
                    null; // Сбрасываем выбор машины при смене фильтра
              });
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) {
          _logger.e("Error loading clients for filter",
              error: error, stackTrace: stack);
          // Можно показать сообщение об ошибке или пустой Dropdown
          return DropdownButtonFormField<String?>(
            decoration: InputDecoration(
              labelText: t.clients.client,
              border: const OutlineInputBorder(),
              errorText: t.core.errorLoadingData(error: ''),
            ),
            items: const [],
            onChanged: null,
          );
        },
      ),
    );
  }

  // --- Диалог фильтра по клиентам (для мобильных) ---
  Future<void> _showClientFilterDialog(String? currentFilterUuid) async {
    final t = Translations.of(context);
    // Получаем список клиентов через ref.read (однократно)
    final clientsAsyncValue = await ref.read(clientsForFilterProvider.future);
    // Обработка ошибки загрузки клиентов (если нужна)
    // if (clientsAsyncValue is AsyncError) { ... }

    final clients = clientsAsyncValue; // Предполагаем успешную загрузку

    if (!mounted) return;

    final String? result = await showDialog<String?>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(t.core.filterByClient),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView(
            shrinkWrap: true,
            children: [
              ListTile(
                title: Text(t.core.all),
                leading: Radio<String?>(
                  value: null,
                  groupValue:
                      currentFilterUuid, // Используем переданное значение
                  onChanged: (value) => Navigator.of(dialogContext).pop(value),
                ),
                onTap: () => Navigator.of(dialogContext).pop(null),
              ),
              ...clients.map((client) => ListTile(
                    title: Text(client.displayName),
                    leading: Radio<String?>(
                      value: client.uuid,
                      groupValue:
                          currentFilterUuid, // Используем переданное значение
                      onChanged: (value) =>
                          Navigator.of(dialogContext).pop(value),
                    ),
                    onTap: () => Navigator.of(dialogContext).pop(client.uuid),
                  )),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(
                currentFilterUuid), // Возвращаем текущее значение при отмене
            child: Text(t.vehicles.cancel),
          ),
        ],
      ),
    );

    // Применяем выбранный фильтр, если он изменился
    if (result != currentFilterUuid) {
      ref.read(carsNotifierProvider.notifier).setClientFilter(result);
      setState(() {
        _selectedCar = null; // Сбрасываем выбор машины
      });
    }
  }

  // --- Виджет для отображения списка автомобилей ---
  Widget _buildCarsList({
    required AsyncValue<List<CarWithOwnerModel>>
        carsAsyncValue, // Принимаем AsyncValue
    required Function(CarModelComposite) onCarSelected,
    String? selectedCarUuid,
  }) {
    final t = Translations.of(context);
    final isDesktop = _isDesktop(context);

    // Используем .when для обработки состояний AsyncValue
    return carsAsyncValue.when(
      data: (cars) {
        // Фильтрация больше не нужна здесь, она в Notifier'е
        if (cars.isEmpty) {
          // Получаем текущий фильтр для текста
          final currentFilter =
              ref.read(carsNotifierProvider.notifier).currentClientFilterUuid;
          return Center(
            child: Text(currentFilter == null
                ? t.vehicles.emptyList
                : t.vehicles.noCarsAvailable),
          );
        }

        // --- DataTable для десктопа ---
        if (isDesktop) {
          return SingleChildScrollView(
            child: DataTable(
              showCheckboxColumn: false,
              columns: [
                DataColumn(label: Text(t.vehicles.make)),
                DataColumn(label: Text(t.vehicles.model)),
                DataColumn(label: Text(t.vehicles.owner)),
                DataColumn(label: Text(t.vehicles.licensePlate)),
              ],
              rows: cars.map((carWithOwner) {
                final car = carWithOwner.car;
                final owner = carWithOwner.owner;
                final isSelected = car.uuid == selectedCarUuid;

                return DataRow(
                  selected: isSelected,
                  onSelectChanged: (selected) {
                    if (selected ?? false) {
                      onCarSelected(car);
                    }
                  },
                  cells: [
                    DataCell(Text(car.make)),
                    DataCell(Text(car.model)),
                    DataCell(Text(owner.displayName)),
                    DataCell(Text(car.displayLicensePlate)),
                  ],
                );
              }).toList(),
            ),
          );
        } else {
          // --- ListView для мобильных ---
          return ListView.builder(
            itemCount: cars.length,
            itemBuilder: (context, index) {
              final carWithOwner = cars[index];
              final car = carWithOwner.car;
              final owner = carWithOwner.owner;

              return Dismissible(
                key: Key(car.uuid),
                background: Container(
                  color: Theme.of(context)
                      .colorScheme
                      .error, // Цвет фона ошибки из темы
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.only(right: 20.0),
                  child: Icon(
                    Icons.delete,
                    color: Theme.of(context)
                        .colorScheme
                        .onError, // Цвет иконки на фоне ошибки
                  ),
                ),
                direction: DismissDirection.endToStart,
                confirmDismiss: (direction) => _confirmDelete(car),
                onDismissed: (direction) =>
                    _deleteCar(car), // Вызываем новый метод
                child: Card(
                  margin: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 4.0),
                  child: ListTile(
                    title: Text('${car.make} ${car.model} (${car.year})'),
                    subtitle: Text(
                        '${t.vehicles.owner}: ${owner.displayName}\n${t.vehicles.vin}: ${car.vin}'),
                    isThreeLine: true,
                    trailing: Text(car.displayLicensePlate),
                    onTap: () => onCarSelected(car),
                  ),
                ),
              );
            },
          );
        }
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (error, stackTrace) {
        // Обработка ошибки БД
        if (error.toString().contains('no such table')) {
          _logger.e('${LogMessages.dbTableMissingError}: $error',
              error: error, stackTrace: stackTrace);
          // Показываем UI для сброса БД
          return _buildDbErrorUI(t); // Выносим в отдельный метод
        }
        _logger.e(LogMessages.dataLoadingError,
            error: error, stackTrace: stackTrace);
        return Center(
          child: Text(
            t.core.errorLoadingData(error: error.toString()),
            style: TextStyle(color: Theme.of(context).colorScheme.error),
          ),
        );
      },
    );
  }

  // --- UI для ошибки БД ---
  Widget _buildDbErrorUI(Translations t) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(t.vehicles.databaseError),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () async {
              final scaffoldMessenger = ScaffoldMessenger.of(context);
              try {
                // Логика сброса БД
                final db = locator<AppDatabase>();
                await db.resetDatabase();
                // Пересоздаем зависимости
                locator.unregister<AppDatabase>();
                locator.registerSingleton<AppDatabase>(AppDatabase());
                // Инвалидируем провайдеры Riverpod
                ref.invalidate(carServiceProvider);
                ref.invalidate(
                    clientServiceProvider); // Если CarService от него зависит
                ref.invalidate(carsNotifierProvider);
                ref.invalidate(clientsForFilterProvider);
                // Не нужно делать setState, Riverpod обновит UI
                if (mounted) {
                  scaffoldMessenger.showSnackBar(
                    SnackBar(content: Text(t.vehicles.resetDatabaseSuccess)),
                  );
                }
              } catch (e, s) {
                _logger.e(LogMessages.databaseResetError,
                    error: e, stackTrace: s);
                if (mounted) {
                  scaffoldMessenger.showSnackBar(
                    SnackBar(
                        content: Text(
                            '${LogMessages.databaseResetError}: ${e.toString()}')),
                  );
                }
              }
            },
            child: Text(t.vehicles.resetDatabase),
          )
        ],
      ),
    );
  }

  // --- Виджет для отображения детальной информации об автомобиле ---
  Widget _buildCarDetails(CarModelComposite car) {
    final t = Translations.of(context);
    // Получаем клиента через ref.watch или FutureProvider
    final clientAsyncValue = ref.watch(
        clientProvider(car.clientId)); // Предполагаем наличие clientProvider

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                car.displayName,
                style: Theme.of(context).textTheme.headlineSmall,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.edit),
                  tooltip: t.common.edit,
                  onPressed: () => _editCar(car),
                ),
                IconButton(
                  icon: const Icon(Icons.delete),
                  tooltip: t.common.delete,
                  onPressed: () async {
                    // Сохраняем context-зависимые значения ДО await
                    final bool isDesktop = _isDesktop(context);
                    final bool isLarge = _isLargeScreen(context);

                    // Асинхронный вызов
                    final confirmed = await _confirmDelete(car);

                    // Проверяем mounted ПОСЛЕ await
                    if (confirmed && mounted) {
                      _deleteCar(car); // Вызываем метод удаления
                      // Сбрасываем детали в десктопном режиме, используя сохраненные значения
                      if (isDesktop && isLarge) {
                        setState(() => _selectedCar = null);
                      }
                    }
                  },
                ),
              ],
            ),
          ],
        ),
        const Divider(),
        // Используем .when для отображения клиента
        clientAsyncValue.when(
            data: (client) => ListTile(
                  title: Text(t.vehicles.owner),
                  subtitle:
                      Text(client?.displayName ?? t.clients.clientNotFound),
                  leading: const Icon(Icons.person),
                ),
            loading: () => ListTile(
                  title: Text(t.vehicles.owner),
                  subtitle: Text(t.common.loading),
                  leading: const Icon(Icons.person),
                ),
            error: (e, s) {
              _logger.e('Error loading client details for car ${car.uuid}',
                  error: e, stackTrace: s);
              return ListTile(
                title: Text(t.vehicles.owner),
                subtitle: Text(t.core.errorLoadingData(
                    error: e.toString())), // Показываем ошибку
                leading:
                    const Icon(Icons.error, color: Colors.red), // Иконка ошибки
              );
            }),
        ListTile(
          title: Text(t.vehicles.vin),
          subtitle: Text(car.vin),
          leading: const Icon(Icons.confirmation_number),
        ),
        ListTile(
          title: Text(t.vehicles.licensePlate),
          subtitle: Text(car.displayLicensePlate),
          leading: const Icon(Icons.badge),
        ),
        ListTile(
          title: Text(t.vehicles.year),
          subtitle: Text(car.year.toString()),
          leading: const Icon(Icons.calendar_today),
        ),
        // Используем collection if
        if (car.additionalInfo?.isNotEmpty ??
            false) // Проверка на null и пустоту
          ListTile(
            title: Text(t.vehicles.additionalInfo),
            subtitle:
                Text(car.additionalInfo!), // Безопасно из-за проверки выше
            leading: const Icon(Icons.info_outline),
            isThreeLine: true,
          ), // Или ничего не отображаем, если null или пусто
        const Divider(),
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Text(t.vehicles.carHistory,
              style: Theme.of(context).textTheme.titleMedium),
        ),
        Expanded(
          child: Center(
            child: Text(t.vehicles.orderHistoryComingSoon),
          ),
          // TODO: ... интеграция с заказ-нарядами ...
        ),
      ],
    );
  }

  // --- Метод для подтверждения удаления автомобиля ---
  Future<bool> _confirmDelete(CarModelComposite car) async {
    // Получаем BuildContext, так как метод вызывается из build-контекста
    final currentContext = context;
    final t = Translations.of(currentContext); // Используем currentContext

    // Показываем диалог подтверждения
    final confirmed = await showDialog<bool>(
      context: currentContext, // Передаем context
      builder: (BuildContext dialogContext) {
        // Передаем builder
        return AlertDialog(
          title: Text(t.vehicles.deleteConfirmTitle),
          content: Text(t.vehicles.deleteConfirmMessage(
            make: car.make,
            model: car.model,
            vin: car.vin,
          )), // Используем ключ confirmDeleteMessage
          actions: <Widget>[
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(false), // Отмена
              child: Text(t.vehicles.cancel),
            ),
            TextButton(
              style: TextButton.styleFrom(
                foregroundColor: Theme.of(dialogContext).colorScheme.error,
              ),
              onPressed: () =>
                  Navigator.of(dialogContext).pop(true), // Подтверждение
              child: Text(t.common.delete),
            ),
          ],
        );
      },
    );
    // Возвращаем результат (true, если подтверждено, false или null, если отменено)
    return confirmed ?? false;
  }

  // --- Метод удаления (вызывается из onDismissed и _buildCarDetails) ---
  Future<void> _deleteCar(CarModelComposite car) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = Translations.of(context);
    final carUuid = car.uuid; // Сохраняем для Snackbar
    final carName = '${car.make} ${car.model}';

    try {
      // Вызываем метод Notifier'а
      await ref.read(carsNotifierProvider.notifier).deleteCar(carUuid);

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(t.vehicles.deleted(make: car.make, model: car.model)),
            action: SnackBarAction(
              label: t.common.undo,
              onPressed: () =>
                  _restoreCar(carUuid, carName), // Передаем UUID и имя
            ),
          ),
        );
      }
    } catch (e, s) {
      _logger.e(LogMessages.carDeleteError.replaceAll('{uuid}', carUuid),
          error: e, stackTrace: s);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(t.vehicles.deleteError(error: e.toString()))),
        );
      }
    }
  }

  // --- Метод восстановления ---
  Future<void> _restoreCar(String carUuid, String carName) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final t = Translations.of(context);
    try {
      await ref.read(carsNotifierProvider.notifier).restoreCar(carUuid);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
              content: Text(
                  t.vehicles.restored(name: carName))), // Нужен ключ restored
        );
      }
    } catch (e, s) {
      _logger.e(LogMessages.carRestoreError.replaceAll('{uuid}', carUuid),
          error: e, stackTrace: s);
      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(t.vehicles.restoreError(error: e.toString()))),
        );
      }
    }
  }

  // --- Методы добавления/редактирования ---
  Future<void> _addCar() async {
    final t = Translations.of(context);
    // Передаем ref в диалог
    final newCarComposite = await _showCarDialog(context, ref: ref);
    if (newCarComposite != null && mounted) {
      final scaffoldMessenger = ScaffoldMessenger.of(context);
      try {
        // Вызываем метод Notifier'а
        await ref.read(carsNotifierProvider.notifier).addCar(newCarComposite);
        if (mounted) {
          scaffoldMessenger.showSnackBar(SnackBar(
              content: Text(t.vehicles.added(
                  name: newCarComposite.displayName)))); // Нужен ключ added
        }
      } catch (e, stackTrace) {
        _logger.e(LogMessages.carAddError, error: e, stackTrace: stackTrace);
        if (mounted) {
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text(t.vehicles.addError(error: e.toString()))),
          );
        }
      }
    }
  }

  Future<void> _editCar(CarModelComposite car) async {
    final t = Translations.of(context);
    // Передаем ref и текущий композитор в диалог
    final updatedCarComposite =
        await _showCarDialog(context, car: car, ref: ref);
    if (updatedCarComposite != null && mounted) {
      final scaffoldMessenger = ScaffoldMessenger.of(context);
      try {
        // Вызываем метод Notifier'а
        await ref
            .read(carsNotifierProvider.notifier)
            .updateCar(updatedCarComposite);
        // Обновляем выбранный автомобиль в десктопном режиме
        if (_selectedCar != null &&
            _selectedCar!.uuid == updatedCarComposite.uuid) {
          setState(() => _selectedCar = updatedCarComposite);
        }
        if (mounted) {
          scaffoldMessenger.showSnackBar(SnackBar(
              content: Text(t.vehicles.updated(
                  name:
                      updatedCarComposite.displayName)))); // Нужен ключ updated
        }
      } catch (e, stackTrace) {
        _logger.e(LogMessages.carUpdateError.replaceAll('{uuid}', car.uuid),
            error: e, stackTrace: stackTrace);
        if (mounted) {
          scaffoldMessenger.showSnackBar(
            SnackBar(
                content: Text(t.vehicles.updateError(error: e.toString()))),
          );
        }
      }
    }
  }

  // --- Диалог добавления/редактирования автомобиля ---
  // Добавляем required WidgetRef ref
  Future<CarModelComposite?> _showCarDialog(BuildContext context,
      {CarModelComposite? car, required WidgetRef ref}) async {
    final t = Translations.of(context);
    final bool isEditing = car != null;

    // Контроллеры
    final makeController = TextEditingController(text: car?.make ?? '');
    final modelController =
        TextEditingController(text: car?.model ?? ''); // Добавлено
    final yearController =
        TextEditingController(text: car?.year.toString() ?? ''); // Добавлено
    final vinController = TextEditingController(text: car?.vin ?? '');
    final licensePlateController =
        TextEditingController(text: car?.licensePlate ?? ''); // Добавлено
    final additionalInfoController =
        TextEditingController(text: car?.additionalInfo ?? ''); // Добавлено

    // Состояние диалога
    ClientModelComposite? selectedClient;
    String? selectedClientUuid = car?.clientId;
    List<ClientModelComposite> clients = [];
    bool isLoading = true;
    String? vinError;
    bool vinCheckLoading = false; // Для индикатора проверки VIN

    final formKey = GlobalKey<FormState>();
    Timer? vinDebounce; // Дебаунс для проверки VIN

    // Функция для валидации VIN на уникальность (асинхронная)
    // Используем isVinUniqueProvider
    Future<void> validateVinUniqueness(String vin) async {
      if (vin.length != 17) {
        setState(() {
          // setState из StatefulBuilder
          vinError = t.vehicles.vinRequirement;
          vinCheckLoading = false;
        });
        return;
      }

      setState(() {
        // setState из StatefulBuilder
        vinCheckLoading = true;
        vinError = null; // Сбрасываем предыдущую ошибку
      });

      try {
        // Используем ref для доступа к провайдеру
        final isUnique = await ref.read(isVinUniqueProvider(
          vin: vin,
          excludeUuid: car?.uuid,
        ).future);

        // Проверяем mounted перед setStateDialog (хотя он внутри StatefulBuilder)
        if (mounted) {
          setState(() {
            // setState из StatefulBuilder
            vinError = isUnique ? null : t.vehicles.vinNotUnique;
            vinCheckLoading = false;
          });
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            // setState из StatefulBuilder
            vinError = t.vehicles.vinCheckError; // Ключ для ошибки проверки
            vinCheckLoading = false;
          });
        }
        _logger.e('Error checking VIN uniqueness', error: e);
      }
    }

    // Инициализация: загрузка клиентов и начальная валидация VIN
    Future<void> initializeDialog(StateSetter setStateDialog) async {
      final navigator = Navigator.of(context);
      final scaffoldMessenger = ScaffoldMessenger.of(context);

      try {
        // Получаем клиентов через ref
        clients = await ref.read(clientsForFilterProvider.future);
        if (selectedClientUuid != null) {
          selectedClient =
              clients.firstWhereOrNull((c) => c.uuid == selectedClientUuid);
        }
        if (isEditing && vinController.text.isNotEmpty) {
          // Вызываем валидацию через локальную функцию, которая использует setStateDialog
          await validateVinUniqueness(vinController.text);
        }
      } catch (error, stackTrace) {
        _logger.e(LogMessages.dataLoadingError,
            error: error, stackTrace: stackTrace);
        if (mounted) {
          navigator.pop();
          scaffoldMessenger.showSnackBar(
            SnackBar(
                content:
                    Text(t.core.errorLoadingData(error: error.toString()))),
          );
        }
      } finally {
        // Используем setStateDialog для обновления состояния диалога
        if (mounted) {
          // Проверка mounted для _CarsScreenState
          setStateDialog(() {
            isLoading = false;
          });
        }
      }
    }

    // Очистка debounce таймера при закрытии диалога
    void disposeDialog() {
      vinDebounce?.cancel();
    }

    return showDialog<CarModelComposite>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setState) {
            // Переименовали setState в setStateDialog для ясности
            // Вызываем инициализацию один раз
            if (isLoading) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                // Передаем setState диалога в initializeDialog
                initializeDialog(setState);
              });
            }

            // Определяем, валидна ли форма
            bool isFormValid = (formKey.currentState?.validate() ?? false) &&
                selectedClient != null &&
                vinError == null &&
                !vinCheckLoading; // Проверяем и загрузку VIN

            return PopScope(
              // Используем PopScope для очистки таймера
              canPop: !isLoading, // Нельзя закрыть во время загрузки
              onPopInvokedWithResult: (bool didPop, dynamic result) {
                if (didPop) {
                  disposeDialog();
                }
              },
              child: AlertDialog(
                title: Text(isEditing ? t.vehicles.edit : t.vehicles.add),
                content: isLoading
                    ? const Center(child: CircularProgressIndicator())
                    : SingleChildScrollView(
                        child: Form(
                          key: formKey,
                          autovalidateMode: AutovalidateMode.onUserInteraction,
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: <Widget>[
                              // --- Выбор клиента ---
                              DropdownButtonFormField<ClientModelComposite>(
                                value: selectedClient,
                                decoration: InputDecoration(
                                  labelText: t.clients.client,
                                  border: const OutlineInputBorder(),
                                ),
                                items: clients.map((client) {
                                  return DropdownMenuItem<ClientModelComposite>(
                                    value: client,
                                    child: Text(client.displayName),
                                  );
                                }).toList(),
                                onChanged: (value) {
                                  setState(() {
                                    // Используем setState диалога
                                    selectedClient = value;
                                    selectedClientUuid = value?.uuid;
                                  });
                                },
                                validator: (value) => value == null
                                    ? t.clients.clientRequired
                                    : null,
                              ),
                              const SizedBox(height: 16),
                              // --- Марка ---
                              TextFormField(
                                controller: makeController,
                                decoration: InputDecoration(
                                  labelText: t.vehicles.make,
                                  hintText: t.vehicles.makeHint,
                                  border: const OutlineInputBorder(),
                                ),
                                validator: (value) =>
                                    (value == null || value.isEmpty)
                                        ? t.vehicles.requiredField
                                        : null,
                              ),
                              const SizedBox(height: 16),
                              // --- Модель ---
                              TextFormField(
                                controller: modelController,
                                decoration: InputDecoration(
                                  labelText: t.vehicles.model,
                                  hintText: t.vehicles.modelHint,
                                  border: const OutlineInputBorder(),
                                ),
                                validator: (value) =>
                                    (value == null || value.isEmpty)
                                        ? t.vehicles.requiredField
                                        : null,
                              ),
                              const SizedBox(height: 16),
                              // --- Год ---
                              TextFormField(
                                controller: yearController,
                                decoration: InputDecoration(
                                  labelText: t.vehicles.year,
                                  hintText: t.vehicles.yearHint,
                                  border: const OutlineInputBorder(),
                                ),
                                keyboardType: TextInputType.number,
                                validator: (value) {
                                  if (value == null || value.isEmpty) {
                                    return t.vehicles.requiredField;
                                  }
                                  final year = int.tryParse(value);
                                  if (year == null ||
                                      year < 1900 ||
                                      year > DateTime.now().year + 1) {
                                    return t.vehicles.invalidYear;
                                  }
                                  return null;
                                },
                              ),
                              const SizedBox(height: 16),
                              // --- VIN ---
                              TextFormField(
                                controller: vinController,
                                decoration: InputDecoration(
                                  labelText: t.vehicles.vin,
                                  hintText: t.vehicles.vinHint,
                                  border: const OutlineInputBorder(),
                                  errorText: vinError,
                                  // Индикатор загрузки для VIN
                                  suffixIcon: vinCheckLoading
                                      ? const Padding(
                                          padding: EdgeInsets.all(10.0),
                                          child: SizedBox(
                                              width: 20,
                                              height: 20,
                                              child: CircularProgressIndicator(
                                                  strokeWidth: 2.0)),
                                        )
                                      : (vinError != null
                                          ? const Icon(Icons.error,
                                              color: Colors.red)
                                          : null),
                                ),
                                maxLength: 17,
                                textCapitalization:
                                    TextCapitalization.characters,
                                onChanged: (value) {
                                  // Дебаунс для проверки VIN
                                  vinDebounce?.cancel();
                                  vinDebounce =
                                      Timer(const Duration(milliseconds: 400),
                                          () async {
                                    // Вызываем валидацию через локальную функцию
                                    await validateVinUniqueness(value);
                                    // Обновляем состояние кнопки после проверки
                                    setState(
                                        () {}); // Используем setState диалога
                                  });
                                  // Обновляем состояние кнопки сразу
                                  setState(
                                      () {}); // Используем setState диалога
                                },
                                validator: (value) {
                                  // Валидатор для VIN (длина)
                                  if (value == null || value.isEmpty) {
                                    return t.vehicles.requiredField;
                                  }
                                  if (value.length != 17) {
                                    return t.vehicles.vinRequirement;
                                  }
                                  // Ошибка уникальности обрабатывается через vinError
                                  return null;
                                },
                              ),
                              const SizedBox(height: 16),
                              // --- Гос. номер ---
                              TextFormField(
                                controller:
                                    licensePlateController, // Теперь определен
                                decoration: InputDecoration(
                                  labelText: t.vehicles.licensePlate,
                                  hintText: t.vehicles.licensePlateHint,
                                  border: const OutlineInputBorder(),
                                ),
                                // TODO: Валидатор для гос. номера (опционально)
                              ),
                              const SizedBox(height: 16),
                              // --- Доп. информация ---
                              TextFormField(
                                controller:
                                    additionalInfoController, // Теперь определен
                                decoration: InputDecoration(
                                  labelText: t.vehicles.additionalInfo,
                                  hintText: t.vehicles.additionalInfoHint,
                                  border: const OutlineInputBorder(),
                                ),
                                maxLines: 3,
                              ),
                            ],
                          ),
                        ),
                      ),
                actions: <Widget>[
                  TextButton(
                    onPressed: () {
                      disposeDialog(); // Очищаем таймер при отмене
                      Navigator.of(context).pop(null);
                    },
                    child: Text(t.vehicles.cancel),
                  ),
                  ElevatedButton(
                    onPressed: isFormValid
                        ? () {
                            // Создаем или обновляем композитор
                            final now = DateTime.now();
                            final EntityCoreData
                                coreData; // Объявляем переменную
                            if (isEditing) {
                              coreData = car.coreData.copyWith(
                                modifiedAt: now, // Используем modifiedAt
                                // displayName можно обновить здесь или в композиторе, если нужно
                              );
                            } else {
                              // Используем стандартный конструктор EntityCoreData
                              coreData = EntityCoreData(
                                uuid:
                                    const Uuid().v4(), // Генерируем UUID здесь
                                code: vinController
                                    .text, // Используем VIN как код по умолчанию
                                displayName:
                                    '${makeController.text} ${modelController.text}',
                                createdAt: now,
                                modifiedAt: now, // Устанавливаем modifiedAt
                                isDeleted: false,
                                deletedAt: null,
                              );
                            }

                            final carSpecificData = CarSpecificData(
                              clientId: selectedClient!
                                  .uuid, // selectedClient не может быть null из-за isFormValid
                              make: makeController.text,
                              model: modelController.text,
                              year: int.parse(yearController
                                  .text), // Безопасно из-за валидатора
                              vin: vinController.text,
                              licensePlate: licensePlateController.text,
                              additionalInfo: additionalInfoController.text,
                            );

                            // Передаем coreData и carSpecificData позиционно
                            final resultCar = CarModelComposite.fromData(
                              coreData,
                              carSpecificData,
                            );

                            disposeDialog(); // Очищаем таймер при сохранении
                            Navigator.of(context).pop(resultCar);
                          }
                        : null, // Кнопка неактивна, если форма невалидна
                    child: Text(t.vehicles.save),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

```

## lib\features\references\vehicles\services\car_service.dart
```dart
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/daos/cars_dao.dart'; // Содержит CarFullData, CarWithOwnerData
// Импорт бизнес-модели (композитора)
import 'package:part_catalog/features/references/vehicles/models/car_model_composite.dart';
// Логгер и сообщения
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/core/utils/log_messages.dart';
// Импорт композитора клиента для CarWithOwnerModel
import 'package:part_catalog/features/references/clients/models/client_model_composite.dart';

/// Модель для представления автомобиля с информацией о владельце (использует композиторы).
class CarWithOwnerModel {
  final CarModelComposite car;
  final ClientModelComposite owner; // Используем композитор клиента

  CarWithOwnerModel({
    required this.car,
    required this.owner,
  });
}

/// {@template car_service}
/// Сервис для управления автомобилями.
/// Работает с бизнес-моделью [CarModelComposite] и взаимодействует
/// с DAO для получения/сохранения данных в виде @freezed моделей.
/// {@endtemplate}
class CarService {
  /// {@macro car_service}
  CarService(this._db)
      : _logger = AppLoggers.vehicles; // Используем настроенный логгер

  final AppDatabase _db;
  final Logger _logger;

  /// Получение DAO для работы с автомобилями
  CarsDao get _carsDao => _db.carsDao;

  // --- Приватные методы маппинга ---

  /// Маппинг из CarFullData (@freezed) в CarModelComposite (бизнес-модель)
  CarModelComposite _mapDataToComposite(CarFullData data) {
    // Используем фабричный конструктор fromData композитора
    return CarModelComposite.fromData(
      data.coreData,
      data.carData,
      // parentId, isFolder, ancestorIds, itemsMap пока не поддерживаются DAO
    );
  }

  /// Маппинг из CarWithOwnerData (@freezed) в CarWithOwnerModel (модель представления)
  CarWithOwnerModel _mapWithOwnerDataToViewModel(CarWithOwnerData data) {
    final carComposite = _mapDataToComposite(data.carFullData);
    // Создаем композитор клиента из данных владельца
    final ownerComposite = ClientModelComposite.fromData(
      data.ownerCoreData,
      data.ownerSpecificData,
      // parentId, isFolder, ancestorIds, itemsMap пока не поддерживаются DAO
    );
    return CarWithOwnerModel(
      car: carComposite,
      owner: ownerComposite,
    );
  }

  // --- Публичные методы сервиса ---

  /// Возвращает поток списка активных автомобилей [CarModelComposite].
  Stream<List<CarModelComposite>> watchActiveCars() {
    _logger.i(LogMessages.carWatchActive);
    return _carsDao.watchAllActiveCars().map(
          (dataList) => dataList.map(_mapDataToComposite).toList(),
        );
  }

  /// Возвращает поток списка активных автомобилей клиента [CarModelComposite].
  ///
  /// [clientUuid] - UUID клиента, автомобили которого нужно получить.
  Stream<List<CarModelComposite>> watchActiveClientCars(String clientUuid) {
    _logger
        .i(LogMessages.carWatchActiveByClient.replaceAll('{uuid}', clientUuid));
    return _carsDao.watchActiveClientCars(clientUuid).map(
          (dataList) => dataList.map(_mapDataToComposite).toList(),
        );
  }

  /// Возвращает автомобиль [CarModelComposite] по его UUID.
  Future<CarModelComposite?> getCarByUuid(String carUuid) async {
    _logger.i(LogMessages.carGetByUuid.replaceAll('{uuid}', carUuid));
    final carData = await _carsDao.getCarByUuid(carUuid);
    if (carData == null) {
      _logger.w(LogMessages.carNotFoundByUuid.replaceAll('{uuid}', carUuid));
      return null;
    }
    return _mapDataToComposite(carData);
  }

  /// Добавляет новый автомобиль.
  /// Принимает [CarModelComposite].
  /// Возвращает UUID созданного автомобиля.
  Future<String> addCar(CarModelComposite car) async {
    // UUID должен быть сгенерирован при создании композитора через .create()
    if (car.uuid.isEmpty) {
      _logger.e(LogMessages.carAddErrorMissingUuid);
      throw Exception(LogMessages.carAddErrorMissingUuid);
    }

    // Извлекаем @freezed модели из композитора
    final coreData = car.coreData;
    final carData = car.carData;

    try {
      // DAO вернет int ID, но нам нужен UUID
      await _carsDao.insertCar(coreData, carData);
      _logger.i(LogMessages.carCreated.replaceAll('{uuid}', car.uuid));
      return car.uuid;
    } catch (e, s) {
      _logger.e(LogMessages.carAddError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Обновляет существующий автомобиль.
  /// Принимает [CarModelComposite] с обновленными данными.
  Future<void> updateCar(CarModelComposite car) async {
    // Обновляем дату модификации перед сохранением
    final updatedCar = car.withModifiedDate(DateTime.now());

    // Извлекаем @freezed модели из обновленного композитора
    final coreData = updatedCar.coreData;
    final carData = updatedCar.carData;

    _logger.i(LogMessages.carUpdating.replaceAll('{uuid}', car.uuid));
    try {
      final updatedRows = await _carsDao.updateCarByUuid(coreData, carData);
      if (updatedRows == 0) {
        _logger
            .w(LogMessages.carNotFoundForUpdate.replaceAll('{uuid}', car.uuid));
        // Можно бросить исключение или просто завершить
      } else {
        _logger.d(LogMessages.carUpdated.replaceAll('{uuid}', car.uuid));
      }
    } catch (e, s) {
      _logger.e(LogMessages.carUpdateError.replaceAll('{uuid}', car.uuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Удаляет автомобиль (мягкое удаление).
  Future<void> deleteCar(String carUuid) async {
    _logger.i(LogMessages.carDeleting.replaceAll('{uuid}', carUuid));
    try {
      // Можно сначала получить автомобиль, чтобы убедиться, что он существует
      final car = await getCarByUuid(carUuid);
      if (car == null) {
        _logger
            .w(LogMessages.carNotFoundForDelete.replaceAll('{uuid}', carUuid));
        return; // Автомобиль не найден или уже удален
      }
      if (car.isDeleted) {
        _logger.w(LogMessages.carAlreadyDeleted.replaceAll('{uuid}', carUuid));
        return; // Уже удален
      }
      // Помечаем как удаленный и обновляем
      final deletedCar = car.markAsDeleted();
      await updateCar(deletedCar); // Используем общий метод обновления
      _logger.i(LogMessages.carDeleted.replaceAll('{uuid}', carUuid));
    } catch (e, s) {
      _logger.e(LogMessages.carDeleteError.replaceAll('{uuid}', carUuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Восстанавливает удалённый автомобиль.
  Future<void> restoreCar(String carUuid) async {
    _logger.i(LogMessages.carRestoring.replaceAll('{uuid}', carUuid));
    try {
      // Получаем автомобиль, включая удаленные
      final carData =
          await _carsDao.getCarByUuid(carUuid, includeDeleted: true);
      if (carData == null) {
        _logger
            .w(LogMessages.carNotFoundForRestore.replaceAll('{uuid}', carUuid));
        return;
      }
      final car = _mapDataToComposite(carData);

      if (!car.isDeleted) {
        _logger.w(LogMessages.carRestoreAttemptOnNonDeleted
            .replaceAll('{uuid}', carUuid));
        return; // Не удален
      }

      // Восстанавливаем и обновляем
      // Используем DAO напрямую для восстановления, чтобы не вызывать updateCar,
      // который снова обновит modifiedAt и может вызвать лишние срабатывания потоков.
      // final restoredCar = car.restore(); // Композитор больше не нужен для DAO
      // await updateCar(restoredCar); // Используем общий метод обновления - НЕ НАДО
      final restoredRows = await _carsDao.restoreCarByUuid(carUuid);
      if (restoredRows > 0) {
        _logger.i(LogMessages.carRestored.replaceAll('{uuid}', carUuid));
      } else {
        _logger
            .w(LogMessages.carNotFoundForRestore.replaceAll('{uuid}', carUuid));
      }
    } catch (e, s) {
      _logger.e(LogMessages.carRestoreError.replaceAll('{uuid}', carUuid),
          error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Проверяет уникальность VIN-кода.
  ///
  /// [vin] - VIN-код для проверки.
  /// [excludeUuid] - UUID автомобиля, который нужно исключить из проверки (при редактировании).
  Future<bool> isVinUnique(String vin, {String? excludeUuid}) async {
    _logger.d('Checking VIN uniqueness for "$vin", excluding $excludeUuid');
    try {
      final existingCar = await _carsDao.getCarByVin(vin);
      if (existingCar == null) {
        _logger.d('VIN "$vin" is unique (no car found).');
        return true; // VIN не найден, значит уникален
      }
      // Если VIN найден, проверяем, не принадлежит ли он автомобилю, который мы редактируем
      if (excludeUuid != null && existingCar.coreData.uuid == excludeUuid) {
        _logger.d(
            'VIN "$vin" belongs to the car being edited ($excludeUuid), considering unique.');
        return true; // Найденный VIN принадлежит редактируемому авто, считаем уникальным для других
      }
      _logger.w(
          'VIN "$vin" is not unique (found car ${existingCar.coreData.uuid}).');
      return false; // VIN найден и не принадлежит редактируемому авто
    } catch (e, s) {
      _logger.e('Error checking VIN uniqueness for "$vin"',
          error: e, stackTrace: s);
      // В случае ошибки лучше считать VIN не уникальным, чтобы предотвратить дублирование
      return false;
    }
  }

  /// Получает список автомобилей [CarWithOwnerModel] с информацией о владельцах.
  Future<List<CarWithOwnerModel>> getCarsWithOwners() async {
    _logger.i(LogMessages.carGetWithOwners);
    try {
      final results = await _carsDao.getCarsWithOwners();
      return results.map(_mapWithOwnerDataToViewModel).toList();
    } catch (e, s) {
      _logger.e(LogMessages.carGetWithOwnersError, error: e, stackTrace: s);
      rethrow;
    }
  }

  /// Возвращает поток списка автомобилей [CarWithOwnerModel] с информацией о владельцах.
  Stream<List<CarWithOwnerModel>> watchCarsWithOwners() {
    _logger
        .i(LogMessages.carWatchWithOwners); // Добавим сообщение в LogMessages
    try {
      return _carsDao.watchCarsWithOwners().map(
            (dataList) => dataList.map(_mapWithOwnerDataToViewModel).toList(),
          );
    } catch (e, s) {
      // Логгирование здесь может быть избыточным, т.к. StreamBuilder обработает ошибку
      _logger.e(LogMessages.carWatchWithOwnersError,
          error: e, stackTrace: s); // Добавим сообщение в LogMessages
      // Перебрасываем ошибку, чтобы StreamBuilder мог ее поймать
      return Stream.error(e, s);
    }
  }
}

```

## lib\features\settings\api_control_center\notifiers\api_control_center_notifier.dart
```dart
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/config/global_api_settings_service.dart';
import 'package:part_catalog/core/database/daos/supplier_settings_dao.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/features/settings/api_control_center/state/api_control_center_state.dart';
import 'package:part_catalog/features/suppliers/api/api_connection_mode.dart';
import 'package:part_catalog/features/suppliers/config/supported_suppliers.dart';

final apiControlCenterNotifierProvider =
    StateNotifierProvider<ApiControlCenterNotifier, ApiControlCenterState>(
        (ref) {
  return ApiControlCenterNotifier(
    ref.watch(globalApiSettingsServiceProvider),
    ref
        .watch(appDatabaseProvider)
        .supplierSettingsDao, // Получаем DAO из провайдера БД
    ref.watch(appDatabaseProvider), // Передаем AppDatabase
  );
});

class ApiControlCenterNotifier extends StateNotifier<ApiControlCenterState> {
  final GlobalApiSettingsService _settingsService;
  final SupplierSettingsDao _supplierSettingsDao;
  final AppDatabase _appDatabase; // Добавляем AppDatabase
  final _logger = appLogger('ApiControlCenterNotifier');

  ApiControlCenterNotifier(
    this._settingsService,
    this._supplierSettingsDao,
    this._appDatabase, // Инициализируем AppDatabase
  ) : super(ApiControlCenterState.initial()) {
    loadInitialData();
  }

  Future<void> loadInitialData() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final mode = await _settingsService.getApiConnectionMode();
      final url = await _settingsService.getProxyUrl();

      // Загружаем все настройки поставщиков
      final allSettings = await _supplierSettingsDao.getAllSupplierSettings();
      final Map<String, SupplierSettingsItem> settingsMap = {
        for (var s in allSettings) s.supplierCode: s
      };

      final List<SupplierDisplayInfo> supplierInfos = [];
      for (var supportedSupplier in allSupportedSuppliers) {
        final setting = settingsMap[supportedSupplier.code];
        supplierInfos.add(SupplierDisplayInfo(
          code: supportedSupplier.code,
          displayName: supportedSupplier.displayName,
          // TODO: Улучшить логику определения статуса
          status: setting?.lastCheckStatus ?? 'Не настроен',
          isConfigured: setting != null &&
              (setting.encryptedCredentials?.isNotEmpty ?? false),
          // icon: supportedSupplier.icon, // Если добавили иконки в enum
        ));
      }

      state = state.copyWith(
        apiMode: mode,
        proxyUrl: url ?? '',
        suppliers: supplierInfos,
        isLoading: false,
      );
      _logger.i(
          'Initial data loaded: mode=$mode, suppliers=${supplierInfos.length}');
    } catch (e, s) {
      _logger.e('Error loading initial data', error: e, stackTrace: s);
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  Future<void> setApiConnectionMode(ApiConnectionMode mode) async {
    state = state.copyWith(apiMode: mode, isLoading: true);
    try {
      await _settingsService.setApiConnectionMode(mode);
      // TODO: Уведомить ApiClientManager об изменении режима
      _logger.i('API connection mode set to: ${mode.name}');
      state = state.copyWith(isLoading: false);
    } catch (e, s) {
      _logger.e('Error setting API connection mode', error: e, stackTrace: s);
      state = state.copyWith(isLoading: false, error: e.toString());
      // Можно откатить изменение state.apiMode, если сохранение не удалось
    }
  }

  Future<void> setProxyUrl(String url) async {
    state = state.copyWith(proxyUrl: url, isLoading: true);
    try {
      await _settingsService.setProxyUrl(url);
      // TODO: Уведомить ApiClientManager об изменении URL
      _logger.i('Proxy URL set to: $url');
      state = state.copyWith(isLoading: false);
    } catch (e, s) {
      _logger.e('Error setting proxy URL', error: e, stackTrace: s);
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  // Метод для добавления/обновления настроек поставщика (заглушка для демонстрации)
  // В реальности это будет происходить на экране настроек конкретного поставщика
  Future<void> addOrUpdateTestSupplierSetting(
      SupplierCode supplierCode, bool configured) async {
    _logger.i(
        'Attempting to update test setting for ${supplierCode.code}, configured: $configured');
    try {
      final companion = SupplierSettingsItemsCompanion(
        supplierCode: Value(supplierCode.code),
        isEnabled: const Value(true),
        encryptedCredentials:
            Value(configured ? 'test_encrypted_data' : null), // Заглушка
        lastCheckStatus:
            Value(configured ? 'success' : 'not_configured'), // Заглушка
        additionalConfig:
            Value(configured ? '{"some_config":"value"}' : null), // Заглушка
        updatedAt: Value(DateTime.now()),
      );

      // Используем транзакцию для атомарности, если нужно несколько операций
      await _appDatabase.transaction(() async {
        await _supplierSettingsDao.upsertSupplierSetting(companion);
      });

      _logger.i('Test setting for ${supplierCode.code} updated in DB.');
      await loadInitialData(); // Перезагружаем данные, чтобы обновить UI
    } catch (e, s) {
      _logger.e('Error updating test supplier setting for ${supplierCode.code}',
          error: e, stackTrace: s);
      // Обработка ошибки (например, показать SnackBar)
    }
  }
}

```

## lib\features\settings\api_control_center\screens\api_control_center_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:part_catalog/features/suppliers/api/api_connection_mode.dart';
// import 'package:part_catalog/core/config/global_api_settings_service.dart'; // Больше не нужен напрямую
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/features/settings/api_control_center/notifiers/api_control_center_notifier.dart';
import 'package:part_catalog/features/settings/api_control_center/state/api_control_center_state.dart';
import 'package:part_catalog/features/suppliers/config/supported_suppliers.dart'; // Для тестовой кнопки

class ApiControlCenterScreen extends ConsumerWidget {
  const ApiControlCenterScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final t = Translations.of(context);
    final state = ref.watch(apiControlCenterNotifierProvider);
    final notifier = ref.read(apiControlCenterNotifierProvider.notifier);
    final logger = appLogger(
        'ApiControlCenterScreen'); // Логгер можно инициализировать здесь

    final TextEditingController proxyUrlController =
        TextEditingController(text: state.proxyUrl);
    // Слушатель для обновления текста в контроллере, если он изменится извне
    ref.listen<ApiControlCenterState>(apiControlCenterNotifierProvider,
        (previous, next) {
      if (previous?.proxyUrl != next.proxyUrl) {
        proxyUrlController.text = next.proxyUrl;
        proxyUrlController.selection = TextSelection.fromPosition(
            TextPosition(offset: proxyUrlController.text.length));
      }
    });

    if (state.isLoading && state.suppliers.isEmpty) {
      // Показываем загрузку только при первой загрузке
      return Scaffold(
        appBar: AppBar(
          title: Text(t.settings.apiControlCenter.screenTitle),
        ),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    if (state.error != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ошибка: ${state.error}')),
        );
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(t.settings.apiControlCenter.screenTitle),
        actions: [
          if (state.isLoading)
            const Padding(
              padding: EdgeInsets.only(right: 16.0),
              child: Center(
                  child: SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                      ))),
            )
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              t.settings.apiControlCenter.apiConnectionMode,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            RadioListTile<ApiConnectionMode>(
              title: Text(t.settings.apiControlCenter.directMode),
              value: ApiConnectionMode.direct,
              groupValue: state.apiMode,
              onChanged: (ApiConnectionMode? value) {
                if (value != null) {
                  notifier.setApiConnectionMode(value);
                }
              },
            ),
            RadioListTile<ApiConnectionMode>(
              title: Text(t.settings.apiControlCenter.proxyMode),
              value: ApiConnectionMode.proxy,
              groupValue: state.apiMode,
              onChanged: (ApiConnectionMode? value) {
                if (value != null) {
                  notifier.setApiConnectionMode(value);
                }
              },
            ),
            if (state.apiMode == ApiConnectionMode.proxy)
              Padding(
                padding:
                    const EdgeInsets.only(top: 8.0, left: 16.0, right: 16.0),
                child: TextFormField(
                  controller: proxyUrlController,
                  decoration: InputDecoration(
                    labelText: t.settings.apiControlCenter.proxyUrlLabel,
                    hintText: t.settings.apiControlCenter.proxyUrlHint,
                    border: const OutlineInputBorder(),
                  ),
                  onEditingComplete: () {
                    notifier.setProxyUrl(proxyUrlController.text);
                    FocusScope.of(context).unfocus(); // Скрыть клавиатуру
                  },
                ),
              ),
            const SizedBox(height: 24),
            Text(
              t.settings.apiControlCenter.suppliersListTitle,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            if (state.suppliers.isEmpty && !state.isLoading)
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Center(child: Text(t.core.noDataAvailable)),
              ),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: state.suppliers.length,
              itemBuilder: (context, index) {
                final supplierInfo = state.suppliers[index];
                return _buildSupplierTile(context,
                    // icon: supplierInfo.icon ?? Icons.business_center, // Используем иконку или дефолтную
                    icon: Icons.business_center, // Заглушка иконки
                    name: supplierInfo.displayName,
                    status: supplierInfo.status,
                    isConfigured: supplierInfo.isConfigured, onConfigure: () {
                  logger.i(
                      'Configure button pressed for ${supplierInfo.displayName}');
                  // TODO: Навигация на экран настроек supplierInfo.code
                  // Например, context.go('/settings/suppliers/${supplierInfo.code}');
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                        content: Text(
                            'Переход к настройкам ${supplierInfo.displayName} (TODO)')),
                  );
                },
                    // Тестовая кнопка для имитации сохранения настроек
                    onTestToggleConfigured: () {
                  final sc = SupplierCode.values
                      .firstWhere((e) => e.code == supplierInfo.code);
                  notifier.addOrUpdateTestSupplierSetting(
                      sc, !supplierInfo.isConfigured);
                });
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSupplierTile(
    BuildContext context, {
    required IconData icon,
    required String name,
    required String status,
    required bool isConfigured,
    required VoidCallback onConfigure,
    required VoidCallback onTestToggleConfigured, // Тестовый коллбэк
  }) {
    final t = Translations.of(context);
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      child: ListTile(
        leading: Icon(icon,
            size: 40, color: isConfigured ? Colors.green : Colors.grey),
        title: Text(name),
        subtitle: Text(status),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Тестовая кнопка для переключения статуса isConfigured
            IconButton(
              icon: Icon(
                isConfigured ? Icons.toggle_on : Icons.toggle_off,
                color: isConfigured ? Colors.green : Colors.grey,
                size: 30,
              ),
              tooltip:
                  'Тест: ${isConfigured ? "Сделать не настроенным" : "Сделать настроенным"}',
              onPressed: onTestToggleConfigured,
            ),
            const SizedBox(width: 8),
            ElevatedButton(
              onPressed: onConfigure,
              child: Text(t.settings.apiControlCenter.configureButton),
            ),
          ],
        ),
      ),
    );
  }
}

```

## lib\features\settings\api_control_center\state\api_control_center_state.dart
```dart
//import 'package:flutter/material.dart'; // Для IconData, если будете использовать
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/features/suppliers/api/api_connection_mode.dart';

part 'api_control_center_state.freezed.dart';

@freezed
abstract class SupplierDisplayInfo with _$SupplierDisplayInfo {
  const factory SupplierDisplayInfo({
    required String code,
    required String displayName,
    required String status,
    required bool isConfigured,
    // IconData? icon, // Если будете использовать иконки
  }) = _SupplierDisplayInfo;
}

@freezed
abstract class ApiControlCenterState with _$ApiControlCenterState {
  const factory ApiControlCenterState({
    @Default(ApiConnectionMode.direct) ApiConnectionMode apiMode,
    @Default('') String proxyUrl,
    @Default([]) List<SupplierDisplayInfo> suppliers,
    @Default(true) bool isLoading,
    String? error,
  }) = _ApiControlCenterState;

  factory ApiControlCenterState.initial() => const ApiControlCenterState();
}

```

## lib\features\settings\api_control_center\state\api_control_center_state.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_control_center_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$SupplierDisplayInfo {
  String get code;
  String get displayName;
  String get status;
  bool get isConfigured;

  /// Create a copy of SupplierDisplayInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SupplierDisplayInfoCopyWith<SupplierDisplayInfo> get copyWith =>
      _$SupplierDisplayInfoCopyWithImpl<SupplierDisplayInfo>(
          this as SupplierDisplayInfo, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SupplierDisplayInfo &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isConfigured, isConfigured) ||
                other.isConfigured == isConfigured));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, code, displayName, status, isConfigured);

  @override
  String toString() {
    return 'SupplierDisplayInfo(code: $code, displayName: $displayName, status: $status, isConfigured: $isConfigured)';
  }
}

/// @nodoc
abstract mixin class $SupplierDisplayInfoCopyWith<$Res> {
  factory $SupplierDisplayInfoCopyWith(
          SupplierDisplayInfo value, $Res Function(SupplierDisplayInfo) _then) =
      _$SupplierDisplayInfoCopyWithImpl;
  @useResult
  $Res call(
      {String code, String displayName, String status, bool isConfigured});
}

/// @nodoc
class _$SupplierDisplayInfoCopyWithImpl<$Res>
    implements $SupplierDisplayInfoCopyWith<$Res> {
  _$SupplierDisplayInfoCopyWithImpl(this._self, this._then);

  final SupplierDisplayInfo _self;
  final $Res Function(SupplierDisplayInfo) _then;

  /// Create a copy of SupplierDisplayInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? displayName = null,
    Object? status = null,
    Object? isConfigured = null,
  }) {
    return _then(_self.copyWith(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      isConfigured: null == isConfigured
          ? _self.isConfigured
          : isConfigured // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _SupplierDisplayInfo implements SupplierDisplayInfo {
  const _SupplierDisplayInfo(
      {required this.code,
      required this.displayName,
      required this.status,
      required this.isConfigured});

  @override
  final String code;
  @override
  final String displayName;
  @override
  final String status;
  @override
  final bool isConfigured;

  /// Create a copy of SupplierDisplayInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SupplierDisplayInfoCopyWith<_SupplierDisplayInfo> get copyWith =>
      __$SupplierDisplayInfoCopyWithImpl<_SupplierDisplayInfo>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SupplierDisplayInfo &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.isConfigured, isConfigured) ||
                other.isConfigured == isConfigured));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, code, displayName, status, isConfigured);

  @override
  String toString() {
    return 'SupplierDisplayInfo(code: $code, displayName: $displayName, status: $status, isConfigured: $isConfigured)';
  }
}

/// @nodoc
abstract mixin class _$SupplierDisplayInfoCopyWith<$Res>
    implements $SupplierDisplayInfoCopyWith<$Res> {
  factory _$SupplierDisplayInfoCopyWith(_SupplierDisplayInfo value,
          $Res Function(_SupplierDisplayInfo) _then) =
      __$SupplierDisplayInfoCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String code, String displayName, String status, bool isConfigured});
}

/// @nodoc
class __$SupplierDisplayInfoCopyWithImpl<$Res>
    implements _$SupplierDisplayInfoCopyWith<$Res> {
  __$SupplierDisplayInfoCopyWithImpl(this._self, this._then);

  final _SupplierDisplayInfo _self;
  final $Res Function(_SupplierDisplayInfo) _then;

  /// Create a copy of SupplierDisplayInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = null,
    Object? displayName = null,
    Object? status = null,
    Object? isConfigured = null,
  }) {
    return _then(_SupplierDisplayInfo(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      isConfigured: null == isConfigured
          ? _self.isConfigured
          : isConfigured // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$ApiControlCenterState {
  ApiConnectionMode get apiMode;
  String get proxyUrl;
  List<SupplierDisplayInfo> get suppliers;
  bool get isLoading;
  String? get error;

  /// Create a copy of ApiControlCenterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ApiControlCenterStateCopyWith<ApiControlCenterState> get copyWith =>
      _$ApiControlCenterStateCopyWithImpl<ApiControlCenterState>(
          this as ApiControlCenterState, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiControlCenterState &&
            (identical(other.apiMode, apiMode) || other.apiMode == apiMode) &&
            (identical(other.proxyUrl, proxyUrl) ||
                other.proxyUrl == proxyUrl) &&
            const DeepCollectionEquality().equals(other.suppliers, suppliers) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, apiMode, proxyUrl,
      const DeepCollectionEquality().hash(suppliers), isLoading, error);

  @override
  String toString() {
    return 'ApiControlCenterState(apiMode: $apiMode, proxyUrl: $proxyUrl, suppliers: $suppliers, isLoading: $isLoading, error: $error)';
  }
}

/// @nodoc
abstract mixin class $ApiControlCenterStateCopyWith<$Res> {
  factory $ApiControlCenterStateCopyWith(ApiControlCenterState value,
          $Res Function(ApiControlCenterState) _then) =
      _$ApiControlCenterStateCopyWithImpl;
  @useResult
  $Res call(
      {ApiConnectionMode apiMode,
      String proxyUrl,
      List<SupplierDisplayInfo> suppliers,
      bool isLoading,
      String? error});
}

/// @nodoc
class _$ApiControlCenterStateCopyWithImpl<$Res>
    implements $ApiControlCenterStateCopyWith<$Res> {
  _$ApiControlCenterStateCopyWithImpl(this._self, this._then);

  final ApiControlCenterState _self;
  final $Res Function(ApiControlCenterState) _then;

  /// Create a copy of ApiControlCenterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? apiMode = null,
    Object? proxyUrl = null,
    Object? suppliers = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_self.copyWith(
      apiMode: null == apiMode
          ? _self.apiMode
          : apiMode // ignore: cast_nullable_to_non_nullable
              as ApiConnectionMode,
      proxyUrl: null == proxyUrl
          ? _self.proxyUrl
          : proxyUrl // ignore: cast_nullable_to_non_nullable
              as String,
      suppliers: null == suppliers
          ? _self.suppliers
          : suppliers // ignore: cast_nullable_to_non_nullable
              as List<SupplierDisplayInfo>,
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _ApiControlCenterState implements ApiControlCenterState {
  const _ApiControlCenterState(
      {this.apiMode = ApiConnectionMode.direct,
      this.proxyUrl = '',
      final List<SupplierDisplayInfo> suppliers = const [],
      this.isLoading = true,
      this.error})
      : _suppliers = suppliers;

  @override
  @JsonKey()
  final ApiConnectionMode apiMode;
  @override
  @JsonKey()
  final String proxyUrl;
  final List<SupplierDisplayInfo> _suppliers;
  @override
  @JsonKey()
  List<SupplierDisplayInfo> get suppliers {
    if (_suppliers is EqualUnmodifiableListView) return _suppliers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_suppliers);
  }

  @override
  @JsonKey()
  final bool isLoading;
  @override
  final String? error;

  /// Create a copy of ApiControlCenterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ApiControlCenterStateCopyWith<_ApiControlCenterState> get copyWith =>
      __$ApiControlCenterStateCopyWithImpl<_ApiControlCenterState>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ApiControlCenterState &&
            (identical(other.apiMode, apiMode) || other.apiMode == apiMode) &&
            (identical(other.proxyUrl, proxyUrl) ||
                other.proxyUrl == proxyUrl) &&
            const DeepCollectionEquality()
                .equals(other._suppliers, _suppliers) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, apiMode, proxyUrl,
      const DeepCollectionEquality().hash(_suppliers), isLoading, error);

  @override
  String toString() {
    return 'ApiControlCenterState(apiMode: $apiMode, proxyUrl: $proxyUrl, suppliers: $suppliers, isLoading: $isLoading, error: $error)';
  }
}

/// @nodoc
abstract mixin class _$ApiControlCenterStateCopyWith<$Res>
    implements $ApiControlCenterStateCopyWith<$Res> {
  factory _$ApiControlCenterStateCopyWith(_ApiControlCenterState value,
          $Res Function(_ApiControlCenterState) _then) =
      __$ApiControlCenterStateCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ApiConnectionMode apiMode,
      String proxyUrl,
      List<SupplierDisplayInfo> suppliers,
      bool isLoading,
      String? error});
}

/// @nodoc
class __$ApiControlCenterStateCopyWithImpl<$Res>
    implements _$ApiControlCenterStateCopyWith<$Res> {
  __$ApiControlCenterStateCopyWithImpl(this._self, this._then);

  final _ApiControlCenterState _self;
  final $Res Function(_ApiControlCenterState) _then;

  /// Create a copy of ApiControlCenterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? apiMode = null,
    Object? proxyUrl = null,
    Object? suppliers = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_ApiControlCenterState(
      apiMode: null == apiMode
          ? _self.apiMode
          : apiMode // ignore: cast_nullable_to_non_nullable
              as ApiConnectionMode,
      proxyUrl: null == proxyUrl
          ? _self.proxyUrl
          : proxyUrl // ignore: cast_nullable_to_non_nullable
              as String,
      suppliers: null == suppliers
          ? _self._suppliers
          : suppliers // ignore: cast_nullable_to_non_nullable
              as List<SupplierDisplayInfo>,
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\settings\armtek\notifiers\armtek_settings_notifier.dart
```dart
import 'dart:convert';
import 'package:drift/drift.dart' hide JsonKey;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/database/daos/supplier_settings_dao.dart';
import 'package:part_catalog/core/providers/database_providers.dart';
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/features/settings/armtek/state/armtek_settings_state.dart';
import 'package:part_catalog/features/suppliers/api/api_client_manager.dart';
import 'package:part_catalog/features/suppliers/api/implementations/armtek_api_client.dart'; // Предполагается наличие
import 'package:part_catalog/core/service_locator.dart'; // Для ApiClientManager

const String armtekSupplierCode = 'armtek';

final armtekSettingsNotifierProvider = StateNotifierProvider.autoDispose<
    ArmtekSettingsNotifier, ArmtekSettingsState>((ref) {
  final supplierSettingsDao = ref.watch(supplierSettingsDaoProvider);
  // ApiClientManager должен быть зарегистрирован в service_locator
  final apiClientManager = locator<ApiClientManager>();
  return ArmtekSettingsNotifier(supplierSettingsDao, apiClientManager);
});

class ArmtekSettingsNotifier extends StateNotifier<ArmtekSettingsState> {
  final SupplierSettingsDao _supplierSettingsDao;
  final ApiClientManager _apiClientManager;
  final _logger = appLogger('ArmtekSettingsNotifier');

  ArmtekSettingsNotifier(this._supplierSettingsDao, this._apiClientManager)
      : super(ArmtekSettingsState.initial()) {
    _loadInitialSettings();
  }

  Future<void> _loadInitialSettings() async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    try {
      final setting = await _supplierSettingsDao
          .getSupplierSettingByCode(armtekSupplierCode);
      String initialLogin = '';
      String initialPassword = '';
      String? initialSelectedVkorg;

      if (setting != null && setting.encryptedCredentials != null) {
        try {
          // Пока без шифрования, просто парсим JSON
          final credentialsMap =
              jsonDecode(setting.encryptedCredentials!) as Map<String, dynamic>;
          initialLogin = credentialsMap['username'] as String? ?? '';
          initialPassword = credentialsMap['password'] as String? ?? '';
        } catch (e) {
          _logger.w(
              'Could not parse credentials from DB for $armtekSupplierCode',
              error: e);
        }
      }
      if (setting != null && setting.additionalConfig != null) {
        try {
          final additionalConfigMap =
              jsonDecode(setting.additionalConfig!) as Map<String, dynamic>;
          initialSelectedVkorg =
              additionalConfigMap['selectedVkorg'] as String?;
        } catch (e) {
          _logger.w(
              'Could not parse additionalConfig from DB for $armtekSupplierCode',
              error: e);
        }
      }

      state = state.copyWith(
        isLoading: false,
        currentSetting: setting,
        loginInput: initialLogin,
        // passwordInput: initialPassword, // Не заполняем пароль из безопасности
        isConnected: setting?.lastCheckStatus == 'success',
        connectionStatusMessage: setting?.lastCheckMessage,
        selectedVkorg: initialSelectedVkorg,
      );

      if (state.isConnected && initialLogin.isNotEmpty) {
        // Если уже подключены, пытаемся загрузить VKORG
        await _fetchUserVkorgList(initialLogin, initialPassword);
        if (initialSelectedVkorg != null && state.userVkorgList != null) {
          await _fetchArmtekSpecificData(
              initialLogin, initialPassword, initialSelectedVkorg);
        }
      }
    } catch (e, s) {
      _logger.e('Error loading initial Armtek settings',
          error: e, stackTrace: s);
      state = state.copyWith(
          isLoading: false, errorMessage: 'Ошибка загрузки начальных настроек');
    }
  }

  void updateLogin(String login) {
    state = state.copyWith(loginInput: login);
  }

  void updatePassword(String password) {
    state = state.copyWith(passwordInput: password);
  }

  Future<void> checkAndSaveConnection() async {
    if (state.loginInput.isEmpty || state.passwordInput.isEmpty) {
      state = state.copyWith(
          connectionStatusMessage: 'Логин и пароль не могут быть пустыми');
      return;
    }
    state = state.copyWith(isLoading: true, errorMessage: null);

    // Пока без шифрования
    final credentialsJson = jsonEncode({
      'username': state.loginInput,
      'password': state.passwordInput,
    });

    final companion = SupplierSettingsItemsCompanion(
      supplierCode: const Value(armtekSupplierCode),
      isEnabled: const Value(true),
      encryptedCredentials: Value(credentialsJson),
      updatedAt: Value(DateTime.now()),
    );

    try {
      await _supplierSettingsDao.upsertSupplierSetting(companion);
      final updatedSetting = await _supplierSettingsDao
          .getSupplierSettingByCode(armtekSupplierCode);

      // Создаем клиент для проверки
      // Важно: ApiClientManager должен уметь создавать ArmtekApiClient
      // на основе предоставленных (или сохраненных) учетных данных.
      // Для этого ArmtekApiClient должен принимать их в конструкторе.
      // Здесь мы создаем временный клиент для проверки.
      final armtekClient = ArmtekApiClient(
        username: state.loginInput,
        password: state.passwordInput,
        // httpClient: ..., // Dio должен быть предоставлен
      );

      final pingResult =
          await armtekClient.ping(); // Предполагаем, что метод ping есть

      if (pingResult) {
        // Замените на реальную проверку ответа ping
        await _supplierSettingsDao.upsertSupplierSetting(
          companion.copyWith(
            lastCheckStatus: const Value('success'),
            lastCheckMessage: const Value('Подключение успешно'),
            lastSuccessfulCheckAt: Value(DateTime.now()),
          ),
        );
        state = state.copyWith(
          isLoading: false,
          isConnected: true,
          connectionStatusMessage: 'Подключение успешно',
          currentSetting: updatedSetting,
        );
        await _fetchUserVkorgList(state.loginInput, state.passwordInput);
      } else {
        throw Exception('Ошибка проверки подключения (ping failed)');
      }
    } catch (e, s) {
      _logger.e('Error checking/saving Armtek connection',
          error: e, stackTrace: s);
      await _supplierSettingsDao.upsertSupplierSetting(
        companion.copyWith(
          lastCheckStatus: const Value('error_auth'), // или error_network
          lastCheckMessage: Value('Ошибка подключения: ${e.toString()}'),
        ),
      );
      final updatedSetting = await _supplierSettingsDao
          .getSupplierSettingByCode(armtekSupplierCode);
      state = state.copyWith(
        isLoading: false,
        isConnected: false,
        connectionStatusMessage: 'Ошибка подключения: ${e.toString()}',
        currentSetting: updatedSetting,
        errorMessage: 'Не удалось подключиться к Armtek.',
      );
    }
  }

  Future<void> _fetchUserVkorgList(String login, String password) async {
    if (login.isEmpty) return;
    state = state.copyWith(isLoadingArmtekData: true);
    try {
      final armtekClient = ArmtekApiClient(username: login, password: password);
      final vkorgs = await armtekClient.getUserVkorgList();
      state = state.copyWith(userVkorgList: vkorgs, isLoadingArmtekData: false);
    } catch (e, s) {
      _logger.e('Error fetching Armtek VKORG list', error: e, stackTrace: s);
      state = state.copyWith(
          isLoadingArmtekData: false,
          connectionStatusMessage:
              'Ошибка загрузки списка VKORG: ${e.toString()}');
    }
  }

  Future<void> selectVkorg(String? vkorg) async {
    if (vkorg == null || state.loginInput.isEmpty) {
      state = state.copyWith(
        selectedVkorg: null,
        userInfo: null,
        storeList: null,
        brandList: null,
      );
      // Очистить additionalConfig в БД
      if (state.currentSetting != null) {
        final currentAdditionalConfig = state.currentSetting!.additionalConfig;
        Map<String, dynamic> configMap = {};
        if (currentAdditionalConfig != null &&
            currentAdditionalConfig.isNotEmpty) {
          configMap =
              jsonDecode(currentAdditionalConfig) as Map<String, dynamic>;
        }
        configMap.remove('selectedVkorg');
        final newConfigJson = configMap.isEmpty ? null : jsonEncode(configMap);

        await _supplierSettingsDao.upsertSupplierSetting(
          SupplierSettingsItemsCompanion(
            supplierCode: const Value(armtekSupplierCode),
            additionalConfig: Value(newConfigJson),
            updatedAt: Value(DateTime.now()),
          ),
        );
        final updatedSetting = await _supplierSettingsDao
            .getSupplierSettingByCode(armtekSupplierCode);
        state = state.copyWith(currentSetting: updatedSetting);
      }
      return;
    }

    state = state.copyWith(selectedVkorg: vkorg, isLoadingArmtekData: true);

    // Сохраняем выбранный VKORG в additionalConfig
    if (state.currentSetting != null) {
      final currentAdditionalConfig = state.currentSetting!.additionalConfig;
      Map<String, dynamic> configMap = {};
      if (currentAdditionalConfig != null &&
          currentAdditionalConfig.isNotEmpty) {
        configMap = jsonDecode(currentAdditionalConfig) as Map<String, dynamic>;
      }
      configMap['selectedVkorg'] = vkorg;
      final newConfigJson = jsonEncode(configMap);

      await _supplierSettingsDao.upsertSupplierSetting(
        SupplierSettingsItemsCompanion(
          supplierCode: const Value(armtekSupplierCode),
          additionalConfig: Value(newConfigJson),
          updatedAt: Value(DateTime.now()),
        ),
      );
      final updatedSetting = await _supplierSettingsDao
          .getSupplierSettingByCode(armtekSupplierCode);
      state = state.copyWith(currentSetting: updatedSetting);
    }

    await _fetchArmtekSpecificData(
        state.loginInput, state.passwordInput, vkorg);
  }

  Future<void> _fetchArmtekSpecificData(
      String login, String password, String vkorg) async {
    state = state.copyWith(isLoadingArmtekData: true);
    try {
      final armtekClient = ArmtekApiClient(username: login, password: password);
      // Параллельная загрузка
      final results = await Future.wait([
        armtekClient.getUserInfo(vkorg: vkorg, structure: '1', ftpData: '1'),
        armtekClient.getStoreList(vkorg: vkorg),
        armtekClient.getBrandList(vkorg: vkorg),
      ]);

      final userInfo = results[0] as Map<String,
          dynamic>?; // Предполагаем, что getUserInfo возвращает Map
      final clientIdentifier =
          userInfo?['RESP']?['STRUCTURE']?['KUNAG'] as String?;

      if (clientIdentifier != null &&
          state.currentSetting?.clientIdentifierAtSupplier !=
              clientIdentifier) {
        await _supplierSettingsDao.upsertSupplierSetting(
          SupplierSettingsItemsCompanion(
            supplierCode: const Value(armtekSupplierCode),
            clientIdentifierAtSupplier: Value(clientIdentifier),
            updatedAt: Value(DateTime.now()),
          ),
        );
        final updatedSetting = await _supplierSettingsDao
            .getSupplierSettingByCode(armtekSupplierCode);
        state = state.copyWith(currentSetting: updatedSetting);
      }

      state = state.copyWith(
        userInfo: userInfo,
        storeList: results[1] as List<dynamic>?,
        brandList: results[2] as List<dynamic>?,
        isLoadingArmtekData: false,
      );
    } catch (e, s) {
      _logger.e('Error fetching Armtek specific data for VKORG $vkorg',
          error: e, stackTrace: s);
      state = state.copyWith(
          isLoadingArmtekData: false,
          connectionStatusMessage:
              'Ошибка загрузки данных для VKORG: ${e.toString()}');
    }
  }

  Future<void> clearSettings() async {
    state = state.copyWith(isLoading: true);
    try {
      await _supplierSettingsDao.upsertSupplierSetting(
        SupplierSettingsItemsCompanion(
          supplierCode: const Value(armtekSupplierCode),
          isEnabled: const Value(false), // Можно отключать, а не удалять все
          encryptedCredentials: const Value(null),
          lastCheckStatus: const Value(null),
          lastCheckMessage: const Value(null),
          lastSuccessfulCheckAt: const Value(null),
          clientIdentifierAtSupplier: const Value(null),
          additionalConfig: const Value(null),
          updatedAt: Value(DateTime.now()),
        ),
      );
      state = ArmtekSettingsState.initial()
          .copyWith(connectionStatusMessage: 'Настройки Armtek очищены.');
    } catch (e, s) {
      _logger.e('Error clearing Armtek settings', error: e, stackTrace: s);
      state = state.copyWith(
          isLoading: false, errorMessage: 'Ошибка очистки настроек');
    }
  }
}

```

## lib\features\settings\armtek\screens\armtek_settings_screen.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:part_catalog/core/widgets/buttons.dart';
import 'package:part_catalog/core/widgets/loading_indicator.dart';
import 'package:part_catalog/core/widgets/responsive_layout_builder.dart';
import 'package:part_catalog/features/settings/armtek/notifiers/armtek_settings_notifier.dart';
import 'package:part_catalog/features/settings/armtek/state/armtek_settings_state.dart';
import 'package:part_catalog/core/i18n/strings.g.dart';

class ArmtekSettingsScreen extends ConsumerStatefulWidget {
  const ArmtekSettingsScreen({super.key});

  @override
  ConsumerState<ArmtekSettingsScreen> createState() =>
      _ArmtekSettingsScreenState();
}

class _ArmtekSettingsScreenState extends ConsumerState<ArmtekSettingsScreen> {
  final _loginController = TextEditingController();
  final _passwordController = TextEditingController();
  final _formKey = GlobalKey<FormState>();

  @override
  void initState() {
    super.initState();
    // Загрузка начальных данных при инициализации
    // ref.read(armtekSettingsNotifierProvider.notifier).init(); // Уже вызывается в конструкторе Notifier

    // Синхронизация контроллеров с состоянием (если нужно при первой загрузке)
    final initialState = ref.read(armtekSettingsNotifierProvider);
    _loginController.text = initialState.loginInput;
    // _passwordController.text = initialState.passwordInput; // Пароль не предзаполняем
  }

  @override
  void dispose() {
    _loginController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(armtekSettingsNotifierProvider);
    final notifier = ref.read(armtekSettingsNotifierProvider.notifier);
    final t = Translations.of(context);

    // Обновляем контроллеры, если логин изменился в состоянии (например, после загрузки)
    // Делаем это аккуратно, чтобы не перезаписывать ввод пользователя
    if (_loginController.text != state.loginInput &&
        !(_formKey.currentState?.validate() ?? false)) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) _loginController.text = state.loginInput;
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(t.settings.armtekSettings.screenTitle),
        actions: [
          if (state.isLoading) const AppBarLoadingIndicator(),
        ],
      ),
      body: ResponsiveLayoutBuilder(
        small: (_, __) => _buildMobileLayout(context, state, notifier, t),
        medium: (_, __) => _buildTabletLayout(context, state, notifier, t),
        large: (_, __) => _buildDesktopLayout(context, state, notifier, t),
      ),
    );
  }

  Widget _buildMobileLayout(BuildContext context, ArmtekSettingsState state,
      ArmtekSettingsNotifier notifier, Translations t) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: _buildFormContent(context, state, notifier, t),
    );
  }

  Widget _buildTabletLayout(BuildContext context, ArmtekSettingsState state,
      ArmtekSettingsNotifier notifier, Translations t) {
    // Для планшета можно использовать две колонки или более широкую форму
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 600),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: _buildFormContent(context, state, notifier, t),
        ),
      ),
    );
  }

  Widget _buildDesktopLayout(BuildContext context, ArmtekSettingsState state,
      ArmtekSettingsNotifier notifier, Translations t) {
    // Для десктопа можно использовать более сложный макет
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 700),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(32.0),
          child: _buildFormContent(context, state, notifier, t),
        ),
      ),
    );
  }

  Widget _buildFormContent(BuildContext context, ArmtekSettingsState state,
      ArmtekSettingsNotifier notifier, Translations t) {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          Text(t.settings.armtekSettings.credentialsSectionTitle,
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 16),
          TextFormField(
            controller: _loginController,
            decoration: InputDecoration(
              labelText: t.settings.armtekSettings.loginLabel,
              border: const OutlineInputBorder(),
            ),
            onChanged: notifier.updateLogin,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return t.settings.armtekSettings.loginRequiredError;
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: _passwordController,
            decoration: InputDecoration(
              labelText: t.settings.armtekSettings.passwordLabel,
              border: const OutlineInputBorder(),
            ),
            obscureText: true,
            onChanged: notifier.updatePassword,
            validator: (value) {
              // Валидация пароля только если пытаемся сохранить
              return null;
            },
          ),
          const SizedBox(height: 24),
          if (state.connectionStatusMessage != null)
            Padding(
              padding: const EdgeInsets.only(bottom: 16.0),
              child: Text(
                state.connectionStatusMessage!,
                style: TextStyle(
                    color: state.isConnected ? Colors.green : Colors.red),
              ),
            ),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              SecondaryButton(
                onPressed: state.isLoading ? null : notifier.clearSettings,
                child: Text(t.core
                    .resetButtonLabel), // Используйте t.core.clearButtonLabel если есть
              ),
              const SizedBox(width: 16),
              PrimaryButton(
                onPressed: state.isLoading
                    ? null
                    : () {
                        if (_formKey.currentState!.validate()) {
                          if (state.passwordInput.isEmpty &&
                              !state.isConnected) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                  content: Text(t.settings.armtekSettings
                                      .passwordRequiredError)),
                            );
                            return;
                          }
                          notifier.checkAndSaveConnection();
                        }
                      },
                child: Text(t.settings.armtekSettings.checkAndSaveButton),
              ),
            ],
          ),
          const SizedBox(height: 16),
          if (state.errorMessage != null)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16.0),
              child: Text(state.errorMessage!,
                  style: const TextStyle(color: Colors.red)),
            ),
          if (state.isConnected) ...[
            const Divider(height: 40),
            Text(t.settings.armtekSettings.supplierInfoSectionTitle,
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            if (state.isLoadingArmtekData) const LoadingIndicator(),
            if (state.userVkorgList != null && state.userVkorgList!.isNotEmpty)
              DropdownButtonFormField<String>(
                value: state.selectedVkorg,
                decoration: InputDecoration(
                  labelText: t.settings.armtekSettings.vkorgLabel,
                  border: const OutlineInputBorder(),
                ),
                items: state.userVkorgList!
                    .map((vkorg) => DropdownMenuItem<String>(
                          // Предполагаем, что vkorg это Map или объект с полем 'NAME' и 'VKORG'
                          value: vkorg['VKORG'] as String,
                          child: Text(vkorg['NAME'] as String? ??
                              vkorg['VKORG'] as String),
                        ))
                    .toList(),
                onChanged: state.isLoadingArmtekData
                    ? null
                    : (value) => notifier.selectVkorg(value),
              ),
            const SizedBox(height: 16),
            if (state.selectedVkorg != null && state.userInfo != null)
              _buildUserInfo(context, state.userInfo!, t),
            // TODO: Отобразить storeList и brandList, если нужно
          ],
        ],
      ),
    );
  }

  Widget _buildUserInfo(
      BuildContext context, Map<String, dynamic> userInfo, Translations t) {
    // Пример отображения UserInfo. Адаптируйте под вашу структуру данных.
    final structure = userInfo['RESP']?['STRUCTURE'];
    if (structure == null || structure is! Map) {
      return Text(t.settings.armtekSettings.userInfoUnavailable);
    }
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(t.settings.armtekSettings.clientInfoTitle,
                style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Text(
                '${t.settings.armtekSettings.clientStructureKUNAG}: ${structure['KUNAG'] ?? ''}'),
            Text(
                '${t.settings.armtekSettings.clientStructureVKORG}: ${structure['VKORG'] ?? ''}'),
            Text(
                '${t.settings.armtekSettings.clientStructureSNAME}: ${structure['SNAME'] ?? ''}'),
            Text(
                '${t.settings.armtekSettings.clientStructureADRESS}: ${structure['ADRESS'] ?? ''}'),
            // Добавьте другие поля по необходимости
          ],
        ),
      ),
    );
  }
}

// Добавьте AppBarLoadingIndicator если его нет
class AppBarLoadingIndicator extends StatelessWidget
    implements PreferredSizeWidget {
  const AppBarLoadingIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: SizedBox(
        width: 20,
        height: 20,
        child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
      ),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

```

## lib\features\settings\armtek\state\armtek_settings_state.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:part_catalog/core/database/database.dart'; // Для SupplierSettingsItemData
import 'package:part_catalog/features/suppliers/models/armtek/user_info_response.dart';
// Предполагается, что у вас есть модели для ответа API Armtek,
// если нет, можно использовать Map<String, dynamic> или создать их.
import 'package:part_catalog/features/suppliers/models/armtek/user_vkorg.dart';
// import 'package:part_catalog/features/suppliers/armtek/models/user_info.dart';

part 'armtek_settings_state.freezed.dart';

@freezed
abstract class ArmtekSettingsState with _$ArmtekSettingsState {
  const factory ArmtekSettingsState({
    @Default(false) bool isLoading,
    String? errorMessage,
    // Поля для ввода учетных данных
    @Default('') String loginInput,
    @Default('') String passwordInput,
    // Статус подключения и информация
    String? connectionStatusMessage,
    @Default(false) bool isConnected,
    SupplierSettingsItem? currentSetting,
    // Данные от Armtek
    List<UserVkorg>? userVkorgList, // Замените dynamic на вашу модель UserVkorg
    String? selectedVkorg,
    Map<String, UserInfoResponse>?
        userInfo, // Замените Map на вашу модель UserInfo
    List<dynamic>? storeList, // Замените dynamic на вашу модель Store
    List<dynamic>? brandList, // Замените dynamic на вашу модель Brand
    @Default(false) bool isLoadingArmtekData,
  }) = _ArmtekSettingsState;

  factory ArmtekSettingsState.initial() => const ArmtekSettingsState();
}

```

## lib\features\settings\armtek\state\armtek_settings_state.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'armtek_settings_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ArmtekSettingsState {
  bool get isLoading;
  String? get errorMessage; // Поля для ввода учетных данных
  String get loginInput;
  String get passwordInput; // Статус подключения и информация
  String? get connectionStatusMessage;
  bool get isConnected;
  SupplierSettingsItem? get currentSetting; // Данные от Armtek
  List<UserVkorg>?
      get userVkorgList; // Замените dynamic на вашу модель UserVkorg
  String? get selectedVkorg;
  Map<String, UserInfoResponse>?
      get userInfo; // Замените Map на вашу модель UserInfo
  List<dynamic>? get storeList; // Замените dynamic на вашу модель Store
  List<dynamic>? get brandList; // Замените dynamic на вашу модель Brand
  bool get isLoadingArmtekData;

  /// Create a copy of ArmtekSettingsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ArmtekSettingsStateCopyWith<ArmtekSettingsState> get copyWith =>
      _$ArmtekSettingsStateCopyWithImpl<ArmtekSettingsState>(
          this as ArmtekSettingsState, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ArmtekSettingsState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage) &&
            (identical(other.loginInput, loginInput) ||
                other.loginInput == loginInput) &&
            (identical(other.passwordInput, passwordInput) ||
                other.passwordInput == passwordInput) &&
            (identical(
                    other.connectionStatusMessage, connectionStatusMessage) ||
                other.connectionStatusMessage == connectionStatusMessage) &&
            (identical(other.isConnected, isConnected) ||
                other.isConnected == isConnected) &&
            const DeepCollectionEquality()
                .equals(other.currentSetting, currentSetting) &&
            const DeepCollectionEquality()
                .equals(other.userVkorgList, userVkorgList) &&
            (identical(other.selectedVkorg, selectedVkorg) ||
                other.selectedVkorg == selectedVkorg) &&
            const DeepCollectionEquality().equals(other.userInfo, userInfo) &&
            const DeepCollectionEquality().equals(other.storeList, storeList) &&
            const DeepCollectionEquality().equals(other.brandList, brandList) &&
            (identical(other.isLoadingArmtekData, isLoadingArmtekData) ||
                other.isLoadingArmtekData == isLoadingArmtekData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      errorMessage,
      loginInput,
      passwordInput,
      connectionStatusMessage,
      isConnected,
      const DeepCollectionEquality().hash(currentSetting),
      const DeepCollectionEquality().hash(userVkorgList),
      selectedVkorg,
      const DeepCollectionEquality().hash(userInfo),
      const DeepCollectionEquality().hash(storeList),
      const DeepCollectionEquality().hash(brandList),
      isLoadingArmtekData);

  @override
  String toString() {
    return 'ArmtekSettingsState(isLoading: $isLoading, errorMessage: $errorMessage, loginInput: $loginInput, passwordInput: $passwordInput, connectionStatusMessage: $connectionStatusMessage, isConnected: $isConnected, currentSetting: $currentSetting, userVkorgList: $userVkorgList, selectedVkorg: $selectedVkorg, userInfo: $userInfo, storeList: $storeList, brandList: $brandList, isLoadingArmtekData: $isLoadingArmtekData)';
  }
}

/// @nodoc
abstract mixin class $ArmtekSettingsStateCopyWith<$Res> {
  factory $ArmtekSettingsStateCopyWith(
          ArmtekSettingsState value, $Res Function(ArmtekSettingsState) _then) =
      _$ArmtekSettingsStateCopyWithImpl;
  @useResult
  $Res call(
      {bool isLoading,
      String? errorMessage,
      String loginInput,
      String passwordInput,
      String? connectionStatusMessage,
      bool isConnected,
      SupplierSettingsItem? currentSetting,
      List<UserVkorg>? userVkorgList,
      String? selectedVkorg,
      Map<String, UserInfoResponse>? userInfo,
      List<dynamic>? storeList,
      List<dynamic>? brandList,
      bool isLoadingArmtekData});
}

/// @nodoc
class _$ArmtekSettingsStateCopyWithImpl<$Res>
    implements $ArmtekSettingsStateCopyWith<$Res> {
  _$ArmtekSettingsStateCopyWithImpl(this._self, this._then);

  final ArmtekSettingsState _self;
  final $Res Function(ArmtekSettingsState) _then;

  /// Create a copy of ArmtekSettingsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? errorMessage = freezed,
    Object? loginInput = null,
    Object? passwordInput = null,
    Object? connectionStatusMessage = freezed,
    Object? isConnected = null,
    Object? currentSetting = freezed,
    Object? userVkorgList = freezed,
    Object? selectedVkorg = freezed,
    Object? userInfo = freezed,
    Object? storeList = freezed,
    Object? brandList = freezed,
    Object? isLoadingArmtekData = null,
  }) {
    return _then(_self.copyWith(
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      errorMessage: freezed == errorMessage
          ? _self.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      loginInput: null == loginInput
          ? _self.loginInput
          : loginInput // ignore: cast_nullable_to_non_nullable
              as String,
      passwordInput: null == passwordInput
          ? _self.passwordInput
          : passwordInput // ignore: cast_nullable_to_non_nullable
              as String,
      connectionStatusMessage: freezed == connectionStatusMessage
          ? _self.connectionStatusMessage
          : connectionStatusMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      isConnected: null == isConnected
          ? _self.isConnected
          : isConnected // ignore: cast_nullable_to_non_nullable
              as bool,
      currentSetting: freezed == currentSetting
          ? _self.currentSetting
          : currentSetting // ignore: cast_nullable_to_non_nullable
              as SupplierSettingsItem?,
      userVkorgList: freezed == userVkorgList
          ? _self.userVkorgList
          : userVkorgList // ignore: cast_nullable_to_non_nullable
              as List<UserVkorg>?,
      selectedVkorg: freezed == selectedVkorg
          ? _self.selectedVkorg
          : selectedVkorg // ignore: cast_nullable_to_non_nullable
              as String?,
      userInfo: freezed == userInfo
          ? _self.userInfo
          : userInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, UserInfoResponse>?,
      storeList: freezed == storeList
          ? _self.storeList
          : storeList // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      brandList: freezed == brandList
          ? _self.brandList
          : brandList // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      isLoadingArmtekData: null == isLoadingArmtekData
          ? _self.isLoadingArmtekData
          : isLoadingArmtekData // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _ArmtekSettingsState implements ArmtekSettingsState {
  const _ArmtekSettingsState(
      {this.isLoading = false,
      this.errorMessage,
      this.loginInput = '',
      this.passwordInput = '',
      this.connectionStatusMessage,
      this.isConnected = false,
      this.currentSetting,
      final List<UserVkorg>? userVkorgList,
      this.selectedVkorg,
      final Map<String, UserInfoResponse>? userInfo,
      final List<dynamic>? storeList,
      final List<dynamic>? brandList,
      this.isLoadingArmtekData = false})
      : _userVkorgList = userVkorgList,
        _userInfo = userInfo,
        _storeList = storeList,
        _brandList = brandList;

  @override
  @JsonKey()
  final bool isLoading;
  @override
  final String? errorMessage;
// Поля для ввода учетных данных
  @override
  @JsonKey()
  final String loginInput;
  @override
  @JsonKey()
  final String passwordInput;
// Статус подключения и информация
  @override
  final String? connectionStatusMessage;
  @override
  @JsonKey()
  final bool isConnected;
  @override
  final SupplierSettingsItem? currentSetting;
// Данные от Armtek
  final List<UserVkorg>? _userVkorgList;
// Данные от Armtek
  @override
  List<UserVkorg>? get userVkorgList {
    final value = _userVkorgList;
    if (value == null) return null;
    if (_userVkorgList is EqualUnmodifiableListView) return _userVkorgList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// Замените dynamic на вашу модель UserVkorg
  @override
  final String? selectedVkorg;
  final Map<String, UserInfoResponse>? _userInfo;
  @override
  Map<String, UserInfoResponse>? get userInfo {
    final value = _userInfo;
    if (value == null) return null;
    if (_userInfo is EqualUnmodifiableMapView) return _userInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

// Замените Map на вашу модель UserInfo
  final List<dynamic>? _storeList;
// Замените Map на вашу модель UserInfo
  @override
  List<dynamic>? get storeList {
    final value = _storeList;
    if (value == null) return null;
    if (_storeList is EqualUnmodifiableListView) return _storeList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// Замените dynamic на вашу модель Store
  final List<dynamic>? _brandList;
// Замените dynamic на вашу модель Store
  @override
  List<dynamic>? get brandList {
    final value = _brandList;
    if (value == null) return null;
    if (_brandList is EqualUnmodifiableListView) return _brandList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// Замените dynamic на вашу модель Brand
  @override
  @JsonKey()
  final bool isLoadingArmtekData;

  /// Create a copy of ArmtekSettingsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ArmtekSettingsStateCopyWith<_ArmtekSettingsState> get copyWith =>
      __$ArmtekSettingsStateCopyWithImpl<_ArmtekSettingsState>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ArmtekSettingsState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage) &&
            (identical(other.loginInput, loginInput) ||
                other.loginInput == loginInput) &&
            (identical(other.passwordInput, passwordInput) ||
                other.passwordInput == passwordInput) &&
            (identical(
                    other.connectionStatusMessage, connectionStatusMessage) ||
                other.connectionStatusMessage == connectionStatusMessage) &&
            (identical(other.isConnected, isConnected) ||
                other.isConnected == isConnected) &&
            const DeepCollectionEquality()
                .equals(other.currentSetting, currentSetting) &&
            const DeepCollectionEquality()
                .equals(other._userVkorgList, _userVkorgList) &&
            (identical(other.selectedVkorg, selectedVkorg) ||
                other.selectedVkorg == selectedVkorg) &&
            const DeepCollectionEquality().equals(other._userInfo, _userInfo) &&
            const DeepCollectionEquality()
                .equals(other._storeList, _storeList) &&
            const DeepCollectionEquality()
                .equals(other._brandList, _brandList) &&
            (identical(other.isLoadingArmtekData, isLoadingArmtekData) ||
                other.isLoadingArmtekData == isLoadingArmtekData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      errorMessage,
      loginInput,
      passwordInput,
      connectionStatusMessage,
      isConnected,
      const DeepCollectionEquality().hash(currentSetting),
      const DeepCollectionEquality().hash(_userVkorgList),
      selectedVkorg,
      const DeepCollectionEquality().hash(_userInfo),
      const DeepCollectionEquality().hash(_storeList),
      const DeepCollectionEquality().hash(_brandList),
      isLoadingArmtekData);

  @override
  String toString() {
    return 'ArmtekSettingsState(isLoading: $isLoading, errorMessage: $errorMessage, loginInput: $loginInput, passwordInput: $passwordInput, connectionStatusMessage: $connectionStatusMessage, isConnected: $isConnected, currentSetting: $currentSetting, userVkorgList: $userVkorgList, selectedVkorg: $selectedVkorg, userInfo: $userInfo, storeList: $storeList, brandList: $brandList, isLoadingArmtekData: $isLoadingArmtekData)';
  }
}

/// @nodoc
abstract mixin class _$ArmtekSettingsStateCopyWith<$Res>
    implements $ArmtekSettingsStateCopyWith<$Res> {
  factory _$ArmtekSettingsStateCopyWith(_ArmtekSettingsState value,
          $Res Function(_ArmtekSettingsState) _then) =
      __$ArmtekSettingsStateCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      String? errorMessage,
      String loginInput,
      String passwordInput,
      String? connectionStatusMessage,
      bool isConnected,
      SupplierSettingsItem? currentSetting,
      List<UserVkorg>? userVkorgList,
      String? selectedVkorg,
      Map<String, UserInfoResponse>? userInfo,
      List<dynamic>? storeList,
      List<dynamic>? brandList,
      bool isLoadingArmtekData});
}

/// @nodoc
class __$ArmtekSettingsStateCopyWithImpl<$Res>
    implements _$ArmtekSettingsStateCopyWith<$Res> {
  __$ArmtekSettingsStateCopyWithImpl(this._self, this._then);

  final _ArmtekSettingsState _self;
  final $Res Function(_ArmtekSettingsState) _then;

  /// Create a copy of ArmtekSettingsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? isLoading = null,
    Object? errorMessage = freezed,
    Object? loginInput = null,
    Object? passwordInput = null,
    Object? connectionStatusMessage = freezed,
    Object? isConnected = null,
    Object? currentSetting = freezed,
    Object? userVkorgList = freezed,
    Object? selectedVkorg = freezed,
    Object? userInfo = freezed,
    Object? storeList = freezed,
    Object? brandList = freezed,
    Object? isLoadingArmtekData = null,
  }) {
    return _then(_ArmtekSettingsState(
      isLoading: null == isLoading
          ? _self.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      errorMessage: freezed == errorMessage
          ? _self.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      loginInput: null == loginInput
          ? _self.loginInput
          : loginInput // ignore: cast_nullable_to_non_nullable
              as String,
      passwordInput: null == passwordInput
          ? _self.passwordInput
          : passwordInput // ignore: cast_nullable_to_non_nullable
              as String,
      connectionStatusMessage: freezed == connectionStatusMessage
          ? _self.connectionStatusMessage
          : connectionStatusMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      isConnected: null == isConnected
          ? _self.isConnected
          : isConnected // ignore: cast_nullable_to_non_nullable
              as bool,
      currentSetting: freezed == currentSetting
          ? _self.currentSetting
          : currentSetting // ignore: cast_nullable_to_non_nullable
              as SupplierSettingsItem?,
      userVkorgList: freezed == userVkorgList
          ? _self._userVkorgList
          : userVkorgList // ignore: cast_nullable_to_non_nullable
              as List<UserVkorg>?,
      selectedVkorg: freezed == selectedVkorg
          ? _self.selectedVkorg
          : selectedVkorg // ignore: cast_nullable_to_non_nullable
              as String?,
      userInfo: freezed == userInfo
          ? _self._userInfo
          : userInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, UserInfoResponse>?,
      storeList: freezed == storeList
          ? _self._storeList
          : storeList // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      brandList: freezed == brandList
          ? _self._brandList
          : brandList // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      isLoadingArmtekData: null == isLoadingArmtekData
          ? _self.isLoadingArmtekData
          : isLoadingArmtekData // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\api\api_client_manager.dart
```dart
import 'package:part_catalog/core/utils/logger_config.dart'; // Используем общий логгер
import 'package:part_catalog/features/suppliers/api/api_connection_mode.dart';

import 'base_supplier_api_client.dart';
// TODO: import 'implementations/armtek_api_client.dart'; // Будет создан позже
// import 'implementations/autodoc_api_client.dart'; // Пример
// import 'implementations/exist_api_client.dart';  // Пример

class ApiClientManager {
  final _logger = AppLoggers.suppliers;
  ApiConnectionMode _currentMode = ApiConnectionMode.direct;
  String? _proxyUrl;

  // TODO: Заменить на реальную логику получения клиентов
  final Map<String, BaseSupplierApiClient> _directClients = {};
  final Map<String, BaseSupplierApiClient> _proxyClients = {};

  ApiConnectionMode get currentMode => _currentMode;
  String? get proxyUrl => _proxyUrl;

  Future<void> initialize({
    required ApiConnectionMode mode,
    String? proxyUrl,
  }) async {
    _logger.i(
        'Initializing ApiClientManager with mode: $mode, proxyUrl: $proxyUrl');
    _currentMode = mode;
    _proxyUrl = proxyUrl;
    // TODO: Инициализировать или переконфигурировать клиентов на основе режима
    _updateClientConfigurations();
  }

  Future<void> switchMode(ApiConnectionMode newMode) async {
    if (_currentMode == newMode) return;
    _logger.i('Switching API connection mode from $_currentMode to $newMode');
    _currentMode = newMode;
    // TODO: Пересоздать/переконфигурировать клиентов
    _updateClientConfigurations();
  }

  Future<void> setProxyUrl(String? url) async {
    if (_proxyUrl == url) return;
    _logger.i('Setting proxy URL to: $url');
    _proxyUrl = url;
    if (_currentMode == ApiConnectionMode.proxy) {
      // TODO: Пересоздать/переконфигурировать клиентов, использующих прокси
      _updateClientConfigurations();
    }
  }

  BaseSupplierApiClient? getClient(String supplierCode) {
    _logger
        .d('Getting client for supplier: $supplierCode, mode: $_currentMode');
    if (_currentMode == ApiConnectionMode.direct) {
      return _directClients[
          supplierCode]; // TODO: Реализовать создание direct клиентов
    } else if (_currentMode == ApiConnectionMode.proxy) {
      // TODO: Реализовать создание proxy клиентов с использованием _proxyUrl
      return _proxyClients[supplierCode];
    }
    _logger.w(
        'Client not found for supplier: $supplierCode with mode: $_currentMode');
    return null;
  }

  /// Возвращает список всех доступных клиентов API в зависимости от текущего режима.
  List<BaseSupplierApiClient> getAllAvailableClients() {
    _logger.d('Getting all available clients for mode: $_currentMode');
    if (_currentMode == ApiConnectionMode.direct) {
      // Если клиенты еще не созданы, их нужно будет создать здесь или в _updateClientConfigurations
      // Пока просто возвращаем зарегистрированные
      if (_directClients.isEmpty) {
        _logger.w('No direct clients registered or created yet.');
        // Возможно, здесь стоит вызвать _updateClientConfigurations() или аналогичный метод,
        // который отвечает за инициализацию клиентов.
        // Для примера, если у вас есть список известных поставщиков:
        // _initializeDirectClientsIfNeeded();
      }
      return _directClients.values.toList();
    } else if (_currentMode == ApiConnectionMode.proxy) {
      // Аналогично для прокси клиентов
      if (_proxyClients.isEmpty) {
        _logger.w('No proxy clients registered or created yet.');
        // _initializeProxyClientsIfNeeded();
      }
      return _proxyClients.values.toList();
    }
    _logger.w('No clients available for mode: $_currentMode');
    return [];
  }

  void registerDirectClient(BaseSupplierApiClient client) {
    _logger.i('Registering direct client for: ${client.supplierCode}');
    _directClients[client.supplierCode] = client;
  }

  void registerProxyClient(BaseSupplierApiClient client) {
    _logger.i('Registering proxy client for: ${client.supplierCode}');
    _proxyClients[client.supplierCode] = client;
  }

  void _updateClientConfigurations() {
    _logger.i('Updating client configurations for mode: $_currentMode');
    // Здесь будет логика пересоздания или переконфигурации клиентов
    // Например, если у нас есть список всех зарегистрированных поставщиков,
    // мы можем пройтись по ним и создать/обновить их клиенты API.

    // Пример:
    // for (var supplierCode in _getAllKnownSupplierCodes()) {
    //   if (_currentMode == ApiConnectionMode.direct) {
    //     _directClients[supplierCode] = _createDirectClientFor(supplierCode);
    //   } else if (_currentMode == ApiConnectionMode.proxy) {
    //     _proxyClients[supplierCode] = _createProxyClientFor(supplierCode, _proxyUrl);
    //   }
    // }
  }

  // TODO: Добавить методы для создания конкретных клиентов ( _createDirectClientFor, _createProxyClientFor)
  // TODO: Добавить метод для получения списка всех известных кодов поставщиков (_getAllKnownSupplierCodes)
}

```

## lib\features\suppliers\api\api_connection_mode.dart
```dart
enum ApiConnectionMode {
  direct,
  proxy,
  // hybrid, // Можно добавить позже, если потребуется
}

extension ApiConnectionModeExtension on ApiConnectionMode {
  String get name {
    switch (this) {
      case ApiConnectionMode.direct:
        return 'direct';
      case ApiConnectionMode.proxy:
        return 'proxy';
    }
  }

  static ApiConnectionMode fromName(String? name) {
    switch (name) {
      case 'direct':
        return ApiConnectionMode.direct;
      case 'proxy':
        return ApiConnectionMode.proxy;
      default:
        return ApiConnectionMode.direct; // Значение по умолчанию
    }
  }
}

```

## lib\features\suppliers\api\base_supplier_api_client.dart
```dart
import '../models/base/part_price_response.dart'; // Предполагается, что эта модель будет создана

/// Базовый интерфейс для всех клиентов API поставщиков.
abstract class BaseSupplierApiClient {
  /// Возвращает название поставщика.
  String get supplierName;
  String get supplierCode;

  Future<bool> checkConnection(); // Пример метода

  /// Получает цены на запчасть по артикулу.
  ///
  /// [articleNumber] - артикул запчасти.
  /// [brand] - опциональный бренд для уточнения поиска.
  Future<List<PartPriceModel>> getPricesByArticle(String articleNumber,
      {String? brand});

  // TODO: Добавить другие общие методы, если они будут определены, например:
  // Future<List<PartInfoModel>> searchPartsByName(String name);
  // Future<PartDetailModel?> getPartDetails(String articleNumber, String brand);
}

// Базовая модель для ответа по ценам (нужно будет создать)
// Пример в lib/features/suppliers/models/base/part_price_response.dart
// @freezed
// class PartPriceModel with _$PartPriceModel {
//   const factory PartPriceModel({
//     required String article,
//     required String brand,
//     required String name,
//     required double price,
//     required int quantity,
//     required int deliveryDays,
//     required String supplier,
//     // ... другие общие поля
//   }) = _PartPriceModel;
//   factory PartPriceModel.fromJson(Map<String, dynamic> json) => _$PartPriceModelFromJson(json);
// }

```

## lib\features\suppliers\api\implementations\armtek_api_client.dart
```dart
import 'dart:convert'; // For base64Encode
import 'package:dio/dio.dart';
import 'package:part_catalog/core/utils/logger_config.dart';
import 'package:part_catalog/features/suppliers/models/armtek/brand_item.dart';
import 'package:part_catalog/features/suppliers/models/armtek/ping_response.dart';
import 'package:part_catalog/features/suppliers/models/armtek/store_item.dart';
import 'package:retrofit/retrofit.dart';
import 'package:part_catalog/features/suppliers/api/base_supplier_api_client.dart';
import 'package:part_catalog/features/suppliers/models/base/part_price_response.dart';
import 'package:part_catalog/features/suppliers/models/armtek/armtek_response_wrapper.dart';
import 'package:part_catalog/features/suppliers/models/armtek/user_vkorg.dart';
import 'package:part_catalog/features/suppliers/models/armtek/user_info_request.dart';
import 'package:part_catalog/features/suppliers/models/armtek/user_info_response.dart';
// TODO: Импортировать модели для getBrandList и getStoreList, когда они будут созданы

part 'armtek_api_client.g.dart';

const String armtekBaseUrl =
    "http://ws.armtek.ru"; // Можно вынести в конфигурацию

@RestApi(baseUrl: armtekBaseUrl)
abstract class ArmtekRestInterface {
  factory ArmtekRestInterface(Dio dio, {String baseUrl}) = _ArmtekRestInterface;

  // --- ServicePing ---
  @GET("/ws_ping/index")
  Future<ArmtekResponseWrapper<PingResponse>> pingService({
    @Query("format") String format = "json",
  });

  // --- ServiceUser ---
  @GET("/ws_user/getUserVkorgList")
  Future<ArmtekResponseWrapper<List<UserVkorg>>> getUserVkorgList({
    @Query("format") String format = "json",
  });

  @POST("/ws_user/getUserInfo")
  @FormUrlEncoded() // Armtek API может ожидать form-urlencoded для POST
  Future<ArmtekResponseWrapper<UserInfoResponse>> getUserInfo({
    @Field("VKORG") required String vkorg,
    @Field("STRUCTURE") String? structure, // '0' or '1'
    @Field("FTPDATA") String? ftpData, // '0' or '1'
    @Query("format") String format = "json",
  });

  /// Добавляем метод getBrandList
  @GET("/ws_user/getBrandList")
  Future<ArmtekResponseWrapper<List<BrandItem>>> getBrandList({
    @Query("VKORG") required String vkorg,
    @Query("format") String format = "json",
  });

  // Добавляем метод getStoreList
  @GET("/ws_user/getStoreList")
  Future<ArmtekResponseWrapper<List<StoreItem>>> getStoreList({
    @Query("VKORG") required String vkorg,
    @Query("format") String format = "json",
  });

  // --- ServiceSearch ---
  // TODO: Добавить методы для поиска (например, getSearch)
  // @POST("/ws_search/search")
  // @FormUrlEncoded()
  // Future<ArmtekResponseWrapper<SearchResponse>> searchParts(...);
}

class ArmtekApiClient implements BaseSupplierApiClient {
  final Dio _dio;
  final ArmtekRestInterface _client;
  final _logger = AppLoggers.suppliers;

  ArmtekApiClient(this._dio,
      {String? username,
      String? password,
      String? baseUrl,
      String? proxyAuthToken}) // Сделали username и password опциональными
      : _client = ArmtekRestInterface(_dio, baseUrl: baseUrl ?? armtekBaseUrl) {
    // Добавляем Interceptor для Basic Authentication или Proxy Authentication
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        if (baseUrl == null || baseUrl.contains('ws.armtek.ru')) {
          // Если это прямой запрос к Armtek
          if (username != null && password != null) {
            final basicAuth =
                'Basic ${base64Encode(utf8.encode('$username:$password'))}';
            options.headers['Authorization'] = basicAuth;
          } else if (proxyAuthToken == null) {
            // Логика для случая, когда это прямой запрос, но нет username/password
            // Возможно, здесь стоит выбросить ошибку конфигурации, если они ожидаются
            _logger.w(
                'ArmtekApiClient: Direct request but no credentials provided.');
          }
        }
        // Если это запрос к прокси и есть токен для прокси
        if (proxyAuthToken != null &&
            options.baseUrl == baseUrl /* baseUrl здесь будет URL прокси */) {
          options.headers['X-Proxy-Auth-Token'] =
              proxyAuthToken; // Пример заголовка для прокси
        }
        return handler.next(options);
      },
    ));
  }

  @override
  String get supplierName => 'Armtek';

  @override
  String get supplierCode => 'Armtek';

  // --- Реализация методов BaseSupplierApiClient ---

  @override
  Future<List<PartPriceModel>> getPricesByArticle(String articleNumber,
      {String? brand}) async {
    // TODO: Реализовать получение цен через метод поиска Armtek API (ServiceSearch)
    // Это потребует создания моделей запроса и ответа для поиска,
    // а затем маппинга ответа Armtek в унифицированную модель PartPriceModel.
    // Пример:
    // final searchRequest = SearchRequest(article: articleNumber, brand: brand, ...);
    // final response = await _client.searchParts(request: searchRequest);
    // if (response.status == 200 && response.responseData != null) {
    //   return response.responseData.items.map((item) => PartPriceModel(
    //     article: item.article,
    //     brand: item.brand,
    //     name: item.name,
    //     price: item.price,
    //     quantity: item.quantity,
    //     deliveryDays: item.deliveryDays,
    //     supplierName: supplierName,
    //   )).toList();
    // }
    throw UnimplementedError(
        'getPricesByArticle for Armtek is not yet implemented.');
  }

  @override
  Future<bool> checkConnection() async {
    try {
      // Используем наш метод pingService вместо прямого запроса
      final response = await pingService();

      if (response.status == 200 && response.responseData != null) {
        _logger.i('API Armtek доступно. IP: ${response.responseData!.ip}, '
            'Время выполнения: ${response.responseData!.time}');
        return true;
      } else {
        _logger.w('API Armtek недоступно. Статус ответа: ${response.status}');
        return false;
      }
    } catch (e, stackTrace) {
      _logger.e('Ошибка при проверке доступности API Armtek',
          error: e, stackTrace: stackTrace);
      return false;
    }
  }

  // --- Методы для проверки сервиса (ServicePing) ---

  /// Проверяет доступность сервиса Armtek
  Future<ArmtekResponseWrapper<PingResponse>> pingService() async {
    _logger.i('Проверка доступности сервиса Armtek...');
    try {
      final response = await _client.pingService();

      final pingData = response.responseData;
      if (pingData != null) {
        _logger.i('Сервис Armtek доступен. IP: ${pingData.ip}, '
            'Время выполнения: ${pingData.time}');
      } else {
        _logger.i('Сервис Armtek доступен, но данные отсутствуют.');
      }

      return response;
    } catch (e, stackTrace) {
      _logger.e('Ошибка при проверке сервиса Armtek',
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  // --- Методы специфичные для Armtek API (из ServiceUser) ---

  Future<ArmtekResponseWrapper<List<UserVkorg>>> getUserVkorgList() async {
    return _client.getUserVkorgList();
  }

  Future<ArmtekResponseWrapper<UserInfoResponse>> getUserInfo(
      UserInfoRequest request) async {
    return _client.getUserInfo(
      vkorg: request.vkorg,
      structure: request.structure,
      ftpData: request.ftpData,
    );
  }

  // Добавляем метод getBrandList
  Future<ArmtekResponseWrapper<List<BrandItem>>> getBrandList(
      String vkorg) async {
    _logger.i('Getting brand list for VKORG: $vkorg');
    return _client.getBrandList(vkorg: vkorg);
  }

  // Добавляем метод getStoreList
  Future<ArmtekResponseWrapper<List<StoreItem>>> getStoreList(
      String vkorg) async {
    _logger.i('Getting store list for VKORG: $vkorg');
    return _client.getStoreList(vkorg: vkorg);
  }
}

```

## lib\features\suppliers\api\implementations\armtek_api_client.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'armtek_api_client.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _ArmtekRestInterface implements ArmtekRestInterface {
  _ArmtekRestInterface(this._dio, {this.baseUrl, this.errorLogger}) {
    baseUrl ??= 'http://ws.armtek.ru';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<ArmtekResponseWrapper<List<UserVkorg>>> getUserVkorgList({
    String format = "json",
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'format': format};
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<ArmtekResponseWrapper<List<UserVkorg>>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/ws_user/getUserVkorgList',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late ArmtekResponseWrapper<List<UserVkorg>> _value;
    try {
      _value = ArmtekResponseWrapper<List<UserVkorg>>.fromJson(
        _result.data!,
        (json) => json is List<dynamic>
            ? json
                .map<UserVkorg>(
                  (i) => UserVkorg.fromJson(i as Map<String, dynamic>),
                )
                .toList()
            : List.empty(),
      );
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<ArmtekResponseWrapper<UserInfoResponse>> getUserInfo({
    required String vkorg,
    String? structure,
    String? ftpData,
    String format = "json",
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'format': format};
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    final _data = {'VKORG': vkorg, 'STRUCTURE': structure, 'FTPDATA': ftpData};
    _data.removeWhere((k, v) => v == null);
    final _options = _setStreamType<ArmtekResponseWrapper<UserInfoResponse>>(
      Options(
        method: 'POST',
        headers: _headers,
        extra: _extra,
        contentType: 'application/x-www-form-urlencoded',
      )
          .compose(
            _dio.options,
            '/ws_user/getUserInfo',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late ArmtekResponseWrapper<UserInfoResponse> _value;
    try {
      _value = ArmtekResponseWrapper<UserInfoResponse>.fromJson(
        _result.data!,
        (json) => UserInfoResponse.fromJson(json as Map<String, dynamic>),
      );
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<ArmtekResponseWrapper<List<BrandItem>>> getBrandList({
    required String vkorg,
    String format = "json",
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'VKORG': vkorg,
      r'format': format,
    };
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<ArmtekResponseWrapper<List<BrandItem>>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/ws_user/getBrandList',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late ArmtekResponseWrapper<List<BrandItem>> _value;
    try {
      _value = ArmtekResponseWrapper<List<BrandItem>>.fromJson(
        _result.data!,
        (json) => json is List<dynamic>
            ? json
                .map<BrandItem>(
                  (i) => BrandItem.fromJson(i as Map<String, dynamic>),
                )
                .toList()
            : List.empty(),
      );
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<ArmtekResponseWrapper<List<StoreItem>>> getStoreList({
    required String vkorg,
    String format = "json",
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'VKORG': vkorg,
      r'format': format,
    };
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<ArmtekResponseWrapper<List<StoreItem>>>(
      Options(method: 'GET', headers: _headers, extra: _extra)
          .compose(
            _dio.options,
            '/ws_user/getStoreList',
            queryParameters: queryParameters,
            data: _data,
          )
          .copyWith(baseUrl: _combineBaseUrls(_dio.options.baseUrl, baseUrl)),
    );
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late ArmtekResponseWrapper<List<StoreItem>> _value;
    try {
      _value = ArmtekResponseWrapper<List<StoreItem>>.fromJson(
        _result.data!,
        (json) => json is List<dynamic>
            ? json
                .map<StoreItem>(
                  (i) => StoreItem.fromJson(i as Map<String, dynamic>),
                )
                .toList()
            : List.empty(),
      );
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(String dioBaseUrl, String? baseUrl) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

```

## lib\features\suppliers\config\supported_suppliers.dart
```dart
// TODO: Заменить на более гибкое решение в будущем (например, загрузка из конфига или БД)

enum SupplierCode {
  armtek,
  autodoc,
  // emex, // Пример другого поставщика
  // berg, // Пример другого поставщика
}

extension SupplierCodeExtension on SupplierCode {
  String get displayName {
    switch (this) {
      case SupplierCode.armtek:
        return 'Armtek';
      case SupplierCode.autodoc:
        return 'Autodoc';
      // case SupplierCode.emex:
      //   return 'Emex';
      // case SupplierCode.berg:
      //   return 'Berg';
    }
  }

  String get code {
    return name; // 'armtek', 'autodoc'
  }

  // Можно добавить иконки или другую метаинформацию здесь
  // IconData get icon {
  //   switch (this) {
  //     case SupplierCode.armtek:
  //       return Icons.store;
  //     case SupplierCode.autodoc:
  //       return Icons.local_shipping;
  //   }
  // }
}

// Список всех поддерживаемых поставщиков
final List<SupplierCode> allSupportedSuppliers = SupplierCode.values;

```

## lib\features\suppliers\models\armtek\armtek_message.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'armtek_message.freezed.dart';
part 'armtek_message.g.dart';

@freezed
abstract class ArmtekMessage with _$ArmtekMessage {
  const factory ArmtekMessage({
    @JsonKey(name: 'TYPE') required String type,
    @JsonKey(name: 'TEXT') required String text,
    @JsonKey(name: 'DATE')
    required String date, // Можно преобразовать в DateTime при необходимости
  }) = _ArmtekMessage;

  factory ArmtekMessage.fromJson(Map<String, dynamic> json) =>
      _$ArmtekMessageFromJson(json);
}

```

## lib\features\suppliers\models\armtek\armtek_message.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'armtek_message.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ArmtekMessage {
  @JsonKey(name: 'TYPE')
  String get type;
  @JsonKey(name: 'TEXT')
  String get text;
  @JsonKey(name: 'DATE')
  String get date;

  /// Create a copy of ArmtekMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ArmtekMessageCopyWith<ArmtekMessage> get copyWith =>
      _$ArmtekMessageCopyWithImpl<ArmtekMessage>(
          this as ArmtekMessage, _$identity);

  /// Serializes this ArmtekMessage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ArmtekMessage &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.date, date) || other.date == date));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text, date);

  @override
  String toString() {
    return 'ArmtekMessage(type: $type, text: $text, date: $date)';
  }
}

/// @nodoc
abstract mixin class $ArmtekMessageCopyWith<$Res> {
  factory $ArmtekMessageCopyWith(
          ArmtekMessage value, $Res Function(ArmtekMessage) _then) =
      _$ArmtekMessageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'TYPE') String type,
      @JsonKey(name: 'TEXT') String text,
      @JsonKey(name: 'DATE') String date});
}

/// @nodoc
class _$ArmtekMessageCopyWithImpl<$Res>
    implements $ArmtekMessageCopyWith<$Res> {
  _$ArmtekMessageCopyWithImpl(this._self, this._then);

  final ArmtekMessage _self;
  final $Res Function(ArmtekMessage) _then;

  /// Create a copy of ArmtekMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? date = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _ArmtekMessage implements ArmtekMessage {
  const _ArmtekMessage(
      {@JsonKey(name: 'TYPE') required this.type,
      @JsonKey(name: 'TEXT') required this.text,
      @JsonKey(name: 'DATE') required this.date});
  factory _ArmtekMessage.fromJson(Map<String, dynamic> json) =>
      _$ArmtekMessageFromJson(json);

  @override
  @JsonKey(name: 'TYPE')
  final String type;
  @override
  @JsonKey(name: 'TEXT')
  final String text;
  @override
  @JsonKey(name: 'DATE')
  final String date;

  /// Create a copy of ArmtekMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ArmtekMessageCopyWith<_ArmtekMessage> get copyWith =>
      __$ArmtekMessageCopyWithImpl<_ArmtekMessage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ArmtekMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ArmtekMessage &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.date, date) || other.date == date));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text, date);

  @override
  String toString() {
    return 'ArmtekMessage(type: $type, text: $text, date: $date)';
  }
}

/// @nodoc
abstract mixin class _$ArmtekMessageCopyWith<$Res>
    implements $ArmtekMessageCopyWith<$Res> {
  factory _$ArmtekMessageCopyWith(
          _ArmtekMessage value, $Res Function(_ArmtekMessage) _then) =
      __$ArmtekMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'TYPE') String type,
      @JsonKey(name: 'TEXT') String text,
      @JsonKey(name: 'DATE') String date});
}

/// @nodoc
class __$ArmtekMessageCopyWithImpl<$Res>
    implements _$ArmtekMessageCopyWith<$Res> {
  __$ArmtekMessageCopyWithImpl(this._self, this._then);

  final _ArmtekMessage _self;
  final $Res Function(_ArmtekMessage) _then;

  /// Create a copy of ArmtekMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? date = null,
  }) {
    return _then(_ArmtekMessage(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _self.date
          : date // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\armtek_message.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'armtek_message.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ArmtekMessage _$ArmtekMessageFromJson(Map<String, dynamic> json) =>
    _ArmtekMessage(
      type: json['TYPE'] as String,
      text: json['TEXT'] as String,
      date: json['DATE'] as String,
    );

Map<String, dynamic> _$ArmtekMessageToJson(_ArmtekMessage instance) =>
    <String, dynamic>{
      'TYPE': instance.type,
      'TEXT': instance.text,
      'DATE': instance.date,
    };

```

## lib\features\suppliers\models\armtek\armtek_response_wrapper.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'armtek_message.dart'; // Модель для сообщений

part 'armtek_response_wrapper.freezed.dart';
part 'armtek_response_wrapper.g.dart';

@Freezed(
    genericArgumentFactories:
        true) // Важно для поддержки дженерика T при генерации fromJson
abstract class ArmtekResponseWrapper<T> with _$ArmtekResponseWrapper<T> {
  const factory ArmtekResponseWrapper({
    @JsonKey(name: 'STATUS') required int status,
    @JsonKey(name: 'MESSAGES') List<ArmtekMessage>? messages,
    @JsonKey(name: 'RESP') T? responseData, // Полезная нагрузка
  }) = _ArmtekResponseWrapper<T>;

  factory ArmtekResponseWrapper.fromJson(
          Map<String, dynamic> json, T Function(Object?) fromJsonT) =>
      _$ArmtekResponseWrapperFromJson<T>(json, fromJsonT);
}

```

## lib\features\suppliers\models\armtek\armtek_response_wrapper.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'armtek_response_wrapper.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ArmtekResponseWrapper<T> {
  @JsonKey(name: 'STATUS')
  int get status;
  @JsonKey(name: 'MESSAGES')
  List<ArmtekMessage>? get messages;
  @JsonKey(name: 'RESP')
  T? get responseData;

  /// Create a copy of ArmtekResponseWrapper
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ArmtekResponseWrapperCopyWith<T, ArmtekResponseWrapper<T>> get copyWith =>
      _$ArmtekResponseWrapperCopyWithImpl<T, ArmtekResponseWrapper<T>>(
          this as ArmtekResponseWrapper<T>, _$identity);

  /// Serializes this ArmtekResponseWrapper to a JSON map.
  Map<String, dynamic> toJson(Object? Function(T) toJsonT);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ArmtekResponseWrapper<T> &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other.messages, messages) &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      const DeepCollectionEquality().hash(messages),
      const DeepCollectionEquality().hash(responseData));

  @override
  String toString() {
    return 'ArmtekResponseWrapper<$T>(status: $status, messages: $messages, responseData: $responseData)';
  }
}

/// @nodoc
abstract mixin class $ArmtekResponseWrapperCopyWith<T, $Res> {
  factory $ArmtekResponseWrapperCopyWith(ArmtekResponseWrapper<T> value,
          $Res Function(ArmtekResponseWrapper<T>) _then) =
      _$ArmtekResponseWrapperCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'STATUS') int status,
      @JsonKey(name: 'MESSAGES') List<ArmtekMessage>? messages,
      @JsonKey(name: 'RESP') T? responseData});
}

/// @nodoc
class _$ArmtekResponseWrapperCopyWithImpl<T, $Res>
    implements $ArmtekResponseWrapperCopyWith<T, $Res> {
  _$ArmtekResponseWrapperCopyWithImpl(this._self, this._then);

  final ArmtekResponseWrapper<T> _self;
  final $Res Function(ArmtekResponseWrapper<T>) _then;

  /// Create a copy of ArmtekResponseWrapper
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? messages = freezed,
    Object? responseData = freezed,
  }) {
    return _then(_self.copyWith(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int,
      messages: freezed == messages
          ? _self.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ArmtekMessage>?,
      responseData: freezed == responseData
          ? _self.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc
@JsonSerializable(genericArgumentFactories: true)
class _ArmtekResponseWrapper<T> implements ArmtekResponseWrapper<T> {
  const _ArmtekResponseWrapper(
      {@JsonKey(name: 'STATUS') required this.status,
      @JsonKey(name: 'MESSAGES') final List<ArmtekMessage>? messages,
      @JsonKey(name: 'RESP') this.responseData})
      : _messages = messages;
  factory _ArmtekResponseWrapper.fromJson(
          Map<String, dynamic> json, T Function(Object?) fromJsonT) =>
      _$ArmtekResponseWrapperFromJson(json, fromJsonT);

  @override
  @JsonKey(name: 'STATUS')
  final int status;
  final List<ArmtekMessage>? _messages;
  @override
  @JsonKey(name: 'MESSAGES')
  List<ArmtekMessage>? get messages {
    final value = _messages;
    if (value == null) return null;
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'RESP')
  final T? responseData;

  /// Create a copy of ArmtekResponseWrapper
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ArmtekResponseWrapperCopyWith<T, _ArmtekResponseWrapper<T>> get copyWith =>
      __$ArmtekResponseWrapperCopyWithImpl<T, _ArmtekResponseWrapper<T>>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson(Object? Function(T) toJsonT) {
    return _$ArmtekResponseWrapperToJson<T>(this, toJsonT);
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ArmtekResponseWrapper<T> &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      const DeepCollectionEquality().hash(_messages),
      const DeepCollectionEquality().hash(responseData));

  @override
  String toString() {
    return 'ArmtekResponseWrapper<$T>(status: $status, messages: $messages, responseData: $responseData)';
  }
}

/// @nodoc
abstract mixin class _$ArmtekResponseWrapperCopyWith<T, $Res>
    implements $ArmtekResponseWrapperCopyWith<T, $Res> {
  factory _$ArmtekResponseWrapperCopyWith(_ArmtekResponseWrapper<T> value,
          $Res Function(_ArmtekResponseWrapper<T>) _then) =
      __$ArmtekResponseWrapperCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'STATUS') int status,
      @JsonKey(name: 'MESSAGES') List<ArmtekMessage>? messages,
      @JsonKey(name: 'RESP') T? responseData});
}

/// @nodoc
class __$ArmtekResponseWrapperCopyWithImpl<T, $Res>
    implements _$ArmtekResponseWrapperCopyWith<T, $Res> {
  __$ArmtekResponseWrapperCopyWithImpl(this._self, this._then);

  final _ArmtekResponseWrapper<T> _self;
  final $Res Function(_ArmtekResponseWrapper<T>) _then;

  /// Create a copy of ArmtekResponseWrapper
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? status = null,
    Object? messages = freezed,
    Object? responseData = freezed,
  }) {
    return _then(_ArmtekResponseWrapper<T>(
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as int,
      messages: freezed == messages
          ? _self._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ArmtekMessage>?,
      responseData: freezed == responseData
          ? _self.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\armtek_response_wrapper.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'armtek_response_wrapper.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_ArmtekResponseWrapper<T> _$ArmtekResponseWrapperFromJson<T>(
  Map<String, dynamic> json,
  T Function(Object? json) fromJsonT,
) =>
    _ArmtekResponseWrapper<T>(
      status: (json['STATUS'] as num).toInt(),
      messages: (json['MESSAGES'] as List<dynamic>?)
          ?.map((e) => ArmtekMessage.fromJson(e as Map<String, dynamic>))
          .toList(),
      responseData: _$nullableGenericFromJson(json['RESP'], fromJsonT),
    );

Map<String, dynamic> _$ArmtekResponseWrapperToJson<T>(
  _ArmtekResponseWrapper<T> instance,
  Object? Function(T value) toJsonT,
) =>
    <String, dynamic>{
      'STATUS': instance.status,
      'MESSAGES': instance.messages,
      'RESP': _$nullableGenericToJson(instance.responseData, toJsonT),
    };

T? _$nullableGenericFromJson<T>(
  Object? input,
  T Function(Object? json) fromJson,
) =>
    input == null ? null : fromJson(input);

Object? _$nullableGenericToJson<T>(
  T? input,
  Object? Function(T value) toJson,
) =>
    input == null ? null : toJson(input);

```

## lib\features\suppliers\models\armtek\brand_item.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'brand_item.freezed.dart';
part 'brand_item.g.dart';

@freezed
abstract class BrandItem with _$BrandItem {
  const factory BrandItem({
    @JsonKey(name: 'BRAND') required String brand,
    @JsonKey(name: 'BRAND_NAME') required String brandName,
  }) = _BrandItem;

  factory BrandItem.fromJson(Map<String, dynamic> json) =>
      _$BrandItemFromJson(json);
}

```

## lib\features\suppliers\models\armtek\brand_item.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'brand_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BrandItem {
  @JsonKey(name: 'BRAND')
  String get brand;
  @JsonKey(name: 'BRAND_NAME')
  String get brandName;

  /// Create a copy of BrandItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BrandItemCopyWith<BrandItem> get copyWith =>
      _$BrandItemCopyWithImpl<BrandItem>(this as BrandItem, _$identity);

  /// Serializes this BrandItem to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BrandItem &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, brand, brandName);

  @override
  String toString() {
    return 'BrandItem(brand: $brand, brandName: $brandName)';
  }
}

/// @nodoc
abstract mixin class $BrandItemCopyWith<$Res> {
  factory $BrandItemCopyWith(BrandItem value, $Res Function(BrandItem) _then) =
      _$BrandItemCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'BRAND') String brand,
      @JsonKey(name: 'BRAND_NAME') String brandName});
}

/// @nodoc
class _$BrandItemCopyWithImpl<$Res> implements $BrandItemCopyWith<$Res> {
  _$BrandItemCopyWithImpl(this._self, this._then);

  final BrandItem _self;
  final $Res Function(BrandItem) _then;

  /// Create a copy of BrandItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? brand = null,
    Object? brandName = null,
  }) {
    return _then(_self.copyWith(
      brand: null == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String,
      brandName: null == brandName
          ? _self.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _BrandItem implements BrandItem {
  const _BrandItem(
      {@JsonKey(name: 'BRAND') required this.brand,
      @JsonKey(name: 'BRAND_NAME') required this.brandName});
  factory _BrandItem.fromJson(Map<String, dynamic> json) =>
      _$BrandItemFromJson(json);

  @override
  @JsonKey(name: 'BRAND')
  final String brand;
  @override
  @JsonKey(name: 'BRAND_NAME')
  final String brandName;

  /// Create a copy of BrandItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BrandItemCopyWith<_BrandItem> get copyWith =>
      __$BrandItemCopyWithImpl<_BrandItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BrandItemToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BrandItem &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, brand, brandName);

  @override
  String toString() {
    return 'BrandItem(brand: $brand, brandName: $brandName)';
  }
}

/// @nodoc
abstract mixin class _$BrandItemCopyWith<$Res>
    implements $BrandItemCopyWith<$Res> {
  factory _$BrandItemCopyWith(
          _BrandItem value, $Res Function(_BrandItem) _then) =
      __$BrandItemCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'BRAND') String brand,
      @JsonKey(name: 'BRAND_NAME') String brandName});
}

/// @nodoc
class __$BrandItemCopyWithImpl<$Res> implements _$BrandItemCopyWith<$Res> {
  __$BrandItemCopyWithImpl(this._self, this._then);

  final _BrandItem _self;
  final $Res Function(_BrandItem) _then;

  /// Create a copy of BrandItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? brand = null,
    Object? brandName = null,
  }) {
    return _then(_BrandItem(
      brand: null == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String,
      brandName: null == brandName
          ? _self.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\brand_item.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'brand_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_BrandItem _$BrandItemFromJson(Map<String, dynamic> json) => _BrandItem(
      brand: json['BRAND'] as String,
      brandName: json['BRAND_NAME'] as String,
    );

Map<String, dynamic> _$BrandItemToJson(_BrandItem instance) =>
    <String, dynamic>{
      'BRAND': instance.brand,
      'BRAND_NAME': instance.brandName,
    };

```

## lib\features\suppliers\models\armtek\ping_response.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'ping_response.freezed.dart';
part 'ping_response.g.dart';

/// {@template ping_response}
/// Модель ответа для метода index сервиса ws_ping
/// {@endtemplate}
@freezed
abstract class PingResponse with _$PingResponse {
  /// {@macro ping_response}
  const factory PingResponse({
    /// IP адрес клиента, с которого пришел запрос
    @JsonKey(name: 'IP') required String ip,

    /// Время выполнения скрипта на сервере (в секундах с микросекундами)
    @JsonKey(name: 'TIME') required String time,
  }) = _PingResponse;

  /// Создает [PingResponse] из JSON объекта
  factory PingResponse.fromJson(Map<String, dynamic> json) =>
      _$PingResponseFromJson(json);
}

```

## lib\features\suppliers\models\armtek\ping_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ping_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PingResponse {
  /// IP адрес клиента, с которого пришел запрос
  @JsonKey(name: 'IP')
  String get ip;

  /// Время выполнения скрипта на сервере (в секундах с микросекундами)
  @JsonKey(name: 'TIME')
  String get time;

  /// Create a copy of PingResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PingResponseCopyWith<PingResponse> get copyWith =>
      _$PingResponseCopyWithImpl<PingResponse>(
          this as PingResponse, _$identity);

  /// Serializes this PingResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PingResponse &&
            (identical(other.ip, ip) || other.ip == ip) &&
            (identical(other.time, time) || other.time == time));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ip, time);

  @override
  String toString() {
    return 'PingResponse(ip: $ip, time: $time)';
  }
}

/// @nodoc
abstract mixin class $PingResponseCopyWith<$Res> {
  factory $PingResponseCopyWith(
          PingResponse value, $Res Function(PingResponse) _then) =
      _$PingResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'IP') String ip, @JsonKey(name: 'TIME') String time});
}

/// @nodoc
class _$PingResponseCopyWithImpl<$Res> implements $PingResponseCopyWith<$Res> {
  _$PingResponseCopyWithImpl(this._self, this._then);

  final PingResponse _self;
  final $Res Function(PingResponse) _then;

  /// Create a copy of PingResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ip = null,
    Object? time = null,
  }) {
    return _then(_self.copyWith(
      ip: null == ip
          ? _self.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      time: null == time
          ? _self.time
          : time // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PingResponse implements PingResponse {
  const _PingResponse(
      {@JsonKey(name: 'IP') required this.ip,
      @JsonKey(name: 'TIME') required this.time});
  factory _PingResponse.fromJson(Map<String, dynamic> json) =>
      _$PingResponseFromJson(json);

  /// IP адрес клиента, с которого пришел запрос
  @override
  @JsonKey(name: 'IP')
  final String ip;

  /// Время выполнения скрипта на сервере (в секундах с микросекундами)
  @override
  @JsonKey(name: 'TIME')
  final String time;

  /// Create a copy of PingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PingResponseCopyWith<_PingResponse> get copyWith =>
      __$PingResponseCopyWithImpl<_PingResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PingResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PingResponse &&
            (identical(other.ip, ip) || other.ip == ip) &&
            (identical(other.time, time) || other.time == time));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ip, time);

  @override
  String toString() {
    return 'PingResponse(ip: $ip, time: $time)';
  }
}

/// @nodoc
abstract mixin class _$PingResponseCopyWith<$Res>
    implements $PingResponseCopyWith<$Res> {
  factory _$PingResponseCopyWith(
          _PingResponse value, $Res Function(_PingResponse) _then) =
      __$PingResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'IP') String ip, @JsonKey(name: 'TIME') String time});
}

/// @nodoc
class __$PingResponseCopyWithImpl<$Res>
    implements _$PingResponseCopyWith<$Res> {
  __$PingResponseCopyWithImpl(this._self, this._then);

  final _PingResponse _self;
  final $Res Function(_PingResponse) _then;

  /// Create a copy of PingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? ip = null,
    Object? time = null,
  }) {
    return _then(_PingResponse(
      ip: null == ip
          ? _self.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      time: null == time
          ? _self.time
          : time // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\ping_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'ping_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PingResponse _$PingResponseFromJson(Map<String, dynamic> json) =>
    _PingResponse(
      ip: json['IP'] as String,
      time: json['TIME'] as String,
    );

Map<String, dynamic> _$PingResponseToJson(_PingResponse instance) =>
    <String, dynamic>{
      'IP': instance.ip,
      'TIME': instance.time,
    };

```

## lib\features\suppliers\models\armtek\store_item.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'store_item.freezed.dart';
part 'store_item.g.dart';

@freezed
abstract class StoreItem with _$StoreItem {
  const factory StoreItem({
    @JsonKey(name: 'KEYZAK') required String keyzak,
    @JsonKey(name: 'KEYZAK_NAME') required String keyzakName,
    @JsonKey(name: 'WERKS') String? werks,
    @JsonKey(name: 'ACTIVE') String? active,
  }) = _StoreItem;

  factory StoreItem.fromJson(Map<String, dynamic> json) =>
      _$StoreItemFromJson(json);
}

```

## lib\features\suppliers\models\armtek\store_item.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'store_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$StoreItem {
  @JsonKey(name: 'KEYZAK')
  String get keyzak;
  @JsonKey(name: 'KEYZAK_NAME')
  String get keyzakName;
  @JsonKey(name: 'WERKS')
  String? get werks;
  @JsonKey(name: 'ACTIVE')
  String? get active;

  /// Create a copy of StoreItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StoreItemCopyWith<StoreItem> get copyWith =>
      _$StoreItemCopyWithImpl<StoreItem>(this as StoreItem, _$identity);

  /// Serializes this StoreItem to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StoreItem &&
            (identical(other.keyzak, keyzak) || other.keyzak == keyzak) &&
            (identical(other.keyzakName, keyzakName) ||
                other.keyzakName == keyzakName) &&
            (identical(other.werks, werks) || other.werks == werks) &&
            (identical(other.active, active) || other.active == active));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, keyzak, keyzakName, werks, active);

  @override
  String toString() {
    return 'StoreItem(keyzak: $keyzak, keyzakName: $keyzakName, werks: $werks, active: $active)';
  }
}

/// @nodoc
abstract mixin class $StoreItemCopyWith<$Res> {
  factory $StoreItemCopyWith(StoreItem value, $Res Function(StoreItem) _then) =
      _$StoreItemCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'KEYZAK') String keyzak,
      @JsonKey(name: 'KEYZAK_NAME') String keyzakName,
      @JsonKey(name: 'WERKS') String? werks,
      @JsonKey(name: 'ACTIVE') String? active});
}

/// @nodoc
class _$StoreItemCopyWithImpl<$Res> implements $StoreItemCopyWith<$Res> {
  _$StoreItemCopyWithImpl(this._self, this._then);

  final StoreItem _self;
  final $Res Function(StoreItem) _then;

  /// Create a copy of StoreItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyzak = null,
    Object? keyzakName = null,
    Object? werks = freezed,
    Object? active = freezed,
  }) {
    return _then(_self.copyWith(
      keyzak: null == keyzak
          ? _self.keyzak
          : keyzak // ignore: cast_nullable_to_non_nullable
              as String,
      keyzakName: null == keyzakName
          ? _self.keyzakName
          : keyzakName // ignore: cast_nullable_to_non_nullable
              as String,
      werks: freezed == werks
          ? _self.werks
          : werks // ignore: cast_nullable_to_non_nullable
              as String?,
      active: freezed == active
          ? _self.active
          : active // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _StoreItem implements StoreItem {
  const _StoreItem(
      {@JsonKey(name: 'KEYZAK') required this.keyzak,
      @JsonKey(name: 'KEYZAK_NAME') required this.keyzakName,
      @JsonKey(name: 'WERKS') this.werks,
      @JsonKey(name: 'ACTIVE') this.active});
  factory _StoreItem.fromJson(Map<String, dynamic> json) =>
      _$StoreItemFromJson(json);

  @override
  @JsonKey(name: 'KEYZAK')
  final String keyzak;
  @override
  @JsonKey(name: 'KEYZAK_NAME')
  final String keyzakName;
  @override
  @JsonKey(name: 'WERKS')
  final String? werks;
  @override
  @JsonKey(name: 'ACTIVE')
  final String? active;

  /// Create a copy of StoreItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StoreItemCopyWith<_StoreItem> get copyWith =>
      __$StoreItemCopyWithImpl<_StoreItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StoreItemToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StoreItem &&
            (identical(other.keyzak, keyzak) || other.keyzak == keyzak) &&
            (identical(other.keyzakName, keyzakName) ||
                other.keyzakName == keyzakName) &&
            (identical(other.werks, werks) || other.werks == werks) &&
            (identical(other.active, active) || other.active == active));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, keyzak, keyzakName, werks, active);

  @override
  String toString() {
    return 'StoreItem(keyzak: $keyzak, keyzakName: $keyzakName, werks: $werks, active: $active)';
  }
}

/// @nodoc
abstract mixin class _$StoreItemCopyWith<$Res>
    implements $StoreItemCopyWith<$Res> {
  factory _$StoreItemCopyWith(
          _StoreItem value, $Res Function(_StoreItem) _then) =
      __$StoreItemCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'KEYZAK') String keyzak,
      @JsonKey(name: 'KEYZAK_NAME') String keyzakName,
      @JsonKey(name: 'WERKS') String? werks,
      @JsonKey(name: 'ACTIVE') String? active});
}

/// @nodoc
class __$StoreItemCopyWithImpl<$Res> implements _$StoreItemCopyWith<$Res> {
  __$StoreItemCopyWithImpl(this._self, this._then);

  final _StoreItem _self;
  final $Res Function(_StoreItem) _then;

  /// Create a copy of StoreItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? keyzak = null,
    Object? keyzakName = null,
    Object? werks = freezed,
    Object? active = freezed,
  }) {
    return _then(_StoreItem(
      keyzak: null == keyzak
          ? _self.keyzak
          : keyzak // ignore: cast_nullable_to_non_nullable
              as String,
      keyzakName: null == keyzakName
          ? _self.keyzakName
          : keyzakName // ignore: cast_nullable_to_non_nullable
              as String,
      werks: freezed == werks
          ? _self.werks
          : werks // ignore: cast_nullable_to_non_nullable
              as String?,
      active: freezed == active
          ? _self.active
          : active // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\store_item.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'store_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_StoreItem _$StoreItemFromJson(Map<String, dynamic> json) => _StoreItem(
      keyzak: json['KEYZAK'] as String,
      keyzakName: json['KEYZAK_NAME'] as String,
      werks: json['WERKS'] as String?,
      active: json['ACTIVE'] as String?,
    );

Map<String, dynamic> _$StoreItemToJson(_StoreItem instance) =>
    <String, dynamic>{
      'KEYZAK': instance.keyzak,
      'KEYZAK_NAME': instance.keyzakName,
      'WERKS': instance.werks,
      'ACTIVE': instance.active,
    };

```

## lib\features\suppliers\models\armtek\user_contact.dart
```dart
// filepath: c:\FlutterProject\part_catalog\lib\features\armtek\api\models\user_contact.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_contact.freezed.dart';
part 'user_contact.g.dart';

@freezed
abstract class UserContact with _$UserContact {
  const factory UserContact({
    @JsonKey(name: 'NAME_CON') String? name,
    @JsonKey(name: 'TEL_CON') String? telephone,
    @JsonKey(name: 'MOB_CON') String? mobile,
    @JsonKey(name: 'EMAIL_CON') String? email,
  }) = _UserContact;

  factory UserContact.fromJson(Map<String, dynamic> json) =>
      _$UserContactFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_contact.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_contact.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserContact {
  @JsonKey(name: 'NAME_CON')
  String? get name;
  @JsonKey(name: 'TEL_CON')
  String? get telephone;
  @JsonKey(name: 'MOB_CON')
  String? get mobile;
  @JsonKey(name: 'EMAIL_CON')
  String? get email;

  /// Create a copy of UserContact
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserContactCopyWith<UserContact> get copyWith =>
      _$UserContactCopyWithImpl<UserContact>(this as UserContact, _$identity);

  /// Serializes this UserContact to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserContact &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.telephone, telephone) ||
                other.telephone == telephone) &&
            (identical(other.mobile, mobile) || other.mobile == mobile) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, telephone, mobile, email);

  @override
  String toString() {
    return 'UserContact(name: $name, telephone: $telephone, mobile: $mobile, email: $email)';
  }
}

/// @nodoc
abstract mixin class $UserContactCopyWith<$Res> {
  factory $UserContactCopyWith(
          UserContact value, $Res Function(UserContact) _then) =
      _$UserContactCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'NAME_CON') String? name,
      @JsonKey(name: 'TEL_CON') String? telephone,
      @JsonKey(name: 'MOB_CON') String? mobile,
      @JsonKey(name: 'EMAIL_CON') String? email});
}

/// @nodoc
class _$UserContactCopyWithImpl<$Res> implements $UserContactCopyWith<$Res> {
  _$UserContactCopyWithImpl(this._self, this._then);

  final UserContact _self;
  final $Res Function(UserContact) _then;

  /// Create a copy of UserContact
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? telephone = freezed,
    Object? mobile = freezed,
    Object? email = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      telephone: freezed == telephone
          ? _self.telephone
          : telephone // ignore: cast_nullable_to_non_nullable
              as String?,
      mobile: freezed == mobile
          ? _self.mobile
          : mobile // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserContact implements UserContact {
  const _UserContact(
      {@JsonKey(name: 'NAME_CON') this.name,
      @JsonKey(name: 'TEL_CON') this.telephone,
      @JsonKey(name: 'MOB_CON') this.mobile,
      @JsonKey(name: 'EMAIL_CON') this.email});
  factory _UserContact.fromJson(Map<String, dynamic> json) =>
      _$UserContactFromJson(json);

  @override
  @JsonKey(name: 'NAME_CON')
  final String? name;
  @override
  @JsonKey(name: 'TEL_CON')
  final String? telephone;
  @override
  @JsonKey(name: 'MOB_CON')
  final String? mobile;
  @override
  @JsonKey(name: 'EMAIL_CON')
  final String? email;

  /// Create a copy of UserContact
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserContactCopyWith<_UserContact> get copyWith =>
      __$UserContactCopyWithImpl<_UserContact>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserContactToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserContact &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.telephone, telephone) ||
                other.telephone == telephone) &&
            (identical(other.mobile, mobile) || other.mobile == mobile) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, telephone, mobile, email);

  @override
  String toString() {
    return 'UserContact(name: $name, telephone: $telephone, mobile: $mobile, email: $email)';
  }
}

/// @nodoc
abstract mixin class _$UserContactCopyWith<$Res>
    implements $UserContactCopyWith<$Res> {
  factory _$UserContactCopyWith(
          _UserContact value, $Res Function(_UserContact) _then) =
      __$UserContactCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'NAME_CON') String? name,
      @JsonKey(name: 'TEL_CON') String? telephone,
      @JsonKey(name: 'MOB_CON') String? mobile,
      @JsonKey(name: 'EMAIL_CON') String? email});
}

/// @nodoc
class __$UserContactCopyWithImpl<$Res> implements _$UserContactCopyWith<$Res> {
  __$UserContactCopyWithImpl(this._self, this._then);

  final _UserContact _self;
  final $Res Function(_UserContact) _then;

  /// Create a copy of UserContact
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? telephone = freezed,
    Object? mobile = freezed,
    Object? email = freezed,
  }) {
    return _then(_UserContact(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      telephone: freezed == telephone
          ? _self.telephone
          : telephone // ignore: cast_nullable_to_non_nullable
              as String?,
      mobile: freezed == mobile
          ? _self.mobile
          : mobile // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_contact.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_contact.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserContact _$UserContactFromJson(Map<String, dynamic> json) => _UserContact(
      name: json['NAME_CON'] as String?,
      telephone: json['TEL_CON'] as String?,
      mobile: json['MOB_CON'] as String?,
      email: json['EMAIL_CON'] as String?,
    );

Map<String, dynamic> _$UserContactToJson(_UserContact instance) =>
    <String, dynamic>{
      'NAME_CON': instance.name,
      'TEL_CON': instance.telephone,
      'MOB_CON': instance.mobile,
      'EMAIL_CON': instance.email,
    };

```

## lib\features\suppliers\models\armtek\user_delivery_address.dart
```dart
// filepath: c:\FlutterProject\part_catalog\lib\features\armtek\api\models\user_delivery_address.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_delivery_address.freezed.dart';
part 'user_delivery_address.g.dart';

@freezed
abstract class UserDeliveryAddress with _$UserDeliveryAddress {
  const factory UserDeliveryAddress({
    @JsonKey(name: 'ADDRESS_CODE') String? addressCode,
    @JsonKey(name: 'ADDRESS_NAME') String? addressName,
  }) = _UserDeliveryAddress;

  factory UserDeliveryAddress.fromJson(Map<String, dynamic> json) =>
      _$UserDeliveryAddressFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_delivery_address.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_delivery_address.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserDeliveryAddress {
  @JsonKey(name: 'ADDRESS_CODE')
  String? get addressCode;
  @JsonKey(name: 'ADDRESS_NAME')
  String? get addressName;

  /// Create a copy of UserDeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserDeliveryAddressCopyWith<UserDeliveryAddress> get copyWith =>
      _$UserDeliveryAddressCopyWithImpl<UserDeliveryAddress>(
          this as UserDeliveryAddress, _$identity);

  /// Serializes this UserDeliveryAddress to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserDeliveryAddress &&
            (identical(other.addressCode, addressCode) ||
                other.addressCode == addressCode) &&
            (identical(other.addressName, addressName) ||
                other.addressName == addressName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, addressCode, addressName);

  @override
  String toString() {
    return 'UserDeliveryAddress(addressCode: $addressCode, addressName: $addressName)';
  }
}

/// @nodoc
abstract mixin class $UserDeliveryAddressCopyWith<$Res> {
  factory $UserDeliveryAddressCopyWith(
          UserDeliveryAddress value, $Res Function(UserDeliveryAddress) _then) =
      _$UserDeliveryAddressCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'ADDRESS_CODE') String? addressCode,
      @JsonKey(name: 'ADDRESS_NAME') String? addressName});
}

/// @nodoc
class _$UserDeliveryAddressCopyWithImpl<$Res>
    implements $UserDeliveryAddressCopyWith<$Res> {
  _$UserDeliveryAddressCopyWithImpl(this._self, this._then);

  final UserDeliveryAddress _self;
  final $Res Function(UserDeliveryAddress) _then;

  /// Create a copy of UserDeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressCode = freezed,
    Object? addressName = freezed,
  }) {
    return _then(_self.copyWith(
      addressCode: freezed == addressCode
          ? _self.addressCode
          : addressCode // ignore: cast_nullable_to_non_nullable
              as String?,
      addressName: freezed == addressName
          ? _self.addressName
          : addressName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserDeliveryAddress implements UserDeliveryAddress {
  const _UserDeliveryAddress(
      {@JsonKey(name: 'ADDRESS_CODE') this.addressCode,
      @JsonKey(name: 'ADDRESS_NAME') this.addressName});
  factory _UserDeliveryAddress.fromJson(Map<String, dynamic> json) =>
      _$UserDeliveryAddressFromJson(json);

  @override
  @JsonKey(name: 'ADDRESS_CODE')
  final String? addressCode;
  @override
  @JsonKey(name: 'ADDRESS_NAME')
  final String? addressName;

  /// Create a copy of UserDeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserDeliveryAddressCopyWith<_UserDeliveryAddress> get copyWith =>
      __$UserDeliveryAddressCopyWithImpl<_UserDeliveryAddress>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserDeliveryAddressToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserDeliveryAddress &&
            (identical(other.addressCode, addressCode) ||
                other.addressCode == addressCode) &&
            (identical(other.addressName, addressName) ||
                other.addressName == addressName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, addressCode, addressName);

  @override
  String toString() {
    return 'UserDeliveryAddress(addressCode: $addressCode, addressName: $addressName)';
  }
}

/// @nodoc
abstract mixin class _$UserDeliveryAddressCopyWith<$Res>
    implements $UserDeliveryAddressCopyWith<$Res> {
  factory _$UserDeliveryAddressCopyWith(_UserDeliveryAddress value,
          $Res Function(_UserDeliveryAddress) _then) =
      __$UserDeliveryAddressCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'ADDRESS_CODE') String? addressCode,
      @JsonKey(name: 'ADDRESS_NAME') String? addressName});
}

/// @nodoc
class __$UserDeliveryAddressCopyWithImpl<$Res>
    implements _$UserDeliveryAddressCopyWith<$Res> {
  __$UserDeliveryAddressCopyWithImpl(this._self, this._then);

  final _UserDeliveryAddress _self;
  final $Res Function(_UserDeliveryAddress) _then;

  /// Create a copy of UserDeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? addressCode = freezed,
    Object? addressName = freezed,
  }) {
    return _then(_UserDeliveryAddress(
      addressCode: freezed == addressCode
          ? _self.addressCode
          : addressCode // ignore: cast_nullable_to_non_nullable
              as String?,
      addressName: freezed == addressName
          ? _self.addressName
          : addressName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_delivery_address.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_delivery_address.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserDeliveryAddress _$UserDeliveryAddressFromJson(Map<String, dynamic> json) =>
    _UserDeliveryAddress(
      addressCode: json['ADDRESS_CODE'] as String?,
      addressName: json['ADDRESS_NAME'] as String?,
    );

Map<String, dynamic> _$UserDeliveryAddressToJson(
        _UserDeliveryAddress instance) =>
    <String, dynamic>{
      'ADDRESS_CODE': instance.addressCode,
      'ADDRESS_NAME': instance.addressName,
    };

```

## lib\features\suppliers\models\armtek\user_ftp_data.dart
```dart
// filepath: c:\FlutterProject\part_catalog\lib\features\armtek\api\models\user_ftp_data.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_ftp_data.freezed.dart';
part 'user_ftp_data.g.dart';

@freezed
abstract class UserFtpData with _$UserFtpData {
  const factory UserFtpData({
    @JsonKey(name: 'FTP_SERVER') String? server,
    @JsonKey(name: 'FTP_LOGIN') String? login,
    @JsonKey(name: 'FTP_PASSWORD') String? password,
    @JsonKey(name: 'FTP_WORK_DIR') String? workDir,
  }) = _UserFtpData;

  factory UserFtpData.fromJson(Map<String, dynamic> json) =>
      _$UserFtpDataFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_ftp_data.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_ftp_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserFtpData {
  @JsonKey(name: 'FTP_SERVER')
  String? get server;
  @JsonKey(name: 'FTP_LOGIN')
  String? get login;
  @JsonKey(name: 'FTP_PASSWORD')
  String? get password;
  @JsonKey(name: 'FTP_WORK_DIR')
  String? get workDir;

  /// Create a copy of UserFtpData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserFtpDataCopyWith<UserFtpData> get copyWith =>
      _$UserFtpDataCopyWithImpl<UserFtpData>(this as UserFtpData, _$identity);

  /// Serializes this UserFtpData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserFtpData &&
            (identical(other.server, server) || other.server == server) &&
            (identical(other.login, login) || other.login == login) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.workDir, workDir) || other.workDir == workDir));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, server, login, password, workDir);

  @override
  String toString() {
    return 'UserFtpData(server: $server, login: $login, password: $password, workDir: $workDir)';
  }
}

/// @nodoc
abstract mixin class $UserFtpDataCopyWith<$Res> {
  factory $UserFtpDataCopyWith(
          UserFtpData value, $Res Function(UserFtpData) _then) =
      _$UserFtpDataCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'FTP_SERVER') String? server,
      @JsonKey(name: 'FTP_LOGIN') String? login,
      @JsonKey(name: 'FTP_PASSWORD') String? password,
      @JsonKey(name: 'FTP_WORK_DIR') String? workDir});
}

/// @nodoc
class _$UserFtpDataCopyWithImpl<$Res> implements $UserFtpDataCopyWith<$Res> {
  _$UserFtpDataCopyWithImpl(this._self, this._then);

  final UserFtpData _self;
  final $Res Function(UserFtpData) _then;

  /// Create a copy of UserFtpData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? server = freezed,
    Object? login = freezed,
    Object? password = freezed,
    Object? workDir = freezed,
  }) {
    return _then(_self.copyWith(
      server: freezed == server
          ? _self.server
          : server // ignore: cast_nullable_to_non_nullable
              as String?,
      login: freezed == login
          ? _self.login
          : login // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
      workDir: freezed == workDir
          ? _self.workDir
          : workDir // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserFtpData implements UserFtpData {
  const _UserFtpData(
      {@JsonKey(name: 'FTP_SERVER') this.server,
      @JsonKey(name: 'FTP_LOGIN') this.login,
      @JsonKey(name: 'FTP_PASSWORD') this.password,
      @JsonKey(name: 'FTP_WORK_DIR') this.workDir});
  factory _UserFtpData.fromJson(Map<String, dynamic> json) =>
      _$UserFtpDataFromJson(json);

  @override
  @JsonKey(name: 'FTP_SERVER')
  final String? server;
  @override
  @JsonKey(name: 'FTP_LOGIN')
  final String? login;
  @override
  @JsonKey(name: 'FTP_PASSWORD')
  final String? password;
  @override
  @JsonKey(name: 'FTP_WORK_DIR')
  final String? workDir;

  /// Create a copy of UserFtpData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserFtpDataCopyWith<_UserFtpData> get copyWith =>
      __$UserFtpDataCopyWithImpl<_UserFtpData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserFtpDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserFtpData &&
            (identical(other.server, server) || other.server == server) &&
            (identical(other.login, login) || other.login == login) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.workDir, workDir) || other.workDir == workDir));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, server, login, password, workDir);

  @override
  String toString() {
    return 'UserFtpData(server: $server, login: $login, password: $password, workDir: $workDir)';
  }
}

/// @nodoc
abstract mixin class _$UserFtpDataCopyWith<$Res>
    implements $UserFtpDataCopyWith<$Res> {
  factory _$UserFtpDataCopyWith(
          _UserFtpData value, $Res Function(_UserFtpData) _then) =
      __$UserFtpDataCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'FTP_SERVER') String? server,
      @JsonKey(name: 'FTP_LOGIN') String? login,
      @JsonKey(name: 'FTP_PASSWORD') String? password,
      @JsonKey(name: 'FTP_WORK_DIR') String? workDir});
}

/// @nodoc
class __$UserFtpDataCopyWithImpl<$Res> implements _$UserFtpDataCopyWith<$Res> {
  __$UserFtpDataCopyWithImpl(this._self, this._then);

  final _UserFtpData _self;
  final $Res Function(_UserFtpData) _then;

  /// Create a copy of UserFtpData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? server = freezed,
    Object? login = freezed,
    Object? password = freezed,
    Object? workDir = freezed,
  }) {
    return _then(_UserFtpData(
      server: freezed == server
          ? _self.server
          : server // ignore: cast_nullable_to_non_nullable
              as String?,
      login: freezed == login
          ? _self.login
          : login // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
      workDir: freezed == workDir
          ? _self.workDir
          : workDir // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_ftp_data.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_ftp_data.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserFtpData _$UserFtpDataFromJson(Map<String, dynamic> json) => _UserFtpData(
      server: json['FTP_SERVER'] as String?,
      login: json['FTP_LOGIN'] as String?,
      password: json['FTP_PASSWORD'] as String?,
      workDir: json['FTP_WORK_DIR'] as String?,
    );

Map<String, dynamic> _$UserFtpDataToJson(_UserFtpData instance) =>
    <String, dynamic>{
      'FTP_SERVER': instance.server,
      'FTP_LOGIN': instance.login,
      'FTP_PASSWORD': instance.password,
      'FTP_WORK_DIR': instance.workDir,
    };

```

## lib\features\suppliers\models\armtek\user_info_request.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_info_request.freezed.dart';
part 'user_info_request.g.dart';

@freezed
abstract class UserInfoRequest with _$UserInfoRequest {
  const factory UserInfoRequest({
    @JsonKey(name: 'VKORG') required String vkorg,
    @JsonKey(name: 'STRUCTURE', defaultValue: '1') String? structure,
    @JsonKey(name: 'FTPDATA', defaultValue: '1') String? ftpData,
  }) = _UserInfoRequest;

  factory UserInfoRequest.fromJson(Map<String, dynamic> json) =>
      _$UserInfoRequestFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_info_request.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_info_request.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserInfoRequest {
  @JsonKey(name: 'VKORG')
  String get vkorg;
  @JsonKey(name: 'STRUCTURE', defaultValue: '1')
  String? get structure;
  @JsonKey(name: 'FTPDATA', defaultValue: '1')
  String? get ftpData;

  /// Create a copy of UserInfoRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserInfoRequestCopyWith<UserInfoRequest> get copyWith =>
      _$UserInfoRequestCopyWithImpl<UserInfoRequest>(
          this as UserInfoRequest, _$identity);

  /// Serializes this UserInfoRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserInfoRequest &&
            (identical(other.vkorg, vkorg) || other.vkorg == vkorg) &&
            (identical(other.structure, structure) ||
                other.structure == structure) &&
            (identical(other.ftpData, ftpData) || other.ftpData == ftpData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, vkorg, structure, ftpData);

  @override
  String toString() {
    return 'UserInfoRequest(vkorg: $vkorg, structure: $structure, ftpData: $ftpData)';
  }
}

/// @nodoc
abstract mixin class $UserInfoRequestCopyWith<$Res> {
  factory $UserInfoRequestCopyWith(
          UserInfoRequest value, $Res Function(UserInfoRequest) _then) =
      _$UserInfoRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'VKORG') String vkorg,
      @JsonKey(name: 'STRUCTURE', defaultValue: '1') String? structure,
      @JsonKey(name: 'FTPDATA', defaultValue: '1') String? ftpData});
}

/// @nodoc
class _$UserInfoRequestCopyWithImpl<$Res>
    implements $UserInfoRequestCopyWith<$Res> {
  _$UserInfoRequestCopyWithImpl(this._self, this._then);

  final UserInfoRequest _self;
  final $Res Function(UserInfoRequest) _then;

  /// Create a copy of UserInfoRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vkorg = null,
    Object? structure = freezed,
    Object? ftpData = freezed,
  }) {
    return _then(_self.copyWith(
      vkorg: null == vkorg
          ? _self.vkorg
          : vkorg // ignore: cast_nullable_to_non_nullable
              as String,
      structure: freezed == structure
          ? _self.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as String?,
      ftpData: freezed == ftpData
          ? _self.ftpData
          : ftpData // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserInfoRequest implements UserInfoRequest {
  const _UserInfoRequest(
      {@JsonKey(name: 'VKORG') required this.vkorg,
      @JsonKey(name: 'STRUCTURE', defaultValue: '1') this.structure,
      @JsonKey(name: 'FTPDATA', defaultValue: '1') this.ftpData});
  factory _UserInfoRequest.fromJson(Map<String, dynamic> json) =>
      _$UserInfoRequestFromJson(json);

  @override
  @JsonKey(name: 'VKORG')
  final String vkorg;
  @override
  @JsonKey(name: 'STRUCTURE', defaultValue: '1')
  final String? structure;
  @override
  @JsonKey(name: 'FTPDATA', defaultValue: '1')
  final String? ftpData;

  /// Create a copy of UserInfoRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserInfoRequestCopyWith<_UserInfoRequest> get copyWith =>
      __$UserInfoRequestCopyWithImpl<_UserInfoRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserInfoRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserInfoRequest &&
            (identical(other.vkorg, vkorg) || other.vkorg == vkorg) &&
            (identical(other.structure, structure) ||
                other.structure == structure) &&
            (identical(other.ftpData, ftpData) || other.ftpData == ftpData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, vkorg, structure, ftpData);

  @override
  String toString() {
    return 'UserInfoRequest(vkorg: $vkorg, structure: $structure, ftpData: $ftpData)';
  }
}

/// @nodoc
abstract mixin class _$UserInfoRequestCopyWith<$Res>
    implements $UserInfoRequestCopyWith<$Res> {
  factory _$UserInfoRequestCopyWith(
          _UserInfoRequest value, $Res Function(_UserInfoRequest) _then) =
      __$UserInfoRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'VKORG') String vkorg,
      @JsonKey(name: 'STRUCTURE', defaultValue: '1') String? structure,
      @JsonKey(name: 'FTPDATA', defaultValue: '1') String? ftpData});
}

/// @nodoc
class __$UserInfoRequestCopyWithImpl<$Res>
    implements _$UserInfoRequestCopyWith<$Res> {
  __$UserInfoRequestCopyWithImpl(this._self, this._then);

  final _UserInfoRequest _self;
  final $Res Function(_UserInfoRequest) _then;

  /// Create a copy of UserInfoRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? vkorg = null,
    Object? structure = freezed,
    Object? ftpData = freezed,
  }) {
    return _then(_UserInfoRequest(
      vkorg: null == vkorg
          ? _self.vkorg
          : vkorg // ignore: cast_nullable_to_non_nullable
              as String,
      structure: freezed == structure
          ? _self.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as String?,
      ftpData: freezed == ftpData
          ? _self.ftpData
          : ftpData // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_info_request.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_info_request.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserInfoRequest _$UserInfoRequestFromJson(Map<String, dynamic> json) =>
    _UserInfoRequest(
      vkorg: json['VKORG'] as String,
      structure: json['STRUCTURE'] as String? ?? '1',
      ftpData: json['FTPDATA'] as String? ?? '1',
    );

Map<String, dynamic> _$UserInfoRequestToJson(_UserInfoRequest instance) =>
    <String, dynamic>{
      'VKORG': instance.vkorg,
      'STRUCTURE': instance.structure,
      'FTPDATA': instance.ftpData,
    };

```

## lib\features\suppliers\models\armtek\user_info_response.dart
```dart
// filepath: c:\FlutterProject\part_catalog\lib\features\armtek\api\models\user_info_response.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'user_structure_item.dart';
import 'user_ftp_data.dart';

part 'user_info_response.freezed.dart';
part 'user_info_response.g.dart';

@freezed
abstract class UserInfoResponse with _$UserInfoResponse {
  const factory UserInfoResponse({
    @JsonKey(name: 'STRUCTURE') List<UserStructureItem>? structure,
    @JsonKey(name: 'FTPDATA') UserFtpData? ftpData,
  }) = _UserInfoResponse;

  factory UserInfoResponse.fromJson(Map<String, dynamic> json) =>
      _$UserInfoResponseFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_info_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_info_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserInfoResponse {
  @JsonKey(name: 'STRUCTURE')
  List<UserStructureItem>? get structure;
  @JsonKey(name: 'FTPDATA')
  UserFtpData? get ftpData;

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserInfoResponseCopyWith<UserInfoResponse> get copyWith =>
      _$UserInfoResponseCopyWithImpl<UserInfoResponse>(
          this as UserInfoResponse, _$identity);

  /// Serializes this UserInfoResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserInfoResponse &&
            const DeepCollectionEquality().equals(other.structure, structure) &&
            (identical(other.ftpData, ftpData) || other.ftpData == ftpData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(structure), ftpData);

  @override
  String toString() {
    return 'UserInfoResponse(structure: $structure, ftpData: $ftpData)';
  }
}

/// @nodoc
abstract mixin class $UserInfoResponseCopyWith<$Res> {
  factory $UserInfoResponseCopyWith(
          UserInfoResponse value, $Res Function(UserInfoResponse) _then) =
      _$UserInfoResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'STRUCTURE') List<UserStructureItem>? structure,
      @JsonKey(name: 'FTPDATA') UserFtpData? ftpData});

  $UserFtpDataCopyWith<$Res>? get ftpData;
}

/// @nodoc
class _$UserInfoResponseCopyWithImpl<$Res>
    implements $UserInfoResponseCopyWith<$Res> {
  _$UserInfoResponseCopyWithImpl(this._self, this._then);

  final UserInfoResponse _self;
  final $Res Function(UserInfoResponse) _then;

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? structure = freezed,
    Object? ftpData = freezed,
  }) {
    return _then(_self.copyWith(
      structure: freezed == structure
          ? _self.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<UserStructureItem>?,
      ftpData: freezed == ftpData
          ? _self.ftpData
          : ftpData // ignore: cast_nullable_to_non_nullable
              as UserFtpData?,
    ));
  }

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserFtpDataCopyWith<$Res>? get ftpData {
    if (_self.ftpData == null) {
      return null;
    }

    return $UserFtpDataCopyWith<$Res>(_self.ftpData!, (value) {
      return _then(_self.copyWith(ftpData: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _UserInfoResponse implements UserInfoResponse {
  const _UserInfoResponse(
      {@JsonKey(name: 'STRUCTURE') final List<UserStructureItem>? structure,
      @JsonKey(name: 'FTPDATA') this.ftpData})
      : _structure = structure;
  factory _UserInfoResponse.fromJson(Map<String, dynamic> json) =>
      _$UserInfoResponseFromJson(json);

  final List<UserStructureItem>? _structure;
  @override
  @JsonKey(name: 'STRUCTURE')
  List<UserStructureItem>? get structure {
    final value = _structure;
    if (value == null) return null;
    if (_structure is EqualUnmodifiableListView) return _structure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'FTPDATA')
  final UserFtpData? ftpData;

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserInfoResponseCopyWith<_UserInfoResponse> get copyWith =>
      __$UserInfoResponseCopyWithImpl<_UserInfoResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserInfoResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserInfoResponse &&
            const DeepCollectionEquality()
                .equals(other._structure, _structure) &&
            (identical(other.ftpData, ftpData) || other.ftpData == ftpData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_structure), ftpData);

  @override
  String toString() {
    return 'UserInfoResponse(structure: $structure, ftpData: $ftpData)';
  }
}

/// @nodoc
abstract mixin class _$UserInfoResponseCopyWith<$Res>
    implements $UserInfoResponseCopyWith<$Res> {
  factory _$UserInfoResponseCopyWith(
          _UserInfoResponse value, $Res Function(_UserInfoResponse) _then) =
      __$UserInfoResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'STRUCTURE') List<UserStructureItem>? structure,
      @JsonKey(name: 'FTPDATA') UserFtpData? ftpData});

  @override
  $UserFtpDataCopyWith<$Res>? get ftpData;
}

/// @nodoc
class __$UserInfoResponseCopyWithImpl<$Res>
    implements _$UserInfoResponseCopyWith<$Res> {
  __$UserInfoResponseCopyWithImpl(this._self, this._then);

  final _UserInfoResponse _self;
  final $Res Function(_UserInfoResponse) _then;

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? structure = freezed,
    Object? ftpData = freezed,
  }) {
    return _then(_UserInfoResponse(
      structure: freezed == structure
          ? _self._structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<UserStructureItem>?,
      ftpData: freezed == ftpData
          ? _self.ftpData
          : ftpData // ignore: cast_nullable_to_non_nullable
              as UserFtpData?,
    ));
  }

  /// Create a copy of UserInfoResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserFtpDataCopyWith<$Res>? get ftpData {
    if (_self.ftpData == null) {
      return null;
    }

    return $UserFtpDataCopyWith<$Res>(_self.ftpData!, (value) {
      return _then(_self.copyWith(ftpData: value));
    });
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_info_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_info_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserInfoResponse _$UserInfoResponseFromJson(Map<String, dynamic> json) =>
    _UserInfoResponse(
      structure: (json['STRUCTURE'] as List<dynamic>?)
          ?.map((e) => UserStructureItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      ftpData: json['FTPDATA'] == null
          ? null
          : UserFtpData.fromJson(json['FTPDATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$UserInfoResponseToJson(_UserInfoResponse instance) =>
    <String, dynamic>{
      'STRUCTURE': instance.structure,
      'FTPDATA': instance.ftpData,
    };

```

## lib\features\suppliers\models\armtek\user_structure_item.dart
```dart
// filepath: c:\FlutterProject\part_catalog\lib\features\armtek\api\models\user_structure_item.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'user_contact.dart';
import 'user_delivery_address.dart';

part 'user_structure_item.freezed.dart';
part 'user_structure_item.g.dart';

@freezed
abstract class UserStructureItem with _$UserStructureItem {
  const factory UserStructureItem({
    @JsonKey(name: 'KUNNR') String? kunnr,
    @JsonKey(name: 'NAME1') String? name1,
    @JsonKey(name: 'NAME2') String? name2,
    @JsonKey(name: 'ORT01') String? city,
    @JsonKey(name: 'STRAS') String? street,
    @JsonKey(name: 'KUNNR_RG') String? payerKunnr,
    @JsonKey(name: 'KUNNR_WE') String? consigneeKunnr,
    @JsonKey(name: 'PARVW') String? partnerRole,
    @JsonKey(name: 'CONTACTS') List<UserContact>? contacts,
    @JsonKey(name: 'DELIVERY_ADDRESSES')
    List<UserDeliveryAddress>? deliveryAddresses,
  }) = _UserStructureItem;

  factory UserStructureItem.fromJson(Map<String, dynamic> json) =>
      _$UserStructureItemFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_structure_item.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_structure_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserStructureItem {
  @JsonKey(name: 'KUNNR')
  String? get kunnr;
  @JsonKey(name: 'NAME1')
  String? get name1;
  @JsonKey(name: 'NAME2')
  String? get name2;
  @JsonKey(name: 'ORT01')
  String? get city;
  @JsonKey(name: 'STRAS')
  String? get street;
  @JsonKey(name: 'KUNNR_RG')
  String? get payerKunnr;
  @JsonKey(name: 'KUNNR_WE')
  String? get consigneeKunnr;
  @JsonKey(name: 'PARVW')
  String? get partnerRole;
  @JsonKey(name: 'CONTACTS')
  List<UserContact>? get contacts;
  @JsonKey(name: 'DELIVERY_ADDRESSES')
  List<UserDeliveryAddress>? get deliveryAddresses;

  /// Create a copy of UserStructureItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserStructureItemCopyWith<UserStructureItem> get copyWith =>
      _$UserStructureItemCopyWithImpl<UserStructureItem>(
          this as UserStructureItem, _$identity);

  /// Serializes this UserStructureItem to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserStructureItem &&
            (identical(other.kunnr, kunnr) || other.kunnr == kunnr) &&
            (identical(other.name1, name1) || other.name1 == name1) &&
            (identical(other.name2, name2) || other.name2 == name2) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.street, street) || other.street == street) &&
            (identical(other.payerKunnr, payerKunnr) ||
                other.payerKunnr == payerKunnr) &&
            (identical(other.consigneeKunnr, consigneeKunnr) ||
                other.consigneeKunnr == consigneeKunnr) &&
            (identical(other.partnerRole, partnerRole) ||
                other.partnerRole == partnerRole) &&
            const DeepCollectionEquality().equals(other.contacts, contacts) &&
            const DeepCollectionEquality()
                .equals(other.deliveryAddresses, deliveryAddresses));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      kunnr,
      name1,
      name2,
      city,
      street,
      payerKunnr,
      consigneeKunnr,
      partnerRole,
      const DeepCollectionEquality().hash(contacts),
      const DeepCollectionEquality().hash(deliveryAddresses));

  @override
  String toString() {
    return 'UserStructureItem(kunnr: $kunnr, name1: $name1, name2: $name2, city: $city, street: $street, payerKunnr: $payerKunnr, consigneeKunnr: $consigneeKunnr, partnerRole: $partnerRole, contacts: $contacts, deliveryAddresses: $deliveryAddresses)';
  }
}

/// @nodoc
abstract mixin class $UserStructureItemCopyWith<$Res> {
  factory $UserStructureItemCopyWith(
          UserStructureItem value, $Res Function(UserStructureItem) _then) =
      _$UserStructureItemCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'KUNNR') String? kunnr,
      @JsonKey(name: 'NAME1') String? name1,
      @JsonKey(name: 'NAME2') String? name2,
      @JsonKey(name: 'ORT01') String? city,
      @JsonKey(name: 'STRAS') String? street,
      @JsonKey(name: 'KUNNR_RG') String? payerKunnr,
      @JsonKey(name: 'KUNNR_WE') String? consigneeKunnr,
      @JsonKey(name: 'PARVW') String? partnerRole,
      @JsonKey(name: 'CONTACTS') List<UserContact>? contacts,
      @JsonKey(name: 'DELIVERY_ADDRESSES')
      List<UserDeliveryAddress>? deliveryAddresses});
}

/// @nodoc
class _$UserStructureItemCopyWithImpl<$Res>
    implements $UserStructureItemCopyWith<$Res> {
  _$UserStructureItemCopyWithImpl(this._self, this._then);

  final UserStructureItem _self;
  final $Res Function(UserStructureItem) _then;

  /// Create a copy of UserStructureItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kunnr = freezed,
    Object? name1 = freezed,
    Object? name2 = freezed,
    Object? city = freezed,
    Object? street = freezed,
    Object? payerKunnr = freezed,
    Object? consigneeKunnr = freezed,
    Object? partnerRole = freezed,
    Object? contacts = freezed,
    Object? deliveryAddresses = freezed,
  }) {
    return _then(_self.copyWith(
      kunnr: freezed == kunnr
          ? _self.kunnr
          : kunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      name1: freezed == name1
          ? _self.name1
          : name1 // ignore: cast_nullable_to_non_nullable
              as String?,
      name2: freezed == name2
          ? _self.name2
          : name2 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      street: freezed == street
          ? _self.street
          : street // ignore: cast_nullable_to_non_nullable
              as String?,
      payerKunnr: freezed == payerKunnr
          ? _self.payerKunnr
          : payerKunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      consigneeKunnr: freezed == consigneeKunnr
          ? _self.consigneeKunnr
          : consigneeKunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      partnerRole: freezed == partnerRole
          ? _self.partnerRole
          : partnerRole // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self.contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<UserContact>?,
      deliveryAddresses: freezed == deliveryAddresses
          ? _self.deliveryAddresses
          : deliveryAddresses // ignore: cast_nullable_to_non_nullable
              as List<UserDeliveryAddress>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserStructureItem implements UserStructureItem {
  const _UserStructureItem(
      {@JsonKey(name: 'KUNNR') this.kunnr,
      @JsonKey(name: 'NAME1') this.name1,
      @JsonKey(name: 'NAME2') this.name2,
      @JsonKey(name: 'ORT01') this.city,
      @JsonKey(name: 'STRAS') this.street,
      @JsonKey(name: 'KUNNR_RG') this.payerKunnr,
      @JsonKey(name: 'KUNNR_WE') this.consigneeKunnr,
      @JsonKey(name: 'PARVW') this.partnerRole,
      @JsonKey(name: 'CONTACTS') final List<UserContact>? contacts,
      @JsonKey(name: 'DELIVERY_ADDRESSES')
      final List<UserDeliveryAddress>? deliveryAddresses})
      : _contacts = contacts,
        _deliveryAddresses = deliveryAddresses;
  factory _UserStructureItem.fromJson(Map<String, dynamic> json) =>
      _$UserStructureItemFromJson(json);

  @override
  @JsonKey(name: 'KUNNR')
  final String? kunnr;
  @override
  @JsonKey(name: 'NAME1')
  final String? name1;
  @override
  @JsonKey(name: 'NAME2')
  final String? name2;
  @override
  @JsonKey(name: 'ORT01')
  final String? city;
  @override
  @JsonKey(name: 'STRAS')
  final String? street;
  @override
  @JsonKey(name: 'KUNNR_RG')
  final String? payerKunnr;
  @override
  @JsonKey(name: 'KUNNR_WE')
  final String? consigneeKunnr;
  @override
  @JsonKey(name: 'PARVW')
  final String? partnerRole;
  final List<UserContact>? _contacts;
  @override
  @JsonKey(name: 'CONTACTS')
  List<UserContact>? get contacts {
    final value = _contacts;
    if (value == null) return null;
    if (_contacts is EqualUnmodifiableListView) return _contacts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<UserDeliveryAddress>? _deliveryAddresses;
  @override
  @JsonKey(name: 'DELIVERY_ADDRESSES')
  List<UserDeliveryAddress>? get deliveryAddresses {
    final value = _deliveryAddresses;
    if (value == null) return null;
    if (_deliveryAddresses is EqualUnmodifiableListView)
      return _deliveryAddresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of UserStructureItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserStructureItemCopyWith<_UserStructureItem> get copyWith =>
      __$UserStructureItemCopyWithImpl<_UserStructureItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserStructureItemToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserStructureItem &&
            (identical(other.kunnr, kunnr) || other.kunnr == kunnr) &&
            (identical(other.name1, name1) || other.name1 == name1) &&
            (identical(other.name2, name2) || other.name2 == name2) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.street, street) || other.street == street) &&
            (identical(other.payerKunnr, payerKunnr) ||
                other.payerKunnr == payerKunnr) &&
            (identical(other.consigneeKunnr, consigneeKunnr) ||
                other.consigneeKunnr == consigneeKunnr) &&
            (identical(other.partnerRole, partnerRole) ||
                other.partnerRole == partnerRole) &&
            const DeepCollectionEquality().equals(other._contacts, _contacts) &&
            const DeepCollectionEquality()
                .equals(other._deliveryAddresses, _deliveryAddresses));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      kunnr,
      name1,
      name2,
      city,
      street,
      payerKunnr,
      consigneeKunnr,
      partnerRole,
      const DeepCollectionEquality().hash(_contacts),
      const DeepCollectionEquality().hash(_deliveryAddresses));

  @override
  String toString() {
    return 'UserStructureItem(kunnr: $kunnr, name1: $name1, name2: $name2, city: $city, street: $street, payerKunnr: $payerKunnr, consigneeKunnr: $consigneeKunnr, partnerRole: $partnerRole, contacts: $contacts, deliveryAddresses: $deliveryAddresses)';
  }
}

/// @nodoc
abstract mixin class _$UserStructureItemCopyWith<$Res>
    implements $UserStructureItemCopyWith<$Res> {
  factory _$UserStructureItemCopyWith(
          _UserStructureItem value, $Res Function(_UserStructureItem) _then) =
      __$UserStructureItemCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'KUNNR') String? kunnr,
      @JsonKey(name: 'NAME1') String? name1,
      @JsonKey(name: 'NAME2') String? name2,
      @JsonKey(name: 'ORT01') String? city,
      @JsonKey(name: 'STRAS') String? street,
      @JsonKey(name: 'KUNNR_RG') String? payerKunnr,
      @JsonKey(name: 'KUNNR_WE') String? consigneeKunnr,
      @JsonKey(name: 'PARVW') String? partnerRole,
      @JsonKey(name: 'CONTACTS') List<UserContact>? contacts,
      @JsonKey(name: 'DELIVERY_ADDRESSES')
      List<UserDeliveryAddress>? deliveryAddresses});
}

/// @nodoc
class __$UserStructureItemCopyWithImpl<$Res>
    implements _$UserStructureItemCopyWith<$Res> {
  __$UserStructureItemCopyWithImpl(this._self, this._then);

  final _UserStructureItem _self;
  final $Res Function(_UserStructureItem) _then;

  /// Create a copy of UserStructureItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? kunnr = freezed,
    Object? name1 = freezed,
    Object? name2 = freezed,
    Object? city = freezed,
    Object? street = freezed,
    Object? payerKunnr = freezed,
    Object? consigneeKunnr = freezed,
    Object? partnerRole = freezed,
    Object? contacts = freezed,
    Object? deliveryAddresses = freezed,
  }) {
    return _then(_UserStructureItem(
      kunnr: freezed == kunnr
          ? _self.kunnr
          : kunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      name1: freezed == name1
          ? _self.name1
          : name1 // ignore: cast_nullable_to_non_nullable
              as String?,
      name2: freezed == name2
          ? _self.name2
          : name2 // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      street: freezed == street
          ? _self.street
          : street // ignore: cast_nullable_to_non_nullable
              as String?,
      payerKunnr: freezed == payerKunnr
          ? _self.payerKunnr
          : payerKunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      consigneeKunnr: freezed == consigneeKunnr
          ? _self.consigneeKunnr
          : consigneeKunnr // ignore: cast_nullable_to_non_nullable
              as String?,
      partnerRole: freezed == partnerRole
          ? _self.partnerRole
          : partnerRole // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _self._contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<UserContact>?,
      deliveryAddresses: freezed == deliveryAddresses
          ? _self._deliveryAddresses
          : deliveryAddresses // ignore: cast_nullable_to_non_nullable
              as List<UserDeliveryAddress>?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_structure_item.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_structure_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserStructureItem _$UserStructureItemFromJson(Map<String, dynamic> json) =>
    _UserStructureItem(
      kunnr: json['KUNNR'] as String?,
      name1: json['NAME1'] as String?,
      name2: json['NAME2'] as String?,
      city: json['ORT01'] as String?,
      street: json['STRAS'] as String?,
      payerKunnr: json['KUNNR_RG'] as String?,
      consigneeKunnr: json['KUNNR_WE'] as String?,
      partnerRole: json['PARVW'] as String?,
      contacts: (json['CONTACTS'] as List<dynamic>?)
          ?.map((e) => UserContact.fromJson(e as Map<String, dynamic>))
          .toList(),
      deliveryAddresses: (json['DELIVERY_ADDRESSES'] as List<dynamic>?)
          ?.map((e) => UserDeliveryAddress.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$UserStructureItemToJson(_UserStructureItem instance) =>
    <String, dynamic>{
      'KUNNR': instance.kunnr,
      'NAME1': instance.name1,
      'NAME2': instance.name2,
      'ORT01': instance.city,
      'STRAS': instance.street,
      'KUNNR_RG': instance.payerKunnr,
      'KUNNR_WE': instance.consigneeKunnr,
      'PARVW': instance.partnerRole,
      'CONTACTS': instance.contacts,
      'DELIVERY_ADDRESSES': instance.deliveryAddresses,
    };

```

## lib\features\suppliers\models\armtek\user_vkorg.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_vkorg.freezed.dart';
part 'user_vkorg.g.dart';

@freezed
abstract class UserVkorg with _$UserVkorg {
  const factory UserVkorg({
    @JsonKey(name: 'VKORG') required String vkorg,
    @JsonKey(name: 'PROGRAM_NAME') required String programName,
  }) = _UserVkorg;

  factory UserVkorg.fromJson(Map<String, dynamic> json) =>
      _$UserVkorgFromJson(json);
}

```

## lib\features\suppliers\models\armtek\user_vkorg.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_vkorg.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserVkorg {
  @JsonKey(name: 'VKORG')
  String get vkorg;
  @JsonKey(name: 'PROGRAM_NAME')
  String get programName;

  /// Create a copy of UserVkorg
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserVkorgCopyWith<UserVkorg> get copyWith =>
      _$UserVkorgCopyWithImpl<UserVkorg>(this as UserVkorg, _$identity);

  /// Serializes this UserVkorg to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserVkorg &&
            (identical(other.vkorg, vkorg) || other.vkorg == vkorg) &&
            (identical(other.programName, programName) ||
                other.programName == programName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, vkorg, programName);

  @override
  String toString() {
    return 'UserVkorg(vkorg: $vkorg, programName: $programName)';
  }
}

/// @nodoc
abstract mixin class $UserVkorgCopyWith<$Res> {
  factory $UserVkorgCopyWith(UserVkorg value, $Res Function(UserVkorg) _then) =
      _$UserVkorgCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'VKORG') String vkorg,
      @JsonKey(name: 'PROGRAM_NAME') String programName});
}

/// @nodoc
class _$UserVkorgCopyWithImpl<$Res> implements $UserVkorgCopyWith<$Res> {
  _$UserVkorgCopyWithImpl(this._self, this._then);

  final UserVkorg _self;
  final $Res Function(UserVkorg) _then;

  /// Create a copy of UserVkorg
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vkorg = null,
    Object? programName = null,
  }) {
    return _then(_self.copyWith(
      vkorg: null == vkorg
          ? _self.vkorg
          : vkorg // ignore: cast_nullable_to_non_nullable
              as String,
      programName: null == programName
          ? _self.programName
          : programName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _UserVkorg implements UserVkorg {
  const _UserVkorg(
      {@JsonKey(name: 'VKORG') required this.vkorg,
      @JsonKey(name: 'PROGRAM_NAME') required this.programName});
  factory _UserVkorg.fromJson(Map<String, dynamic> json) =>
      _$UserVkorgFromJson(json);

  @override
  @JsonKey(name: 'VKORG')
  final String vkorg;
  @override
  @JsonKey(name: 'PROGRAM_NAME')
  final String programName;

  /// Create a copy of UserVkorg
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserVkorgCopyWith<_UserVkorg> get copyWith =>
      __$UserVkorgCopyWithImpl<_UserVkorg>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UserVkorgToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserVkorg &&
            (identical(other.vkorg, vkorg) || other.vkorg == vkorg) &&
            (identical(other.programName, programName) ||
                other.programName == programName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, vkorg, programName);

  @override
  String toString() {
    return 'UserVkorg(vkorg: $vkorg, programName: $programName)';
  }
}

/// @nodoc
abstract mixin class _$UserVkorgCopyWith<$Res>
    implements $UserVkorgCopyWith<$Res> {
  factory _$UserVkorgCopyWith(
          _UserVkorg value, $Res Function(_UserVkorg) _then) =
      __$UserVkorgCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'VKORG') String vkorg,
      @JsonKey(name: 'PROGRAM_NAME') String programName});
}

/// @nodoc
class __$UserVkorgCopyWithImpl<$Res> implements _$UserVkorgCopyWith<$Res> {
  __$UserVkorgCopyWithImpl(this._self, this._then);

  final _UserVkorg _self;
  final $Res Function(_UserVkorg) _then;

  /// Create a copy of UserVkorg
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? vkorg = null,
    Object? programName = null,
  }) {
    return _then(_UserVkorg(
      vkorg: null == vkorg
          ? _self.vkorg
          : vkorg // ignore: cast_nullable_to_non_nullable
              as String,
      programName: null == programName
          ? _self.programName
          : programName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\armtek\user_vkorg.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_vkorg.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserVkorg _$UserVkorgFromJson(Map<String, dynamic> json) => _UserVkorg(
      vkorg: json['VKORG'] as String,
      programName: json['PROGRAM_NAME'] as String,
    );

Map<String, dynamic> _$UserVkorgToJson(_UserVkorg instance) =>
    <String, dynamic>{
      'VKORG': instance.vkorg,
      'PROGRAM_NAME': instance.programName,
    };

```

## lib\features\suppliers\models\base\part_price_response.dart
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'part_price_response.freezed.dart';
part 'part_price_response.g.dart';

@freezed
abstract class PartPriceModel with _$PartPriceModel {
  const factory PartPriceModel({
    required String article,
    required String brand,
    required String name,
    required double price,
    required int quantity, // Доступное количество или минимальная партия
    required int deliveryDays, // Срок поставки в днях
    required String
        supplierName, // Имя поставщика, от которого пришло предложение
    String? originalArticle, // Оригинальный артикул, если это замена
    String? comment, // Комментарий от поставщика
    DateTime? priceUpdatedAt, // Когда цена была обновлена у поставщика
    // Можно добавить другие общие поля, которые могут возвращать разные поставщики
    Map<String, dynamic>?
        additionalProperties, // Для специфичных данных поставщика
  }) = _PartPriceModel;

  factory PartPriceModel.fromJson(Map<String, dynamic> json) =>
      _$PartPriceModelFromJson(json);
}

```

## lib\features\suppliers\models\base\part_price_response.freezed.dart
```dart
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'part_price_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PartPriceModel {
  String get article;
  String get brand;
  String get name;
  double get price;
  int get quantity; // Доступное количество или минимальная партия
  int get deliveryDays; // Срок поставки в днях
  String get supplierName; // Имя поставщика, от которого пришло предложение
  String? get originalArticle; // Оригинальный артикул, если это замена
  String? get comment; // Комментарий от поставщика
  DateTime? get priceUpdatedAt; // Когда цена была обновлена у поставщика
// Можно добавить другие общие поля, которые могут возвращать разные поставщики
  Map<String, dynamic>? get additionalProperties;

  /// Create a copy of PartPriceModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PartPriceModelCopyWith<PartPriceModel> get copyWith =>
      _$PartPriceModelCopyWithImpl<PartPriceModel>(
          this as PartPriceModel, _$identity);

  /// Serializes this PartPriceModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PartPriceModel &&
            (identical(other.article, article) || other.article == article) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.deliveryDays, deliveryDays) ||
                other.deliveryDays == deliveryDays) &&
            (identical(other.supplierName, supplierName) ||
                other.supplierName == supplierName) &&
            (identical(other.originalArticle, originalArticle) ||
                other.originalArticle == originalArticle) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            (identical(other.priceUpdatedAt, priceUpdatedAt) ||
                other.priceUpdatedAt == priceUpdatedAt) &&
            const DeepCollectionEquality()
                .equals(other.additionalProperties, additionalProperties));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      article,
      brand,
      name,
      price,
      quantity,
      deliveryDays,
      supplierName,
      originalArticle,
      comment,
      priceUpdatedAt,
      const DeepCollectionEquality().hash(additionalProperties));

  @override
  String toString() {
    return 'PartPriceModel(article: $article, brand: $brand, name: $name, price: $price, quantity: $quantity, deliveryDays: $deliveryDays, supplierName: $supplierName, originalArticle: $originalArticle, comment: $comment, priceUpdatedAt: $priceUpdatedAt, additionalProperties: $additionalProperties)';
  }
}

/// @nodoc
abstract mixin class $PartPriceModelCopyWith<$Res> {
  factory $PartPriceModelCopyWith(
          PartPriceModel value, $Res Function(PartPriceModel) _then) =
      _$PartPriceModelCopyWithImpl;
  @useResult
  $Res call(
      {String article,
      String brand,
      String name,
      double price,
      int quantity,
      int deliveryDays,
      String supplierName,
      String? originalArticle,
      String? comment,
      DateTime? priceUpdatedAt,
      Map<String, dynamic>? additionalProperties});
}

/// @nodoc
class _$PartPriceModelCopyWithImpl<$Res>
    implements $PartPriceModelCopyWith<$Res> {
  _$PartPriceModelCopyWithImpl(this._self, this._then);

  final PartPriceModel _self;
  final $Res Function(PartPriceModel) _then;

  /// Create a copy of PartPriceModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? article = null,
    Object? brand = null,
    Object? name = null,
    Object? price = null,
    Object? quantity = null,
    Object? deliveryDays = null,
    Object? supplierName = null,
    Object? originalArticle = freezed,
    Object? comment = freezed,
    Object? priceUpdatedAt = freezed,
    Object? additionalProperties = freezed,
  }) {
    return _then(_self.copyWith(
      article: null == article
          ? _self.article
          : article // ignore: cast_nullable_to_non_nullable
              as String,
      brand: null == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      quantity: null == quantity
          ? _self.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      deliveryDays: null == deliveryDays
          ? _self.deliveryDays
          : deliveryDays // ignore: cast_nullable_to_non_nullable
              as int,
      supplierName: null == supplierName
          ? _self.supplierName
          : supplierName // ignore: cast_nullable_to_non_nullable
              as String,
      originalArticle: freezed == originalArticle
          ? _self.originalArticle
          : originalArticle // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _self.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      priceUpdatedAt: freezed == priceUpdatedAt
          ? _self.priceUpdatedAt
          : priceUpdatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      additionalProperties: freezed == additionalProperties
          ? _self.additionalProperties
          : additionalProperties // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _PartPriceModel implements PartPriceModel {
  const _PartPriceModel(
      {required this.article,
      required this.brand,
      required this.name,
      required this.price,
      required this.quantity,
      required this.deliveryDays,
      required this.supplierName,
      this.originalArticle,
      this.comment,
      this.priceUpdatedAt,
      final Map<String, dynamic>? additionalProperties})
      : _additionalProperties = additionalProperties;
  factory _PartPriceModel.fromJson(Map<String, dynamic> json) =>
      _$PartPriceModelFromJson(json);

  @override
  final String article;
  @override
  final String brand;
  @override
  final String name;
  @override
  final double price;
  @override
  final int quantity;
// Доступное количество или минимальная партия
  @override
  final int deliveryDays;
// Срок поставки в днях
  @override
  final String supplierName;
// Имя поставщика, от которого пришло предложение
  @override
  final String? originalArticle;
// Оригинальный артикул, если это замена
  @override
  final String? comment;
// Комментарий от поставщика
  @override
  final DateTime? priceUpdatedAt;
// Когда цена была обновлена у поставщика
// Можно добавить другие общие поля, которые могут возвращать разные поставщики
  final Map<String, dynamic>? _additionalProperties;
// Когда цена была обновлена у поставщика
// Можно добавить другие общие поля, которые могут возвращать разные поставщики
  @override
  Map<String, dynamic>? get additionalProperties {
    final value = _additionalProperties;
    if (value == null) return null;
    if (_additionalProperties is EqualUnmodifiableMapView)
      return _additionalProperties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of PartPriceModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PartPriceModelCopyWith<_PartPriceModel> get copyWith =>
      __$PartPriceModelCopyWithImpl<_PartPriceModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PartPriceModelToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PartPriceModel &&
            (identical(other.article, article) || other.article == article) &&
            (identical(other.brand, brand) || other.brand == brand) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.deliveryDays, deliveryDays) ||
                other.deliveryDays == deliveryDays) &&
            (identical(other.supplierName, supplierName) ||
                other.supplierName == supplierName) &&
            (identical(other.originalArticle, originalArticle) ||
                other.originalArticle == originalArticle) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            (identical(other.priceUpdatedAt, priceUpdatedAt) ||
                other.priceUpdatedAt == priceUpdatedAt) &&
            const DeepCollectionEquality()
                .equals(other._additionalProperties, _additionalProperties));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      article,
      brand,
      name,
      price,
      quantity,
      deliveryDays,
      supplierName,
      originalArticle,
      comment,
      priceUpdatedAt,
      const DeepCollectionEquality().hash(_additionalProperties));

  @override
  String toString() {
    return 'PartPriceModel(article: $article, brand: $brand, name: $name, price: $price, quantity: $quantity, deliveryDays: $deliveryDays, supplierName: $supplierName, originalArticle: $originalArticle, comment: $comment, priceUpdatedAt: $priceUpdatedAt, additionalProperties: $additionalProperties)';
  }
}

/// @nodoc
abstract mixin class _$PartPriceModelCopyWith<$Res>
    implements $PartPriceModelCopyWith<$Res> {
  factory _$PartPriceModelCopyWith(
          _PartPriceModel value, $Res Function(_PartPriceModel) _then) =
      __$PartPriceModelCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String article,
      String brand,
      String name,
      double price,
      int quantity,
      int deliveryDays,
      String supplierName,
      String? originalArticle,
      String? comment,
      DateTime? priceUpdatedAt,
      Map<String, dynamic>? additionalProperties});
}

/// @nodoc
class __$PartPriceModelCopyWithImpl<$Res>
    implements _$PartPriceModelCopyWith<$Res> {
  __$PartPriceModelCopyWithImpl(this._self, this._then);

  final _PartPriceModel _self;
  final $Res Function(_PartPriceModel) _then;

  /// Create a copy of PartPriceModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? article = null,
    Object? brand = null,
    Object? name = null,
    Object? price = null,
    Object? quantity = null,
    Object? deliveryDays = null,
    Object? supplierName = null,
    Object? originalArticle = freezed,
    Object? comment = freezed,
    Object? priceUpdatedAt = freezed,
    Object? additionalProperties = freezed,
  }) {
    return _then(_PartPriceModel(
      article: null == article
          ? _self.article
          : article // ignore: cast_nullable_to_non_nullable
              as String,
      brand: null == brand
          ? _self.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _self.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      quantity: null == quantity
          ? _self.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      deliveryDays: null == deliveryDays
          ? _self.deliveryDays
          : deliveryDays // ignore: cast_nullable_to_non_nullable
              as int,
      supplierName: null == supplierName
          ? _self.supplierName
          : supplierName // ignore: cast_nullable_to_non_nullable
              as String,
      originalArticle: freezed == originalArticle
          ? _self.originalArticle
          : originalArticle // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _self.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      priceUpdatedAt: freezed == priceUpdatedAt
          ? _self.priceUpdatedAt
          : priceUpdatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      additionalProperties: freezed == additionalProperties
          ? _self._additionalProperties
          : additionalProperties // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

// dart format on

```

## lib\features\suppliers\models\base\part_price_response.g.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'part_price_response.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PartPriceModel _$PartPriceModelFromJson(Map<String, dynamic> json) =>
    _PartPriceModel(
      article: json['article'] as String,
      brand: json['brand'] as String,
      name: json['name'] as String,
      price: (json['price'] as num).toDouble(),
      quantity: (json['quantity'] as num).toInt(),
      deliveryDays: (json['deliveryDays'] as num).toInt(),
      supplierName: json['supplierName'] as String,
      originalArticle: json['originalArticle'] as String?,
      comment: json['comment'] as String?,
      priceUpdatedAt: json['priceUpdatedAt'] == null
          ? null
          : DateTime.parse(json['priceUpdatedAt'] as String),
      additionalProperties:
          json['additionalProperties'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$PartPriceModelToJson(_PartPriceModel instance) =>
    <String, dynamic>{
      'article': instance.article,
      'brand': instance.brand,
      'name': instance.name,
      'price': instance.price,
      'quantity': instance.quantity,
      'deliveryDays': instance.deliveryDays,
      'supplierName': instance.supplierName,
      'originalArticle': instance.originalArticle,
      'comment': instance.comment,
      'priceUpdatedAt': instance.priceUpdatedAt?.toIso8601String(),
      'additionalProperties': instance.additionalProperties,
    };

```

## lib\features\suppliers\services\suppliers_service.dart
```dart
import 'package:part_catalog/core/utils/logger_config.dart';
import '../api/api_client_manager.dart';
import '../models/base/part_price_response.dart'; // Предполагается, что эта модель будет создана

class SuppliersService {
  final ApiClientManager _apiClientManager;
  final _logger = AppLoggers.suppliers;

  SuppliersService(this._apiClientManager);

  /// Получает цены от всех доступных поставщиков для указанного артикула.
  Future<Map<String, List<PartPriceModel>>> getAllPricesByArticle(
    String articleNumber, {
    String? brand,
  }) async {
    final results = <String, List<PartPriceModel>>{};
    final clients = _apiClientManager.getAllAvailableClients();

    // Выполняем запросы параллельно
    final futures = clients.map((client) async {
      try {
        _logger.i(
            'Fetching prices for "$articleNumber" from ${client.supplierName}');
        final prices =
            await client.getPricesByArticle(articleNumber, brand: brand);
        results[client.supplierName] = prices;
        _logger.i(
            'Received ${prices.length} price offers for "$articleNumber" from ${client.supplierName}');
      } catch (e, stackTrace) {
        _logger.e(
          'Error fetching prices from ${client.supplierName} for article $articleNumber',
          error: e,
          stackTrace: stackTrace,
        );
        results[client.supplierName] =
            []; // Возвращаем пустой список в случае ошибки
      }
    }).toList();

    await Future.wait(futures);
    _logger.i(
        'Finished fetching all prices for "$articleNumber". Found offers from ${results.keys.where((k) => results[k]!.isNotEmpty).length} suppliers.');
    return results;
  }

  /// Получает лучшие (например, самые дешевые или самые быстрые) предложения для артикула.
  /// Логика "лучшего" может быть сложной и настраиваемой.
  Future<List<PartPriceModel>> getBestPricesByArticle(
    String articleNumber, {
    String? brand,
    int limit = 5, // Ограничение на количество лучших предложений
  }) async {
    final allPricesMap =
        await getAllPricesByArticle(articleNumber, brand: brand);
    final allPricesList = allPricesMap.values.expand((list) => list).toList();

    if (allPricesList.isEmpty) {
      _logger.i(
          'No price offers found for "$articleNumber" to determine best prices.');
      return [];
    }

    // Сортируем по цене (возрастание), затем по сроку доставки (возрастание)
    allPricesList.sort((a, b) {
      final priceComparison = a.price.compareTo(b.price);
      if (priceComparison != 0) {
        return priceComparison;
      }
      return a.deliveryDays.compareTo(b.deliveryDays);
    });

    final bestPrices = allPricesList.take(limit).toList();
    _logger.i(
        'Determined ${bestPrices.length} best price offers for "$articleNumber".');
    return bestPrices;
  }

  // TODO: Добавить другие методы, например, для поиска по названию, получения деталей и т.д.
}

```

## lib\main.dart
```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import 'package:part_catalog/core/database/database.dart';
import 'package:part_catalog/core/navigation/app_router.dart';
import 'package:part_catalog/core/service_locator.dart';
// Используем slang для локализации
import 'package:part_catalog/core/i18n/strings.g.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  // Выполнение в защищенной зоне для перехвата всех ошибок
  runZonedGuarded(() async {
    // Загружаем переменные окружения
    await dotenv.load();
    WidgetsFlutterBinding.ensureInitialized();

    // Настраиваем FlutterError для перехвата ошибок Flutter
    FlutterError.onError = (details) {
      FlutterError.presentError(details);
      final logger = Logger(); // Используем стандартный логгер
      logger.e(
        'Flutter error: ${details.exception}',
        error: details.exception,
        stackTrace: details.stack,
      );
    };

    // Инициализация Slang (устанавливаем локаль устройства по умолчанию)
    LocaleSettings.useDeviceLocale();

    // Создаем экземпляр базы данных один раз
    final database = AppDatabase();
    // Убедимся, что база данных готова (миграции и т.д.)
    await database
        .ensureDatabaseReady(); // Раскомментируйте, если есть такой метод

    // Передаем существующий экземпляр в setupLocator
    setupLocator(database);

    // Оборачиваем приложение в ProviderScope и TranslationProvider
    runApp(
      ProviderScope(
        // <--- Обертка для Riverpod
        child: TranslationProvider(
          child: const MyApp(),
        ),
      ),
    );
  }, (error, stackTrace) {
    // Ловим все необработанные исключения в зоне
    final logger = Logger(); // Используем стандартный логгер
    logger.e(
      'Unhandled error',
      error: error,
      stackTrace: stackTrace,
    );
    // В режиме отладки можно перебросить ошибку для лучшей видимости
    // if (kDebugMode) {
    //   throw error;
    // }
  });
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Используем MaterialApp.router для интеграции с GoRouter
    return MaterialApp.router(
      // Передаем конфигурацию роутера
      routerConfig: router,

      // Настройки локализации из Slang
      locale: TranslationProvider.of(context)
          .flutterLocale, // Получаем текущую локаль
      supportedLocales: AppLocaleUtils
          .supportedLocales, // Получаем список поддерживаемых локалей
      localizationsDelegates:
          GlobalMaterialLocalizations.delegates, // Стандартные делегаты

      // Заголовок приложения (можно взять из локализации, если нужно)
      title: t.core.appTitle,

      theme: ThemeData(
        // Настройте вашу тему
        primarySwatch: Colors.blue, // Пример
        useMaterial3: true,
        // Дополнительные настройки темы...
      ),
      // Убрали home, так как начальный маршрут задается в GoRouter (initialLocation)
    );
  }
}

```

