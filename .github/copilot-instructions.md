# Part Catalog - Инструкции для GitHub Copilot

> Это автоматически сгенерированный файл из документации проекта. Не редактируйте его напрямую.

## Содержание

1. [Основной обзор проекта и навигация по документации](#основной-обзор-проекта-и-навигация-по-документации)
2. [Общая архитектура приложения](#общая-архитектура-приложения)
3. [Руководство по стилю кодирования](#руководство-по-стилю-кодирования)
4. [Модуль клиентов](#модуль-клиентов)
5. [Модуль поставщиков запчастей](#модуль-поставщиков-запчастей)
6. [Структура БД и маппинги](#структура-бд-и-маппинги)
7. [Стратегия и паттерны тестирования](#стратегия-и-паттерны-тестирования)
8. [Модуль автомобилей](#модуль-автомобилей)
9. [Интеграция с внешними API](#интеграция-с-внешними-api)
10. [Стратегия обработки ошибок](#стратегия-обработки-ошибок)
11. [Модуль заказ-нарядов](#модуль-заказ-нарядов)
12. [Работа с асинхронным кодом](#работа-с-асинхронным-кодом)
13. [Прямое подключение к API](#прямое-подключение-к-api)
14. [Прокси-сервер для API поставщиков](#прокси-сервер-для-api-поставщиков)
15. [Справочник по API проекта](#справочник-по-api-проекта)

---

<!-- Source: docs\README.md -->
## Основной обзор проекта и навигация по документации

# Part Catalog

> Система управления учетом клиентов, автомобилей и заказ-нарядов для СТО

###### Содержание

- [Обзор](#обзор)
- [Архитектура](#архитектура)
- [Модули](#модули)
- [Руководства](#руководства)
- [Справочные материалы](#справочные-материалы)

###### Обзор

Part Catalog - это приложение для работников станций технического обслуживания автомобилей (СТО), обеспечивающее полный цикл учета клиентов, автомобилей, заказ-нарядов и запчастей.

**Ключевые возможности:**

- Учет клиентов (физических и юридических лиц)
- Учет автомобилей клиентов
- Управление заказ-нарядами
- Интеграция с каталогами запчастей
- Получение цен на запчасти от поставщиков

###### Архитектура

Документация по архитектуре приложения:

- [Общая архитектура](#overview) - обзор архитектуры приложения, слоев и компонентов
- [Структура БД](#database_schema) - схема БД, таблицы, связи и маппинги моделей
- [API интеграции](#api_integration) - интеграция с внешними API поставщиков и каталогов

###### Модули

Основные модули приложения:

- [Клиенты](#clients) - управление клиентами
- [Автомобили](#vehicles) - управление автомобилями клиентов
- [Заказ-наряды](#orders) - управление заказ-нарядами
- Поставщики:
  - [Обзор модуля](#overview) - общая информация о модуле
  - [Прямое подключение к API](#direct_api) - прямое взаимодействие с API поставщиков
  - [Прокси-сервер](#proxy_server) - использование прокси-сервера для запросов к API

###### Руководства

- [Стиль кодирования](#code_style) - соглашения по именованию, структуре файлов и организации кода
- [Тестирование](#testing) - стратегия и паттерны тестирования
- [Обработка ошибок](#error_handling) - подход к обработке ошибок и исключений
- [Асинхронное программирование](#async_programming) - работа с асинхронным кодом

###### Справочные материалы

- [API Reference](#api_reference) - справочник по API проекта
- [Примеры кода](#code_examples) - полные примеры кода

---

<!-- Source: docs\architecture\overview.md -->
## Общая архитектура приложения

> Данный документ описывает высокоуровневую архитектуру приложения Part Catalog, разрабатываемого для разных платформ: десктоп (Windows, macOS, Linux), планшет и смартфон (iOS, Android).

###### Содержание
- [Обзор](#обзор)
- [Архитектурные слои](#архитектурные-слои)
- [Ключевые компоненты](#ключевые-компоненты)
- [Взаимодействие между модулями](#взаимодействие-между-модулями)
- [Кросс-платформенная адаптация](#кросс-платформенная-адаптация)
- [Управление состоянием](#управление-состоянием)
- [Навигация](#навигация)
- [Внедрение зависимостей](#внедрение-зависимостей)
- [Локализация](#локализация)
- [Облачная интеграция](#облачная-интеграция)
- [Диаграммы](#диаграммы)

###### Обзор

Part Catalog - это приложение для работников станций технического обслуживания автомобилей (СТО), обеспечивающее полный цикл учета клиентов, автомобилей, заказ-нарядов и подбора запчастей. Архитектура приложения построена с учетом мультиплатформенности и следует принципам чистой архитектуры (Clean Architecture).

###### Технический стек:

Framework: Flutter
Язык программирования: Dart
База данных: Drift (SQLite) + Supabase для облачной синхронизации
Сетевые запросы: Dio
Управление состоянием: Provider/BLoC/Riverpod (выбрать предпочтительный)
Внедрение зависимостей: get_it
Навигация: go_router
Локализация: flutter_localizations + intl
Кодогенерация: build_runner + drift + freezed
Логгирование: logger

###### Архитектурные слои

Архитектура приложения состоит из следующих слоев:

###### 1. Presentation Layer (UI)

Назначение: Отвечает за пользовательский интерфейс и взаимодействие с пользователем
Компоненты: Экраны, виджеты, диалоги, провайдеры состояния
Особенности: Адаптивный дизайн для разных платформ и размеров экрана

###### 2. Domain Layer (Business Logic)

Назначение: Содержит бизнес-логику приложения
Компоненты: Сервисы, use cases, бизнес-модели, репозитории (интерфейсы)
Особенности: Не зависит от UI и источников данных

###### 3. Data Layer

Назначение: Обеспечивает доступ к данным из различных источников
Компоненты: Репозитории (реализации), API-клиенты, DAO, модели данных
Особенности: Преобразует данные между форматами API/БД и бизнес-моделями

###### 4. Core Layer

Назначение: Содержит общие компоненты и утилиты
Компоненты: Логгеры, константы, расширения, утилитарные функции, инфраструктурный код
Особенности: Используется всеми другими слоями

###### Ключевые компоненты

###### База данных

Технология: Drift (SQLite wrapper)
Основные таблицы:
ClientsItems
CarsItems
OrdersItems
OrderPartsItems
OrderServicesItems
Особенности: Мягкое удаление, реактивные запросы, миграции
Синхронизация: Интеграция с Supabase для облачного хранения и синхронизации

###### API интеграции

Каталоги запчастей: ApiClientPartsCatalogs
Поставщики запчастей:
Адаптивная архитектура с режимами direct/proxy/hybrid
Общая модель ответов для разных поставщиков
Кэширование результатов

###### Модули

Клиенты: Управление физическими и юридическими лицами
Автомобили: Управление автомобилями клиентов
Заказ-наряды: Создание и отслеживание ремонтных работ
Поставщики: Получение цен и сроков поставки запчастей

###### Взаимодействие между модулями

Модули взаимодействуют между собой через четко определенные интерфейсы, следуя принципам низкой связанности:

Клиенты → Автомобили: Клиент владеет автомобилями (связь один-ко-многим)
Автомобили → Заказ-наряды: Заказ-наряд связан с конкретным автомобилем
Клиенты → Заказ-наряды: Заказ-наряд связан с конкретным клиентом
Заказ-наряды → Поставщики: Заказ-наряд использует API поставщиков для получения цен на запчасти

###### Кросс-платформенная адаптация

Приложение оптимизировано для работы на различных платформах и устройствах:

###### Десктопные платформы (Windows, macOS, Linux)

Многооконный интерфейс с боковой навигацией
Табличное представление данных с сортировкой и фильтрацией
Поддержка горячих клавиш
Оптимизация для работы с мышью и клавиатурой

###### Планшеты

Разделенный интерфейс (master-detail)
Адаптивное расположение элементов в зависимости от ориентации
Оптимизация для сенсорного ввода с поддержкой стилуса

###### Смартфоны

Оптимизированный однооконный интерфейс
Адаптация под небольшие экраны
Оптимизация для управления одной рукой
Упрощенные формы ввода

###### Управление состоянием

В приложении используется комбинация подходов к управлению состоянием:

Локальное состояние: StatefulWidget для локального UI-состояния
Глобальное состояние: Provider/BLoC/Riverpod
Персистентное состояние: Drift (SQLite)
Реактивное состояние: Stream-based подход с использованием реактивных запросов Drift

###### Навигация

Навигация в приложении осуществляется с помощью go_router, который обеспечивает:

Декларативное определение маршрутов
Вложенную навигацию
Поддержку deep linking
Различные стратегии навигации для разных платформ

###### Внедрение зависимостей

Для управления зависимостями используется get_it, который обеспечивает:

Ленивую инициализацию компонентов
Регистрацию синглтонов и фабрик
Модульную регистрацию зависимостей по feature-modules
Разрешение зависимостей во время выполнения

###### Локализация

Для поддержки различных языков в приложении используется система локализации:

Технологии: flutter_localizations, intl пакеты
Структура: Текстовые ресурсы хранятся в .arb файлах для каждого поддерживаемого языка
Управление: Автоматическая генерация кода для доступа к локализованным строкам
Поддерживаемые языки: Русский, Английский (с возможностью расширения)
Форматирование: Локализованное форматирование дат, валют и чисел

```dart
// Пример использования локализации
Text(AppLocalizations.of(context)!.clientNameLabel),

// Пример локализованного форматирования
Text(NumberFormat.currency(
  locale: Localizations.localeOf(context).toString(),
  symbol: '₽',
).format(order.totalAmount)),
```

###### Облачная интеграция

Приложение поддерживает гибридный режим работы с локальными и облачными данными через Supabase:

Основные возможности Supabase в приложении
Синхронизация данных: Двунаправленная синхронизация между локальной базой и облаком
Аутентификация: Поддержка входа через различные провайдеры (email/пароль, Google, Apple)
Управление правами: Настройка доступа к данным на основе ролей пользователей
Уведомления: Реализация серверных уведомлений через Postgres Realtime
Хранилище: Загрузка и хранение файлов и изображений
Функции: Выполнение серверной логики через Edge Functions

###### Архитектура интеграции с Supabase

```
┌─────────────────┐      ┌───────────────────┐      ┌──────────────────┐
│  Local Database │◄────►│ Sync Coordinator  │◄────►│ Supabase Client  │
│     (Drift)     │      │                   │      │                  │
└─────────────────┘      └───────────────────┘      └─────────┬────────┘
                                                              │
                                                              ▼
                                                    ┌──────────────────┐
                                                    │  Supabase Cloud  │
                                                    │                  │
                                                    └──────────────────┘
```

###### Стратегия синхронизации

Оффлайн-режим: Приложение полноценно работает без интернета с локальной базой
Фоновая синхронизация: При появлении соединения изменения автоматически синхронизируются
Разрешение конфликтов: Стратегии для разрешения конфликтов при одновременном редактировании
Состояние синхронизации: Индикаторы, показывающие статус синхронизации данных

###### Диаграммы

###### Высокоуровневая архитектура

```
┌────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
│                                                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Клиенты UI  │  │Автомобили UI │  │Заказ-наряды UI│ ... │
│  └──────┬───────┘  └───────┬──────┘  └───────┬──────┘      │
└─────────┼────────────────┬─┼──────────────┬──┼─────────────┘
          │                │ │              │  │
┌─────────┼────────────────┼─┼──────────────┼──┼─────────────┐
│         │   Domain Layer  │ │              │  │             │
│         │                 │ │              │  │             │
│  ┌──────▼──────┐  ┌───────▼──────┐  ┌─────▼───────┐        │
│  │ClientService│  │ CarService   │  │OrderService │   ...   │
│  └──────┬──────┘  └───────┬──────┘  └─────┬───────┘        │
└─────────┼────────────────┬┼───────────────┼────────────────┘
          │                ││               │
┌─────────┼────────────────┼┼───────────────┼────────────────┐
│         │    Data Layer   ││               │                │
│         │                 ││               │                │
│  ┌──────▼─────┐  ┌────────▼─────┐  ┌──────▼─────┐          │
│  │ClientsDao  │  │   CarsDao    │  │ OrdersDao  │    ...    │
│  └──────┬─────┘  └──────┬───────┘  └──────┬─────┘          │
└─────────┼─────────────┬─┼─────────────────┼────────────────┘
          │             │ │                 │
┌─────────┼─────────────┼─┼─────────────────┼────────────────┐
│         │             │ │ Core Layer      │                │
│  ┌──────▼─────────────▼─▼─────────────────▼─────┐          │
│  │                 AppDatabase                   │          │
│  └──────────────────────────────────────────────┘          │
│                                                            │
│  ┌───────────────────┐  ┌──────────────────────┐           │
│  │   ApiClients      │  │   ServiceLocator     │    ...    │
│  └───────────────────┘  └──────────────────────┘           │
└────────────────────────────────────────────────────────────┘
```

###### Взаимодействие компонентов

```
┌─────────────┐      ┌─────────────┐      ┌────────────────┐
│  UI Widget  │─────▶│  Service    │─────▶│  Repository    │
└─────────────┘      └─────────────┘      └────────────────┘
                                                   │
                                                   ▼
                                          ┌────────────────┐
                                          │ Data Source    │
                                          │ (API, Database)│
                                          └────────────────┘
```

###### Многоуровневое хранение данных

```
┌────────────────────────────────────────────────────────────────┐
│              Пользовательский интерфейс (UI)                   │
└────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Провайдеры состояния (State Management)            │
└─────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Сервисы (Services)                                 │
└─────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Репозитории (Repositories)                         │
└─────────────────────────────────────────────────────────────────┘
          │                │                   │
          ▼                ▼                   ▼
┌───────────────────┐ ┌──────────────┐ ┌─────────────────────┐
│   Локальная БД    │ │  REST API    │ │ Supabase Cloud      │
│     (Drift)       │ │  клиенты     │ │ (PostgreSQL/Storage)│
└───────────────────┘ └──────────────┘ └─────────────────────┘
```

---

<!-- Source: docs\guides\code_style.md -->
## Руководство по стилю кодирования

> В этом документе описаны принципы и соглашения по стилю кодирования, принятые в проекте Part Catalog.

###### Содержание
- [Общие принципы](#общие-принципы)
- [Форматирование кода](#форматирование-кода)
- [Именование](#именование)
- [Комментарии и документация](#комментарии-и-документация)
- [Структура файлов](#Структура-файлов)
- [Архитектурные паттерны](#архитектурные-паттерны)
- [Работа с ресурсами](#работа-с-ресурсами)
- [Управление зависимостями](#управление-зависимостями)
- [Асинхронный код](#асинхронный-код)
- [Тестирование](#тестирование)
- [Безопасность](#безопасность)
- [Производительность](#производительность)
- [Логгирование](#логгирование)
- [Дополнительные рекомендации](#дополнительные-рекомендации)

###### Общие принципы

###### Приоритетные правила

1. **Читаемость превыше всего** - код должен быть понятным для других разработчиков
2. **DRY (Don't Repeat Yourself)** - избегайте дублирования кода
3. **KISS (Keep It Simple, Stupid)** - старайтесь писать простой код, избегайте излишней сложности
4. **YAGNI (You Aren't Gonna Need It)** - не добавляйте функциональность "про запас"
5. **Единообразие** - придерживайтесь единого стиля во всём проекте

###### Соблюдение принципов Flutter/Dart

- Следуйте [официальному руководству по стилю Dart](https://dart.dev/guides/language/effective-dart/style)
- Используйте встроенные инструменты форматирования (`dart format`)
- Поддерживайте высокий балл в анализаторе кода (minimum 80/100)

###### Форматирование кода

###### Отступы и пробелы

- Используйте **2 пробела** для отступов (не табуляции)
- Ограничивайте длину строк **80 символами**
- Добавляйте пустую строку между логическими блоками кода
- Используйте пробелы вокруг операторов и после запятых

###### Фигурные скобки

Открывающая скобка на той же строке, что и объявление
Закрывающая скобка на отдельной строке

###### Trailing Commas

Добавляйте запятые в конце параметров для многострочных объявлений
Форматируйте параметры виджетов один под другим для улучшения читаемости

###### Именование

###### Файлы

* Используйте snake_case для имён файлов: client_service.dart
* Придерживайтесь шаблона <что>_<тип>.dart: clients_screen.dart, car_model.dart
* Группируйте связанные файлы в одной директории

###### Классы и типы

* Используйте PascalCase для классов, enum, типов и миксинов: ClientService, OrderStatus
* Имена должны быть существительными или существительными с прилагательными: CarModel, ClientsScreen
* Используйте суффиксы для определения роли класса:
    *Controller / *Cubit / *Bloc - для управления состоянием
    *Service - для бизнес-логики
    *Repository - для слоя данных
    *Provider - для доступа к данным
    *Screen / *Page - для экранов
    *Widget - для переиспользуемых UI компонентов
    *Model - для моделей данных

###### Переменные и методы

Используйте camelCase для переменных и методов: clientName, calculateTotal()
Методы и функции должны начинаться с глагола: fetchData(), calculatePrice()
Булевы переменные должны иметь префикс is, has, should и т.д.: isActive, hasChildren
Избегайте сокращений, кроме общепринятых (e.g., id, url)

###### Константы

Используйте lowerCamelCase для константных значений: const double borderRadius = 8.0;
Для статических/глобальных констант используйте kConstantName: kDefaultTimeout

###### Комментарии и документация

###### Документирование API

Используйте комментарии /// для документации публичных API
Описывайте параметры, возвращаемые значения и исключения
Добавляйте примеры для сложных методов

###### Внутренние комментарии

Используйте комментарии // для объяснения сложных участков кода
Добавляйте комментарии перед сложными алгоритмами или нестандартными решениями
Используйте маркеры // TODO:, // FIXME:, // NOTE: для обозначения задач

###### Структура файлов

###### Организация проекта

Проект организован по принципу feature-first:

```
lib/
  ├─ features/            # Функциональные модули
  │   ├─ clients/         # Модуль клиентов
  │   │   ├─ models/      # Модели данных
  │   │   ├─ services/    # Бизнес-логика
  │   │   ├─ screens/     # Экраны UI
  │   │   └─ widgets/     # UI компоненты
  │   ├─ vehicles/        # Модуль автомобилей
  │   └─ orders/          # Модуль заказ-нарядов
  ├─ core/                # Общие компоненты
  │   ├─ database/        # Доступ к БД
  │   ├─ config/          # Конфигурация
  │   ├─ di/              # Внедрение зависимостей
  │   └─ utils/           # Утилиты
  └─ main.dart            # Точка входа
```

###### Структура файла

1. Импорты (сгруппированные и отсортированные):

* Dart импорты
* Flutter импорты
* Импорты пакетов
* Импорты проекта

2. Объявление части:

* part/part of директивы

3. Константы и типы:

* Enums, константы, типы данных

4. Основной класс/функциональность:

* Основной класс, его поля, конструкторы
* Функции, геттеры/сеттеры, методы

###### Архитектурные паттерны

###### Разделение ответственности

UI компоненты должны отвечать только за отображение и пользовательское взаимодействие
Бизнес-логика должна быть в отдельных сервисах
Доступ к данным должен быть инкапсулирован в репозиториях

###### Инъекция зависимостей

Используйте get_it для управления зависимостями

###### Работа с ресурсами

###### Assets

Организуйте ресурсы по типам в директории assets/
Используйте snake_case для имён файлов ресурсов
Регистрируйте все ресурсы в pubspec.yaml

###### Строки

Используйте константы для строк вместо хардкода
Располагайте строки в файлах локализации для поддержки мультиязычности

###### Управление зависимостями

###### Версионирование пакетов

Указывайте конкретные версии в pubspec.yaml
Регулярно обновляйте зависимости
Ведите CHANGELOG для отслеживания изменений

###### Импорты

Используйте относительные импорты для файлов в том же пакете
Используйте абсолютные импорты для файлов из других пакетов
Группируйте и сортируйте импорты

###### Асинхронный код

###### Принципы работы с асинхронным кодом

Всегда используйте ключевые слова async/await для читаемости
Используйте FutureBuilder и StreamBuilder для работы с асинхронными данными в UI
Обрабатывайте все состояния загрузки и ошибки

###### Безопасное обновление UI после асинхронных операций

Всегда проверяйте mounted перед вызовом setState()
Используйте addPostFrameCallback для отложенных UI-операций
Сохраняйте ссылки на контекстные объекты перед асинхронными операциями

###### Тестирование

###### Паттерны для тестирования

Используйте паттерн AAA (Arrange-Act-Assert) для структурирования тестов
Применяйте принцип Given-When-Then для улучшения читаемости
Группируйте похожие тесты с помощью функции group()

###### Генерация моков

Используйте пакеты mockito или mocktail для создания моков
Предпочитайте инъекцию зависимостей для упрощения тестирования
Применяйте принцип "dependency inversion" для легкой подмены компонентов в тестах

###### Безопасность

###### Защита чувствительных данных

Не храните секреты (API-ключи, токены) в исходном коде
Используйте flutter_secure_storage для хранения чувствительных данных
Не отправляйте чувствительную информацию в логи

###### Валидация входных данных

Всегда проверяйте входящие данные, особенно от пользователя или внешних источников
Применяйте строгую типизацию и избегайте dynamic, где это возможно

###### Null Safety
В проекте строго соблюдается null safety. Все поля должны быть явно обозначены как nullable или non-nullable:

- Используйте тип с `?` для полей, которые могут быть null: `String?`, `int?`
- Для non-nullable полей с обязательными значениями используйте `required` в конструкторах
- При работе с nullable полями всегда используйте операторы `?.`, `??` и проверки типа `field?.isEmpty == true`
- Вместо условий `if (value == null)` предпочтительно использовать паттерн `value?.isEmpty == true`
- При передаче nullable значений в функции, требующие non-null, всегда предоставляйте значение по умолчанию

###### Производительность

###### Оптимизация списков

Используйте ListView.builder вместо ListView для длинных списков
Применяйте const конструкторы для неизменяемых виджетов
Используйте кэширование для дорогостоящих вычислений

###### Изображения и ресурсы

Оптимизируйте размеры изображений перед добавлением в проект
Используйте кэширование изображений с cached_network_image
Загружайте тяжелые ресурсы асинхронно и по мере необходимости

###### Логгирование

- **Всегда использовать пакет logger вместо print**:
  - Инициализируйте логгер на уровне компонента: `final _logger = Logger('ComponentName');`
  - Используйте соответствующие уровни логирования: `_logger.d()`, `_logger.i()`, `_logger.w()`, `_logger.e()`
  - Никогда не используйте функцию `print()` в коде проекта
  - При логировании ошибок всегда включайте трассировку стека: `_logger.e('Message', error, stackTrace)`
  - Используйте `logger.v()` для отладочной информации, которая не должна попадать в продакшен
  - При использовании `logger` используйте именнованное обращение
  Неправильно: 
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', e, stackTrace);
  ```
  Правильно:
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', error: e, stackTrace: stackTrace);
  ```

###### Управление объемом генерируемого кода

При работе с GitHub Copilot важно управлять объемом генерируемого кода для достижения оптимальных результатов. Ниже представлены рекомендации по эффективной генерации кода.

###### Предварительная оценка объема

- **Планируйте заранее**: Оцените приблизительный размер требуемого решения до генерации
- **Устанавливайте ограничения**: При работе с большими компонентами явно указывайте в запросе требования к объему (например, "сократите пример до основных компонентов")
- **Поэтапный подход**: Для сложных задач сначала запрашивайте структуру/каркас кода, затем детализируйте отдельные части

###### Структурированный подход к большим генерациям

- **Логическое разделение**: Разбивайте сложные запросы на модульные части

- **Итеративное улучшение**: Начинайте с простой реализации, постепенно добавляя функциональность
- **Фокусировка на секциях**: При работе с большими файлами концентрируйтесь на конкретных участках кода

###### Форматирование запросов для оптимальной генерации

**Типы запросов с префиксами**

| Префикс       | Назначение                                | Пример  |
|---------------|-------------------------------------------|---------|
| [КОНЦЕПТ]     | Общая архитектура без деталей реализации  | [КОНЦЕПТ] Опиши как реализовать интеграцию с API платежной системы  |
| [РЕАЛИЗАЦИЯ]  | Полный код с обработкой ошибок и комментариями | [РЕАЛИЗАЦИЯ] Создай клиент для API поставщика Autodoc, который будет наследоваться от BaseSupplierClient |
| [ОПТИМИЗАЦИЯ] | Улучшение существующего кода | [ОПТИМИЗАЦИЯ] Оптими код метода fetchData для снижения потребления памяти  |
| [СТРУКТУРА]   | Организация файлов и компонентов | [СТРУКТУРА] Предложи организацию файлов для модуля поставщиков |

**Комбинированные запросы**

[РЕАЛИЗАЦИЯ] Создай сервис для работы с текущими поставщиками
[КОНЦЕПТ] При этом учти возможность добавления новых поставщиков в будущем
Такой формат позволяет получить полную реализацию текущей функциональности и рекомендации по будущим расширениям.

###### Уровни детализации и поэтапная генерация

- **Явные указания**: Четко обозначайте требуемый уровень детализации в запросе
- **Поэтапный подход**: Используйте принцип "сначала что, потом как"
- **Постепенная детализация**: Для сложных классов запрашивайте генерацию основной структуры, затем отдельных методов

**Подсказка**: Добавляйте конкретные технические детали в запрос для получения более точных результатов генерации.

###### Дополнительные рекомендации

###### Локализация

Все строки интерфейса должны поддерживать локализацию
Используйте пакеты flutter_localizations и intl

###### Доступность

Добавляйте значения для semanticsLabel и semanticsValue
Используйте достаточный контраст цветов
Обеспечивайте корректный порядок фокусировки

###### Жесты и анимации

Используйте стандартные жесты, понятные пользователям
Обеспечивайте визуальную обратную связь для жестов
Делайте анимации плавными, но не навязчивыми




---

<!-- Source: docs\modules\clients.md -->
## Модуль клиентов

> Модуль клиентов обеспечивает управление информацией о клиентах СТО, включая физические и юридические лица.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)

###### Назначение

Модуль клиентов решает следующие задачи:
- Учет физических и юридических лиц, являющихся клиентами СТО
- Хранение и управление контактными данными клиентов
- Связь клиентов с их автомобилями и заказ-нарядами
- Предоставление интерфейса для создания, редактирования и удаления клиентов

###### Архитектура

Модуль следует принципам чистой архитектуры и состоит из следующих уровней:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Пользовательский интерфейс | `ClientsScreen`, `ClientDialog` |
| Domain | Бизнес-логика | `ClientService` |
| Data | Доступ к данным | `ClientsDao`, `ClientsItemsCompanion` |

###### Основные компоненты

###### ClientService

Сервисный класс, обеспечивающий бизнес-логику работы с клиентами:

Функциональность: Преобразует данные между моделями БД и бизнес-моделями
Ключевые методы:
- **getClients()**: Получение всех активных клиентов
- **watchClients()**: Реактивное наблюдение за списком клиентов
- **addClient()**: Добавление нового клиента
- **updateClient()**: Обновление существующего клиента
- **deleteClient()**: Мягкое удаление клиента
- **searchClientsByName()**: Поиск клиентов по имени или названию

###### ClientsDao

DAO (Data Access Object) для прямой работы с таблицей клиентов в БД:

Функциональность: Предоставляет низкоуровневый доступ к данным таблицы
Ключевые методы:
- **getActiveClients()**: Получение неудаленных клиентов
- **watchActiveClients()**: Отслеживание изменений в таблице
- **insertClient()**: Добавление новой записи
- **updateClient()**: Обновление записи
- **softDeleteClient()**: Мягкое удаление (установка метки времени)
- **searchByName()**: Поиск по строке в имени клиента

###### Модели данных

###### ClientsItem (модель таблицы)

Представляет структуру таблицы клиентов в БД:

id: Первичный ключ (автоинкремент)
type: Тип клиента (строковое значение)
name: Имя/наименование клиента
contactInfo: Контактная информация
additionalInfo: Дополнительная информация (опционально)
deletedAt: Метка времени удаления для реализации мягкого удаления

###### Client (бизнес-модель)

Представляет клиента в бизнес-логике приложения:

id: Уникальный идентификатор
type: Тип клиента (перечисление ClientType)
name: Имя/наименование
contactInfo: Контактная информация
additionalInfo: Дополнительная информация (опционально)

###### ClientType (перечисление)

Определяет возможные типы клиентов:

physical: Физическое лицо
legal: Юридическое лицо
individualEntrepreneur: Индивидуальный предприниматель
other: Другой тип
Дополнено вспомогательными методами для работы с отображаемыми названиями и преобразованиями строк.

###### Основные операции

Отображение списка клиентов
Реализация: Использует StreamBuilder и watchClients() для реактивного обновления UI
Особенности: Обрабатывает различные состояния потока (загрузка, ошибка, пустой список)
UI: Отображает список с возможностью взаимодействия (редактирование, удаление)
Добавление/редактирование клиента
Реализация: Диалоговое окно с формой для ввода данных
Поля формы: Имя/название, тип клиента, контактная информация, дополнительная информация
Валидация: Проверка обязательных полей перед сохранением
Поведение: Адаптируется для режимов создания и редактирования

###### UI компоненты

###### ClientsScreen

Основной экран управления клиентами:

Функциональность: Отображение, поиск, добавление, редактирование, удаление клиентов
Особенности:
Использование StreamBuilder для реактивного UI
Поиск с дебаунсингом для оптимизации запросов
Адаптивный интерфейс для разных размеров экрана

###### ClientListItem

Виджет для отображения одного клиента в списке:

Функциональность: Отображает основную информацию о клиенте
Особенности:
Разные иконки для разных типов клиентов
Поддержка свайпа для удаления с подтверждением
Интерактивность для перехода к редактированию

###### DialogComponents

Элементы диалоговых окон для работы с данными клиентов:

ClientFormDialog: Форма с валидацией для создания и редактирования
ClientDeleteConfirmation: Диалог подтверждения удаления
ClientTypeSelector: Выбор типа клиента с визуальным форматированием

---

<!-- Source: docs\modules\suppliers\overview.md -->
## Модуль поставщиков запчастей

> Этот модуль отвечает за интеграцию с API поставщиков запчастей для получения информации о ценах и сроках доставки.

###### Содержание

- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Ключевые компоненты](#ключевые-компоненты)
- [Режимы работы](#режимы-работы)
- [Интеграция с прокси-сервером](#интеграция-с-прокси-сервером)

###### Назначение

Модуль поставщиков решает следующие задачи:

- Получение актуальных цен на запчасти от разных поставщиков
- Поиск запчастей по артикулу у разных поставщиков
- Получение информации о сроках доставки
- Агрегация данных от разных поставщиков в единый формат

###### Архитектура

Модуль построен на принципах **Чистой архитектуры** с четким разделением на уровни:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Отображение данных | `SupplierScreen`, `PriceListWidget` |
| Domain | Бизнес-логика | `SuppliersService`, `SupplierRepository` |
| Data | Источники данных | `SupplierApiClient`, `LocalCacheManager` |

###### Диаграмма компонентов

###### Диаграмма компонентов

```
┌───────────────┐       ┌──────────────────┐      ┌─────────────────┐
│ ApiConnection │       │                  │      │                 │
│     Mode      │────>  │ ApiClientManager │────> │SupplierApiClient│
└───────────────┘       └──────────────────┘      └─────────────────┘
                                │                          │
                                │                          │
                                ▼                          │
                        ┌───────────────┐                  │
                        │ LocalStorage  │ <────────────────┘
                        │   Manager     │
                        └───────────────┘
```

###### Ключевые компоненты

###### SupplierApiClient

Базовый интерфейс для всех клиентов API поставщиков:

```dart
abstract class SupplierApiClient {
  Future<List<PartPriceModel>> getPricesByArticle(String article);
  Future<List<PartInfoModel>> searchPartsByName(String name);
  Future<PartDetailModel?> getPartDetails(String articleNumber);
}
```

###### SuppliersService

Сервис для работы с API поставщиков:

```dart
class SuppliersService {
  final Map<String, SupplierApiClient> _clients;

  SuppliersService(this._clients);

  Future<Map<String, List<PartPriceModel>>> getAllPricesByArticle(String article) async {
    // Реализация
  }
  
  Future<List<PartPriceModel>> getBestPricesByArticle(String article) async {
    // Реализация
  }
}
```

###### Режимы работы

Модуль поддерживает 3 режима работы с API поставщиков:

|   Режим   |   Описание                    |	Применение  |
|-----------|-------------------------------|---------------|
| Direct    | Прямое подключение к API      | Автономная работа, разработка, тестирование, локальная разработка    |
| Proxy     | Через прокси-сервер           | Продакшен, ограничения безопасности, платные API    |
|   Hybrid |	Автоматическое переключение |   Повышенная отказоустойчивость           |

**Подробнее о каждом режиме:**

    *   Прямое подключение к API
    *   Использование прокси-сервера
    *   Автоматическое переключение между режимами

###### Интеграция с прокси-сервером

Для перехода на работу через прокси-сервер необходима минимальная модификация кода клиента:

    1. Настройка режима работы в AppConfig
    2. Использование ApiClientManager для создания подходящих клиентов API
    3. Настройка адреса прокси-сервера

Подробнее см. [Реализация прокси-сервера](#proxy_server).


---

<!-- Source: docs\architecture\database_schema.md -->
## Структура БД и маппинги

> В этом документе описана структура базы данных приложения Part Catalog, включая схему таблиц, отношения между ними и механизмы маппинга данных.

###### Содержание
- [Обзор](#обзор)
- [Технология и подход](#технология-и-подход)
- [Структура таблиц](#структура-таблиц)
- [Отношения и связи](#отношения-и-связи)
- [Маппинг моделей](#маппинг-моделей)
- [Миграции](#миграции)
- [Навигация](#навигация)
- [Оптимизация и индексы](#оптимизация-и-индексы)

###### Обзор

База данных Part Catalog реализована с использованием SQLite через ORM-библиотеку Drift. Она обеспечивает локальное хранение данных о клиентах, автомобилях, заказ-нарядах и связанных с ними сущностях. Дополнительно реализована синхронизация с облачной базой Supabase для мультиустройственных сценариев.

###### Технология и подход

###### Используемые технологии:

ORM-система: Drift (SQLite wrapper для Dart/Flutter)
Базовая БД: SQLite
Облачная синхронизация: Supabase (PostgreSQL)

###### Ключевые особенности:

Мягкое удаление: Записи помечаются как удаленные через поле deletedAt вместо физического удаления
Реактивные запросы: Использование стримов для наблюдения за изменениями данных
Кодогенерация: Автоматическая генерация кода для взаимодействия с БД
Двухуровневая архитектура моделей: Разделение на модели таблиц и бизнес-модели

###### Структура таблиц

| Таблица         | Описание                                                                 |
|------------------|--------------------------------------------------------------------------| 
|------------------|--------------------------------------------------------------------------|
| ClientsItems     | Информация о клиентах, включая имя, телефон и адрес                     |
| CarsItems        | Данные об автомобилях клиентов, включая марку, модель и год выпуска      |
| OrdersItems      | Заказ-наряды, связывающие клиентов и автомобили с деталями заказа        |
| OrderPartsItems  | Таблица для хранения запчастей, связанных с заказ-нарядами.                   |
| OrderServicesItems | Услуги, связанные с заказ-нарядами, включая описание и стоимость       |
| PartsItems       | Информация о деталях, включая название, артикул и цену                   |
| SuppliersItems   | Поставщики деталей, включая название и контактную информацию             |
| OrderStatusItems | Статусы заказов, включая "в работе", "завершен" и "отменен"             |
| PartsCategoriesItems | Категории деталей, включая название и описание                          |
| PartsSuppliersItems  | Связь между деталями и поставщиками, включая цену и условия поставки    |
| UsersItems       | Пользователи системы, включая имя, email и пароль                        |
| RolesItems       | Роли пользователей, включая "администратор", "менеджер" и "клиент"      |
| PermissionsItems | Права доступа, связанные с ролями пользователей                         |
| AuditLogsItems   | Логи аудита, включая действия пользователей и время выполнения           |
| SettingsItems    | Настройки приложения, включая язык, тему и уведомления                  |
| AppInfoItems     | Служебная таблица для метаданных приложения                              |
|------------------|--------------------------------------------------------------------------|

###### Отношения и связи

```
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│   ClientsItems  │       │    CarsItems    │       │   OrdersItems   │
├─────────────────┤       ├─────────────────┤       ├─────────────────┤
│ id              │◄──┐   │ id              │◄──┐   │ id              │
│ type            │   │   │ clientId        │───┘   │ clientId        │───┐
│ name            │   └───│ make            │       │ carId           │───┘
│ contactInfo     │       │ model           │       │ orderNumber     │
│ additionalInfo  │       │ year            │       │ createdAt       │
│ deletedAt       │       │ vin             │       │ scheduledDate   │
└─────────────────┘       │ licensePlate    │       │ completedAt     │
                          │ additionalInfo  │       │ status          │
                          │ deletedAt       │       │ description     │
                          └─────────────────┘       │ totalAmount     │
                                                    │ deletedAt       │
                                                    └─────────┬───────┘
                                                              │
                          ┌─────────────────┐       ┌─────────┴───────┐
                          │OrderServicesItems│       │ OrderPartsItems │
                          ├─────────────────┤       ├─────────────────┤
                          │ id              │       │ id              │
                          │ orderId         │───┐   │ orderId         │───┐
                          │ name            │   └───│ partNumber      │   │
                          │ description     │       │ name            │   │
                          │ price           │       │ brand           │   │
                          │ duration        │       │ quantity        │   │
                          │ performedBy     │       │ price           │   │
                          │ isCompleted     │       │ supplierName    │   │
                          └─────────────────┘       │ deliveryDays    │   │
                                                    │ isOrdered       │   │
                                                    │ isReceived      │   │
                                                    └─────────────────┘   │
                                                                          │
```

###### Описание связей:

ClientsItems → CarsItems: Один-ко-многим (один клиент имеет много автомобилей)
ClientsItems → OrdersItems: Один-ко-многим (один клиент имеет много заказ-нарядов)
CarsItems → OrdersItems: Один-ко-многим (один автомобиль имеет много заказ-нарядов)
OrdersItems → OrderPartsItems: Один-ко-многим (один заказ-наряд содержит много запчастей)
OrdersItems → OrderServicesItems: Один-ко-многим (один заказ-наряд содержит много работ)
PartsItems → PartsSuppliersItems: Один-ко-многим (одна запчасть может иметь много поставщиков)
PartsCategoriesItems → PartsItems: Один-ко-многим (одна категория может содержать много запчастей)
SuppliersItems → PartsSuppliersItems: Один-ко-многим (один поставщик может предлагать много запчастей)
UsersItems → RolesItems: Один-ко-многим (один пользователь может иметь много ролей)
RolesItems → PermissionsItems: Один-ко-многим (одна роль может иметь много прав доступа)
AuditLogsItems → UsersItems: Один-ко-многим (один пользователь может иметь много логов аудита)
SettingsItems → AppInfoItems: Один-ко-многим (одна настройка может относиться к многим метаданным приложения)

###### Маппинг моделей

###### Двухуровневая архитектура моделей:

Модели таблиц (Items) - Представляют структуру таблиц в БД
Бизнес-модели (Models) - Используются в бизнес-логике приложения

###### Маппинг между моделями:

Модель БД (Items)	Бизнес-модель	Сервисный класс	Методы преобразования
ClientsItem	Client	ClientService	_mapToModel(ClientsItem) → Client<br>_mapToCompanion(Client) → ClientsItemsCompanion
CarsItem	CarModel	CarService	_mapToModel(CarsItem) → CarModel<br>_mapToCompanion(CarModel) → CarsItemsCompanion
CarWithOwner	CarWithOwnerModel	CarService	_mapWithOwnerToModel(CarWithOwner) → CarWithOwnerModel
OrdersItem	OrderModel	OrderService	_mapToModel(OrdersItem) → OrderModel<br>_mapToCompanion(OrderModel) → OrdersItemsCompanion
OrderPartsItem	OrderPartModel	OrderService	_mapPartToModel(OrderPartsItem) → OrderPartModel<br>_mapPartToCompanion(OrderPartModel) → OrderPartsItemsCompanion
OrderServicesItem	OrderServiceModel	OrderService	_mapServiceToModel(OrderServicesItem) → OrderServiceModel<br>_mapServiceToCompanion(OrderServiceModel) → OrderServicesItemsCompanion

###### Миграции

###### Схема миграций
    
Для управления изменениями схемы базы данных используется система миграций Drift

###### Автоматическая валидация схемы

Для обеспечения согласованности схемы БД реализована автоматическая валидация и обновление схемы при старте приложения

###### Оптимизация и индексы

###### Индексирование

В схеме базы данных определены следующие индексы для оптимизации запросов:

ClientsItems: индекс по имени и типу клиента для быстрого поиска
CarsItems: индексы по clientId, VIN и госномеру для быстрого поиска
OrdersItems: индексы по clientId, carId, статусу и дате создания
OrderPartsItems: индексы по orderId и артикулу запчасти
OrderServicesItems: индекс по orderId

###### Оптимизированные запросы

Для улучшения производительности используются следующие подходы:
1. Использование индексов в запросах
2. Комплексные JOIN-запросы вместо множества простых
3. Использование транзакций для серии операций
4. Пакетная обработка данных для уменьшения количества запросов к БД
5. Кэширование часто запрашиваемых данных
6. Использование стримов для реактивного обновления данных
7. Параллельная обработка запросов для повышения производительности
8. Использование асинхронных операций для улучшения отзывчивости интерфейса
9. Регулярная оптимизация и анализ производительности запросов
10. Мониторинг и логирование медленных запросов для их последующей оптимизации
11. Использование EXPLAIN для анализа плана выполнения запросов
12. Мягкое удаление вместо физического удаления записей
13. Использование триггеров для автоматизации задач
14. Каскадное удаление связанных записей на уровне бизнес-логики
15. Регулярное резервное копирование и восстановление данных

---

<!-- Source: docs\guides\testing.md -->
## Стратегия и паттерны тестирования

> Этот документ описывает подходы к тестированию в проекте Part Catalog, включая стратегию, инструменты и рекомендуемые паттерны.

###### Содержание
- [Обзор стратегии тестирования](#обзор-стратегии-тестирования)
- [Уровни тестирования](#уровни-тестирования)
- [Unit-тестирование](#unit-тестирование)
- [Widget-тестирование](#widget-тестирование)
- [Интеграционное тестирование](#интеграционное-тестирование)
- [Моки и стабы](#моки-и-стабы)
- [Структура тестового проекта](#структура-тестового-проекта)
- [Непрерывная интеграция](#непрерывная-интеграция)
- [Рекомендации и лучшие практики](#рекомендации-и-лучшие-практики)

###### Обзор стратегии тестирования

Проект Part Catalog использует многоуровневый подход к тестированию, следуя принципу пирамиды тестирования:

```
▲  Меньше
│
│    E2E тесты
│    Интеграционные тесты
│    Widget тесты
│    Unit тесты
│
▼  Больше
```

Этот подход обеспечивает:
* Раннее обнаружение ошибок
* Эффективную отладку благодаря локализации проблем
* Снижение стоимости исправления ошибок
* Быстрое выполнение тестовых наборов

###### Уровни тестирования

###### 1. Unit-тестирование

Фокус: Отдельные компоненты и функции
Объем: ~70% всех тестов
Инструменты: flutter_test, mockito, mocktail

###### 2. Widget-тестирование

Фокус: UI-компоненты и взаимодействие пользователя
Объем: ~20% всех тестов
Инструменты: flutter_test с виджет-тестами

###### 3. Интеграционное тестирование

Фокус: Взаимодействие между различными частями приложения
Объем: ~10% всех тестов
Инструменты: integration_test

###### 4. E2E-тестирование

Фокус: Полноценные пользовательские сценарии
Объем: Ограниченное количество ключевых сценариев
Инструменты: flutter_driver

###### Unit-тестирование

###### Подход

Для модульного тестирования используется метод AAA (Arrange-Act-Assert):

1. Arrange: Подготовка данных, создание моков и настройка тестового окружения
2. Act: Вызов тестируемой функциональности
3. Assert: Проверка результатов и побочных эффектов

###### Инструменты

flutter_test: Основной фреймворк для тестирования Dart/Flutter
mockito/mocktail: Библиотеки для создания моков
fake_async: Для тестирования асинхронного кода с виртуальным временем

###### Тестирование асинхронного кода

Для асинхронного кода используем:

* async/await в тестах с асинхронными операциями
* fakeAsync для тестирования кода с таймерами
* pumpAndSettle для ожидания завершения анимаций в виджет-тестах

###### Widget-тестирование

###### Подход

Widget-тесты проверяют:

* Корректное отображение UI-компонентов
* Обработку пользовательских взаимодействий
* Правильное отображение данных
* Обработку различных состояний (загрузка, ошибка, пустые данные)

###### Инструменты

* WidgetTester: API для взаимодействия с виджетами
* Finder: Поиск виджетов в дереве
* GoldenFileComparator: Сравнение с эталонными снимками виджетов

###### Golden-тестирование

Golden-тесты создают скриншоты виджетов для визуального сравнения

###### Интеграционное тестирование

###### Подход

Интеграционные тесты проверяют взаимодействие между различными частями приложения:

* Интеграцию между экранами
* Потоки данных между слоями
* Взаимодействие с внешними зависимостями (при необходимости с их моками)

###### Инструменты

integration_test: Фреймворк для интеграционного тестирования
flutter_driver: Управление приложением для E2E тестов

###### Моки и стабы

###### Определения

* Мок (Mock): Имитирует объект и отслеживает вызовы его методов
* Стаб (Stub): Возвращает предопределенный результат без отслеживания
* Фейк (Fake): Предоставляет упрощенную реализацию функциональности

###### Создание моков с Mocktail
###### Создание моков с Mocktail
###### Ручные моки

###### Структура тестового проекта

###### Организация тестов

```
test/
  ├─ unit/                       # Модульные тесты
  │   ├─ features/
  │   │   ├─ clients/
  │   │   │   ├─ services/
  │   │   │   │   └─ client_service_test.dart
  │   │   │   └─ repositories/
  │   │   │       └─ client_repository_test.dart
  │   │   └─ vehicles/
  │   └─ core/
  │       ├─ utils/
  │       └─ database/
  │
  ├─ widget/                     # Тесты виджетов
  │   ├─ features/
  │   │   ├─ clients/
  │   │   │   └─ screens/
  │   │   │       └─ client_list_screen_test.dart
  │   │   └─ vehicles/
  │   └─ shared/
  │       └─ widgets/
  │
  ├─ integration/                # Интеграционные тесты
  │   ├─ clients_flow_test.dart
  │   └─ vehicles_flow_test.dart
  │
  └─ mocks/                      # Общие моки для тестов
      ├─ mock_client_repository.dart
      └─ mock_service_locator.dart

integration_test/                # Тесты для интеграции с устройствами
  ├─ app_test.dart
  └─ driver.dart
```

###### Общие моки и тестовые данные

###### Непрерывная интеграция

###### GitHub Actions

###### Автоматизация тестов

Pre-commit хуки: flutter analyze и flutter test перед коммитом
CI/CD: Автоматический запуск тестов при пуше и пулл-реквестах
Отчеты о покрытии: Интеграция с сервисами анализа кода (Codecov, SonarQube)

###### Рекомендации и лучшие практики

###### Основные рекомендации

Изоляция тестов: Каждый тест должен быть независимым от других
Детерминированность: Тесты должны давать одинаковый результат при многократном запуске
Быстрое выполнение: Модульные тесты должны выполняться быстро
Тестирование граничных условий: Проверяйте крайние случаи и исключения
Поддержание тестов в актуальном состоянии: Обновляйте тесты при изменении кода

###### Паттерн AAA (Arrange-Act-Assert)

Структурируйте тесты по паттерну AAA для повышения читаемости

###### BDD стиль с описательными именами тестов

###### Использование фикстур и setUp/tearDown

###### Проверка покрытия кода тестами

Запуск тестов с генерацией отчета о покрытии
Конвертация отчета в HTML для удобного просмотра (требуется lcov)

---

<!-- Source: docs\modules\vehicles.md -->
## Модуль автомобилей

> Модуль автомобилей обеспечивает управление информацией об автомобилях клиентов СТО, включая их характеристики и связь с владельцами.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)
- [Адаптивный интерфейс](#адаптивный-интерфейс)
- [Типичные сценарии использования](#типичные-сценарии-использования)

###### Назначение

Модуль автомобилей решает следующие задачи:
- Учет автомобилей клиентов СТО
- Хранение технических характеристик автомобилей (марка, модель, VIN-код)
- Связь автомобилей с их владельцами (клиентами)
- Предоставление интерфейса для создания, редактирования и удаления автомобилей

###### Архитектура

Модуль следует принципам чистой архитектуры и состоит из следующих уровней:

|   Уровень       | Назначение                    | Компоненты                    |
|-----------------|-------------------------------|-------------------------------|
|   Presentation  | Пользовательский интерфейс    | CarsScreen, CarFormDialog     |
|   Domain        | Бизнес-логика                 | CarService                    |
|   Data          | Доступ к данным               | CarsDao, CarsItemsCompanion   |

###### Основные компоненты

###### CarService

Сервисный класс для работы с автомобилями. Основные методы:

- **getCars()** - Получение списка всех автомобилей
- **watchCarsWithOwners()** - Реактивное наблюдение за автомобилями с информацией о владельцах
- **getCarById(int id)** - Получение автомобиля по ID
- **addCar(CarModel car)** - Добавление нового автомобиля
- **updateCar(CarModel car)** - Обновление данных автомобиля
- **deleteCar(int carId)** - Удаление автомобиля
- **getCarsByClientId(int clientId)** - Получение автомобилей конкретного клиента

###### CarsDao

Data Access Object для прямого взаимодействия с таблицей автомобилей в базе данных:

- **getActiveCars()** - Получение всех неудаленных автомобилей
- **watchCarsWithOwners()** - Реактивное наблюдение за связкой автомобиль-владелец
- **getCarById(int id)** - Получение записи автомобиля по ID
- **insertCar(CarsItemsCompanion car)** - Вставка нового автомобиля
- **updateCar(CarsItemsCompanion car)** - Обновление информации об автомобиле
- **softDeleteCar(int carId)** - Мягкое удаление автомобиля
- **softDeleteCarsByClientId(int clientId)** - Удаление всех автомобилей клиента

###### Модели данных

CarsItem (модель таблицы)

```dart
class CarsItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get clientId => integer().references(ClientsItems, #id)();
  TextColumn get make => text()();
  TextColumn get model => text()();
  IntColumn get year => integer().nullable()();
  TextColumn get vin => text().nullable()();
  TextColumn get licensePlate => text().nullable()();
  TextColumn get additionalInfo => text().nullable()();
  DateTimeColumn get deletedAt => dateTime().nullable()();
}
```

CarModel (бизнес-модель)

Представляет автомобиль в бизнес-логике приложения:

**id**: Уникальный идентификатор
**clientId**: ID клиента-владельца
**make**: Марка автомобиля
**model**: Модель автомобиля
**year**: Год выпуска
**vin**: VIN-код
**licensePlate**: Государственный номер
**additionalInfo**: Дополнительная информация

CarWithOwnerModel (расширенная бизнес-модель)

Объединяет данные об автомобиле с информацией о владельце:

car: Основная модель автомобиля
ownerName: Имя владельца
ownerType: Тип клиента-владельца


###### Основные операции

Отображение списка автомобилей с владельцами

Реализация через реактивные потоки данных для автоматического обновления UI при изменениях:

```dart
StreamBuilder<List<CarWithOwnerModel>>(
  stream: _carService.watchCarsWithOwners(),
  builder: (context, snapshot) {
    // Логика построения UI на основе данных
  }
)
```

Добавление/редактирование автомобиля
Процесс включает:

Выбор клиента из списка
Ввод характеристик автомобиля
Валидация данных (обязательные поля, уникальность VIN)
Сохранение в базе данных
Связь с другими модулями
Клиенты: Каждый автомобиль привязан к клиенту
Заказ-наряды: Автомобиль является объектом работ в заказ-нарядах
Каталог запчастей: Поиск запчастей для конкретного автомобиля

###### UI компоненты

CarsScreen
Основной экран управления автомобилями:

Список автомобилей с информацией о владельцах
Поиск по марке, модели, VIN или госномеру
Кнопка добавления нового автомобиля
Возможность редактирования и удаления автомобилей
Фильтрация по владельцу

CarFormDialog
Форма для добавления/редактирования автомобиля:

Поля для ввода характеристик автомобиля
Выпадающий список для выбора владельца
Валидация обязательных полей
Проверка уникальности VIN-кода и госномера

CarDetailsScreen
Экран детальной информации об автомобиле:

Полная информация о характеристиках
История заказ-нарядов для данного автомобиля
Возможность редактирования и удаления

###### Адаптивный интерфейс

Для эффективной работы на разных устройствах реализован адаптивный интерфейс:

Мобильные устройства: Список с карточками автомобилей и отдельные экраны для деталей
Десктопные платформы: Таблица с сортировкой и фильтрацией, редактирование в боковой панели
Планшеты: Комбинация мобильного и десктопного интерфейса
Все компоненты адаптированы для разных размеров экранов и ориентаций.

###### Типичные сценарии использования

1. Регистрация нового автомобиля клиента
Поиск или создание клиента
Заполнение данных автомобиля
Сохранение связи автомобиль-клиент

2. Поиск автомобиля по VIN или госномеру
Быстрый поиск с автодополнением
Отображение детальной информации

3. Привязка автомобиля к новому владельцу
Изменение поля clientId
Обновление связанных данных

4. Просмотр истории заказ-нарядов
На экране детальной информации автомобиля
Быстрый переход к заказ-нарядам

---

<!-- Source: docs\architecture\api_integration.md -->
## Интеграция с внешними API

> Документ описывает архитектуру и принципы интеграции с внешними API поставщиков запчастей в приложении Part Catalog.

###### Содержание
- [Обзор](#обзор)
- [Архитектура API-интеграций](#архитектура-api-интеграций)
- [Режимы подключения](#режимы-подключения)
- [Основные компоненты](#основные-компоненты)
- [Обработка ошибок](#обработка-ошибок)
- [Оптимизация производительности](#оптимизация-производительности)
- [Безопасность](#безопасность)
- [Мониторинг и логирование](#мониторинг-и-логирование)

###### Обзор

Part Catalog взаимодействует с двумя типами внешних API:

1. API каталогов запчастей - для поиска запчастей по VIN-коду и артикулу
2. API поставщиков запчастей - для получения информации о ценах и сроках поставки

Взаимодействие с этими API реализовано через слой абстракции, который позволяет:

* Унифицировать доступ к разным API
* Изолировать бизнес-логику от деталей реализации API
* Обеспечить гибкое переключение между режимами работы

###### Архитектура API-интеграций

###### Общая схема

```mermaid
┌─────────────────┐     ┌───────────────┐     ┌────────────────────┐
│                 │     │               │     │                    │
│  UI Components  │───▶│  API Services │────▶│  API Clients       │
│                 │     │               │     │                    │
└─────────────────┘     └───────────────┘     └────────────┬───────┘
                                                           │
                                                           ▼
                                                 ┌────────────────────┐
                                                 │                    │
                                                 │  External APIs     │
                                                 │                    │
                                                 └────────────────────┘
```

###### Разделение ответственности

UI Components - отображение данных и взаимодействие с пользователем
API Services - бизнес-логика, обработка данных, агрегация результатов
API Clients - низкоуровневая работа с API, сетевые запросы, сериализация/десериализация
External APIs - внешние системы, с которыми взаимодействует приложение

###### Режимы подключения

Приложение поддерживает три режима работы с API поставщиков:

Режим	Описание	Применение
Direct	Прямое подключение к API	Разработка, тестирование, автономная работа
Proxy	Через прокси-сервер	Продакшн, корпоративные развертывания
Hybrid	Автоматическое переключение	Повышенная отказоустойчивость

###### Прямое подключение (Direct)

В этом режиме приложение напрямую обращается к API каждого поставщика:

```
┌────────────────┐     ┌──────────────┐     ┌────────────────┐
│                │     │              │     │                │
│  Flutter App   │────▶│ API Client 1 │────▶│  Provider 1    │
│                │     │              │     │                │
└────────────────┘     └──────────────┘     └────────────────┘
         │                                         
         │             ┌──────────────┐     ┌────────────────┐
         │             │              │     │                │
         └────────────▶│ API Client 2 │────▶│  Provider 2    │
                       │              │     │                │
                       └──────────────┘     └────────────────┘
```

**Преимущества:**

* Простота реализации
* Отсутствие дополнительных задержек
* Независимость от дополнительной инфраструктуры

**Ограничения:**

* API-ключи хранятся на клиенте
* Каждое устройство использует собственную квоту запросов
* Сложности с единым мониторингом

###### Через прокси-сервер (Proxy)

В этом режиме запросы проходят через промежуточный сервер:

```
┌────────────────┐     ┌─────────────┐     ┌────────────────┐
│                │     │             │     │                │
│  Flutter App   │────▶│ Proxy Server│────▶│  Provider 1    │
│                │     │             │     │                │
└────────────────┘     └─────────────┘     └────────────────┘
                              │                    
                              │            ┌────────────────┐
                              │            │                │
                              └───────────▶│  Provider 2    │
                                           │                │
                                           └────────────────┘
```

**Преимущества:**

* Безопасное хранение API-ключей на сервере
* Централизованный мониторинг и кэширование
* Оптимизация расхода квот запросов
* Унификация ответов разных API

**Ограничения:**

* Необходимость поддержки дополнительного сервера
* Дополнительная задержка при запросах
* Зависимость от доступности прокси-сервера

###### Гибридный режим (Hybrid)

Комбинирует преимущества обоих подходов с автоматическим переключением:

```
┌────────────────┐     ┌─────────────┐     ┌────────────────┐
│                │────▶│             │────▶│                │
│                │     │ Proxy Server│     │  Provider 1    │
│                │     │             │     │                │
│  Flutter App   │     └─────────────┘     └────────────────┘
│                │                                
│                │     ┌─────────────┐     ┌────────────────┐
│                │────▶│             │────▶│                │
└────────────────┘     │Direct Client│     │  Provider 2    │
                       │             │     │                │
                       └─────────────┘     └────────────────┘
```

**Преимущества:**

* Повышенная отказоустойчивость
* Автоматическое переключение при проблемах
* Сочетает преимущества обоих подходов

**Ограничения:**

* Повышенная сложность реализации
* Необходимость поддержки обоих режимов
* Сложности с отладкой и тестированием

###### Основные компоненты

###### ApiClientPartsCatalogs

Централизованный клиент для работы с API каталогов запчастей

###### SupplierApiClient

Базовый интерфейс для всех клиентов API поставщиков запчастей

###### SuppliersService

Сервис-агрегатор для работы со всеми поставщиками

###### ApiClientManager

Фабрика для создания API-клиентов с учетом режима работы

###### Обработка ошибок

###### Иерархия исключений

```dart
/// Базовое исключение для всех API-ошибок
abstract class ApiException implements Exception {
  final String message;
  final dynamic cause;
  
  const ApiException(this.message, {this.cause});
}

/// Исключение при ошибках сети
class NetworkException extends ApiException {
  final int? statusCode;
  
  NetworkException(
    super.message, {
    this.statusCode,
    super.cause,
  });
}

/// Исключение при ошибках в ответе API
class ApiResponseException extends ApiException {
  final String? errorCode;
  
  ApiResponseException(
    super.message, {
    this.errorCode,
    super.cause,
  });
}

/// Исключение при ошибках конфигурации
class ConfigurationException extends ApiException {
  ConfigurationException(super.message, {super.cause});
}
```

###### Стратегия обработки ошибок

1. Локальная обработка - специфичные для поставщика ошибки обрабатываются в API-клиенте
2. Преобразование - внешние ошибки преобразуются в унифицированные исключения приложения
3. Каскадная обработка - ошибки проходят вверх по стеку вызовов до соответствующего обработчика

###### Оптимизация производительности

###### Кэширование

Для снижения нагрузки на API и улучшения отзывчивости приложения реализовано многоуровневое кэширование:

1. Кратковременное кэширование - в памяти для частых запросов в рамках сессии
2. Долговременное кэширование - локальное хранение результатов запросов
3. Серверное кэширование - при использовании прокси-сервера

###### Дебаунсинг и троттлинг

Для предотвращения избыточных запросов при часто обновляемых данных

###### Параллельные запросы

Для ускорения получения данных от нескольких поставщиков используются параллельные запросы

###### Безопасность

###### Защита API-ключей

В режиме direct: API-ключи хранятся в зашифрованном виде с использованием flutter_secure_storage
В режиме proxy: API-ключи хранятся только на сервере, клиент использует JWT-токены

###### Защита передаваемых данных

Использование HTTPS для всех запросов
Минимизация передаваемых персональных данных
Валидация всех входящих данных от API

###### Мониторинг и логирование

###### Системное логирование

###### Метрики и аналитика

* Время ответа API
* Количество запросов по типам и поставщикам
* Частота ошибок и их типы
* Объем передаваемых данных

###### Мониторинг доступности

Автоматическая проверка доступности API для раннего обнаружения проблем

---

<!-- Source: docs\guides\error_handling.md -->
## Стратегия обработки ошибок

> В этом документе описан подход к обработке ошибок в приложении Part Catalog, включая иерархию исключений, паттерны обработки ошибок и лучшие практики.

###### Содержание
- [Принципы обработки ошибок](#принципы-обработки-ошибок)
- [Иерархия исключений](#иерархия-исключений)
- [Обработка ошибок в разных слоях](#обработка-ошибок-в-разных-слоях)
- [Асинхронная обработка ошибок](#асинхронная-обработка-ошибок)
- [Отображение ошибок в UI](#отображение-ошибок-в-ui)
- [Логирование ошибок](#логирование-ошибок)
- [Мониторинг и аналитика](#мониторинг-и-аналитика)

###### Принципы обработки ошибок

При разработке Part Catalog мы придерживаемся следующих принципов обработки ошибок:

1. **Прозрачность** - ошибки должны быть понятны как для разработчиков, так и для пользователей
2. **Локализация** - обработка ошибок должна происходить на соответствующем уровне абстракции
3. **Информативность** - ошибки должны содержать достаточно информации для диагностики и решения проблемы
3. **Деградация с сохранением функциональности** - при возникновении ошибок система должна продолжать работу, если это возможно

###### Иерархия исключений

В проекте используется иерархия исключений, отражающая разные типы ошибок:

1. Базовый класс для всех исключений приложения
2. Ошибки, связанные с базой данных
3. Ошибки при сетевых операциях
4. Ошибки бизнес-логики
5. Ошибки в данных
6. Ошибки авторизации
7. Типы ошибок авторизации
8. Ошибки конфигурации
9. Внутренние ошибки приложения

###### Обработка ошибок в разных слоях

###### Data Layer (репозитории, DAO)

На уровне доступа к данным происходит перехват низкоуровневых исключений и преобразование их в исключения приложения

###### Domain Layer (сервисы)

Сервисы добавляют контекст бизнес-логики и могут преобразовывать исключения слоя данных в бизнес-исключения

###### Presentation Layer (UI)

На уровне UI выполняется обработка исключений для отображения пользователю

###### Асинхронная обработка ошибок

###### Использование async/await с try-catch

Предпочтительный подход к работе с асинхронным кодом - использование async/await с блоками try-catch

###### Обработка ошибок в StreamBuilder

При работе со стримами обрабатывайте ошибки в блоке builder

###### Глобальный обработчик ошибок зоны

Для перехвата непредвиденных ошибок используем глобальный обработчик

###### Отображение ошибок в UI

###### Компонент ErrorView

Создадим универсальный компонент для отображения ошибок с возможностью повторного запроса

###### Специфичные виды ошибок

Для разных типов ошибок можно создать специфичные компоненты: NetworkErrorView, NoPermissionErrorView

###### Обработка форм и валидация

Для отображения ошибок валидации в формах используйте виджеты, которые поддерживают отображение ошибок валидации.

###### Логирование ошибок

Логирование ошибок осуществляется с помощью библиотеки logger с настроенными логгерами разного уровня.

1. Стандартный формат логирования ошибок
2. Контекстное логирование. Для более информативных логов добавляйте контекст операции, в которой произошла ошибка.

###### Мониторинг и аналитика

###### Интеграция с Firebase Crashlytics

Для отслеживания ошибок в продакшене используется Firebase Crashlytics

###### Расширенный контекст ошибок

Для улучшения диагностики добавляйте пользовательский контекст в Crashlytics

###### Уведомления о критических ошибках

Для оперативного реагирования на критические ошибки настроены уведомления через Firebase Crashlytics:

1. **Email** -уведомления для команды разработки о новых ошибках
2. **Интеграция с Slack** для срочных уведомлений о критических сбоях
3. **Еженедельные сводки** о стабильности приложения

###### Аналитика пользовательских сценариев

Отслеживание успешности выполнения ключевых сценариев для быстрого выявления проблем

---

<!-- Source: docs\modules\orders.md -->
## Модуль заказ-нарядов

> Модуль заказ-нарядов обеспечивает создание и управление заказ-нарядами на ремонт автомобилей, включая список работ, запчастей и материалов.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)
- [Жизненный цикл заказ-наряда](#жизненный-цикл-заказ-наряда)
- [Интеграция с другими модулями](#интеграция-с-другими-модулями)

###### Назначение

Модуль заказ-нарядов решает следующие задачи:

- Создание и управление заказ-нарядами на ремонт автомобилей
- Учет выполненных работ и использованных запчастей
- Отслеживание статуса выполнения заказ-нарядов
- Расчет стоимости работ и материалов
- Взаимодействие с модулями клиентов, автомобилей и поставщиков

###### Архитектура

Модуль следует принципам чистой архитектуры и состоит из следующих уровней:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Пользовательский интерфейс | `OrdersScreen`, `OrderDetailsScreen`,  `OrderFormScreen`|
| Domain | Бизнес-логика | `OrderService`, `OrderStatusManager` |
| Data | Доступ к данным | `OrdersDao`, `OrderPartsDao`, `OrderServicesDao` |

###### Основные компоненты

###### OrderService

Сервисный класс, обеспечивающий бизнес-логику работы с заказ-нарядами:

Функциональность: Управление жизненным циклом заказ-нарядов, обработка данных
Ключевые методы:
getOrders(): Получение всех активных заказ-нарядов
watchOrders(): Реактивное наблюдение за списком заказ-нарядов
createOrder(): Создание нового заказ-наряда
updateOrder(): Обновление существующего заказ-наряда
addPartToOrder(): Добавление запчасти в заказ-наряд
addServiceToOrder(): Добавление работы в заказ-наряд
calculateOrderTotal(): Расчет общей стоимости заказ-наряда
changeOrderStatus(): Изменение статуса заказ-наряда

###### OrderStatusManager

Класс для управления статусами заказ-нарядов:

Функциональность: Контроль переходов между статусами, валидация возможных действий
Ключевые методы:
canTransitionTo(OrderStatus from, OrderStatus to): Проверка возможности перехода
transitionTo(Order order, OrderStatus newStatus): Выполнение перехода
getAvailableTransitions(Order order): Получение доступных переходов

###### OrdersDao

Data Access Object для прямой работы с таблицей заказ-нарядов:

Функциональность: Предоставляет низкоуровневый доступ к данным таблицы
Ключевые методы:
getActiveOrders(): Получение всех активных заказ-нарядов
watchActiveOrders(): Реактивное наблюдение за заказ-нарядами
getOrdersByClientId(): Получение заказ-нарядов клиента
getOrdersByCarId(): Получение заказ-нарядов для автомобиля
insertOrder(): Добавление нового заказ-наряда
updateOrder(): Обновление данных заказ-наряда
updateOrderStatus(): Обновление статуса заказ-наряда
getFullOrderDetails(): Получение полных данных заказ-наряда с работами и запчастями

###### Модели данных

###### OrdersItem (модель таблицы)

```dart
class OrdersItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get clientId => integer().references(ClientsItems, #id)();
  IntColumn get carId => integer().references(CarsItems, #id)();
  TextColumn get orderNumber => text()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get scheduledDate => dateTime().nullable()();
  DateTimeColumn get completedAt => dateTime().nullable()();
  TextColumn get status => text()(); // "new", "in_progress", "completed", "cancelled"
  TextColumn get description => text().nullable()();
  RealColumn get totalAmount => real().withDefault(const Constant(0.0))();
  DateTimeColumn get deletedAt => dateTime().nullable()();
}
```

###### OrderPartsItem (модель таблицы)

```dart
class OrderPartsItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get orderId => integer().references(OrdersItems, #id)();
  TextColumn get partNumber => text()();
  TextColumn get name => text()();
  TextColumn get brand => text().nullable()();
  IntColumn get quantity => integer()();
  RealColumn get price => real()();
  TextColumn get supplierName => text().nullable()();
  IntColumn get deliveryDays => integer().nullable()();
  BoolColumn get isOrdered => boolean().withDefault(const Constant(false))();
  BoolColumn get isReceived => boolean().withDefault(const Constant(false))();
}
```

###### OrderServicesItem (модель таблицы)

```dart
class OrderServicesItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get orderId => integer().references(OrdersItems, #id)();
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  RealColumn get price => real()();
  RealColumn get duration => real().nullable()(); // в часах
  TextColumn get performedBy => text().nullable()();
  BoolColumn get isCompleted => boolean().withDefault(const Constant(false))();
}
```

###### OrderModel (бизнес-модель)

Представляет заказ-наряд в бизнес-логике приложения:

id: Уникальный идентификатор
clientId: ID клиента
carId: ID автомобиля
orderNumber: Номер заказ-наряда
createdAt: Дата создания
scheduledDate: Запланированная дата выполнения
completedAt: Дата завершения
status: Статус заказ-наряда (OrderStatus)
description: Описание проблемы/работ
totalAmount: Общая стоимость
parts: Список запчастей (OrderPartModel)
services: Список работ (OrderServiceModel)
clientName: Имя клиента (опционально, для отображения)
carInfo: Информация об автомобиле (опционально, для отображения)

###### OrderStatus (перечисление)

```dart
enum OrderStatus {
  new,
  inProgress,
  waitingForParts,
  readyForPickup,
  completed,
  cancelled;
  
  String get displayName {
    switch (this) {
      case OrderStatus.new: return 'Новый';
      case OrderStatus.inProgress: return 'В работе';
      case OrderStatus.waitingForParts: return 'Ожидание запчастей';
      case OrderStatus.readyForPickup: return 'Готов к выдаче';
      case OrderStatus.completed: return 'Завершен';
      case OrderStatus.cancelled: return 'Отменен';
    }
  }
  
  Color get color {
    switch (this) {
      case OrderStatus.new: return Colors.blue;
      case OrderStatus.inProgress: return Colors.orange;
      case OrderStatus.waitingForParts: return Colors.amber;
      case OrderStatus.readyForPickup: return Colors.green;
      case OrderStatus.completed: return Colors.teal;
      case OrderStatus.cancelled: return Colors.red;
    }
  }
}
```

###### Основные операции

###### Создание заказ-наряда

Процесс создания заказ-наряда включает:

Выбор клиента
Выбор автомобиля клиента
Указание описания проблемы
Планирование даты выполнения
Добавление работ
Добавление запчастей
Расчет общей стоимости
Сохранение заказ-наряда

###### Управление запчастями заказ-наряда

Операции с запчастями включают:

Добавление запчасти вручную
Подбор запчасти через каталог
Получение цен от поставщиков
Отметка о заказе запчасти
Отметка о получении запчасти

###### Управление статусом заказ-наряда

Жизненный цикл заказ-наряда включает различные статусы:

Новый → В работе → Завершен
Новый → Ожидание запчастей → В работе → Завершен
Новый → Отменен
Смена статуса сопровождается валидацией и может инициировать дополнительные действия.

###### UI компоненты

###### OrdersScreen

Основной экран управления заказ-нарядами:

Список активных заказ-нарядов с группировкой по статусам
Фильтрация по клиенту, автомобилю, дате, статусу
Поиск по номеру заказ-наряда или описанию
Возможность создания нового заказ-наряда
Отображение статуса и основной информации

###### OrderFormScreen

Форма для создания/редактирования заказ-наряда:

Выбор клиента из списка с возможностью создания нового
Выбор автомобиля из списка автомобилей клиента
Поля для ввода описания и планирования даты
Добавление работ со стоимостью и описанием
Добавление запчастей с интеграцией каталога и поставщиков
Расчет итоговой стоимости

###### OrderDetailsScreen

Экран детальной информации о заказ-наряде:

Полная информация о клиенте и автомобиле
Список работ с возможностью отметки выполнения
Список запчастей с информацией о наличии/заказе
Изменение статуса заказ-наряда
Печать/экспорт заказ-наряда

###### Жизненный цикл заказ-наряда

Жизненный цикл заказ-наряда включает следующие этапы:
1. Создание заказ-наряда
2. Добавление работ и запчастей
3. Изменение статуса (в работе, ожидание запчастей, завершен)
4. Завершение заказ-наряда
5. Архивирование или удаление (мягкое удаление)
6. Отчетность и аналитика по завершенным заказ-нарядам
7. Интеграция с бухгалтерией (при необходимости)

###### Интеграция с другими модулями

###### Взаимодействие с модулем клиентов

Получение информации о клиенте
Отображение истории заказ-нарядов клиента
Создание нового клиента непосредственно из формы заказ-наряда

###### Взаимодействие с модулем автомобилей

Выбор автомобиля клиента для заказ-наряда
Отображение истории заказ-нарядов автомобиля
Создание нового автомобиля непосредственно из формы заказ-наряда

###### Взаимодействие с модулем поставщиков

Подбор запчастей по артикулу с использованием ApiClientPartsCatalogs
Получение цен и сроков поставки от поставщиков
Отображение информации о наличии и стоимости запчастей
Оформление заказа на запчасти у поставщика

---

<!-- Source: docs\guides\async_programming.md -->
## Работа с асинхронным кодом

> В этом руководстве описаны подходы и рекомендации по работе с асинхронным кодом в проекте Part Catalog.

###### Содержание
- [Основные принципы](#основные-принципы)
- [Структурирование асинхронного кода](#структурирование-асинхронного-кода)
- [Безопасная работа с BuildContext](#безопасная-работа-с-buildcontext)
- [Обработка ошибок](#обработка-ошибок)
- [Кэширование и оптимизация](#кэширование-и-оптимизация)
- [Тестирование асинхронного кода](#тестирование-асинхронного-кода)
- [Часто встречающиеся проблемы](#часто-встречающиеся-проблемы)

###### Основные принципы

###### Future и Stream

В проекте используются два основных подхода к работе с асинхронными операциями:

Future - для одиночных асинхронных операций (получение данных от API, запись в БД)
Stream - для потоков данных (реактивное обновление UI при изменении данных в БД)

###### Маркировка асинхронных методов

* Всегда используйте ключевое слово async для методов, возвращающих Future
* Выполняйте await для всех асинхронных операций, за исключением случаев, когда вы намеренно запускаете операции параллельно
* Явно указывайте возвращаемые типы (Future<T>, Stream<T>)

###### Структурирование асинхронного кода

###### Использование паттерна Репозиторий

Разделяйте код на слои, чтобы минимизировать асинхронную сложность

###### Параллельное выполнение асинхронных операций

Для оптимизации производительности используйте Future.wait для параллельного выполнения нескольких асинхронных операций

###### Безопасная работа с BuildContext

###### Проверка mounted перед setState

Всегда проверяйте, что виджет всё ещё находится в дереве (mounted), перед вызовом setState() после асинхронных операций

###### Сохранение ссылок на зависимые от контекста объекты

Сохраняйте ссылки на объекты, зависящие от контекста, перед асинхронными операциями

###### Использование addPostFrameCallback

Для запуска асинхронных операций после отрисовки фрейма используйте WidgetsBinding.instance.addPostFrameCallback

###### Обработка ошибок

###### Паттерн try-catch-finally

Используйте блоки try-catch-finally для обработки асинхронных ошибок

###### Обработка ошибок в Stream

При работе с потоками данных обрабатывайте ошибки в Stream с помощью catchError или внутри StreamBuilder

###### Пробрасывание ошибок

При необходимости проброса ошибок на верхние уровни используйте собственные типы исключений

###### Кэширование и оптимизация

###### Кэширование результатов асинхронных операций

Для часто используемых асинхронных операций применяйте кэширование

###### Дебаунсинг и троттлинг

Для предотвращения лишних запросов при быстром вводе пользователя или прокрутке

###### Тестирование асинхронного кода

###### Unit-тестирование асинхронного кода

Для unit-тестов асинхронного кода используйте async/await и методы для ожидания завершения асинхронных операций

###### Тестирование с fake_async

Для тестирования кода с таймерами используйте fake_async

###### Часто встречающиеся проблемы

###### "Uncaught exception" в асинхронном коде

Если в асинхронном коде возникают необработанные исключения:

```dart
// ❌ Неправильно: исключение не обрабатывается
void initState() {
  super.initState();
  loadData(); // Асинхронный метод без обработки ошибок
}

// ✅ Правильно: добавляем обработку ошибок
void initState() {
  super.initState();
  loadData().catchError((error) {
    if (mounted) {
      setState(() => _error = error.toString());
    }
  });
}
```

###### Проблема "setState() or markNeedsBuild() called during build"

Если вы получаете эту ошибку при асинхронных операциях:

```dart
// ❌ Неправильно: setState вызывается синхронно в build
Widget build(BuildContext context) {
  _service.getData().then((data) {
    setState(() => _data = data); // Вызывает ошибку!
  });
  return Container();
}

// ✅ Правильно: используем FutureBuilder или StreamBuilder
Widget build(BuildContext context) {
  return FutureBuilder<Data>(
    future: _service.getData(),
    builder: (context, snapshot) {
      if (snapshot.hasData) {
        return DataWidget(data: snapshot.data!);
      } else if (snapshot.hasError) {
        return ErrorWidget(error: snapshot.error!);
      }
      return LoadingWidget();
    },
  );
}
```

###### Утечки памяти в асинхронном коде

Если происходят утечки памяти из-за асинхронных операций:

```dart
// ❌ Неправильно: подписка на Stream без отписки
StreamSubscription _subscription;

@override
void initState() {
  super.initState();
  _subscription = _service.dataStream.listen((data) {
    setState(() => _data = data);
  });
}

// ✅ Правильно: отписываемся при dispose
@override
void dispose() {
  _subscription?.cancel();
  super.dispose();
}

// ✅ Еще лучше: используем StreamBuilder вместо ручной подписки
Widget build(BuildContext context) {
  return StreamBuilder<Data>(
    stream: _service.dataStream,
    builder: (context, snapshot) {
      // Логика отображения
    },
  );
}
```

###### Зацикленные асинхронные вызовы

Избегайте создания бесконечных циклов асинхронных вызовов:

```dart
// ❌ Неправильно: метод вызывает сам себя без условия остановки
Future<void> refreshData() async {
  final newData = await _repository.fetchData();
  setState(() => _data = newData);
  refreshData(); // Будет вызываться бесконечно!
}

// ✅ Правильно: используем таймер или условие остановки
Future<void> startPeriodicRefresh() async {
  while (_isActive) {
    final newData = await _repository.fetchData();
    if (mounted) {
      setState(() => _data = newData);
    }
    await Future.delayed(Duration(minutes: 1));
  }
}

@override
void initState() {
  super.initState();
  _isActive = true;
  startPeriodicRefresh();
}

@override
void dispose() {
  _isActive = false;
  super.dispose();
}
```

---

<!-- Source: docs\modules\suppliers\direct_api.md -->
## Прямое подключение к API

> Этот документ описывает прямое подключение к API поставщиков запчастей без использования прокси-сервера.

###### Содержание
- [Обзор](#обзор)
- [Архитектура](#архитектура)
- [Базовый интерфейс и реализация](#базовый-интерфейс-и-реализация)
- [Реализация для конкретных поставщиков](#реализация-для-конкретных-поставщиков)
- [Обработка ошибок](#обработка-ошибок)
- [Оптимизация и кэширование](#оптимизация-и-кэширование)
- [Особенности и ограничения](#особенности-и-ограничения)

###### Обзор

Прямое подключение к API поставщиков позволяет приложению напрямую взаимодействовать с API различных поставщиков запчастей без промежуточных серверов. Этот режим удобен для:

    *   Разработки и тестирования
    *   Работы в локальной сети
    *   Случаев с малым количеством запросов
    *   Мобильных приложений с ограниченным серверным бэкендом

###### Архитектура

В режиме прямого подключения клиентское приложение непосредственно взаимодействует с API каждого поставщика:

```
┌────────────────┐      HTTP запрос       ┌──────────────────┐
│   Flutter      │  ──────────────────>   │    API           │
│   приложение   │                        │    поставщика    │
└────────────────┘  <──────────────────   └──────────────────┘
                       HTTP ответ
```

Ключевые особенности архитектуры:

1. Реализация в клиенте: Вся логика подключения реализована в клиентском приложении
2. API-ключи в клиенте: Требуется хранение API-ключей в клиентском приложении
3. Индивидуальный подход: Для каждого поставщика создаётся отдельный API-клиент

###### Базовый интерфейс и реализация

Для унификации работы с разными API поставщиков используется общий интерфейс:

```dart
abstract class SupplierApiClient {
  /// Получает цены на запчасть по артикулу
  Future<List<PartPriceModel>> getPricesByArticle(String article);
  
  /// Поиск запчастей по наименованию
  Future<List<PartInfoModel>> searchPartsByName(String name);
  
  /// Получает детальную информацию о запчасти
  Future<PartDetailModel?> getPartDetails(String articleNumber);
  
  /// Возвращает название поставщика
  String get supplierName;
}
```

Базовая реализация предоставляет общие механизмы работы с HTTP-запросами:

```dart
abstract class BaseSupplierClient implements SupplierApiClient {
  final HttpClientInterface httpClient;
  final String baseUrl;
  final Map<String, String> defaultHeaders;
  
  BaseSupplierClient({
    required this.httpClient,
    required this.baseUrl,
    this.defaultHeaders = const {},
  });
  
  // Методы для формирования URL и выполнения безопасных HTTP запросов
}
```

###### Реализация для конкретных поставщиков

Каждый поставщик реализует свой собственный клиент, наследующий `BaseSupplierClient` и переопределяющий методы для работы с конкретным API:

```dart
class AutodocClient extends BaseSupplierClient {
  AutodocClient({
    required HttpClientInterface httpClient,
    required String apiKey,
    String baseUrl = 'https://api.autodoc.ru',
  }) : super(
    httpClient: httpClient,
    baseUrl: baseUrl,
    defaultHeaders: {
      'X-API-Key': apiKey,
      'User-Agent': 'PartCatalog/1.0',
    },
  );
  
  @override
  String get supplierName => 'Autodoc';
  
  @override
  Future<List<PartPriceModel>> getPricesByArticle(String article) async {
    // Реализация метода для конкретного поставщика
  }
  
  // Остальные методы...
}
```

###### Обработка ошибок

При прямом подключении к API важна корректная обработка ошибок:

1. Сетевые ошибки: Отсутствие интернет-соединения, таймауты, проблемы DNS
2. Ошибки API: Неверные API-ключи, превышение лимитов запросов, ошибки аутентификации
3. Ошибки данных: Некорректный формат ответа, отсутствие обязательных полей

```dart
try {
  final prices = await apiClient.getPricesByArticle(article);
  // Обработка успешного ответа
} on NetworkException catch (e) {
  // Обработка сетевых ошибок
  logger.e('Ошибка сети при запросе к ${apiClient.supplierName}', e);
  
  if (e.statusCode == 401) {
    // Показать сообщение о неверных учетных данных
  } else if (e.statusCode == 429) {
    // Показать сообщение о превышении лимита запросов
  } else {
    // Общая ошибка сети
  }
} catch (e) {
  // Обработка непредвиденных ошибок
  logger.e('Непредвиденная ошибка', e);
}
```

###### Оптимизация и кэширование

Для повышения производительности и снижения нагрузки на API можно использовать кэширование:

###### Локальное кэширование результатов:

Для кэширования результатов запросов можно использовать локальное хранилище, например, `SharedPreferences` или SQLite:

###### Дебаунсинг запросов:

Для предотвращения частых запросов при вводе пользователем можно использовать дебаунсинг:

###### Умное обновление кэша:

При получении новых данных можно сравнивать их с кэшированными и обновлять только изменившиеся записи. Это позволяет снизить количество запросов к API и ускорить работу приложения.

###### Параллельные запросы:

Для ускорения получения данных можно выполнять несколько запросов параллельно, используя `Future.wait`

###### Особенности и ограничения

При использовании прямого подключения к API следует учитывать:

###### Преимущества:
1. Простота реализации: Не требует дополнительного сервера
2. Отсутствие дополнительных задержек: Запросы идут напрямую к поставщикам
3. Автономность: Приложение не зависит от доступности промежуточного сервера

###### Ограничения:
1. Безопасность: API-ключи хранятся на клиентской стороне
2. Лимиты запросов: Каждое устройство использует собственную квоту запросов
3. Оптимизация: Сложнее реализовать общую оптимизацию запросов
4. Конфигурация: При изменении API поставщиков требуется обновление клиентского приложения

###### Рекомендации по использованию:
1. Используйте для разработки и тестирования: В production-среде предпочтительнее использовать прокси-сервер
2. Обеспечьте защиту API-ключей: Храните ключи в зашифрованном виде
3. Реализуйте кэширование: Для снижения нагрузки на API и улучшения отклика
4. Мониторинг ошибок: Реализуйте централизованный мониторинг ошибок для выявления проблем с API

---

<!-- Source: docs\modules\suppliers\proxy_server.md -->
## Прокси-сервер для API поставщиков

> Прокси-сервер позволяет централизовать доступ к API поставщиков запчастей, обеспечивая безопасное хранение API-ключей, кэширование результатов и оптимизацию платных запросов.

###### Содержание

- Назначение
- Архитектура
- Ключевые компоненты
- Установка и запуск
- Интеграция с клиентом

###### Назначение

Прокси-сервер решает следующие задачи:

- Централизованное хранение API-ключей поставщиков
- Обеспечение доступа к API с фиксированных IP-адресов
- Кэширование результатов для оптимизации платных запросов
- Унификация формата данных от разных поставщиков
- Мониторинг и логирование запросов

###### Архитектура

Прокси-сервер разработан на Dart с использованием пакета `shelf` и переиспользует код клиентской части для работы с API поставщиков.

###### Технический стек

- **Язык**: Dart
- **Фреймворк**: shelf
- **Хранение кэша**: sembast
- **Логирование**: logging

###### Общая схема работы

```
┌──────────────┐      HTTP      ┌──────────────┐      HTTP       ┌─────────────┐
│    Клиент    │   запрос 1 ─▶  │ Прокси-сервер│   запрос     ─▶│   API       │
│  (Flutter)   │                │ (Dart)        │                │ Поставщика  │
└──────────────┘  ◀──────────   └──────────────┘  ◀──────────   └─────────────┘
                       ответ                      ответ
         │
         ▼
    ┌───────────────┐
    │      Кэш      │
    │(sembast/redis)│
    └───────────────┘
```

###### Ключевые компоненты

###### Основные компоненты сервера

- **Router**: маршрутизация HTTP-запросов
- **ApiClientManager**: управление клиентами API поставщиков
- **CacheManager**: кэширование результатов запросов

###### Основные эндпоинты API

| Метод | Путь | Описание |
|-------|------|----------|
| GET | `/api/suppliers/{supplier}/prices` | Получение цен от конкретного поставщика |
| GET | `/api/suppliers/{supplier}/search` | Поиск запчастей у конкретного поставщика |
| GET | `/api/prices` | Агрегация цен от всех поставщиков |
| GET | `/health` | Проверка работоспособности сервера |

###### Установка и запуск

###### Предварительные требования

- Dart SDK 2.17.0 или выше
- Настроенные переменные окружения с API-ключами поставщиков

###### Команда запуска

```bash
# Запуск с параметрами по умолчанию
dart bin/server.dart

# Запуск с указанием порта
dart bin/server.dart --port=8080
```

###### Интеграция с клиентом

Для подключения клиента Flutter к прокси-серверу:

Настройка режима API в конфигурации:

```dart
// Изменение режима API на proxy
await apiClientManager.switchMode(ApiConnectionMode.proxy);
```

Указание URL прокси-сервера:

```dart
// Сохранение URL прокси-сервера
final prefs = await SharedPreferences.getInstance();
await prefs.setString('proxy_server_url', 'https://your-proxy-server.com');
```



---

<!-- Source: docs\references\api_reference.md -->
## Справочник по API проекта

---


## Примеры кода

> Ниже приведены наиболее важные примеры кода из проекта

### api_client.dart

```dart
//# Полный пример API клиента

```

### proxy_server.dart

```dart
//# Полный пример прокси-сервера

```

