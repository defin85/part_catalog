# Part Catalog - GitHub Copilot Instructions

> Auto fleet management system for service stations using Flutter with hybrid 1C + DDD architecture

## Architecture Overview

### Hybrid Architecture: 1C + DDD
The application uses a unique hybrid approach combining:
- **1C concepts**: Document-centric approach (orders), references (clients, vehicles), registers (inventory, finances)
- **DDD patterns**: Bounded contexts, aggregates, composite models, repository pattern, domain services

### Architectural Layers
1. **Presentation Layer** (UI): Screens, widgets, UI state management
2. **Application Layer**: Use cases, application services, DTOs
3. **Domain Layer**: Business logic, composite models, domain services, interfaces
4. **Infrastructure Layer**: Database access (DAOs), API clients, external integrations
5. **Core Layer**: Shared utilities, constants, base classes

### Core Structure
- **Core Layer** (`lib/core/`): Shared infrastructure including database, i18n, navigation, service locator
- **Features** (`lib/features/`): Business modules organized by domain (bounded contexts)
- **Models** (`lib/models/`): Shared data models across features

## Key Patterns

### Composite Model Pattern
**Critical Pattern**: Combines `EntityCoreData` + `SpecificData` into business models
- Example: `OrderModelComposite` = `EntityCoreData` + `OrderSpecificData`
- Implements interfaces like `IDocumentEntity`, `IOrderEntity`
- Uses immutable `@freezed` data structures internally
- Creates new instances with `with...` methods: `order.withStatus(newStatus)`

### Model Structure
- **Interfaces** define contracts (`IEntity`, `IDocumentEntity`)
- **Composite classes** implement interfaces and encapsulate data/behavior
- **`@freezed` models** for immutable data structures

```dart
// Example Composite Model
class OrderModelComposite implements IDocumentEntity {
  final EntityCoreData coreData;
  final DocumentSpecificData docData;
  final OrderSpecificData orderData;
  
  // Factory constructors
  factory OrderModelComposite.create({...});
  factory OrderModelComposite.fromData(...);
  
  // Immutable updates
  OrderModelComposite withStatus(DocumentStatus status) { ... }
}
```

## Development Workflow

### Code Generation Commands
```bash
# Generate all code (run after model changes)
dart run build_runner build -d

# Watch mode for development
dart run build_runner watch -d

# Organize imports
dart run scripts/organize_imports.dart
```

### Running the App
```bash
# Web development
flutter run -d chrome

# Desktop demo
flutter run -d windows -t lib/main_desktop_demo.dart

# Mobile development
flutter run
```

### State Management & Navigation
- **Riverpod** for global state with `@riverpod` annotations
- **GoRouter** with shell routes for adaptive navigation
- **Slang** for i18n with automatic generation from `lib/core/i18n/`

```dart
// Riverpod provider pattern
@riverpod
ClientService clientService(Ref ref) {
  final db = locator<AppDatabase>();
  return ClientService(db);
}

// GoRouter structure
ShellRoute(
  builder: (context, state, child) => HomeScreen(child: child),
  routes: [
    GoRoute(path: '/clients', builder: (context, state) => ClientsScreen()),
  ],
)
```

### Database Patterns
- **Drift ORM** with reactive queries and DAO pattern
- **Three-layer model mapping**: 
  1. Table models (`ClientsItem`) from Drift
  2. `@freezed` data models (`EntityCoreData`, `ClientSpecificData`)
  3. Composite business models (`ClientModelComposite`)

```dart
// Service layer mapping pattern
ClientModelComposite _mapDataToComposite(ClientFullData data) {
  return ClientModelComposite.fromData(
    data.coreData,
    data.clientData,
  );
}
```

### Logging Conventions
- Use category-specific loggers: `AppLoggers.clients`, `AppLoggers.database`
- Never use `print()` - always use `logger.i()`, `logger.e()`, etc.
- Include error and stackTrace in error logs

```dart
final _logger = AppLoggers.clients;
_logger.e('Error message', error: e, stackTrace: stackTrace);
```

### API Client Management
- **Adaptive API mode**: Switch between `direct`, `proxy`, or `hybrid` connection modes
- **ApiClientManager** handles supplier API clients with runtime mode switching
- Use `getOptimizedClient()` for production scenarios

```dart
// Switch API connection mode
await apiClientManager.switchMode(ApiConnectionMode.proxy);

// Get client with credentials
final client = await apiClientManager.getClient(
  supplierCode: 'armtek',
  username: 'user',
  password: 'pass',
  vkorg: '1000',
);
```

## Testing Strategy

- **Unit tests**: Mock repositories/DAOs, test business logic
- **Widget tests**: Use `ProviderScope` for Riverpod testing
- **Integration tests**: Test complete user flows
- Run tests: `flutter test` or `dart run test/run_all_tests.dart`

## Language & Communication
- Working language: **Russian** for documentation, comments, UI text
- Code identifiers: **English** (classes, methods, variables)
- Use feature-first organization under `lib/features/<domain>/`

---

<!-- Source: docs\README.md -->
## Основной обзор проекта и навигация по документации

# Part Catalog

> Система управления учетом клиентов, автомобилей и заказ-нарядов для СТО

###### Содержание

- [Обзор](#обзор)
- [Архитектура](#архитектура)
- [Модули](#модули)
- [Руководства](#руководства)
- [Справочные материалы](#справочные-материалы)

###### Обзор

Part Catalog - это приложение для работников станций технического обслуживания автомобилей (СТО), обеспечивающее полный цикл учета клиентов, автомобилей, заказ-нарядов и запчастей.

**Ключевые возможности:**

- Учет клиентов (физических и юридических лиц)
- Учет автомобилей клиентов
- Управление заказ-нарядами
- Интеграция с каталогами запчастей
- Получение цен на запчасти от поставщиков

###### Архитектура

Документация по архитектуре приложения:

- [Общая архитектура](#overview) - обзор архитектуры приложения, слоев и компонентов
- [Структура БД](#database_schema) - схема БД, таблицы, связи и маппинги моделей
- [API интеграции](#api_integration) - интеграция с внешними API поставщиков и каталогов

###### Модули

Основные модули приложения:

- [Клиенты](#clients) - управление клиентами
- [Автомобили](#vehicles) - управление автомобилями клиентов
- [Заказ-наряды](#orders) - управление заказ-нарядами
- Поставщики:
  - [Обзор модуля](#overview) - общая информация о модуле
  - [Прямое подключение к API](#direct_api) - прямое взаимодействие с API поставщиков
  - [Прокси-сервер](#proxy_server) - использование прокси-сервера для запросов к API

###### Руководства

- [Стиль кодирования](#code_style) - соглашения по именованию, структуре файлов и организации кода
- [Тестирование](#testing) - стратегия и паттерны тестирования
- [Обработка ошибок](#error_handling) - подход к обработке ошибок и исключений
- [Асинхронное программирование](#async_programming) - работа с асинхронным кодом

###### Справочные материалы

- [API Reference](#api_reference) - справочник по API проекта
- [Примеры кода](#code_examples) - полные примеры кода

---

<!-- Source: docs\architecture\overview.md -->
## Общая архитектура приложения

> Данный документ описывает высокоуровневую архитектуру приложения Part Catalog, разрабатываемого для разных платформ: десктоп (Windows, macOS, Linux), планшет и смартфон (iOS, Android).

###### Содержание
- [Обзор](#обзор)
- [Гибридная архитектура: 1С и DDD](#гибридная-архитектура-1с-и-ddd)
- [Архитектурные слои](#архитектурные-слои)
- [Ключевые компоненты](#ключевые-компоненты)
- [Взаимодействие между модулями](#взаимодействие-между-модулями)
- [Кросс-платформенная адаптация](#кросс-платформенная-адаптация)
- [Управление состоянием](#управление-состоянием)
- [Навигация](#навигация)
- [Внедрение зависимостей](#внедрение-зависимостей)
- [Локализация](#локализация)
- [Облачная интеграция](#облачная-интеграция)
- [Диаграммы](#диаграммы)

###### Обзор

Part Catalog - это приложение для работников станций технического обслуживания автомобилей (СТО), обеспечивающее полный цикл учета клиентов, автомобилей, заказ-нарядов и подбора запчастей. Архитектура приложения построена с учетом мультиплатформенности и следует принципам гибридной архитектуры, сочетающей подходы 1С и Domain-Driven Design (DDD).

###### Технический стек:

Framework: Flutter
Язык программирования: Dart
База данных: Drift (SQLite) + Supabase для облачной синхронизации
Сетевые запросы: Dio
Управление состоянием: Provider/BLoC/Riverpod (выбрать предпочтительный)
Внедрение зависимостей: get_it
Навигация: go_router
Локализация: flutter_localizations + intl
Кодогенерация: build_runner + drift + freezed
Логгирование: logger

###### Гибридная архитектура: 1С и DDD

Приложение использует гибридную архитектуру, сочетающую лучшие практики из 1С и Domain-Driven Design (DDD). Этот подход позволяет объединить привычные для бизнеса концепции 1С с современными методиками проектирования сложных систем.

###### Элементы архитектуры 1С

В нашей архитектуре используются следующие концепции, заимствованные из 1С:

1. **Документоцентрический подход** - основные бизнес-операции оформляются как документы (заказ-наряды)
2. **Справочники** - для работы с относительно постоянной информацией (клиенты, автомобили)
3. **Регистры** - для учета движений и состояний (наличие запчастей, статусы заказ-нарядов)
4. **Формы представления данных** - для унифицированного отображения и взаимодействия с данными

###### Элементы Domain-Driven Design (DDD)

Одновременно архитектура включает основные концепции DDD:

1. **Предметная область (Domain)** - выделение бизнес-логики в отдельный слой
2. **Единый язык (Ubiquitous Language)** - использование общих терминов между разработчиками и специалистами предметной области
3. **Агрегаты (Aggregates)** и **корни агрегатов (Aggregate Roots)** - для обеспечения целостности данных. Реализуются через **классы-композиторы** (например, `OrderModelComposite`), которые инкапсулируют состояние и поведение агрегата
4. **Репозитории (Repositories)** - для доступа к хранилищу данных
5. **Сервисы предметной области (Domain Services)** - для реализации сложной бизнес-логики

###### Преимущества гибридного подхода:

1. **Понятность для бизнес-пользователей** - использование привычной терминологии и концепций из 1С
2. **Масштабируемость и поддерживаемость** - благодаря принципам DDD
3. **Четкое разделение ответственности** - каждый компонент имеет строго определенную функцию
4. **Гибкость при изменении требований** - изолированные компоненты позволяют менять отдельные части системы

###### Стратегия идентификации данных

В данной системе применяется следующий подход к идентификаторам:
- БД использует integer ID (автоинкремент)
- Бизнес-модели используют String ID (UUID)
- Для новых объектов генерируется UUID
- При получении данных из БД ID преобразуется в String

Этот подход обеспечивает:
1. Эффективное хранение и индексирование в базе данных
2. Возможность создания новых объектов без доступа к БД
3. Упрощение синхронизации с облачными сервисами
4. Предотвращение конфликтов при работе нескольких устройств

###### Архитектурные слои

Архитектура приложения состоит из следующих слоев:

###### 1. Presentation Layer (UI)

Назначение: Отвечает за пользовательский интерфейс и взаимодействие с пользователем
Компоненты: 
- Экраны (аналог форм в 1С) 
- Виджеты (аналог элементов управления) 
- Диалоги
- Провайдеры состояния
Особенности: Адаптивный дизайн для разных платформ и размеров экрана

###### 2. Application Layer

Назначение: Координирует действия между UI и Domain слоем, не содержит бизнес-логику
Компоненты:
- Use cases (сценарии использования)
- Application services (сервисы приложения)
- DTOs (объекты передачи данных)
Особенности: Организует рабочие процессы, но не содержит бизнес-правил

###### 3. Domain Layer (Business Logic)

Назначение: Содержит бизнес-логику приложения и моделирует предметную область
Компоненты:
- **Интерфейсы сущностей** (`IEntity`, `IDocumentEntity`, `IItemEntity`...) - определяют контракты.
- **Классы-композиторы** (`OrderModelComposite`, `ClientModelComposite`...) - реализуют интерфейсы, инкапсулируют данные и поведение. Являются основными бизнес-моделями.
- **Модели данных (`@freezed`)** (`EntityCoreData`, `DocumentSpecificData`, `OrderSpecificData`...) - чистые, иммутабельные структуры для хранения данных. Используются внутри классов-композиторов.
- **Value Objects** (объекты-значения)
- **Domain Services** (сервисы предметной области)
- **Domain Events** (события предметной области)
Особенности: Не зависит от UI и источников данных, содержит правила и бизнес-логику. Данные хранятся в иммутабельных структурах.

###### 4. Infrastructure Layer

Назначение: Обеспечивает доступ к данным из различных источников
Компоненты: 
- Repositories (репозитории - реализации)
- Data Access Objects (DAO)
- API Clients (клиенты API)
- Persistence Models (модели хранения данных - аналоги таблиц в 1С)
Особенности: Преобразует данные между форматами API/БД и **моделями данных (`@freezed`)**, которые затем используются **классами-композиторами** доменного слоя.

###### 5. Core Layer (Shared Kernel)

Назначение: Содержит общие компоненты и утилиты
Компоненты: 
- Логгеры
- Константы
- Расширения
- Утилитарные функции
- Инфраструктурный код
Особенности: Используется всеми другими слоями

###### Ключевые компоненты

###### База данных

Технология: Drift (SQLite wrapper)
Основные таблицы:
ClientsItems (аналог справочника "Контрагенты" в 1С)
CarsItems (аналог справочника "Транспортные средства" в 1С)
OrdersItems (аналог документа "Заказ-наряд" в 1С)
OrderPartsItems (аналог табличной части документа в 1С)
OrderServicesItems (аналог табличной части документа в 1С)
Особенности: Мягкое удаление, реактивные запросы, миграции
Синхронизация: Интеграция с Supabase для облачного хранения и синхронизации

###### API интеграции

Каталоги запчастей: ApiClientPartsCatalogs
Поставщики запчастей:
- Адаптивная архитектура с режимами direct/proxy/hybrid
- Общая модель ответов для разных поставщиков
- Кэширование результатов

###### Модули (Bounded Contexts в терминологии DDD)

Клиенты: Управление физическими и юридическими лицами (реализует справочник "Контрагенты")
Автомобили: Управление автомобилями клиентов (реализует справочник "Транспортные средства")
Заказ-наряды: Создание и отслеживание ремонтных работ (реализует документ "Заказ-наряд")
Поставщики: Получение цен и сроков поставки запчастей (реализует службу интеграции)

###### Взаимодействие между модулями

Модули взаимодействуют между собой через четко определенные интерфейсы, следуя принципам низкой связанности и антикоррупционных слоев (Anti-Corruption Layers) из DDD:

Клиенты → Автомобили: Клиент владеет автомобилями (связь один-ко-многим)
Автомобили → Заказ-наряды: Заказ-наряд связан с конкретным автомобилем
Клиенты → Заказ-наряды: Заказ-наряд связан с конкретным клиентом
Заказ-наряды → Поставщики: Заказ-наряд использует API поставщиков для получения цен на запчасти

###### Кросс-платформенная адаптация

Приложение оптимизировано для работы на различных платформах и устройствах:

###### Десктопные платформы (Windows, macOS, Linux)

Многооконный интерфейс с боковой навигацией
Табличное представление данных с сортировкой и фильтрацией
Поддержка горячих клавиш
Оптимизация для работы с мышью и клавиатурой

###### Планшеты

Разделенный интерфейс (master-detail)
Адаптивное расположение элементов в зависимости от ориентации
Оптимизация для сенсорного ввода с поддержкой стилуса

###### Смартфоны

Оптимизированный однооконный интерфейс
Адаптация под небольшие экраны
Оптимизация для управления одной рукой
Упрощенные формы ввода

###### Управление состоянием

В приложении используется комбинация подходов к управлению состоянием:

Локальное состояние: StatefulWidget для локального UI-состояния
Глобальное состояние: Provider/BLoC/Riverpod
Персистентное состояние: Drift (SQLite)
Реактивное состояние: Stream-based подход с использованием реактивных запросов Drift

###### Навигация

Навигация в приложении осуществляется с помощью go_router, который обеспечивает:

Декларативное определение маршрутов
Вложенную навигацию
Поддержку deep linking
Различные стратегии навигации для разных платформ

###### Внедрение зависимостей

Для управления зависимостями используется get_it, который обеспечивает:

Ленивую инициализацию компонентов
Регистрацию синглтонов и фабрик
Модульную регистрацию зависимостей по feature-modules
Разрешение зависимостей во время выполнения

###### Локализация

Для поддержки различных языков в приложении используется система локализации:

Технологии: flutter_localizations, intl пакеты
Структура: Текстовые ресурсы хранятся в .arb файлах для каждого поддерживаемого языка
Управление: Автоматическая генерация кода для доступа к локализованным строкам
Поддерживаемые языки: Русский, Английский (с возможностью расширения)
Форматирование: Локализованное форматирование дат, валют и чисел

```dart
// Пример использования локализации
Text(AppLocalizations.of(context)!.clientNameLabel),

// Пример локализованного форматирования
Text(NumberFormat.currency(
  locale: Localizations.localeOf(context).toString(),
  symbol: '₽',
).format(order.totalAmount)),
```

###### Облачная интеграция

Приложение поддерживает гибридный режим работы с локальными и облачными данными через Supabase:

Основные возможности Supabase в приложении
Синхронизация данных: Двунаправленная синхронизация между локальной базой и облаком
Аутентификация: Поддержка входа через различные провайдеры (email/пароль, Google, Apple)
Управление правами: Настройка доступа к данным на основе ролей пользователей
Уведомления: Реализация серверных уведомлений через Postgres Realtime
Хранилище: Загрузка и хранение файлов и изображений
Функции: Выполнение серверной логики через Edge Functions

###### Архитектура интеграции с Supabase

```
┌─────────────────┐      ┌───────────────────┐      ┌──────────────────┐
│  Local Database │◄────►│ Sync Coordinator  │◄────►│ Supabase Client  │
│     (Drift)     │      │                   │      │                  │
└─────────────────┘      └───────────────────┘      └─────────┬────────┘
                                                              │
                                                              ▼
                                                    ┌──────────────────┐
                                                    │  Supabase Cloud  │
                                                    │                  │
                                                    └──────────────────┘
```

###### Стратегия синхронизации

Оффлайн-режим: Приложение полноценно работает без интернета с локальной базой
Фоновая синхронизация: При появлении соединения изменения автоматически синхронизируются
Разрешение конфликтов: Стратегии для разрешения конфликтов при одновременном редактировании
Состояние синхронизации: Индикаторы, показывающие статус синхронизации данных

###### Диаграммы

<!-- ...existing code... -->
###### Высокоуровневая архитектура с учетом гибридного подхода

```
┌────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
│                (Формы и элементы управления)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Клиенты UI  │  │Автомобили UI │  │Заказ-наряды UI│ ... │
│  └──────┬───────┘  └───────┬──────┘  └───────┬──────┘      │
└─────────┼────────────────┬─┼──────────────┬──┼─────────────┘
          │                │ │              │  │
┌─────────┼────────────────┼─┼──────────────┼──┼─────────────┐
│         │  Application Layer               │  │             │
│         │   (Use Cases, DTOs)              │  │             │
│  ┌──────▼──────┐  ┌───────▼──────┐  ┌─────▼───────┐        │
│  │ClientUseCase│  │ CarUseCase   │  │OrderUseCase │   ...   │
│  └──────┬──────┘  └───────┬──────┘  └─────┬───────┘        │
└─────────┼────────────────┬┼───────────────┼────────────────┘
          │                ││               │
┌─────────┼────────────────┼┼───────────────┼────────────────┐
│         │   Domain Layer  ││               │                │
│      (Бизнес-логика, Композиторы, Интерфейсы, Сервисы)     │
│  ┌──────▼──────┐  ┌───────▼──────┐  ┌─────▼───────┐        │
│  │ClientService│  │ CarService   │  │OrderService │   ...   │
│  │(работает с  │  │(работает с   │  │(работает с   │        │
│  │IClientEntity│  │ICarEntity)   │  │IDocumentEntity)│       │
│  │/ClientModel │  │/CarModel     │  │/OrderModel   │        │
│  │Composite)   │  │Composite)    │  │Composite)    │        │
│  └──────┬──────┘  └───────┬──────┘  └─────┬───────┘        │
└─────────┼────────────────┬┼───────────────┼────────────────┘
          │                ││               │
┌─────────┼────────────────┼┼───────────────┼────────────────┐
│         │ Infrastructure Layer            │                │
│         │ (Репозитории, DAO, Модели данных @freezed)      │
│  ┌──────▼─────┐  ┌────────▼─────┐  ┌──────▼─────┐          │
│  │ClientsRepo │  │   CarsRepo   │  │ OrdersRepo │    ...    │
│  │(возвращает │  │(возвращает   │  │(возвращает  │          │
│  │EntityCore..│  │CarSpecific.. │  │OrderSpecific.│          │
│  │/ClientData)│  │/ItemCoreData)│  │/DocSpecific..)│         │
│  └──────┬─────┘  └──────┬───────┘  └──────┬─────┘          │
└─────────┼─────────────┬─┼─────────────────┼────────────────┘
          │             │ │                 │
┌─────────┼─────────────┼─┼─────────────────┼────────────────┐
│         │             │ │ Core Layer      │                │
│         │             │ │(Shared Kernel)  │                │
│  ┌──────▼─────────────▼─▼─────────────────▼─────┐          │
│  │                 AppDatabase                   │          │
│  └──────────────────────────────────────────────┘          │
│                                                            │
│  ┌───────────────────┐  ┌──────────────────────┐           │
│  │   ApiClients      │  │   ServiceLocator     │    ...    │
│  └───────────────────┘  └──────────────────────┘           │
└────────────────────────────────────────────────────────────┘
```

###### Взаимодействие компонентов в гибридной архитектуре

```
┌─────────────┐      ┌─────────────┐      ┌────────────────┐      ┌───────────────┐
│  UI Widget  │─────▶│  Use Case   │─────▶│Domain Service  │─────▶│  Repository   │
│  (Форма)    │      │ (Сценарий)  │      │(Бизнес-логика) │      │  (Хранение)   │
└─────────────┘      └─────────────┘      └────────────────┘      └───────┬───────┘
                                                                          │
                                                                          ▼
                                                                 ┌────────────────┐
                                                                 │ Data Source    │
                                                                 │(БД, API и др.) │
                                                                 └────────────────┘
```

###### Многоуровневое хранение данных

```
┌────────────────────────────────────────────────────────────────┐
│              Пользовательский интерфейс (UI)                   │
└────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Провайдеры состояния (State Management)            │
└─────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Сервисы (Services)                                 │
└─────────────────────────────────────────────────────────────────┘
                  │                      ▲
                  ▼                      │
┌─────────────────────────────────────────────────────────────────┐
│              Репозитории (Repositories)                         │
└─────────────────────────────────────────────────────────────────┘
          │                │                   │
          ▼                ▼                   ▼
┌───────────────────┐ ┌──────────────┐ ┌─────────────────────┐
│   Локальная БД    │ │  REST API    │ │ Supabase Cloud      │
│     (Drift)       │ │  клиенты     │ │ (PostgreSQL/Storage)│
└───────────────────┘ └──────────────┘ └─────────────────────┘
```

---

<!-- Source: docs\guides\code_style.md -->
## Руководство по стилю кодирования

> В этом документе описаны принципы и соглашения по стилю кодирования, принятые в проекте Part Catalog.

###### Содержание
- [Общие принципы](#общие-принципы)
- [Форматирование кода](#форматирование-кода)
- [Именование](#именование)
- [Комментарии и документация](#комментарии-и-документация)
- [Структура файлов](#Структура-файлов)
- [Архитектурные паттерны](#архитектурные-паттерны)
- [Работа с ресурсами](#работа-с-ресурсами)
- [Управление зависимостями](#управление-зависимостями)
- [Асинхронный код](#асинхронный-код)
- [Тестирование](#тестирование)
- [Безопасность](#безопасность)
- [Производительность](#производительность)
- [Логгирование](#логгирование)
- [Управление объемом генерируемого кода](#управление-объемом-генерируемого-кода)
- [Иммутабельность](#иммутабельность)
- [Дополнительные рекомендации](#дополнительные-рекомендации)

###### Общие принципы

###### Приоритетные правила

1. **Читаемость превыше всего** - код должен быть понятным для других разработчиков
2. **DRY (Don't Repeat Yourself)** - избегайте дублирования кода
3. **KISS (Keep It Simple, Stupid)** - старайтесь писать простой код, избегайте излишней сложности
4. **YAGNI (You Aren't Gonna Need It)** - не добавляйте функциональность "про запас"
5. **Единообразие** - придерживайтесь единого стиля во всём проекте

###### Соблюдение принципов Flutter/Dart

- Следуйте [официальному руководству по стилю Dart](https://dart.dev/guides/language/effective-dart/style)
- Используйте встроенные инструменты форматирования (`dart format`)
- Поддерживайте высокий балл в анализаторе кода (minimum 80/100)

###### Форматирование кода

###### Отступы и пробелы

- Используйте **2 пробела** для отступов (не табуляции)
- Ограничивайте длину строк **80 символами**
- Добавляйте пустую строку между логическими блоками кода
- Используйте пробелы вокруг операторов и после запятых

###### Фигурные скобки

Открывающая скобка на той же строке, что и объявление
Закрывающая скобка на отдельной строке

###### Trailing Commas

Добавляйте запятые в конце параметров для многострочных объявлений
Форматируйте параметры виджетов один под другим для улучшения читаемости

###### Именование

###### Файлы

* Используйте snake_case для имён файлов: client_service.dart
* Придерживайтесь шаблона <что>_<тип>.dart: clients_screen.dart, car_model.dart
* Группируйте связанные файлы в одной директории

###### Классы и типы

* Используйте PascalCase для классов, enum, типов и миксинов: `ClientService`, `OrderStatus`
* **Интерфейсы:** Используйте префикс `I`: `IEntity`, `IDocumentEntity`, `IItemEntity`.
* **Модели данных (`@freezed`):** Используйте суффикс `Data`: `EntityCoreData`, `ItemCoreData`, `DocumentSpecificData`, `OrderSpecificData`.
* **Классы-композиторы (Бизнес-модели):** Используйте основной термин без суффикса или с суффиксом `Composite` (пока используем `Composite` для ясности перехода): `OrderModelComposite`, `ClientModelComposite`, `OrderPartModelComposite`.
* Имена должны быть существительными или существительными с прилагательными: `CarModelComposite`, `ClientsScreen`
* Используйте суффиксы для определения роли класса:
    *Controller / *Cubit / *Bloc - для управления состоянием
    *Service - для бизнес-логики
    *Repository - для слоя данных
    *Provider - для доступа к данным
    *Screen / *Page - для экранов
    *Widget - для переиспользуемых UI компонентов
    *Data - для чистых моделей данных (`@freezed`)
    *Composite - для классов-композиторов (бизнес-моделей)

###### Переменные и методы

Используйте camelCase для переменных и методов: clientName, calculateTotal()
Методы и функции должны начинаться с глагола: fetchData(), calculatePrice()
Булевы переменные должны иметь префикс is, has, should и т.д.: isActive, hasChildren
Избегайте сокращений, кроме общепринятых (e.g., id, url)

###### Константы

Используйте lowerCamelCase для константных значений: const double borderRadius = 8.0;
Для статических/глобальных констант используйте kConstantName: kDefaultTimeout

###### Комментарии и документация

###### Документирование API

Используйте комментарии /// для документации публичных API
Описывайте параметры, возвращаемые значения и исключения
Добавляйте примеры для сложных методов

###### Внутренние комментарии

Используйте комментарии // для объяснения сложных участков кода
Добавляйте комментарии перед сложными алгоритмами или нестандартными решениями
Используйте маркеры // TODO:, // FIXME:, // NOTE: для обозначения задач

###### Структура файлов

###### Организация проекта

Проект организован по принципу feature-first:

```
lib/
  ├─ features/            # Функциональные модули
  │   ├─ clients/         # Модуль клиентов
  │   │   ├─ models/      # Модели данных (@freezed) и Композиторы
  │   │   ├─ services/    # Бизнес-логика
  │   │   ├─ screens/     # Экраны UI
  │   │   └─ widgets/     # UI компоненты
  │   ├─ vehicles/        # Модуль автомобилей
  │   └─ orders/          # Модуль заказ-нарядов
  ├─ core/                # Общие компоненты
  │   ├─ database/        # Доступ к БД
  │   ├─ interfaces/      # Общие интерфейсы (IEntity, IItemEntity...)
  │   ├─ models/          # Общие модели данных (@freezed) (EntityCoreData...)
  │   ├─ config/          # Конфигурация
  │   ├─ di/              # Внедрение зависимостей
  │   └─ utils/           # Утилиты
  └─ main.dart            # Точка входа
```

###### Структура файла

1. Импорты (сгруппированные и отсортированные):
    * Dart импорты
    * Flutter импорты
    * Импорты пакетов
    * Импорты проекта (сначала `core`, затем `features`)
2. Объявление части (для `@freezed`):
    * `part '*.freezed.dart';`
    * `part '*.g.dart';`
3. Объявление интерфейса / `@freezed` класса / класса-композитора.
4. Поля класса (для композиторов - `final` ссылки на модели данных).
5. Конструкторы (фабричные, приватные).
6. Геттеры и сеттеры (если необходимы).
7. Методы класса (включая реализацию интерфейсов и методы `with...`).
8. Методы `toJson`/`fromJson` (для композиторов - ручная реализация).

###### Архитектурные паттерны

###### Разделение ответственности

* UI компоненты отвечают только за отображение и взаимодействие.
* Бизнес-логика находится в **сервисах** и **классах-композиторах**.
* Доступ к данным инкапсулирован в **репозиториях**.
* Чистые данные хранятся в **`@freezed` моделях данных**.

###### Композиция вместо наследования

* Предпочитайте композицию для построения сложных объектов (например, `OrderModelComposite` содержит `EntityCoreData`, `DocumentSpecificData` и т.д.).
* Используйте интерфейсы для определения контрактов и полиморфизма.

###### Иммутабельность

- **Предпочитайте неизменяемые структуры данных**:
  - Используйте `@freezed` для создания иммутабельных **моделей данных**.
  - В **классах-композиторах** все поля, содержащие модели данных, должны быть `final`.
  - Избегайте методов, которые модифицируют состояние объекта напрямую.

- **Корректная работа с коллекциями**:
  - В классах-композиторах коллекции (например, `itemsMap`) должны быть неизменяемыми (`Map.unmodifiable`, `List.unmodifiable`).
  - При обновлении коллекций создавайте новые неизменяемые коллекции.

- **Паттерны обновления состояния**:
  - В **классах-композиторах** реализуйте методы `with...` (например, `withStatus`, `withAddedItem`), которые возвращают *новый экземпляр* композитора с обновленными внутренними `@freezed` моделями данных (используя их `copyWith`).
  - Для объектов с вложенными структурами используйте глубокое копирование при необходимости.

- **Работа с freezed и codegen**:
  - Используйте `@freezed` для **моделей данных**.
  - Используйте сгенерированные методы `copyWith()` внутренних `@freezed` моделей при реализации методов `with...` в **классах-композиторах**.

- **Обработка ошибок**:
  - Всегда проверяйте на попытку модификации неизменяемых коллекций.
  - Включайте подробные сообщения об ошибках, указывающие на нарушения иммутабельности.

###### Инъекция зависимостей

Используйте get_it для управления зависимостями

###### Работа с ресурсами

###### Assets

Организуйте ресурсы по типам в директории assets/
Используйте snake_case для имён файлов ресурсов
Регистрируйте все ресурсы в pubspec.yaml

###### Строки

Используйте константы для строк вместо хардкода
Располагайте строки в файлах локализации для поддержки мультиязычности

###### Управление зависимостями

###### Версионирование пакетов

Указывайте конкретные версии в pubspec.yaml
Регулярно обновляйте зависимости
Ведите CHANGELOG для отслеживания изменений

###### Импорты

Используйте относительные импорты для файлов в том же пакете
Используйте абсолютные импорты для файлов из других пакетов
Группируйте и сортируйте импорты

###### Асинхронный код

###### Принципы работы с асинхронным кодом

Всегда используйте ключевые слова async/await для читаемости
Используйте FutureBuilder и StreamBuilder для работы с асинхронными данными в UI
Обрабатывайте все состояния загрузки и ошибки

###### Безопасное обновление UI после асинхронных операций

Всегда проверяйте mounted перед вызовом setState()
Используйте addPostFrameCallback для отложенных UI-операций
Сохраняйте ссылки на контекстные объекты перед асинхронными операциями

###### Тестирование

###### Паттерны для тестирования

Используйте паттерн AAA (Arrange-Act-Assert) для структурирования тестов
Применяйте принцип Given-When-Then для улучшения читаемости
Группируйте похожие тесты с помощью функции group()

###### Генерация моков

Используйте пакеты mockito или mocktail для создания моков
Предпочитайте инъекцию зависимостей для упрощения тестирования
Применяйте принцип "dependency inversion" для легкой подмены компонентов в тестах

###### Безопасность

###### Защита чувствительных данных

Не храните секреты (API-ключи, токены) в исходном коде
Используйте flutter_secure_storage для хранения чувствительных данных
Не отправляйте чувствительную информацию в логи

###### Валидация входных данных

Всегда проверяйте входящие данные, особенно от пользователя или внешних источников
Применяйте строгую типизацию и избегайте dynamic, где это возможно

###### Null Safety
В проекте строго соблюдается null safety. Все поля должны быть явно обозначены как nullable или non-nullable:

- Используйте тип с `?` для полей, которые могут быть null: `String?`, `int?`
- Для non-nullable полей с обязательными значениями используйте `required` в конструкторах
- При работе с nullable полями всегда используйте операторы `?.`, `??` и проверки типа `field?.isEmpty == true`
- Вместо условий `if (value == null)` предпочтительно использовать паттерн `value?.isEmpty == true`
- При передаче nullable значений в функции, требующие non-null, всегда предоставляйте значение по умолчанию

###### Производительность

###### Оптимизация списков

Используйте ListView.builder вместо ListView для длинных списков
Применяйте const конструкторы для неизменяемых виджетов
Используйте кэширование для дорогостоящих вычислений

###### Изображения и ресурсы

Оптимизируйте размеры изображений перед добавлением в проект
Используйте кэширование изображений с cached_network_image
Загружайте тяжелые ресурсы асинхронно и по мере необходимости

###### Логгирование

- **Всегда использовать пакет logger вместо print**:
  - Инициализируйте логгер на уровне компонента: `final _logger = Logger('ComponentName');`
  - Используйте соответствующие уровни логирования: `_logger.d()`, `_logger.i()`, `_logger.w()`, `_logger.e()`
  - Никогда не используйте функцию `print()` в коде проекта
  - При логировании ошибок всегда включайте трассировку стека: `_logger.e('Message', error, stackTrace)`
  - Используйте `logger.v()` для отладочной информации, которая не должна попадать в продакшен
  - При использовании `logger` используйте именнованное обращение
  Неправильно: 
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', e, stackTrace);
  ```
  Правильно:
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', error: e, stackTrace: stackTrace);
  ```

###### Управление объемом генерируемого кода

При работе с GitHub Copilot важно управлять объемом генерируемого кода для достижения оптимальных результатов. Ниже представлены рекомендации по эффективной генерации кода.

###### Предварительная оценка объема

- **Планируйте заранее**: Оцените приблизительный размер требуемого решения до генерации
- **Устанавливайте ограничения**: При работе с большими компонентами явно указывайте в запросе требования к объему (например, "сократите пример до основных компонентов")
- **Поэтапный подход**: Для сложных задач сначала запрашивайте структуру/каркас кода, затем детализируйте отдельные части

###### Структурированный подход к большим генерациям

- **Логическое разделение**: Разбивайте сложные запросы на модульные части

- **Итеративное улучшение**: Начинайте с простой реализации, постепенно добавляя функциональность
- **Фокусировка на секциях**: При работе с большими файлами концентрируйтесь на конкретных участках кода

###### Форматирование запросов для оптимальной генерации

**Типы запросов с префиксами**

| Префикс       | Назначение                                | Пример  |
|---------------|-------------------------------------------|---------|
| [КОНЦЕПТ]     | Общая архитектура без деталей реализации  | [КОНЦЕПТ] Опиши как реализовать интеграцию с API платежной системы  |
| [РЕАЛИЗАЦИЯ]  | Полный код с обработкой ошибок и комментариями | [РЕАЛИЗАЦИЯ] Создай клиент для API поставщика Autodoc, который будет наследоваться от BaseSupplierClient |
| [ОПТИМИЗАЦИЯ] | Улучшение существующего кода | [ОПТИМИЗАЦИЯ] Оптими код метода fetchData для снижения потребления памяти  |
| [СТРУКТУРА]   | Организация файлов и компонентов | [СТРУКТУРА] Предложи организацию файлов для модуля поставщиков |

**Комбинированные запросы**

[РЕАЛИЗАЦИЯ] Создай сервис для работы с текущими поставщиками
[КОНЦЕПТ] При этом учти возможность добавления новых поставщиков в будущем
Такой формат позволяет получить полную реализацию текущей функциональности и рекомендации по будущим расширениям.

###### Уровни детализации и поэтапная генерация

- **Явные указания**: Четко обозначайте требуемый уровень детализации в запросе
- **Поэтапный подход**: Используйте принцип "сначала что, потом как"
- **Постепенная детализация**: Для сложных классов запрашивайте генерацию основной структуры, затем отдельных методов

**Подсказка**: Добавляйте конкретные технические детали в запрос для получения более точных результатов генерации.

###### Иммутабельность

- **Предпочитайте неизменяемые структуры данных**:
  - Используйте `final` для всех полей, которые не должны изменяться после создания объекта
  - Применяйте `const` для создания константных объектов, когда это возможно
  - Избегайте методов, которые модифицируют состояние объекта

- **Корректная работа с коллекциями**:
  - Не модифицируйте существующие коллекции, создавайте новые на основе старых
  - Используйте `.unmodifiable` или `.from()..add()` для безопасного обновления
  - Применяйте шаблон копирования при изменении: `final newList = List<T>.from(oldList)..add(item)`

- **Паттерны обновления состояния**:
  - Используйте методы типа `copyWith()` для создания модифицированных копий объектов
  - Применяйте extension-методы для добавления операций, сохраняющих иммутабельность
  - Для объектов с вложенными структурами используйте глубокое копирование

- **Работа с freezed и codegen**:
  - При использовании библиотек кодогенерации, следуйте их рекомендациям по иммутабельности
  - Используйте сгенерированные методы `.copyWith()` вместо прямого изменения полей
  - Применяйте конструкторы фабрик для создания новых экземпляров объектов

- **Обработка ошибок**:
  - Всегда проверяйте на попытку модификации неизменяемых коллекций
  - Используйте защитное программирование при работе с внешними API
  - Включайте подробные сообщения об ошибках, указывающие на нарушения иммутабельности

###### Дополнительные рекомендации

###### Локализация

Все строки интерфейса должны поддерживать локализацию
Используйте пакеты flutter_localizations и intl

###### Доступность

Добавляйте значения для semanticsLabel и semanticsValue
Используйте достаточный контраст цветов
Обеспечивайте корректный порядок фокусировки

###### Жесты и анимации

Используйте стандартные жесты, понятные пользователям
Обеспечивайте визуальную обратную связь для жестов
Делайте анимации плавными, но не навязчивыми




---

<!-- Source: docs\modules\clients.md -->
## Модуль клиентов

> Модуль клиентов обеспечивает управление информацией о клиентах СТО, включая физические и юридические лица.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)

###### Назначение

Модуль клиентов решает следующие задачи:
- Учет физических и юридических лиц, являющихся клиентами СТО
- Хранение и управление контактными данными клиентов
- Связь клиентов с их автомобилями и заказ-нарядами
- Предоставление интерфейса для создания, редактирования и удаления клиентов

###### Архитектура

Модуль следует принципам чистой архитектуры и состоит из следующих уровней:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Пользовательский интерфейс | `ClientsScreen`, `ClientDialog` |
| Domain | Бизнес-логика | `ClientService`, `ClientModelComposite`, `IClientEntity` (если нужен специфичный интерфейс) |
| Data | Доступ к данным | `ClientsDao`, `ClientsItemsCompanion`, `ClientData` (`@freezed`) |


###### Основные компоненты

###### ClientService

Сервисный класс, обеспечивающий бизнес-логику работы с клиентами:

Функциональность: Преобразует данные между моделями БД (`ClientsItem`), моделями данных (`ClientData`, `EntityCoreData`) и бизнес-моделями (`ClientModelComposite`). Работает с интерфейсами (`IClientEntity`).
Ключевые методы:
- **getClients()**: Получение списка `ClientModelComposite`.
- **watchClients()**: Реактивное наблюдение за списком `ClientModelComposite`.
- **addClient(ClientModelComposite client)**: Добавление нового клиента.
- **updateClient(ClientModelComposite client)**: Обновление существующего клиента.
- **deleteClient(String clientUuid)**: Мягкое удаление клиента.
- **searchClientsByName()**: Поиск клиентов по имени или названию.

###### ClientsDao

DAO (Data Access Object) для прямой работы с таблицей клиентов в БД:

Функциональность: Предоставляет низкоуровневый доступ к данным таблицы
Ключевые методы:
- **getActiveClients()**: Получение неудаленных клиентов
- **watchActiveClients()**: Отслеживание изменений в таблице
- **insertClient()**: Добавление новой записи
- **updateClient()**: Обновление записи
- **softDeleteClient()**: Мягкое удаление (установка метки времени)
- **searchByName()**: Поиск по строке в имени клиента

###### Модели данных

###### ClientsItem (модель таблицы)

Представляет структуру таблицы клиентов в БД:

id: Первичный ключ (автоинкремент)
type: Тип клиента (строковое значение)
name: Имя/наименование клиента
contactInfo: Контактная информация
additionalInfo: Дополнительная информация (опционально)
deletedAt: Метка времени удаления для реализации мягкого удаления

###### Client (бизнес-модель)

Представляет клиента в бизнес-логике приложения:

id: Уникальный идентификатор
type: Тип клиента (перечисление ClientType)
name: Имя/наименование
contactInfo: Контактная информация
additionalInfo: Дополнительная информация (опционально)

###### ClientType (перечисление)

Определяет возможные типы клиентов:

physical: Физическое лицо
legal: Юридическое лицо
individualEntrepreneur: Индивидуальный предприниматель
other: Другой тип
Дополнено вспомогательными методами для работы с отображаемыми названиями и преобразованиями строк.

###### ClientData (`@freezed`, пример)

Модель данных, специфичная для клиента (если нужна)

###### ClientModelComposite (бизнес-модель)

Представляет клиента в бизнес-логике приложения. Реализует IEntity (или IClientEntity).

###### Основные операции

Отображение списка клиентов
Реализация: Использует StreamBuilder и watchClients() для реактивного обновления UI
Особенности: Обрабатывает различные состояния потока (загрузка, ошибка, пустой список)
UI: Отображает список с возможностью взаимодействия (редактирование, удаление)
Добавление/редактирование клиента
Реализация: Диалоговое окно с формой для ввода данных
Поля формы: Имя/название, тип клиента, контактная информация, дополнительная информация
Валидация: Проверка обязательных полей перед сохранением
Поведение: Адаптируется для режимов создания и редактирования

###### UI компоненты

###### ClientsScreen

Основной экран управления клиентами:

Функциональность: Отображение, поиск, добавление, редактирование, удаление клиентов
Особенности:
Использование StreamBuilder для реактивного UI
Поиск с дебаунсингом для оптимизации запросов
Адаптивный интерфейс для разных размеров экрана

###### ClientListItem

Виджет для отображения одного клиента в списке:

Функциональность: Отображает основную информацию о клиенте
Особенности:
Разные иконки для разных типов клиентов
Поддержка свайпа для удаления с подтверждением
Интерактивность для перехода к редактированию

###### DialogComponents

Элементы диалоговых окон для работы с данными клиентов:

ClientFormDialog: Форма с валидацией для создания и редактирования
ClientDeleteConfirmation: Диалог подтверждения удаления
ClientTypeSelector: Выбор типа клиента с визуальным форматированием

---

<!-- Source: docs\modules\suppliers\overview.md -->
## Модуль поставщиков запчастей

> Этот модуль отвечает за интеграцию с API поставщиков запчастей для получения информации о ценах и сроках доставки.

###### Содержание

- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Ключевые компоненты](#ключевые-компоненты)
- [Режимы работы](#режимы-работы)
- [Интеграция с прокси-сервером](#интеграция-с-прокси-сервером)

###### Назначение

Модуль поставщиков решает следующие задачи:

- Получение актуальных цен на запчасти от разных поставщиков
- Поиск запчастей по артикулу у разных поставщиков
- Получение информации о сроках доставки
- Агрегация данных от разных поставщиков в единый формат

###### Архитектура

Модуль построен на принципах **Чистой архитектуры** с четким разделением на уровни:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Отображение данных | `SupplierScreen`, `PriceListWidget` |
| Domain | Бизнес-логика | `SuppliersService`, `SupplierRepository` |
| Data | Источники данных | `SupplierApiClient`, `LocalCacheManager` |

###### Диаграмма компонентов

###### Диаграмма компонентов

```
┌───────────────┐       ┌──────────────────┐      ┌─────────────────┐
│ ApiConnection │       │                  │      │                 │
│     Mode      │────>  │ ApiClientManager │────> │SupplierApiClient│
└───────────────┘       └──────────────────┘      └─────────────────┘
                                │                          │
                                │                          │
                                ▼                          │
                        ┌───────────────┐                  │
                        │ LocalStorage  │ <────────────────┘
                        │   Manager     │
                        └───────────────┘
```

###### Ключевые компоненты

###### SupplierApiClient

Базовый интерфейс для всех клиентов API поставщиков:

```dart
abstract class SupplierApiClient {
  Future<List<PartPriceModel>> getPricesByArticle(String article);
  Future<List<PartInfoModel>> searchPartsByName(String name);
  Future<PartDetailModel?> getPartDetails(String articleNumber);
}
```

###### SuppliersService

Сервис для работы с API поставщиков:

```dart
class SuppliersService {
  final Map<String, SupplierApiClient> _clients;

  SuppliersService(this._clients);

  Future<Map<String, List<PartPriceModel>>> getAllPricesByArticle(String article) async {
    // Реализация
  }
  
  Future<List<PartPriceModel>> getBestPricesByArticle(String article) async {
    // Реализация
  }
}
```

###### Режимы работы

Модуль поддерживает 3 режима работы с API поставщиков:

|   Режим   |   Описание                    |	Применение  |
|-----------|-------------------------------|---------------|
| Direct    | Прямое подключение к API      | Автономная работа, разработка, тестирование, локальная разработка    |
| Proxy     | Через прокси-сервер           | Продакшен, ограничения безопасности, платные API    |
|   Hybrid |	Автоматическое переключение |   Повышенная отказоустойчивость           |

**Подробнее о каждом режиме:**

    *   Прямое подключение к API
    *   Использование прокси-сервера
    *   Автоматическое переключение между режимами

###### Интеграция с прокси-сервером

Для перехода на работу через прокси-сервер необходима минимальная модификация кода клиента:

    1. Настройка режима работы в AppConfig
    2. Использование ApiClientManager для создания подходящих клиентов API
    3. Настройка адреса прокси-сервера

Подробнее см. [Реализация прокси-сервера](#proxy_server).


---

<!-- Source: docs\architecture\database_schema.md -->
## Структура БД и маппинги

> В этом документе описана структура базы данных приложения Part Catalog, включая схему таблиц, отношения между ними и механизмы маппинга данных.

###### Содержание
- [Обзор](#обзор)
- [Технология и подход](#технология-и-подход)
- [Структура таблиц](#структура-таблиц)
- [Отношения и связи](#отношения-и-связи)
- [Маппинг моделей](#маппинг-моделей)
- [Миграции](#миграции)
- [Навигация](#навигация)
- [Оптимизация и индексы](#оптимизация-и-индексы)

###### Обзор

База данных Part Catalog реализована с использованием SQLite через ORM-библиотеку Drift. Она обеспечивает локальное хранение данных о клиентах, автомобилях, заказ-нарядах и связанных с ними сущностях. Дополнительно реализована синхронизация с облачной базой Supabase для мультиустройственных сценариев.

###### Технология и подход

###### Используемые технологии:

ORM-система: Drift (SQLite wrapper для Dart/Flutter)
Базовая БД: SQLite
Облачная синхронизация: Supabase (PostgreSQL)

###### Ключевые особенности:

Мягкое удаление: Записи помечаются как удаленные через поле deletedAt вместо физического удаления
Реактивные запросы: Использование стримов для наблюдения за изменениями данных
Кодогенерация: Автоматическая генерация кода для взаимодействия с БД
Двухуровневая архитектура моделей: Разделение на модели таблиц и бизнес-модели

###### Структура таблиц

| Таблица         | Описание                                                                 |
|------------------|--------------------------------------------------------------------------| 
|------------------|--------------------------------------------------------------------------|
| ClientsItems     | Информация о клиентах, включая имя, телефон и адрес                     |
| CarsItems        | Данные об автомобилях клиентов, включая марку, модель и год выпуска      |
| OrdersItems      | Заказ-наряды, связывающие клиентов и автомобили с деталями заказа        |
| OrderPartsItems  | Таблица для хранения запчастей, связанных с заказ-нарядами.                   |
| OrderServicesItems | Услуги, связанные с заказ-нарядами, включая описание и стоимость       |
| PartsItems       | Информация о деталях, включая название, артикул и цену                   |
| SuppliersItems   | Поставщики деталей, включая название и контактную информацию             |
| OrderStatusItems | Статусы заказов, включая "в работе", "завершен" и "отменен"             |
| PartsCategoriesItems | Категории деталей, включая название и описание                          |
| PartsSuppliersItems  | Связь между деталями и поставщиками, включая цену и условия поставки    |
| UsersItems       | Пользователи системы, включая имя, email и пароль                        |
| RolesItems       | Роли пользователей, включая "администратор", "менеджер" и "клиент"      |
| PermissionsItems | Права доступа, связанные с ролями пользователей                         |
| AuditLogsItems   | Логи аудита, включая действия пользователей и время выполнения           |
| SettingsItems    | Настройки приложения, включая язык, тему и уведомления                  |
| AppInfoItems     | Служебная таблица для метаданных приложения                              |
|------------------|--------------------------------------------------------------------------|

###### Отношения и связи

```
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│   ClientsItems  │       │    CarsItems    │       │   OrdersItems   │
├─────────────────┤       ├─────────────────┤       ├─────────────────┤
│ id              │◄──┐   │ id              │◄──┐   │ id              │
│ type            │   │   │ clientId        │───┘   │ clientId        │───┐
│ name            │   └───│ make            │       │ carId           │───┘
│ contactInfo     │       │ model           │       │ orderNumber     │
│ additionalInfo  │       │ year            │       │ createdAt       │
│ deletedAt       │       │ vin             │       │ scheduledDate   │
└─────────────────┘       │ licensePlate    │       │ completedAt     │
                          │ additionalInfo  │       │ status          │
                          │ deletedAt       │       │ description     │
                          └─────────────────┘       │ totalAmount     │
                                                    │ deletedAt       │
                                                    └─────────┬───────┘
                                                              │
                          ┌─────────────────┐       ┌─────────┴───────┐
                          │OrderServicesItems│       │ OrderPartsItems │
                          ├─────────────────┤       ├─────────────────┤
                          │ id              │       │ id              │
                          │ orderId         │───┐   │ orderId         │───┐
                          │ name            │   └───│ partNumber      │   │
                          │ description     │       │ name            │   │
                          │ price           │       │ brand           │   │
                          │ duration        │       │ quantity        │   │
                          │ performedBy     │       │ price           │   │
                          │ isCompleted     │       │ supplierName    │   │
                          └─────────────────┘       │ deliveryDays    │   │
                                                    │ isOrdered       │   │
                                                    │ isReceived      │   │
                                                    └─────────────────┘   │
                                                                          │
```

###### Описание связей:

ClientsItems → CarsItems: Один-ко-многим (один клиент имеет много автомобилей)
ClientsItems → OrdersItems: Один-ко-многим (один клиент имеет много заказ-нарядов)
CarsItems → OrdersItems: Один-ко-многим (один автомобиль имеет много заказ-нарядов)
OrdersItems → OrderPartsItems: Один-ко-многим (один заказ-наряд содержит много запчастей)
OrdersItems → OrderServicesItems: Один-ко-многим (один заказ-наряд содержит много работ)
PartsItems → PartsSuppliersItems: Один-ко-многим (одна запчасть может иметь много поставщиков)
PartsCategoriesItems → PartsItems: Один-ко-многим (одна категория может содержать много запчастей)
SuppliersItems → PartsSuppliersItems: Один-ко-многим (один поставщик может предлагать много запчастей)
UsersItems → RolesItems: Один-ко-многим (один пользователь может иметь много ролей)
RolesItems → PermissionsItems: Один-ко-многим (одна роль может иметь много прав доступа)
AuditLogsItems → UsersItems: Один-ко-многим (один пользователь может иметь много логов аудита)
SettingsItems → AppInfoItems: Один-ко-многим (одна настройка может относиться к многим метаданным приложения)

###### Маппинг моделей

###### Трехуровневая архитектура моделей:

1. Модели таблиц (Items) - Представляют структуру таблиц в БД (ClientsItem, OrdersItem). Генерируются Drift.
2. Модели данных (@freezed, Data) - Чистые иммутабельные структуры для хранения данных (EntityCoreData, OrderSpecificData, ClientData). Используются для передачи данных между слоями Infrastructure и Domain.
3. Бизнес-модели (Композиторы, Composite) - Реализуют интерфейсы (IEntity, IDocumentEntity), содержат бизнес-логику и композируют модели данных (OrderModelComposite, ClientModelComposite). Используются в слоях Domain и Application.

###### Маппинг между моделями:

**Data Layer (DAO/Repository) <-> Domain Layer (Service):**

**Из БД в Domain:**
1. DAO получает данные из БД в виде моделей таблиц (ClientsItem).
2. Репозиторий или Сервис маппит модели таблиц в соответствующие модели данных (@freezed) (EntityCoreData, ClientData).
3. Сервис использует фабричные конструкторы классов-композиторов (ClientModelComposite.create или ClientModelComposite.fromData) для создания бизнес-моделей из моделей данных.
**Из Domain в БД:**
1. Сервис передает класс-композитор (ClientModelComposite) в Репозиторий.
2. Репозиторий извлекает внутренние модели данных (@freezed) из композитора.
3. Репозиторий или DAO маппит модели данных в Companion модели таблиц (ClientsItemsCompanion) для сохранения в БД.

###### Миграции

###### Схема миграций
    
Для управления изменениями схемы базы данных используется система миграций Drift

###### Автоматическая валидация схемы

Для обеспечения согласованности схемы БД реализована автоматическая валидация и обновление схемы при старте приложения

###### Оптимизация и индексы

###### Индексирование

В схеме базы данных определены следующие индексы для оптимизации запросов:

ClientsItems: индекс по имени и типу клиента для быстрого поиска
CarsItems: индексы по clientId, VIN и госномеру для быстрого поиска
OrdersItems: индексы по clientId, carId, статусу и дате создания
OrderPartsItems: индексы по orderId и артикулу запчасти
OrderServicesItems: индекс по orderId

###### Оптимизированные запросы

Для улучшения производительности используются следующие подходы:
1. Использование индексов в запросах
2. Комплексные JOIN-запросы вместо множества простых
3. Использование транзакций для серии операций
4. Пакетная обработка данных для уменьшения количества запросов к БД
5. Кэширование часто запрашиваемых данных
6. Использование стримов для реактивного обновления данных
7. Параллельная обработка запросов для повышения производительности
8. Использование асинхронных операций для улучшения отзывчивости интерфейса
9. Регулярная оптимизация и анализ производительности запросов
10. Мониторинг и логирование медленных запросов для их последующей оптимизации
11. Использование EXPLAIN для анализа плана выполнения запросов
12. Мягкое удаление вместо физического удаления записей
13. Использование триггеров для автоматизации задач
14. Каскадное удаление связанных записей на уровне бизнес-логики
15. Регулярное резервное копирование и восстановление данных

---

<!-- Source: docs\guides\testing.md -->
## Стратегия и паттерны тестирования

> Этот документ описывает подходы к тестированию в проекте Part Catalog, включая стратегию, инструменты и рекомендуемые паттерны.

###### Содержание
- [Обзор стратегии тестирования](#обзор-стратегии-тестирования)
- [Уровни тестирования](#уровни-тестирования)
- [Unit-тестирование](#unit-тестирование)
- [Widget-тестирование](#widget-тестирование)
- [Интеграционное тестирование](#интеграционное-тестирование)
- [Моки и стабы](#моки-и-стабы)
- [Структура тестового проекта](#структура-тестового-проекта)
- [Непрерывная интеграция](#непрерывная-интеграция)
- [Рекомендации и лучшие практики](#рекомендации-и-лучшие-практики)

###### Обзор стратегии тестирования

Проект Part Catalog использует многоуровневый подход к тестированию, следуя принципу пирамиды тестирования:

```
▲  Меньше
│
│    E2E тесты
│    Интеграционные тесты
│    Widget тесты
│    Unit тесты
│
▼  Больше
```

Этот подход обеспечивает:
* Раннее обнаружение ошибок
* Эффективную отладку благодаря локализации проблем
* Снижение стоимости исправления ошибок
* Быстрое выполнение тестовых наборов

###### Уровни тестирования

###### 1. Unit-тестирование

Фокус: Отдельные компоненты и функции
Объем: ~70% всех тестов
Инструменты: flutter_test, mockito, mocktail
Тестирование Сервисов: Мокаются Репозитории/DAO. Проверяется правильность вызовов методов репозиториев и корректность создания/обновления бизнес-моделей (композиторов).
Тестирование Классов-композиторов: Проверяется корректность реализации интерфейсов, правильность работы геттеров и методов with....
Тестирование Репозиториев/DAO: Мокается база данных или используются in-memory реализации. Проверяется правильность запросов и маппинга между моделями таблиц и моделями данных (@freezed).

###### 2. Widget-тестирование

Фокус: UI-компоненты и взаимодействие пользователя
Объем: ~20% всех тестов
Инструменты: flutter_test с виджет-тестами

###### 3. Интеграционное тестирование

Фокус: Взаимодействие между различными частями приложения
Объем: ~10% всех тестов
Инструменты: integration_test

###### 4. E2E-тестирование

Фокус: Полноценные пользовательские сценарии
Объем: Ограниченное количество ключевых сценариев
Инструменты: flutter_driver

###### Unit-тестирование

###### Подход

Для модульного тестирования используется метод AAA (Arrange-Act-Assert):

1. Arrange: Подготовка данных, создание моков и настройка тестового окружения
2. Act: Вызов тестируемой функциональности
3. Assert: Проверка результатов и побочных эффектов

###### Инструменты

flutter_test: Основной фреймворк для тестирования Dart/Flutter
mockito/mocktail: Библиотеки для создания моков
fake_async: Для тестирования асинхронного кода с виртуальным временем

###### Тестирование асинхронного кода

Для асинхронного кода используем:

* async/await в тестах с асинхронными операциями
* fakeAsync для тестирования кода с таймерами
* pumpAndSettle для ожидания завершения анимаций в виджет-тестах

###### Widget-тестирование

###### Подход

Widget-тесты проверяют:

* Корректное отображение UI-компонентов
* Обработку пользовательских взаимодействий
* Правильное отображение данных
* Обработку различных состояний (загрузка, ошибка, пустые данные)

###### Инструменты

* WidgetTester: API для взаимодействия с виджетами
* Finder: Поиск виджетов в дереве
* GoldenFileComparator: Сравнение с эталонными снимками виджетов

###### Golden-тестирование

Golden-тесты создают скриншоты виджетов для визуального сравнения

###### Интеграционное тестирование

###### Подход

Интеграционные тесты проверяют взаимодействие между различными частями приложения:

* Интеграцию между экранами
* Потоки данных между слоями
* Взаимодействие с внешними зависимостями (при необходимости с их моками)

###### Инструменты

integration_test: Фреймворк для интеграционного тестирования
flutter_driver: Управление приложением для E2E тестов

###### Моки и стабы

###### Определения

* Мок (Mock): Имитирует объект и отслеживает вызовы его методов
* Стаб (Stub): Возвращает предопределенный результат без отслеживания
* Фейк (Fake): Предоставляет упрощенную реализацию функциональности
* Мокайте интерфейсы (IEntity, IDocumentEntity, IRepository) вместо конкретных реализаций.
* Используйте фейковые реализации @freezed моделей данных для тестов.

###### Создание моков с Mocktail
###### Создание моков с Mocktail
###### Ручные моки

###### Структура тестового проекта

###### Организация тестов

```
test/
  ├─ unit/                       # Модульные тесты
  │   ├─ features/
  │   │   ├─ clients/
  │   │   │   ├─ services/
  │   │   │   │   └─ client_service_test.dart
  │   │   │   └─ repositories/
  │   │   │       └─ client_repository_test.dart
  │   │   └─ vehicles/
  │   └─ core/
  │       ├─ utils/
  │       └─ database/
  │
  ├─ widget/                     # Тесты виджетов
  │   ├─ features/
  │   │   ├─ clients/
  │   │   │   └─ screens/
  │   │   │       └─ client_list_screen_test.dart
  │   │   └─ vehicles/
  │   └─ shared/
  │       └─ widgets/
  │
  ├─ integration/                # Интеграционные тесты
  │   ├─ clients_flow_test.dart
  │   └─ vehicles_flow_test.dart
  │
  └─ mocks/                      # Общие моки для тестов
      ├─ mock_client_repository.dart
      └─ mock_service_locator.dart

integration_test/                # Тесты для интеграции с устройствами
  ├─ app_test.dart
  └─ driver.dart
```

###### Общие моки и тестовые данные

###### Непрерывная интеграция

###### GitHub Actions

###### Автоматизация тестов

Pre-commit хуки: flutter analyze и flutter test перед коммитом
CI/CD: Автоматический запуск тестов при пуше и пулл-реквестах
Отчеты о покрытии: Интеграция с сервисами анализа кода (Codecov, SonarQube)

###### Рекомендации и лучшие практики

###### Основные рекомендации

Изоляция тестов: Каждый тест должен быть независимым от других
Детерминированность: Тесты должны давать одинаковый результат при многократном запуске
Быстрое выполнение: Модульные тесты должны выполняться быстро
Тестирование граничных условий: Проверяйте крайние случаи и исключения
Поддержание тестов в актуальном состоянии: Обновляйте тесты при изменении кода

###### Паттерн AAA (Arrange-Act-Assert)

Структурируйте тесты по паттерну AAA для повышения читаемости

###### BDD стиль с описательными именами тестов

###### Использование фикстур и setUp/tearDown

###### Проверка покрытия кода тестами

Запуск тестов с генерацией отчета о покрытии
Конвертация отчета в HTML для удобного просмотра (требуется lcov)

---

<!-- Source: docs\modules\vehicles.md -->
## Модуль автомобилей

> Модуль автомобилей обеспечивает управление информацией об автомобилях клиентов СТО, включая их характеристики и связь с владельцами.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)
- [Адаптивный интерфейс](#адаптивный-интерфейс)
- [Типичные сценарии использования](#типичные-сценарии-использования)

###### Назначение

Модуль автомобилей решает следующие задачи:
- Учет автомобилей клиентов СТО
- Хранение технических характеристик автомобилей (марка, модель, VIN-код)
- Связь автомобилей с их владельцами (клиентами)
- Предоставление интерфейса для создания, редактирования и удаления автомобилей

###### Архитектура

Модуль следует принципам чистой архитектуры и использует архитектуру "Композиция + Интерфейсы + `@freezed`". Он состоит из следующих уровней:

|   Уровень       | Назначение                    | Компоненты                    |
|-----------------|-------------------------------|-------------------------------|
|   Presentation  | Пользовательский интерфейс    | `CarsScreen`, `CarFormDialog`, `CarDetailsScreen` |
|   Domain        | Бизнес-логика                 | `CarService`, `CarModelComposite`, `ICarEntity` (если нужен специфичный интерфейс) |
|   Data          | Доступ к данным               | `CarsDao`, `CarsItemsCompanion`, `EntityCoreData`, `CarSpecificData` (`@freezed` модели) |

###### Основные компоненты

###### CarService

Сервисный класс для работы с автомобилями. Основные методы:

Функциональность: Управляет бизнес-логикой автомобилей, работает с бизнес-моделями (`CarModelComposite`) и интерфейсами (`IEntity` или `ICarEntity`). Координирует взаимодействие с DAO для получения/сохранения данных, преобразуя `@freezed` модели данных (`EntityCoreData`, `CarSpecificData`) в бизнес-модели (`CarModelComposite`) и обратно.
Ключевые методы:
- **getCars()**: Получение списка `CarModelComposite`.
- **watchCarsWithOwners()**: Реактивное наблюдение за списком `CarWithOwnerModel` (содержащим `CarModelComposite`).
- **getCarById(String carUuid)**: Получение `CarModelComposite` по UUID.
- **addCar(CarModelComposite car)**: Добавление нового автомобиля.
- **updateCar(CarModelComposite car)**: Обновление данных автомобиля.
- **deleteCar(String carUuid)**: Мягкое удаление автомобиля.
- **getCarsByClientId(String clientUuid)**: Получение списка `CarModelComposite` для конкретного клиента.

###### CarsDao

Data Access Object для прямого взаимодействия с таблицей `CarsItems` в базе данных:

Функциональность: Предоставляет низкоуровневый доступ к данным таблицы. Получает данные в виде моделей таблиц (`CarsItem`) и маппит их в соответствующие `@freezed` модели данных (`EntityCoreData`, `CarSpecificData`) для передачи в сервисный слой. При сохранении принимает `Companion` объекты, созданные из `@freezed` моделей данных.
Ключевые методы:
- **getActiveCars()**: Получение данных для активных автомобилей.
- **watchCarsWithOwners()**: Реактивное наблюдение за данными автомобилей с информацией о владельцах.
- **getCarById(int id)**: Получение данных автомобиля по ID таблицы.
- **insertCar(CarsItemsCompanion car)**: Вставка нового автомобиля (принимает `Companion`).
- **updateCar(CarsItemsCompanion car)**: Обновление информации об автомобиле (принимает `Companion`).
- **softDeleteCar(int carId)**: Мягкое удаление автомобиля.
- **softDeleteCarsByClientId(int clientId)**: Мягкое удаление всех автомобилей клиента.

###### Модели данных

###### Модели таблиц (Drift)

- `CarsItems`: Структура таблицы автомобилей в БД. Содержит все поля, включая `clientId`, `make`, `model`, `vin` и т.д.

###### Модели данных (`@freezed`)

Чистые, иммутабельные структуры для хранения данных, используемые для передачи между слоями Data и Domain:
- `EntityCoreData`: Базовые данные сущности (uuid, code, displayName...).
- `CarSpecificData`: Специфичные данные автомобиля (clientId, make, model, year, vin, licensePlate, additionalInfo).

###### Бизнес-модели (Композиторы)

Классы, реализующие интерфейсы (`IEntity` или `ICarEntity`) и инкапсулирующие `@freezed` модели данных. Представляют автомобиль в бизнес-логике:
- `CarModelComposite`: Представляет автомобиль. Содержит `EntityCoreData` и `CarSpecificData`. Реализует `IEntity` (или `ICarEntity`). Предоставляет геттеры для всех полей и методы `with...` для иммутабельного обновления.

###### Модели представления (View Models)

- `CarWithOwnerModel`: Объединяет бизнес-модель автомобиля (`CarModelComposite`) с информацией о владельце (например, `ownerName`, `ownerType`) для удобного отображения в UI.

###### Основные операции

###### Отображение списка автомобилей с владельцами

Реализуется через реактивные потоки данных (`watchCarsWithOwners` в `CarService`), которые возвращают `Stream<List<CarWithOwnerModel>>`. UI подписывается на этот поток и автоматически обновляется при изменениях в данных автомобилей или их владельцев.

###### Добавление/редактирование автомобиля

Процесс включает:
- Выбор клиента (получение `ClientModelComposite`).
- Ввод характеристик автомобиля в UI.
- Создание или обновление экземпляра `CarModelComposite` через его фабричный конструктор или методы `with...`.
- Вызов `addCar` или `updateCar` в `CarService`, который выполняет маппинг в `@freezed` модели и передает их в DAO для сохранения.
- Валидация данных (обязательные поля, уникальность VIN) выполняется на уровне сервиса или UI.

###### Связь с другими модулями

- **Клиенты:** Каждый `CarModelComposite` связан с `ClientModelComposite` через `clientId` (хранится в `CarSpecificData`).
- **Заказ-наряды:** `CarModelComposite` используется при создании `OrderModelComposite` для указания объекта ремонта.
- **Каталог запчастей:** `CarModelComposite` (особенно VIN) может использоваться для поиска запчастей в модуле каталогов.

###### UI компоненты

###### CarsScreen

Основной экран управления автомобилями:
- Отображает список `CarWithOwnerModel`, полученный от `CarService`.
- Предоставляет функции поиска и фильтрации.
- Инициирует создание нового автомобиля.

###### CarFormDialog

Диалог или экран для добавления/редактирования `CarModelComposite`:
- Позволяет выбрать клиента (`ClientModelComposite`).
- Содержит поля для ввода характеристик автомобиля.
- Взаимодействует с `CarService` для сохранения данных.

###### CarDetailsScreen

Экран детальной информации об автомобиле (`CarModelComposite`):
- Отображает полную информацию о характеристиках и владельце.
- Может отображать связанную информацию, например, историю заказ-нарядов (`OrderModelComposite`), полученную через соответствующие сервисы.

###### Адаптивный интерфейс

Интерфейс модуля адаптируется для разных платформ:
- **Мобильные устройства:** Списки и отдельные экраны деталей.
- **Десктопные платформы:** Табличное представление, возможно, с редактированием в боковой панели или модальных окнах.
- **Планшеты:** Комбинированный интерфейс (master-detail).

###### Типичные сценарии использования

1.  **Регистрация нового автомобиля клиента:** Пользователь находит клиента, открывает форму добавления автомобиля, вводит данные, сохраняет. `CarService` создает `CarModelComposite` и сохраняет его через DAO.
2.  **Поиск автомобиля по VIN или госномеру:** Пользователь вводит данные в поле поиска на `CarsScreen`. `CarService` выполняет поиск по соответствующим полям `CarModelComposite` (через DAO).
3.  **Привязка автомобиля к новому владельцу:** Пользователь редактирует `CarModelComposite`, изменяя `clientId`. `CarService` обновляет данные через DAO.
4.  **Просмотр истории заказ-нарядов:** На `CarDetailsScreen` запрашивается список `OrderModelComposite` для данного `CarModelComposite` через `OrderService`.

---

<!-- Source: docs\architecture\api_integration.md -->
## Интеграция с внешними API

> Документ описывает архитектуру и принципы интеграции с внешними API поставщиков запчастей в приложении Part Catalog.

###### Содержание
- [Обзор](#обзор)
- [Архитектура API-интеграций](#архитектура-api-интеграций)
- [Режимы подключения](#режимы-подключения)
- [Основные компоненты](#основные-компоненты)
- [Обработка ошибок](#обработка-ошибок)
- [Оптимизация производительности](#оптимизация-производительности)
- [Безопасность](#безопасность)
- [Мониторинг и логирование](#мониторинг-и-логирование)

###### Обзор

Part Catalog взаимодействует с двумя типами внешних API:

1. API каталогов запчастей - для поиска запчастей по VIN-коду и артикулу
2. API поставщиков запчастей - для получения информации о ценах и сроках поставки

Взаимодействие с этими API реализовано через слой абстракции, который позволяет:

* Унифицировать доступ к разным API
* Изолировать бизнес-логику от деталей реализации API
* Обеспечить гибкое переключение между режимами работы

###### Архитектура API-интеграций

###### Общая схема

```mermaid
┌─────────────────┐     ┌───────────────┐     ┌────────────────────┐
│                 │     │               │     │                    │
│  UI Components  │───▶│  API Services │────▶│  API Clients       │
│                 │     │               │     │                    │
└─────────────────┘     └───────────────┘     └────────────┬───────┘
                                                           │
                                                           ▼
                                                 ┌────────────────────┐
                                                 │                    │
                                                 │  External APIs     │
                                                 │                    │
                                                 └────────────────────┘
```

###### Разделение ответственности

UI Components - отображение данных и взаимодействие с пользователем
API Services - бизнес-логика, обработка данных, агрегация результатов
API Clients - низкоуровневая работа с API, сетевые запросы, сериализация/десериализация
External APIs - внешние системы, с которыми взаимодействует приложение

###### Режимы подключения

Приложение поддерживает три режима работы с API поставщиков:

Режим	Описание	Применение
Direct	Прямое подключение к API	Разработка, тестирование, автономная работа
Proxy	Через прокси-сервер	Продакшн, корпоративные развертывания
Hybrid	Автоматическое переключение	Повышенная отказоустойчивость

###### Прямое подключение (Direct)

В этом режиме приложение напрямую обращается к API каждого поставщика:

```
┌────────────────┐     ┌──────────────┐     ┌────────────────┐
│                │     │              │     │                │
│  Flutter App   │────▶│ API Client 1 │────▶│  Provider 1    │
│                │     │              │     │                │
└────────────────┘     └──────────────┘     └────────────────┘
         │                                         
         │             ┌──────────────┐     ┌────────────────┐
         │             │              │     │                │
         └────────────▶│ API Client 2 │────▶│  Provider 2    │
                       │              │     │                │
                       └──────────────┘     └────────────────┘
```

**Преимущества:**

* Простота реализации
* Отсутствие дополнительных задержек
* Независимость от дополнительной инфраструктуры

**Ограничения:**

* API-ключи хранятся на клиенте
* Каждое устройство использует собственную квоту запросов
* Сложности с единым мониторингом

###### Через прокси-сервер (Proxy)

В этом режиме запросы проходят через промежуточный сервер:

```
┌────────────────┐     ┌─────────────┐     ┌────────────────┐
│                │     │             │     │                │
│  Flutter App   │────▶│ Proxy Server│────▶│  Provider 1    │
│                │     │             │     │                │
└────────────────┘     └─────────────┘     └────────────────┘
                              │                    
                              │            ┌────────────────┐
                              │            │                │
                              └───────────▶│  Provider 2    │
                                           │                │
                                           └────────────────┘
```

**Преимущества:**

* Безопасное хранение API-ключей на сервере
* Централизованный мониторинг и кэширование
* Оптимизация расхода квот запросов
* Унификация ответов разных API

**Ограничения:**

* Необходимость поддержки дополнительного сервера
* Дополнительная задержка при запросах
* Зависимость от доступности прокси-сервера

###### Гибридный режим (Hybrid)

Комбинирует преимущества обоих подходов с автоматическим переключением:

```
┌────────────────┐     ┌─────────────┐     ┌────────────────┐
│                │────▶│             │────▶│                │
│                │     │ Proxy Server│     │  Provider 1    │
│                │     │             │     │                │
│  Flutter App   │     └─────────────┘     └────────────────┘
│                │                                
│                │     ┌─────────────┐     ┌────────────────┐
│                │────▶│             │────▶│                │
└────────────────┘     │Direct Client│     │  Provider 2    │
                       │             │     │                │
                       └─────────────┘     └────────────────┘
```

**Преимущества:**

* Повышенная отказоустойчивость
* Автоматическое переключение при проблемах
* Сочетает преимущества обоих подходов

**Ограничения:**

* Повышенная сложность реализации
* Необходимость поддержки обоих режимов
* Сложности с отладкой и тестированием

###### Основные компоненты

###### ApiClientPartsCatalogs

Централизованный клиент для работы с API каталогов запчастей

###### SupplierApiClient

Базовый интерфейс для всех клиентов API поставщиков запчастей

###### SuppliersService

Сервис-агрегатор для работы со всеми поставщиками

###### ApiClientManager

Фабрика для создания API-клиентов с учетом режима работы

###### Обработка ошибок

###### Иерархия исключений

```dart
/// Базовое исключение для всех API-ошибок
abstract class ApiException implements Exception {
  final String message;
  final dynamic cause;
  
  const ApiException(this.message, {this.cause});
}

/// Исключение при ошибках сети
class NetworkException extends ApiException {
  final int? statusCode;
  
  NetworkException(
    super.message, {
    this.statusCode,
    super.cause,
  });
}

/// Исключение при ошибках в ответе API
class ApiResponseException extends ApiException {
  final String? errorCode;
  
  ApiResponseException(
    super.message, {
    this.errorCode,
    super.cause,
  });
}

/// Исключение при ошибках конфигурации
class ConfigurationException extends ApiException {
  ConfigurationException(super.message, {super.cause});
}
```

###### Стратегия обработки ошибок

1. Локальная обработка - специфичные для поставщика ошибки обрабатываются в API-клиенте
2. Преобразование - внешние ошибки преобразуются в унифицированные исключения приложения
3. Каскадная обработка - ошибки проходят вверх по стеку вызовов до соответствующего обработчика

###### Оптимизация производительности

###### Кэширование

Для снижения нагрузки на API и улучшения отзывчивости приложения реализовано многоуровневое кэширование:

1. Кратковременное кэширование - в памяти для частых запросов в рамках сессии
2. Долговременное кэширование - локальное хранение результатов запросов
3. Серверное кэширование - при использовании прокси-сервера

###### Дебаунсинг и троттлинг

Для предотвращения избыточных запросов при часто обновляемых данных

###### Параллельные запросы

Для ускорения получения данных от нескольких поставщиков используются параллельные запросы

###### Безопасность

###### Защита API-ключей

В режиме direct: API-ключи хранятся в зашифрованном виде с использованием flutter_secure_storage
В режиме proxy: API-ключи хранятся только на сервере, клиент использует JWT-токены

###### Защита передаваемых данных

Использование HTTPS для всех запросов
Минимизация передаваемых персональных данных
Валидация всех входящих данных от API

###### Мониторинг и логирование

###### Системное логирование

###### Метрики и аналитика

* Время ответа API
* Количество запросов по типам и поставщикам
* Частота ошибок и их типы
* Объем передаваемых данных

###### Мониторинг доступности

Автоматическая проверка доступности API для раннего обнаружения проблем

---

<!-- Source: docs\guides\error_handling.md -->
## Стратегия обработки ошибок

> В этом документе описан подход к обработке ошибок в приложении Part Catalog, включая иерархию исключений, паттерны обработки ошибок и лучшие практики.

###### Содержание
- [Принципы обработки ошибок](#принципы-обработки-ошибок)
- [Иерархия исключений](#иерархия-исключений)
- [Обработка ошибок в разных слоях](#обработка-ошибок-в-разных-слоях)
- [Асинхронная обработка ошибок](#асинхронная-обработка-ошибок)
- [Отображение ошибок в UI](#отображение-ошибок-в-ui)
- [Логирование ошибок](#логирование-ошибок)
- [Мониторинг и аналитика](#мониторинг-и-аналитика)

###### Принципы обработки ошибок

При разработке Part Catalog мы придерживаемся следующих принципов обработки ошибок:

1. **Прозрачность** - ошибки должны быть понятны как для разработчиков, так и для пользователей
2. **Локализация** - обработка ошибок должна происходить на соответствующем уровне абстракции
3. **Информативность** - ошибки должны содержать достаточно информации для диагностики и решения проблемы
3. **Деградация с сохранением функциональности** - при возникновении ошибок система должна продолжать работу, если это возможно

###### Иерархия исключений

В проекте используется иерархия исключений, отражающая разные типы ошибок:

1. Базовый класс для всех исключений приложения
2. Ошибки, связанные с базой данных
3. Ошибки при сетевых операциях
4. Ошибки бизнес-логики
5. Ошибки в данных
6. Ошибки авторизации
7. Типы ошибок авторизации
8. Ошибки конфигурации
9. Внутренние ошибки приложения

###### Обработка ошибок в разных слоях

###### Data Layer (репозитории, DAO)

На уровне доступа к данным происходит перехват низкоуровневых исключений и преобразование их в исключения приложения

###### Domain Layer (сервисы)

Сервисы добавляют контекст бизнес-логики и могут преобразовывать исключения слоя данных в бизнес-исключения

###### Presentation Layer (UI)

На уровне UI выполняется обработка исключений для отображения пользователю

###### Асинхронная обработка ошибок

###### Использование async/await с try-catch

Предпочтительный подход к работе с асинхронным кодом - использование async/await с блоками try-catch

###### Обработка ошибок в StreamBuilder

При работе со стримами обрабатывайте ошибки в блоке builder

###### Глобальный обработчик ошибок зоны

Для перехвата непредвиденных ошибок используем глобальный обработчик

###### Отображение ошибок в UI

###### Компонент ErrorView

Создадим универсальный компонент для отображения ошибок с возможностью повторного запроса

###### Специфичные виды ошибок

Для разных типов ошибок можно создать специфичные компоненты: NetworkErrorView, NoPermissionErrorView

###### Обработка форм и валидация

Для отображения ошибок валидации в формах используйте виджеты, которые поддерживают отображение ошибок валидации.

###### Логирование ошибок

Логирование ошибок осуществляется с помощью библиотеки logger с настроенными логгерами разного уровня.

1. Стандартный формат логирования ошибок
2. Контекстное логирование. Для более информативных логов добавляйте контекст операции, в которой произошла ошибка.

###### Мониторинг и аналитика

###### Интеграция с Firebase Crashlytics

Для отслеживания ошибок в продакшене используется Firebase Crashlytics

###### Расширенный контекст ошибок

Для улучшения диагностики добавляйте пользовательский контекст в Crashlytics

###### Уведомления о критических ошибках

Для оперативного реагирования на критические ошибки настроены уведомления через Firebase Crashlytics:

1. **Email** -уведомления для команды разработки о новых ошибках
2. **Интеграция с Slack** для срочных уведомлений о критических сбоях
3. **Еженедельные сводки** о стабильности приложения

###### Аналитика пользовательских сценариев

Отслеживание успешности выполнения ключевых сценариев для быстрого выявления проблем

---

<!-- Source: docs\modules\orders.md -->
## Модуль заказ-нарядов

> Модуль заказ-нарядов обеспечивает создание и управление заказ-нарядами на ремонт автомобилей, включая список работ, запчастей и материалов.

###### Содержание
- [Назначение](#назначение)
- [Архитектура](#архитектура)
- [Основные компоненты](#основные-компоненты)
- [Модели данных](#модели-данных)
- [Основные операции](#основные-операции)
- [UI компоненты](#ui-компоненты)
- [Жизненный цикл заказ-наряда](#жизненный-цикл-заказ-наряда)
- [Интеграция с другими модулями](#интеграция-с-другими-модулями)

###### Назначение

Модуль заказ-нарядов решает следующие задачи:

- Создание и управление заказ-нарядами на ремонт автомобилей
- Учет выполненных работ и использованных запчастей
- Отслеживание статуса выполнения заказ-нарядов
- Расчет стоимости работ и материалов
- Взаимодействие с модулями клиентов, автомобилей и поставщиков

###### Архитектура

Модуль следует принципам чистой архитектуры и использует архитектуру "Композиция + Интерфейсы + `@freezed`". Он состоит из следующих уровней:

| Уровень | Назначение | Компоненты |
|---------|------------|------------|
| Presentation | Пользовательский интерфейс | `OrdersScreen`, `OrderDetailsScreen`, `OrderFormScreen` |
| Domain | Бизнес-логика | `OrderService`, `OrderStatusManager`, `OrderModelComposite`, `OrderPartModelComposite`, `OrderServiceModelComposite`, `IDocumentEntity`, `IDocumentItemEntity` |
| Data | Доступ к данным | `OrdersDao`, `OrderPartsDao`, `OrderServicesDao`, `EntityCoreData`, `DocumentSpecificData`, `OrderSpecificData`, `ItemCoreData`, `DocumentItemSpecificData`, `PartSpecificData`, `ServiceSpecificData` (`@freezed` модели) |

###### Основные компоненты

###### OrderService

Сервисный класс, обеспечивающий бизнес-логику работы с заказ-нарядами:

Функциональность: Управляет жизненным циклом заказ-нарядов, работает с бизнес-моделями (`OrderModelComposite`, `OrderPartModelComposite`, `OrderServiceModelComposite`) и интерфейсами (`IDocumentEntity`, `IDocumentItemEntity`). Координирует взаимодействие с DAO для получения/сохранения данных, преобразуя `@freezed` модели данных в бизнес-модели и обратно.
Ключевые методы:
`getOrders()`: Получение списка `OrderModelComposite`.
`watchOrders()`: Реактивное наблюдение за списком `OrderModelComposite`.
`createOrder()`: Создание нового `OrderModelComposite`.
`updateOrder()`: Обновление существующего `OrderModelComposite`.
`addPartToOrder()`: Добавление `OrderPartModelComposite` в `OrderModelComposite`.
`addServiceToOrder()`: Добавление `OrderServiceModelComposite` в `OrderModelComposite`.
`calculateOrderTotal()`: Расчет общей стоимости `OrderModelComposite`.
`changeOrderStatus()`: Изменение статуса `OrderModelComposite`.

###### OrderStatusManager

Класс для управления статусами заказ-нарядов:

Функциональность: Контроль переходов между статусами (`OrderStatus`), валидация возможных действий на основе текущего статуса `OrderModelComposite`.
Ключевые методы:
`canTransitionTo(OrderStatus from, OrderStatus to)`: Проверка возможности перехода.
`transitionTo(OrderModelComposite order, OrderStatus newStatus)`: Выполнение перехода (возвращает новый экземпляр `OrderModelComposite`).
`getAvailableTransitions(OrderModelComposite order)`: Получение доступных переходов.

###### OrdersDao, OrderPartsDao, OrderServicesDao

Data Access Objects для прямой работы с таблицами `OrdersItems`, `OrderPartsItems`, `OrderServicesItems` в БД:

Функциональность: Предоставляют низкоуровневый доступ к данным таблиц. Получают данные в виде моделей таблиц (`OrdersItem` и т.д.) и мапят их в соответствующие `@freezed` модели данных (`EntityCoreData`, `DocumentSpecificData`, `ItemCoreData` и т.д.) для передачи в сервисный слой. При сохранении принимают `Companion` объекты, созданные из `@freezed` моделей данных.
Ключевые методы:
`getActiveOrders()`: Получение данных для активных заказ-нарядов.
`watchActiveOrders()`: Реактивное наблюдение за данными заказ-нарядов.
`getOrdersByClientId()`: Получение данных заказ-нарядов клиента.
`getOrdersByCarId()`: Получение данных заказ-нарядов для автомобиля.
`insertOrder()`: Добавление нового заказ-наряда (принимает `Companion`).
`updateOrder()`: Обновление данных заказ-наряда (принимает `Companion`).
`updateOrderStatus()`: Обновление статуса заказ-наряда.
`getFullOrderDetails()`: Получение полных данных заказ-наряда с работами и запчастями (в виде `@freezed` моделей).

###### Модели данных

###### Модели таблиц (Drift)

- `OrdersItems`: Структура таблицы заказ-нарядов.
- `OrderPartsItems`: Структура таблицы запчастей заказ-наряда.
- `OrderServicesItems`: Структура таблицы услуг заказ-наряда.

###### Модели данных (`@freezed`)

Чистые, иммутабельные структуры для хранения данных, используемые для передачи между слоями Data и Domain:
- `EntityCoreData`: Базовые данные сущности (uuid, code, displayName...).
- `DocumentSpecificData`: Специфичные данные документа (status, documentDate...).
- `OrderSpecificData`: Специфичные данные заказ-наряда (clientId, carId...).
- `ItemCoreData`: Базовые данные элемента (uuid, name, itemType...).
- `DocumentItemSpecificData`: Специфичные данные элемента документа (price, quantity...).
- `PartSpecificData`: Специфичные данные запчасти (partNumber, brand...).
- `ServiceSpecificData`: Специфичные данные услуги (duration, performedBy...).

###### Бизнес-модели (Композиторы)

Классы, реализующие интерфейсы (`IDocumentEntity`, `IDocumentItemEntity`) и инкапсулирующие `@freezed` модели данных. Представляют заказ-наряд и его элементы в бизнес-логике:
- `OrderModelComposite`: Представляет заказ-наряд. Содержит `EntityCoreData`, `DocumentSpecificData`, `OrderSpecificData` и карту `_itemsMap` с `IDocumentItemEntity`. Реализует `IDocumentEntity`.
- `OrderPartModelComposite`: Представляет запчасть в заказ-наряде. Содержит `ItemCoreData`, `DocumentItemSpecificData`, `PartSpecificData`. Реализует `IDocumentItemEntity`.
- `OrderServiceModelComposite`: Представляет услугу в заказ-наряде. Содержит `ItemCoreData`, `DocumentItemSpecificData`, `ServiceSpecificData`. Реализует `IDocumentItemEntity`.

###### OrderStatus (перечисление)

Определяет возможные статусы заказ-наряда (`new`, `inProgress`, `waitingForParts`, `readyForPickup`, `completed`, `cancelled`) с методами для получения отображаемого имени и цвета.

###### Основные операции

###### Создание заказ-наряда

Процесс создания `OrderModelComposite` включает:
- Выбор клиента и автомобиля.
- Указание описания проблемы и планирование даты.
- Добавление работ (`OrderServiceModelComposite`) и запчастей (`OrderPartModelComposite`).
- Расчет общей стоимости.
- Сохранение через `OrderService`, который преобразует композитор в `@freezed` модели и передает их в DAO.

###### Управление запчастями заказ-наряда

Операции с `OrderPartModelComposite` включают:
- Добавление вручную или через каталог.
- Получение цен от поставщиков (через `SuppliersService`).
- Обновление статусов заказа и получения (методы `withOrderStatus`, `withReceiveStatus` в композиторе).

###### Управление статусом заказ-наряда

Изменение статуса `OrderModelComposite` через `OrderService` и `OrderStatusManager`. Смена статуса сопровождается валидацией и может инициировать дополнительные действия. Используется иммутабельный метод `withStatus` композитора.

###### UI компоненты

###### OrdersScreen

Основной экран управления заказ-нарядами:
- Отображает список `OrderModelComposite`.
- Использует `OrderService` для получения и фильтрации данных.
- Позволяет создавать новые заказ-наряды.

###### OrderFormScreen

Форма для создания/редактирования `OrderModelComposite`:
- Взаимодействует с `OrderService` для сохранения данных.
- Позволяет добавлять/редактировать `OrderPartModelComposite` и `OrderServiceModelComposite`.

###### OrderDetailsScreen

Экран детальной информации о `OrderModelComposite`:
- Отображает полную информацию, включая списки работ и запчастей.
- Позволяет изменять статус через `OrderService`.

###### Жизненный цикл заказ-наряда

Жизненный цикл `OrderModelComposite` управляется через `OrderService` и `OrderStatusManager`, включая создание, изменение статусов, завершение и архивирование (мягкое удаление).

###### Интеграция с другими модулями

###### Взаимодействие с модулем клиентов

- Получение информации о клиенте (`ClientModelComposite`) для отображения в заказ-наряде.
- Отображение истории заказ-нарядов (`OrderModelComposite`) клиента.

###### Взаимодействие с модулем автомобилей

- Выбор автомобиля (`CarModelComposite`) клиента для заказ-наряда.
- Отображение истории заказ-нарядов (`OrderModelComposite`) автомобиля.

###### Взаимодействие с модулем поставщиков

- Подбор запчастей (`OrderPartModelComposite`) по артикулу.
- Получение цен и сроков поставки от поставщиков через `SuppliersService`.
- Отображение информации о наличии и стоимости запчастей.

---

<!-- Source: docs\guides\async_programming.md -->
## Работа с асинхронным кодом

> В этом руководстве описаны подходы и рекомендации по работе с асинхронным кодом в проекте Part Catalog.

###### Содержание
- [Основные принципы](#основные-принципы)
- [Структурирование асинхронного кода](#структурирование-асинхронного-кода)
- [Безопасная работа с BuildContext](#безопасная-работа-с-buildcontext)
- [Обработка ошибок](#обработка-ошибок)
- [Кэширование и оптимизация](#кэширование-и-оптимизация)
- [Тестирование асинхронного кода](#тестирование-асинхронного-кода)
- [Часто встречающиеся проблемы](#часто-встречающиеся-проблемы)

###### Основные принципы

###### Future и Stream

В проекте используются два основных подхода к работе с асинхронными операциями:

Future - для одиночных асинхронных операций (получение данных от API, запись в БД)
Stream - для потоков данных (реактивное обновление UI при изменении данных в БД)

###### Маркировка асинхронных методов

* Всегда используйте ключевое слово async для методов, возвращающих Future
* Выполняйте await для всех асинхронных операций, за исключением случаев, когда вы намеренно запускаете операции параллельно
* Явно указывайте возвращаемые типы (Future<T>, Stream<T>)

###### Структурирование асинхронного кода

###### Использование паттерна Репозиторий

Разделяйте код на слои, чтобы минимизировать асинхронную сложность

###### Параллельное выполнение асинхронных операций

Для оптимизации производительности используйте Future.wait для параллельного выполнения нескольких асинхронных операций

###### Безопасная работа с BuildContext

###### Проверка mounted перед setState

Всегда проверяйте, что виджет всё ещё находится в дереве (mounted), перед вызовом setState() после асинхронных операций

###### Сохранение ссылок на зависимые от контекста объекты

Сохраняйте ссылки на объекты, зависящие от контекста, перед асинхронными операциями

###### Использование addPostFrameCallback

Для запуска асинхронных операций после отрисовки фрейма используйте WidgetsBinding.instance.addPostFrameCallback

###### Обработка ошибок

###### Паттерн try-catch-finally

Используйте блоки try-catch-finally для обработки асинхронных ошибок

###### Обработка ошибок в Stream

При работе с потоками данных обрабатывайте ошибки в Stream с помощью catchError или внутри StreamBuilder

###### Пробрасывание ошибок

При необходимости проброса ошибок на верхние уровни используйте собственные типы исключений

###### Кэширование и оптимизация

###### Кэширование результатов асинхронных операций

Для часто используемых асинхронных операций применяйте кэширование

###### Дебаунсинг и троттлинг

Для предотвращения лишних запросов при быстром вводе пользователя или прокрутке

###### Тестирование асинхронного кода

###### Unit-тестирование асинхронного кода

Для unit-тестов асинхронного кода используйте async/await и методы для ожидания завершения асинхронных операций

###### Тестирование с fake_async

Для тестирования кода с таймерами используйте fake_async

###### Часто встречающиеся проблемы

###### "Uncaught exception" в асинхронном коде

Если в асинхронном коде возникают необработанные исключения:

```dart
// ❌ Неправильно: исключение не обрабатывается
void initState() {
  super.initState();
  loadData(); // Асинхронный метод без обработки ошибок
}

// ✅ Правильно: добавляем обработку ошибок
void initState() {
  super.initState();
  loadData().catchError((error) {
    if (mounted) {
      setState(() => _error = error.toString());
    }
  });
}
```

###### Проблема "setState() or markNeedsBuild() called during build"

Если вы получаете эту ошибку при асинхронных операциях:

```dart
// ❌ Неправильно: setState вызывается синхронно в build
Widget build(BuildContext context) {
  _service.getData().then((data) {
    setState(() => _data = data); // Вызывает ошибку!
  });
  return Container();
}

// ✅ Правильно: используем FutureBuilder или StreamBuilder
Widget build(BuildContext context) {
  return FutureBuilder<Data>(
    future: _service.getData(),
    builder: (context, snapshot) {
      if (snapshot.hasData) {
        return DataWidget(data: snapshot.data!);
      } else if (snapshot.hasError) {
        return ErrorWidget(error: snapshot.error!);
      }
      return LoadingWidget();
    },
  );
}
```

###### Утечки памяти в асинхронном коде

Если происходят утечки памяти из-за асинхронных операций:

```dart
// ❌ Неправильно: подписка на Stream без отписки
StreamSubscription _subscription;

@override
void initState() {
  super.initState();
  _subscription = _service.dataStream.listen((data) {
    setState(() => _data = data);
  });
}

// ✅ Правильно: отписываемся при dispose
@override
void dispose() {
  _subscription?.cancel();
  super.dispose();
}

// ✅ Еще лучше: используем StreamBuilder вместо ручной подписки
Widget build(BuildContext context) {
  return StreamBuilder<Data>(
    stream: _service.dataStream,
    builder: (context, snapshot) {
      // Логика отображения
    },
  );
}
```

###### Зацикленные асинхронные вызовы

Избегайте создания бесконечных циклов асинхронных вызовов:

```dart
// ❌ Неправильно: метод вызывает сам себя без условия остановки
Future<void> refreshData() async {
  final newData = await _repository.fetchData();
  setState(() => _data = newData);
  refreshData(); // Будет вызываться бесконечно!
}

// ✅ Правильно: используем таймер или условие остановки
Future<void> startPeriodicRefresh() async {
  while (_isActive) {
    final newData = await _repository.fetchData();
    if (mounted) {
      setState(() => _data = newData);
    }
    await Future.delayed(Duration(minutes: 1));
  }
}

@override
void initState() {
  super.initState();
  _isActive = true;
  startPeriodicRefresh();
}

@override
void dispose() {
  _isActive = false;
  super.dispose();
}
```

---

<!-- Source: docs\modules\suppliers\direct_api.md -->
## Прямое подключение к API

> Этот документ описывает прямое подключение к API поставщиков запчастей без использования прокси-сервера.

###### Содержание
- [Обзор](#обзор)
- [Архитектура](#архитектура)
- [Базовый интерфейс и реализация](#базовый-интерфейс-и-реализация)
- [Реализация для конкретных поставщиков](#реализация-для-конкретных-поставщиков)
- [Обработка ошибок](#обработка-ошибок)
- [Оптимизация и кэширование](#оптимизация-и-кэширование)
- [Особенности и ограничения](#особенности-и-ограничения)

###### Обзор

Прямое подключение к API поставщиков позволяет приложению напрямую взаимодействовать с API различных поставщиков запчастей без промежуточных серверов. Этот режим удобен для:

    *   Разработки и тестирования
    *   Работы в локальной сети
    *   Случаев с малым количеством запросов
    *   Мобильных приложений с ограниченным серверным бэкендом

###### Архитектура

В режиме прямого подключения клиентское приложение непосредственно взаимодействует с API каждого поставщика:

```
┌────────────────┐      HTTP запрос       ┌──────────────────┐
│   Flutter      │  ──────────────────>   │    API           │
│   приложение   │                        │    поставщика    │
└────────────────┘  <──────────────────   └──────────────────┘
                       HTTP ответ
```

Ключевые особенности архитектуры:

1. Реализация в клиенте: Вся логика подключения реализована в клиентском приложении
2. API-ключи в клиенте: Требуется хранение API-ключей в клиентском приложении
3. Индивидуальный подход: Для каждого поставщика создаётся отдельный API-клиент

###### Базовый интерфейс и реализация

Для унификации работы с разными API поставщиков используется общий интерфейс:

```dart
abstract class SupplierApiClient {
  /// Получает цены на запчасть по артикулу
  Future<List<PartPriceModel>> getPricesByArticle(String article);
  
  /// Поиск запчастей по наименованию
  Future<List<PartInfoModel>> searchPartsByName(String name);
  
  /// Получает детальную информацию о запчасти
  Future<PartDetailModel?> getPartDetails(String articleNumber);
  
  /// Возвращает название поставщика
  String get supplierName;
}
```

Базовая реализация предоставляет общие механизмы работы с HTTP-запросами:

```dart
abstract class BaseSupplierClient implements SupplierApiClient {
  final HttpClientInterface httpClient;
  final String baseUrl;
  final Map<String, String> defaultHeaders;
  
  BaseSupplierClient({
    required this.httpClient,
    required this.baseUrl,
    this.defaultHeaders = const {},
  });
  
  // Методы для формирования URL и выполнения безопасных HTTP запросов
}
```

###### Реализация для конкретных поставщиков

Каждый поставщик реализует свой собственный клиент, наследующий `BaseSupplierClient` и переопределяющий методы для работы с конкретным API:

```dart
class AutodocClient extends BaseSupplierClient {
  AutodocClient({
    required HttpClientInterface httpClient,
    required String apiKey,
    String baseUrl = 'https://api.autodoc.ru',
  }) : super(
    httpClient: httpClient,
    baseUrl: baseUrl,
    defaultHeaders: {
      'X-API-Key': apiKey,
      'User-Agent': 'PartCatalog/1.0',
    },
  );
  
  @override
  String get supplierName => 'Autodoc';
  
  @override
  Future<List<PartPriceModel>> getPricesByArticle(String article) async {
    // Реализация метода для конкретного поставщика
  }
  
  // Остальные методы...
}
```

###### Обработка ошибок

При прямом подключении к API важна корректная обработка ошибок:

1. Сетевые ошибки: Отсутствие интернет-соединения, таймауты, проблемы DNS
2. Ошибки API: Неверные API-ключи, превышение лимитов запросов, ошибки аутентификации
3. Ошибки данных: Некорректный формат ответа, отсутствие обязательных полей

```dart
try {
  final prices = await apiClient.getPricesByArticle(article);
  // Обработка успешного ответа
} on NetworkException catch (e) {
  // Обработка сетевых ошибок
  logger.e('Ошибка сети при запросе к ${apiClient.supplierName}', e);
  
  if (e.statusCode == 401) {
    // Показать сообщение о неверных учетных данных
  } else if (e.statusCode == 429) {
    // Показать сообщение о превышении лимита запросов
  } else {
    // Общая ошибка сети
  }
} catch (e) {
  // Обработка непредвиденных ошибок
  logger.e('Непредвиденная ошибка', e);
}
```

###### Оптимизация и кэширование

Для повышения производительности и снижения нагрузки на API можно использовать кэширование:

###### Локальное кэширование результатов:

Для кэширования результатов запросов можно использовать локальное хранилище, например, `SharedPreferences` или SQLite:

###### Дебаунсинг запросов:

Для предотвращения частых запросов при вводе пользователем можно использовать дебаунсинг:

###### Умное обновление кэша:

При получении новых данных можно сравнивать их с кэшированными и обновлять только изменившиеся записи. Это позволяет снизить количество запросов к API и ускорить работу приложения.

###### Параллельные запросы:

Для ускорения получения данных можно выполнять несколько запросов параллельно, используя `Future.wait`

###### Особенности и ограничения

При использовании прямого подключения к API следует учитывать:

###### Преимущества:
1. Простота реализации: Не требует дополнительного сервера
2. Отсутствие дополнительных задержек: Запросы идут напрямую к поставщикам
3. Автономность: Приложение не зависит от доступности промежуточного сервера

###### Ограничения:
1. Безопасность: API-ключи хранятся на клиентской стороне
2. Лимиты запросов: Каждое устройство использует собственную квоту запросов
3. Оптимизация: Сложнее реализовать общую оптимизацию запросов
4. Конфигурация: При изменении API поставщиков требуется обновление клиентского приложения

###### Рекомендации по использованию:
1. Используйте для разработки и тестирования: В production-среде предпочтительнее использовать прокси-сервер
2. Обеспечьте защиту API-ключей: Храните ключи в зашифрованном виде
3. Реализуйте кэширование: Для снижения нагрузки на API и улучшения отклика
4. Мониторинг ошибок: Реализуйте централизованный мониторинг ошибок для выявления проблем с API

---

<!-- Source: docs\modules\suppliers\proxy_server.md -->
## Прокси-сервер для API поставщиков

> Прокси-сервер позволяет централизовать доступ к API поставщиков запчастей, обеспечивая безопасное хранение API-ключей, кэширование результатов и оптимизацию платных запросов.

###### Содержание

- Назначение
- Архитектура
- Ключевые компоненты
- Установка и запуск
- Интеграция с клиентом

###### Назначение

Прокси-сервер решает следующие задачи:

- Централизованное хранение API-ключей поставщиков
- Обеспечение доступа к API с фиксированных IP-адресов
- Кэширование результатов для оптимизации платных запросов
- Унификация формата данных от разных поставщиков
- Мониторинг и логирование запросов

###### Архитектура

Прокси-сервер разработан на Dart с использованием пакета `shelf` и переиспользует код клиентской части для работы с API поставщиков.

###### Технический стек

- **Язык**: Dart
- **Фреймворк**: shelf
- **Хранение кэша**: sembast
- **Логирование**: logging

###### Общая схема работы

```
┌──────────────┐      HTTP      ┌──────────────┐      HTTP       ┌─────────────┐
│    Клиент    │   запрос 1 ─▶  │ Прокси-сервер│   запрос     ─▶│   API       │
│  (Flutter)   │                │ (Dart)        │                │ Поставщика  │
└──────────────┘  ◀──────────   └──────────────┘  ◀──────────   └─────────────┘
                       ответ                      ответ
         │
         ▼
    ┌───────────────┐
    │      Кэш      │
    │(sembast/redis)│
    └───────────────┘
```

###### Ключевые компоненты

###### Основные компоненты сервера

- **Router**: маршрутизация HTTP-запросов
- **ApiClientManager**: управление клиентами API поставщиков
- **CacheManager**: кэширование результатов запросов

###### Основные эндпоинты API

| Метод | Путь | Описание |
|-------|------|----------|
| GET | `/api/suppliers/{supplier}/prices` | Получение цен от конкретного поставщика |
| GET | `/api/suppliers/{supplier}/search` | Поиск запчастей у конкретного поставщика |
| GET | `/api/prices` | Агрегация цен от всех поставщиков |
| GET | `/health` | Проверка работоспособности сервера |

###### Установка и запуск

###### Предварительные требования

- Dart SDK 2.17.0 или выше
- Настроенные переменные окружения с API-ключами поставщиков

###### Команда запуска

```bash
# Запуск с параметрами по умолчанию
dart bin/server.dart

# Запуск с указанием порта
dart bin/server.dart --port=8080
```

###### Интеграция с клиентом

Для подключения клиента Flutter к прокси-серверу:

Настройка режима API в конфигурации:

```dart
// Изменение режима API на proxy
await apiClientManager.switchMode(ApiConnectionMode.proxy);
```

Указание URL прокси-сервера:

```dart
// Сохранение URL прокси-сервера
final prefs = await SharedPreferences.getInstance();
await prefs.setString('proxy_server_url', 'https://your-proxy-server.com');
```



---

<!-- Source: docs\references\api_reference.md -->
## Справочник по API проекта

---


## Примеры кода

> Ниже приведены наиболее важные примеры кода из проекта

### api_client.dart

```dart
//# Полный пример API клиента

```

### proxy_server.dart

```dart
//# Полный пример прокси-сервера

```

