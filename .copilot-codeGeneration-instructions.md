# part_catalog

## 1. Техническое задание:

Приложение предназначено для работников станции технического обслуживания автомобилей (СТО) и должно обеспечивать:

*   Учёт клиентов (физические и юридические лица).
*   Учёт ремонтируемого автотранспорта.
*   Учёт заявок (заказ-нарядов), оформляемых работником СТО, с информацией о:
    *   Дате.
    *   Автомобиле.
    *   Клиенте.
    *   Произведенной работе.
    *   Использованных запчастях и материалах.
*   Подбор запчастей для ремонта автомобиля с использованием `ApiClientPartsCatalogs`.
*   Отправку подобранных запчастей (артикулов) в другой RestAPI поставщика запчастей для получения информации о ценах и сроках поставки.
*   Возврат полученных данных о ценах и сроках поставки в заказ-наряд для дальнейшей передачи в заказ поставщику.

## 2. Архитектура приложения:

**Слои:**

*   **UI (Presentation Layer):** Содержит виджеты Flutter, экраны и логику пользовательского интерфейса.
*   **Business Logic Layer (BLL):** Управляет бизнес-логикой приложения, взаимодействует с API, обрабатывает данные и управляет состоянием. Можно использовать Provider, BLoC или Riverpod для управления состоянием.
*   **Data Layer:** Содержит репозитории, API-клиенты (например, `ApiClientPartsCatalogs`) и модели данных. Отвечает за получение и отправку данных.
*   **Core:** Содержит общие компоненты, такие как сервис-локатор, утилиты и модели данных.

**Управление состоянием:**

Используйте Provider, BLoC или Riverpod для управления состоянием приложения. Это поможет вам разделить логику пользовательского интерфейса и бизнес-логику, а также упростить тестирование и поддержку.

**Сервис-локатор:**

Используйте `get_it` (как вы уже делаете) для внедрения зависимостей и обеспечения доступа к общим сервисам, таким как `ApiClientPartsCatalogs`.

**API-клиенты:**

*   `ApiClientPartsCatalogs` для взаимодействия с API каталогов запчастей.
*   Отдельный API-клиент для взаимодействия с API поставщика запчастей (для получения цен и сроков поставки).

**Модели данных:**

*   Существующие модели (`Catalog`, `CarInfo`, и т.д.).
*   Новые модели для представления клиентов, автомобилей, заказ-нарядов, позиций в заказ-наряде, поставщиков и т.д.

**Локальная база данных (опционально):**

Используйте SQLite (через `sqflite`) или Hive для локального хранения данных, таких как клиенты, автомобили и заказ-наряды. Это позволит приложению работать в автономном режиме и повысит производительность.

## 3. Структура пользовательского интерфейса:

**Главный экран:**

*   Навигационная панель или Drawer для доступа к основным разделам приложения.
*   Разделы:
    *   **Клиенты:** Управление клиентами (добавление, редактирование, просмотр).
    *   **Автомобили:** Управление автомобилями (добавление, редактирование, просмотр).
    *   **Заказ-наряды:** Создание, редактирование, просмотр заказ-нарядов.
    *   **Подбор запчастей:** Интеграция с `ApiClientPartsCatalogs` для поиска и выбора запчастей.
    *   **Поставщики:** Управление поставщиками (опционально).
    *   **Настройки:** Настройки приложения (например, API-ключи, язык).

**Экран управления клиентами:**

*   Список клиентов.
*   Кнопка "Добавить клиента".
*   Форма для добавления/редактирования клиента (ФИО, контактные данные, тип клиента - физическое/юридическое лицо).

**Экран управления автомобилями:**

*   Список автомобилей.
*   Кнопка "Добавить автомобиль".
*   Форма для добавления/редактирования автомобиля (VIN, марка, модель, год выпуска, клиент-владелец).

**Экран управления заказ-нарядами:**

*   Список заказ-нарядов.
*   Кнопка "Создать заказ-наряд".
*   Форма для создания/редактирования заказ-наряда:
    *   Дата.
    *   Клиент.
    *   Автомобиль.
    *   Описание проблемы.
    *   Список работ.
    *   Список запчастей (с возможностью добавления из `ApiClientPartsCatalogs` и получения цен от API поставщика).
    *   Общая стоимость.
    *   Статус (например, "Создан", "В работе", "Завершен").

**Экран подбора запчастей:**

*   Интеграция с `CarInfoWidget` для поиска автомобиля по VIN/FRAME.
*   Список каталогов.
*   Список групп запчастей.
*   Список запчастей.
*   Возможность добавления запчастей в заказ-наряд.

**Компоненты пользовательского интерфейса:**

*   Используйте Material Design или Cupertino (в зависимости от платформы) для создания единообразного и привлекательного пользовательского интерфейса.
*   Используйте `TextField` для ввода данных.
*   Используйте `DropdownButton` или `Autocomplete` для выбора клиентов, автомобилей и запчастей.
*   Используйте `ListView` или `GridView` для отображения списков данных.
*   Используйте `Card` для отображения информации об отдельных элементах (например, клиенте, автомобиле, запчасти).
*   Используйте `AlertDialog` для отображения сообщений об ошибках и подтверждений.
*   Используйте `ProgressIndicator` для отображения индикаторов загрузки.

## 4. Интеграция с API поставщика запчастей:

*   Создайте отдельный API-клиент (например, `SupplierApiClient`) для взаимодействия с API поставщика запчастей.
*   Определите модели данных для представления цен и сроков поставки запчастей.
*   В экране управления заказ-нарядами добавьте возможность отправки списка артикулов запчастей в `SupplierApiClient` и отображения полученных цен и сроков поставки.

## 5. Примерная структура проекта:

lib/
  features/
    parts_catalog/
      api/
      models/
      screens/
      widgets/
    clients/
      models/
      screens/
      services/
    vehicles/
    orders/
    suppliers/
  core/
    service_locator.dart
    database/
    utils/
  main.dart

## 6. Текущий статус реализации

**Реализовано:**
* Базовая структура проекта по предметным областям (features)
* API-клиент для каталога запчастей (`ApiClientPartsCatalogs`)
* Основные модели для работы с каталогом запчастей (`Catalog`, `CarParameterIdx`, и др.)
* База данных (Drift) с таблицей клиентов
* Сервис-локатор (get_it)

**В процессе:**
* Экраны для работы с клиентами
* Интеграция с каталогом запчастей через экраны

**Следующие шаги:**
* См. раздел 8 "Приоритеты и план разработки" для детального плана реализации

## 7. Соглашения по кодированию и шаблоны

**Именование:**
* Файлы: snake_case (например, `car_info_widget.dart`)
* Классы: PascalCase (например, `ApiClientPartsCatalogs`)
* Методы и переменные: camelCase (например, `getClientById`)
* Константы: SCREAMING_SNAKE_CASE (например, `API_BASE_URL`)

**Структура файлов:**
* Один класс на файл, когда это возможно
* Файлы с моделями данных должны содержать класс и его вспомогательные методы
* Имена файлов должны соответствовать основному классу в них

**Документация:**
* Используйте документационные комментарии `///` для публичных API
* Используйте dart-doc теги `{@template}` и `{@macro}` для переиспользуемых описаний

**Примеры:**

Пример сервиса:
```dart
/// {@template client_service}
/// Сервис для управления клиентами в базе данных.
/// {@endtemplate}
class ClientService {
  /// {@macro client_service}
  ClientService(this._database);
  
  final AppDatabase _database;
  
  /// Возвращает список всех клиентов.
  Future<List<Client>> getClients() async {
    // реализация
  }
}
```

## 8. Приоритеты и план разработки

1. **Этап 1: Фундамент (текущий)**
   * Настройка базы данных ✅
   * Базовая структура проекта ✅
   * API-клиенты для внешних сервисов ✅

2. **Этап 2: CRUD-операции для основных сущностей**
   * Реализация моделей данных для всех сущностей
   * Реализация репозиториев/сервисов для работы с данными
   * Базовые экраны для работы с сущностями

3. **Этап 3: Интеграция каталога запчастей**
   * Доработка экранов для выбора запчастей
   * Интеграция с заказ-нарядами

4. **Этап 4: Интеграция с API поставщиков**
   * Реализация API-клиента для поставщиков
   * Интеграция с заказ-нарядами

5. **Этап 5: Улучшение UX/UI и оптимизация**
   * Улучшение дизайна
   * Оптимизация производительности
   * Добавление функций поиска и фильтрации

## 9. Используемые технологии и зависимости

* **Основные:**
  * Flutter - фреймворк UI
  * Dart - язык программирования

* **Управление состоянием:**
  * Provider/BLoC/Riverpod (выбрать предпочтительный)

* **База данных:**
  * Drift (SQLite) - для хранения локальных данных

* **Сетевые запросы:**
  * Dio - HTTP-клиент для работы с API

* **Внедрение зависимостей:**
  * get_it - сервис-локатор

* **Кодогенерация:**
  * freezed - для иммутабельных моделей данных
  * json_serializable - для сериализации JSON
  * drift_dev - для генерации кода базы данных

* **Утилиты:**
  * flutter_dotenv - для переменных окружения
  * logger - для логирования
  * path_provider - для доступа к директориям файловой системы