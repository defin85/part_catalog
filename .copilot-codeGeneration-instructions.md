# part_catalog

## 1. Техническое задание:

Приложение предназначено для работников станции технического обслуживания автомобилей (СТО) и должно обеспечивать:

*   Учёт клиентов (физические и юридические лица).
*   Учёт ремонтируемого автотранспорта.
*   Учёт заявок (заказ-нарядов), оформляемых работником СТО, с информацией о:
    *   Дате.
    *   Автомобиле.
    *   Клиенте.
    *   Произведенной работе.
    *   Использованных запчастях и материалах.
*   Подбор запчастей для ремонта автомобиля с использованием `ApiClientPartsCatalogs`.
*   Отправку подобранных запчастей (артикулов) в другой RestAPI поставщика запчастей для получения информации о ценах и сроках поставки.
*   Возврат полученных данных о ценах и сроках поставки в заказ-наряд для дальнейшей передачи в заказ поставщику.

## 2. Архитектура приложения:

**Слои:**

*   **UI (Presentation Layer):** Содержит виджеты Flutter, экраны и логику пользовательского интерфейса.
*   **Business Logic Layer (BLL):** Управляет бизнес-логикой приложения, взаимодействует с API, обрабатывает данные и управляет состоянием. Можно использовать Provider, BLoC или Riverpod для управления состоянием.
*   **Data Layer:** Содержит репозитории, API-клиенты (например, `ApiClientPartsCatalogs`) и модели данных. Отвечает за получение и отправку данных.
*   **Core:** Содержит общие компоненты, такие как сервис-локатор, утилиты и модели данных.

**Управление состоянием:**

Используйте Provider, BLoC или Riverpod для управления состоянием приложения. Это поможет вам разделить логику пользовательского интерфейса и бизнес-логику, а также упростить тестирование и поддержку.

**Сервис-локатор:**

Используйте `get_it` (как вы уже делаете) для внедрения зависимостей и обеспечения доступа к общим сервисам, таким как `ApiClientPartsCatalogs`.

**API-клиенты:**

*   `ApiClientPartsCatalogs` для взаимодействия с API каталогов запчастей.
*   Отдельный API-клиент для взаимодействия с API поставщика запчастей (для получения цен и сроков поставки).

**Модели данных:**

* **Client** - модель клиента, содержит:
  * id: уникальный идентификатор
  * type: тип клиента (ClientType)
  * name: ФИО/наименование
  * contactInfo: контактная информация
  * additionalInfo: дополнительная информация

* **ClientType** - перечисление, определяющее тип клиента:
  * physical - Физическое лицо
  * legal - Юридическое лицо
  * individualEntrepreneur - Индивидуальный предприниматель
  * other - Другое
  * С расширениями:
    * displayName - получение человекочитаемого названия
    * fromString - создание из строкового представления
    * toShortString - получение короткого строкового представления

*   Новые модели для представления клиентов, автомобилей, заказ-нарядов, позиций в заказ-наряде, поставщиков и т.д.

**Локальная база данных (опционально):**

Используйте SQLite (через `sqflite`) или Hive для локального хранения данных, таких как клиенты, автомобили и заказ-наряды. Это позволит приложению работать в автономном режиме и повысит производительность.

## 3. Структура пользовательского интерфейса:

**Главный экран:**

*   Навигационная панель или Drawer для доступа к основным разделам приложения.
*   Разделы:
    *   **Клиенты:** Управление клиентами (добавление, редактирование, просмотр).
    *   **Автомобили:** Управление автомобилями (добавление, редактирование, просмотр).
    *   **Заказ-наряды:** Создание, редактирование, просмотр заказ-нарядов.
    *   **Подбор запчастей:** Интеграция с `ApiClientPartsCatalogs` для поиска и выбора запчастей.trac
    *   **Поставщики:** Управление поставщиками (опционально).
    *   **Настройки:** Настройки приложения (например, API-ключи, язык).

**Экран управления клиентами:**

*   Список клиентов.
*   Кнопка "Добавить клиента".
*   Форма для добавления/редактирования клиента (ФИО, контактные данные, тип клиента - физическое/юридическое лицо).

**Экран управления автомобилями:**

*   Список автомобилей.
*   Кнопка "Добавить автомобиль".
*   Форма для добавления/редактирования автомобиля (VIN, марка, модель, год выпуска, клиент-владелец).

**Экран управления заказ-нарядами:**

*   Список заказ-нарядов.
*   Кнопка "Создать заказ-наряд".
*   Форма для создания/редактирования заказ-наряда:
    *   Дата.
    *   Клиент.
    *   Автомобиль.
    *   Описание проблемы.
    *   Список работ.
    *   Список запчастей (с возможностью добавления из `ApiClientPartsCatalogs` и получения цен от API поставщика).
    *   Общая стоимость.
    *   Статус (например, "Создан", "В работе", "Завершен").

**Экран подбора запчастей:**

*   Интеграция с `CarInfoWidget` для поиска автомобиля по VIN/FRAME.
*   Список каталогов.
*   Список групп запчастей.
*   Список запчастей.
*   Возможность добавления запчастей в заказ-наряд.

**Компоненты пользовательского интерфейса:**

*   Используйте Material Design или Cupertino (в зависимости от платформы) для создания единообразного и привлекательного пользовательского интерфейса.
*   Используйте `TextField` для ввода данных.
*   Используйте `DropdownButton` или `Autocomplete` для выбора клиентов, автомобилей и запчастей.
*   Используйте `ListView` или `GridView` для отображения списков данных.
*   Используйте `Card` для отображения информации об отдельных элементах (например, клиенте, автомобиле, запчасти).
*   Используйте `AlertDialog` для отображения сообщений об ошибках и подтверждений.
*   Используйте `ProgressIndicator` для отображения индикаторов загрузки.

## 4. Особенности реализации и улучшения:

**База данных:**

*   Добавлена система мягкого удаления записей (soft delete) через поле `deletedAt`
*   Реализован механизм синхронизации схемы БД с автоматическим добавлением отсутствующих таблиц и колонок
*   Добавлено логирование SQL-запросов и транзакций через декоратор `DatabaseLogger`
*   Использование индексов для оптимизации запросов

**DAO и сервисы:**

*   Для каждой таблицы создан соответствующий DAO-класс с методами доступа к данным
*   Сервисные классы инкапсулируют бизнес-логику и преобразуют модели таблиц в бизнес-модели
*   Реализованы потоки (Stream) для реактивного обновления UI

**Оптимизации:**

*   Исключение избыточных обновлений UI через использование реактивных потоков
*   Использование индексов для оптимизации запросов
*   Сокращение числа запросов к БД через агрегирующие методы (например, `getCarsWithOwners`)

**Безопасная работа с асинхронным кодом:**

* Применение паттерна сохранения состояния (state retention) для объектов, зависящих от контекста
* Защита вызовов `setState()` и доступа к контексту проверкой `mounted`
* Использование `addPostFrameCallback` для инициации асинхронных операций после отрисовки фрейма
* Применение паттерна "try-catch-finally" для эффективной обработки ошибок в асинхронных операциях
* Обеспечение плавной деградации интерфейса при асинхронных сбоях

## 5. Интеграция с API поставщика запчастей:

*   Создайте отдельный API-клиент (например, `SupplierApiClient`) для взаимодействия с API поставщика запчастей.
*   Определите модели данных для представления цен и сроков поставки запчастей.
*   В экране управления заказ-нарядами добавьте возможность отправки списка артикулов запчастей в `SupplierApiClient` и отображения полученных цен и сроков поставки.

## 6. Примерная структура проекта:

lib/
  features/
    parts_catalog/
      api/
      models/
      screens/
      widgets/
    clients/
      models/
      screens/
      services/
    vehicles/
    orders/
    suppliers/
  core/
    service_locator.dart
    database/
    utils/
  main.dart

## 7. Текущий статус реализации

**Реализовано:**
* Базовая структура проекта по предметным областям (features)
* API-клиент для каталога запчастей (`ApiClientPartsCatalogs`)
* Основные модели для работы с каталогом запчастей
* База данных (Drift) с таблицами `ClientsItems` и `CarsItems`
* DAO-классы для работы с данными
* Сервисные классы для клиентов и автомобилей
* Реактивные экраны для работы с клиентами и автомобилями
* Механизм синхронизации схемы БД
* Система логирования SQL-запросов

**В процессе:**
* Улучшение UI клиентов и автомобилей
* Интеграция каталога запчастей с заказ-нарядами
* Разработка заказ-нарядов

**Следующие шаги:**
* Завершение базового функционала клиентов и автомобилей
* Переход к разработке заказ-нарядов
* Интеграция выбора запчастей в заказ-наряды

## 8. Соглашения по кодированию и шаблоны

**Именование:**
* Файлы: snake_case (например, `car_info_widget.dart`)
* Классы: PascalCase (например, `ApiClientPartsCatalogs`)
* Методы и переменные: camelCase (например, `getClientById`)
* Константы: SCREAMING_SNAKE_CASE (например, `API_BASE_URL`)

**Структура файлов:**
* Один класс на файл, когда это возможно
* Файлы с моделями данных должны содержать класс и его вспомогательные методы
* Имена файлов должны соответствовать основному классу в них

**Документация:**
* Используйте документационные комментарии `///` для публичных API
* Используйте dart-doc теги `{@template}` и `{@macro}` для переиспользуемых описаний

**Архитектурные особенности:**
* DAO классы отвечают только за доступ к данным
* Сервисные классы преобразуют модели БД в бизнес-модели и обратно
* Бизнес-логика сосредоточена в сервисных классах
* UI использует реактивные потоки для отображения данных

**Асинхронные операции и BuildContext:**

* Избегайте использования `BuildContext` после асинхронных операций без проверки `mounted`
* Сохраняйте ссылки на объекты, зависящие от контекста, перед асинхронными операциями:
  ```dart
  // Правильно:
  final scaffoldMessenger = ScaffoldMessenger.of(context);
  final navigator = Navigator.of(context);
  
  try {
    final result = await someAsyncOperation();
    if (mounted) {
      // Безопасное использование setState
      setState(() { ... });
      // Используем сохраненные ранее ссылки
      scaffoldMessenger.showSnackBar(...);
    }
  } catch (error) {
    if (mounted) {
      // Используем сохраненные ссылки вместо получения новых
      scaffoldMessenger.showSnackBar(...);
      navigator.pop();
    }
  }

* В widget-тестах используйте `tester.pumpAndSettle()` после асинхронных операций
* Используйте `WidgetsBinding.instance.addPostFrameCallback` для запуска асинхронных операций после построения интерфейса
* При использовании `FutureBuilder` и `StreamBuilder`, всегда обрабатывайте состояния загрузки (ConnectionState.waiting) и ошибки

**Примеры:**

Пример сервиса:
```dart
/// {@template client_service}
/// Сервис для управления клиентами в базе данных.
/// {@endtemplate}
class ClientService {
  /// {@macro client_service}
  ClientService(this._database);
  
  final AppDatabase _database;
  
  /// Возвращает список всех клиентов.
  Future<List<Client>> getClients() async {
    // реализация
  }
}
```

## 9. Приоритеты и план разработки

1. **Этап 1: Фундамент (текущий)**
   * Настройка базы данных ✅
   * Базовая структура проекта ✅
   * API-клиенты для внешних сервисов ✅

2. **Этап 2: CRUD-операции для основных сущностей**
   * Реализация моделей данных для всех сущностей
   * Реализация репозиториев/сервисов для работы с данными
   * Базовые экраны для работы с сущностями

3. **Этап 3: Интеграция каталога запчастей**
   * Доработка экранов для выбора запчастей
   * Интеграция с заказ-нарядами

4. **Этап 4: Интеграция с API поставщиков**
   * Реализация API-клиента для поставщиков
   * Интеграция с заказ-нарядами

5. **Этап 5: Улучшение UX/UI и оптимизация**
   * Улучшение дизайна
   * Оптимизация производительности
   * Добавление функций поиска и фильтрации

## 10. Используемые технологии и зависимости

* **Основные:**
  * Flutter - фреймворк UI
  * Dart - язык программирования

* **Управление состоянием:**
  * Provider/BLoC/Riverpod (выбрать предпочтительный)

* **База данных:**
  * Drift (SQLite) - для хранения локальных данных

* **Сетевые запросы:**
  * Dio - HTTP-клиент для работы с API

* **Внедрение зависимостей:**
  * get_it - сервис-локатор

* **Кодогенерация:**
  * freezed - для иммутабельных моделей данных
  * json_serializable - для сериализации JSON
  * drift_dev - для генерации кода базы данных

* **Утилиты:**
  * flutter_dotenv - для переменных окружения
  * logger - для логирования
  * path_provider - для доступа к директориям файловой системы

## 11. Структура базы данных

База данных реализована с использованием Drift ORM для работы с SQLite. Определения таблиц находятся в директории `lib/core/database/items/`:

### Таблицы базы данных:

* **ClientsItems** - хранение информации о клиентах
  * id: уникальный идентификатор (INTEGER, PRIMARY KEY)
  * type: тип клиента (TEXT)
    * Возможные значения (через перечисление ClientType):
      * physical - Физическое лицо
      * legal - Юридическое лицо
      * individualEntrepreneur - Индивидуальный предприниматель
      * other - Другое
  * name: наименование клиента (TEXT)
  * contactInfo: контактная информация (TEXT)
  * additionalInfo: дополнительная информация (TEXT, nullable)
  * deletedAt: метка мягкого удаления (DATETIME, nullable)

* **CarsItems** - хранение информации об автомобилях
  * id: уникальный идентификатор (INTEGER, PRIMARY KEY)
  * clientId: владелец автомобиля (INTEGER, FOREIGN KEY → ClientsItems.id)
  * vin: VIN-код автомобиля (TEXT, nullable)
  * make: марка автомобиля (TEXT)
  * model: модель автомобиля (TEXT)
  * year: год выпуска (INTEGER, nullable)
  * licensePlate: госномер (TEXT, nullable)
  * additionalInfo: дополнительная информация (TEXT, nullable)
  * deletedAt: метка мягкого удаления (DATETIME, nullable)

* **AppInfoItems** - служебная таблица для метаданных приложения
  * key: ключ (TEXT, PRIMARY KEY)
  * value: значение (TEXT)

### Преобразования данных:

При работе с базой данных используется двухуровневая архитектура моделей:
1. Модели таблиц в БД - классы с суффиксом "Items" в директории `lib/core/database/items/`
2. Бизнес-модели - классы в директориях `lib/features/*/models/`

Преобразование между ними выполняется в сервисных классах через методы `_mapToModel` и `_mapToCompanion`.

### Особенности работы с данными:

* Использование реактивных потоков через `watchActiveClients()` и `watchAllCars()`
* Мягкое удаление через установку поля `deletedAt` вместо физического удаления записей
* Каскадное удаление автомобилей при удалении клиента (на уровне бизнес-логики)
* Использование транзакций для атомарных операций с несколькими таблицами
* Оптимизация запросов через индексы