# Прямое подключение к API

> Этот документ описывает прямое подключение к API поставщиков запчастей без использования прокси-сервера.

## Содержание
- [Обзор](#обзор)
- [Архитектура](#архитектура)
- [Базовый интерфейс и реализация](#базовый-интерфейс-и-реализация)
- [Реализация для конкретных поставщиков](#реализация-для-конкретных-поставщиков)
- [Обработка ошибок](#обработка-ошибок)
- [Оптимизация и кэширование](#оптимизация-и-кэширование)
- [Особенности и ограничения](#особенности-и-ограничения)

## Обзор

Прямое подключение к API поставщиков позволяет приложению напрямую взаимодействовать с API различных поставщиков запчастей без промежуточных серверов. Этот режим удобен для:

    *   Разработки и тестирования
    *   Работы в локальной сети
    *   Случаев с малым количеством запросов
    *   Мобильных приложений с ограниченным серверным бэкендом

## Архитектура

В режиме прямого подключения клиентское приложение непосредственно взаимодействует с API каждого поставщика:

```
┌────────────────┐      HTTP запрос       ┌──────────────────┐
│   Flutter      │  ──────────────────>   │    API           │
│   приложение   │                        │    поставщика    │
└────────────────┘  <──────────────────   └──────────────────┘
                       HTTP ответ
```

Ключевые особенности архитектуры:

1. Реализация в клиенте: Вся логика подключения реализована в клиентском приложении
2. API-ключи в клиенте: Требуется хранение API-ключей в клиентском приложении
3. Индивидуальный подход: Для каждого поставщика создаётся отдельный API-клиент

## Базовый интерфейс и реализация

Для унификации работы с разными API поставщиков используется общий интерфейс:

```dart
abstract class SupplierApiClient {
  /// Получает цены на запчасть по артикулу
  Future<List<PartPriceModel>> getPricesByArticle(String article);
  
  /// Поиск запчастей по наименованию
  Future<List<PartInfoModel>> searchPartsByName(String name);
  
  /// Получает детальную информацию о запчасти
  Future<PartDetailModel?> getPartDetails(String articleNumber);
  
  /// Возвращает название поставщика
  String get supplierName;
}
```

Базовая реализация предоставляет общие механизмы работы с HTTP-запросами:

```dart
abstract class BaseSupplierClient implements SupplierApiClient {
  final HttpClientInterface httpClient;
  final String baseUrl;
  final Map<String, String> defaultHeaders;
  
  BaseSupplierClient({
    required this.httpClient,
    required this.baseUrl,
    this.defaultHeaders = const {},
  });
  
  // Методы для формирования URL и выполнения безопасных HTTP запросов
}
```

## Реализация для конкретных поставщиков

Каждый поставщик реализует свой собственный клиент, наследующий `BaseSupplierClient` и переопределяющий методы для работы с конкретным API:

```dart
class AutodocClient extends BaseSupplierClient {
  AutodocClient({
    required HttpClientInterface httpClient,
    required String apiKey,
    String baseUrl = 'https://api.autodoc.ru',
  }) : super(
    httpClient: httpClient,
    baseUrl: baseUrl,
    defaultHeaders: {
      'X-API-Key': apiKey,
      'User-Agent': 'PartCatalog/1.0',
    },
  );
  
  @override
  String get supplierName => 'Autodoc';
  
  @override
  Future<List<PartPriceModel>> getPricesByArticle(String article) async {
    // Реализация метода для конкретного поставщика
  }
  
  // Остальные методы...
}
```

## Обработка ошибок

При прямом подключении к API важна корректная обработка ошибок:

1. Сетевые ошибки: Отсутствие интернет-соединения, таймауты, проблемы DNS
2. Ошибки API: Неверные API-ключи, превышение лимитов запросов, ошибки аутентификации
3. Ошибки данных: Некорректный формат ответа, отсутствие обязательных полей

```dart
try {
  final prices = await apiClient.getPricesByArticle(article);
  // Обработка успешного ответа
} on NetworkException catch (e) {
  // Обработка сетевых ошибок
  logger.e('Ошибка сети при запросе к ${apiClient.supplierName}', e);
  
  if (e.statusCode == 401) {
    // Показать сообщение о неверных учетных данных
  } else if (e.statusCode == 429) {
    // Показать сообщение о превышении лимита запросов
  } else {
    // Общая ошибка сети
  }
} catch (e) {
  // Обработка непредвиденных ошибок
  logger.e('Непредвиденная ошибка', e);
}
```

## Оптимизация и кэширование

Для повышения производительности и снижения нагрузки на API можно использовать кэширование:

### Локальное кэширование результатов:

Для кэширования результатов запросов можно использовать локальное хранилище, например, `SharedPreferences` или SQLite:

### Дебаунсинг запросов:

Для предотвращения частых запросов при вводе пользователем можно использовать дебаунсинг:

### Умное обновление кэша:

При получении новых данных можно сравнивать их с кэшированными и обновлять только изменившиеся записи. Это позволяет снизить количество запросов к API и ускорить работу приложения.

### Параллельные запросы:

Для ускорения получения данных можно выполнять несколько запросов параллельно, используя `Future.wait`

## Особенности и ограничения

При использовании прямого подключения к API следует учитывать:

### Преимущества:
1. Простота реализации: Не требует дополнительного сервера
2. Отсутствие дополнительных задержек: Запросы идут напрямую к поставщикам
3. Автономность: Приложение не зависит от доступности промежуточного сервера

### Ограничения:
1. Безопасность: API-ключи хранятся на клиентской стороне
2. Лимиты запросов: Каждое устройство использует собственную квоту запросов
3. Оптимизация: Сложнее реализовать общую оптимизацию запросов
4. Конфигурация: При изменении API поставщиков требуется обновление клиентского приложения

### Рекомендации по использованию:
1. Используйте для разработки и тестирования: В production-среде предпочтительнее использовать прокси-сервер
2. Обеспечьте защиту API-ключей: Храните ключи в зашифрованном виде
3. Реализуйте кэширование: Для снижения нагрузки на API и улучшения отклика
4. Мониторинг ошибок: Реализуйте централизованный мониторинг ошибок для выявления проблем с API