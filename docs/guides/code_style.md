# Руководство по стилю кодирования

> В этом документе описаны принципы и соглашения по стилю кодирования, принятые в проекте Part Catalog.

## Содержание
- [Общие принципы](#общие-принципы)
- [Форматирование кода](#форматирование-кода)
- [Именование](#именование)
- [Комментарии и документация](#комментарии-и-документация)
- [Структура файлов](#Структура-файлов)
- [Архитектурные паттерны](#архитектурные-паттерны)
- [Работа с ресурсами](#работа-с-ресурсами)
- [Управление зависимостями](#управление-зависимостями)
- [Асинхронный код](#асинхронный-код)
- [Тестирование](#тестирование)
- [Безопасность](#безопасность)
- [Производительность](#производительность)
- [Логгирование](#логгирование)
- [Управление объемом генерируемого кода](#управление-объемом-генерируемого-кода)
- [Иммутабельность](#иммутабельность)
- [Дополнительные рекомендации](#дополнительные-рекомендации)

## Общие принципы

### Приоритетные правила

1. **Читаемость превыше всего** - код должен быть понятным для других разработчиков
2. **DRY (Don't Repeat Yourself)** - избегайте дублирования кода
3. **KISS (Keep It Simple, Stupid)** - старайтесь писать простой код, избегайте излишней сложности
4. **YAGNI (You Aren't Gonna Need It)** - не добавляйте функциональность "про запас"
5. **Единообразие** - придерживайтесь единого стиля во всём проекте

### Соблюдение принципов Flutter/Dart

- Следуйте [официальному руководству по стилю Dart](https://dart.dev/guides/language/effective-dart/style)
- Используйте встроенные инструменты форматирования (`dart format`)
- Поддерживайте высокий балл в анализаторе кода (minimum 80/100)

## Форматирование кода

### Отступы и пробелы

- Используйте **2 пробела** для отступов (не табуляции)
- Ограничивайте длину строк **80 символами**
- Добавляйте пустую строку между логическими блоками кода
- Используйте пробелы вокруг операторов и после запятых

### Фигурные скобки

Открывающая скобка на той же строке, что и объявление
Закрывающая скобка на отдельной строке

### Trailing Commas

Добавляйте запятые в конце параметров для многострочных объявлений
Форматируйте параметры виджетов один под другим для улучшения читаемости

## Именование

### Файлы

* Используйте snake_case для имён файлов: client_service.dart
* Придерживайтесь шаблона <что>_<тип>.dart: clients_screen.dart, car_model.dart
* Группируйте связанные файлы в одной директории

### Классы и типы

* Используйте PascalCase для классов, enum, типов и миксинов: ClientService, OrderStatus
* Имена должны быть существительными или существительными с прилагательными: CarModel, ClientsScreen
* Используйте суффиксы для определения роли класса:
    *Controller / *Cubit / *Bloc - для управления состоянием
    *Service - для бизнес-логики
    *Repository - для слоя данных
    *Provider - для доступа к данным
    *Screen / *Page - для экранов
    *Widget - для переиспользуемых UI компонентов
    *Model - для моделей данных

### Переменные и методы

Используйте camelCase для переменных и методов: clientName, calculateTotal()
Методы и функции должны начинаться с глагола: fetchData(), calculatePrice()
Булевы переменные должны иметь префикс is, has, should и т.д.: isActive, hasChildren
Избегайте сокращений, кроме общепринятых (e.g., id, url)

### Константы

Используйте lowerCamelCase для константных значений: const double borderRadius = 8.0;
Для статических/глобальных констант используйте kConstantName: kDefaultTimeout

## Комментарии и документация

### Документирование API

Используйте комментарии /// для документации публичных API
Описывайте параметры, возвращаемые значения и исключения
Добавляйте примеры для сложных методов

### Внутренние комментарии

Используйте комментарии // для объяснения сложных участков кода
Добавляйте комментарии перед сложными алгоритмами или нестандартными решениями
Используйте маркеры // TODO:, // FIXME:, // NOTE: для обозначения задач

## Структура файлов

### Организация проекта

Проект организован по принципу feature-first:

```
lib/
  ├─ features/            # Функциональные модули
  │   ├─ clients/         # Модуль клиентов
  │   │   ├─ models/      # Модели данных
  │   │   ├─ services/    # Бизнес-логика
  │   │   ├─ screens/     # Экраны UI
  │   │   └─ widgets/     # UI компоненты
  │   ├─ vehicles/        # Модуль автомобилей
  │   └─ orders/          # Модуль заказ-нарядов
  ├─ core/                # Общие компоненты
  │   ├─ database/        # Доступ к БД
  │   ├─ config/          # Конфигурация
  │   ├─ di/              # Внедрение зависимостей
  │   └─ utils/           # Утилиты
  └─ main.dart            # Точка входа
```

### Структура файла

1. Импорты (сгруппированные и отсортированные):

* Dart импорты
* Flutter импорты
* Импорты пакетов
* Импорты проекта

2. Объявление части:

* part/part of директивы

3. Константы и типы:

* Enums, константы, типы данных

4. Основной класс/функциональность:

* Основной класс, его поля, конструкторы
* Функции, геттеры/сеттеры, методы

## Архитектурные паттерны

### Разделение ответственности

UI компоненты должны отвечать только за отображение и пользовательское взаимодействие
Бизнес-логика должна быть в отдельных сервисах
Доступ к данным должен быть инкапсулирован в репозиториях

### Инъекция зависимостей

Используйте get_it для управления зависимостями

## Работа с ресурсами

### Assets

Организуйте ресурсы по типам в директории assets/
Используйте snake_case для имён файлов ресурсов
Регистрируйте все ресурсы в pubspec.yaml

### Строки

Используйте константы для строк вместо хардкода
Располагайте строки в файлах локализации для поддержки мультиязычности

## Управление зависимостями

### Версионирование пакетов

Указывайте конкретные версии в pubspec.yaml
Регулярно обновляйте зависимости
Ведите CHANGELOG для отслеживания изменений

### Импорты

Используйте относительные импорты для файлов в том же пакете
Используйте абсолютные импорты для файлов из других пакетов
Группируйте и сортируйте импорты

## Асинхронный код

### Принципы работы с асинхронным кодом

Всегда используйте ключевые слова async/await для читаемости
Используйте FutureBuilder и StreamBuilder для работы с асинхронными данными в UI
Обрабатывайте все состояния загрузки и ошибки

### Безопасное обновление UI после асинхронных операций

Всегда проверяйте mounted перед вызовом setState()
Используйте addPostFrameCallback для отложенных UI-операций
Сохраняйте ссылки на контекстные объекты перед асинхронными операциями

## Тестирование

### Паттерны для тестирования

Используйте паттерн AAA (Arrange-Act-Assert) для структурирования тестов
Применяйте принцип Given-When-Then для улучшения читаемости
Группируйте похожие тесты с помощью функции group()

### Генерация моков

Используйте пакеты mockito или mocktail для создания моков
Предпочитайте инъекцию зависимостей для упрощения тестирования
Применяйте принцип "dependency inversion" для легкой подмены компонентов в тестах

## Безопасность

### Защита чувствительных данных

Не храните секреты (API-ключи, токены) в исходном коде
Используйте flutter_secure_storage для хранения чувствительных данных
Не отправляйте чувствительную информацию в логи

### Валидация входных данных

Всегда проверяйте входящие данные, особенно от пользователя или внешних источников
Применяйте строгую типизацию и избегайте dynamic, где это возможно

### Null Safety
В проекте строго соблюдается null safety. Все поля должны быть явно обозначены как nullable или non-nullable:

- Используйте тип с `?` для полей, которые могут быть null: `String?`, `int?`
- Для non-nullable полей с обязательными значениями используйте `required` в конструкторах
- При работе с nullable полями всегда используйте операторы `?.`, `??` и проверки типа `field?.isEmpty == true`
- Вместо условий `if (value == null)` предпочтительно использовать паттерн `value?.isEmpty == true`
- При передаче nullable значений в функции, требующие non-null, всегда предоставляйте значение по умолчанию

## Производительность

### Оптимизация списков

Используйте ListView.builder вместо ListView для длинных списков
Применяйте const конструкторы для неизменяемых виджетов
Используйте кэширование для дорогостоящих вычислений

### Изображения и ресурсы

Оптимизируйте размеры изображений перед добавлением в проект
Используйте кэширование изображений с cached_network_image
Загружайте тяжелые ресурсы асинхронно и по мере необходимости

## Логгирование

- **Всегда использовать пакет logger вместо print**:
  - Инициализируйте логгер на уровне компонента: `final _logger = Logger('ComponentName');`
  - Используйте соответствующие уровни логирования: `_logger.d()`, `_logger.i()`, `_logger.w()`, `_logger.e()`
  - Никогда не используйте функцию `print()` в коде проекта
  - При логировании ошибок всегда включайте трассировку стека: `_logger.e('Message', error, stackTrace)`
  - Используйте `logger.v()` для отладочной информации, которая не должна попадать в продакшен
  - При использовании `logger` используйте именнованное обращение
  Неправильно: 
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', e, stackTrace);
  ```
  Правильно:
  ```
  _logger.w('Ошибка AST для ${file.path}: $e', error: e, stackTrace: stackTrace);
  ```

## Управление объемом генерируемого кода

При работе с GitHub Copilot важно управлять объемом генерируемого кода для достижения оптимальных результатов. Ниже представлены рекомендации по эффективной генерации кода.

### Предварительная оценка объема

- **Планируйте заранее**: Оцените приблизительный размер требуемого решения до генерации
- **Устанавливайте ограничения**: При работе с большими компонентами явно указывайте в запросе требования к объему (например, "сократите пример до основных компонентов")
- **Поэтапный подход**: Для сложных задач сначала запрашивайте структуру/каркас кода, затем детализируйте отдельные части

### Структурированный подход к большим генерациям

- **Логическое разделение**: Разбивайте сложные запросы на модульные части

- **Итеративное улучшение**: Начинайте с простой реализации, постепенно добавляя функциональность
- **Фокусировка на секциях**: При работе с большими файлами концентрируйтесь на конкретных участках кода

### Форматирование запросов для оптимальной генерации

**Типы запросов с префиксами**

| Префикс       | Назначение                                | Пример  |
|---------------|-------------------------------------------|---------|
| [КОНЦЕПТ]     | Общая архитектура без деталей реализации  | [КОНЦЕПТ] Опиши как реализовать интеграцию с API платежной системы  |
| [РЕАЛИЗАЦИЯ]  | Полный код с обработкой ошибок и комментариями | [РЕАЛИЗАЦИЯ] Создай клиент для API поставщика Autodoc, который будет наследоваться от BaseSupplierClient |
| [ОПТИМИЗАЦИЯ] | Улучшение существующего кода | [ОПТИМИЗАЦИЯ] Оптими код метода fetchData для снижения потребления памяти  |
| [СТРУКТУРА]   | Организация файлов и компонентов | [СТРУКТУРА] Предложи организацию файлов для модуля поставщиков |

**Комбинированные запросы**

[РЕАЛИЗАЦИЯ] Создай сервис для работы с текущими поставщиками
[КОНЦЕПТ] При этом учти возможность добавления новых поставщиков в будущем
Такой формат позволяет получить полную реализацию текущей функциональности и рекомендации по будущим расширениям.

### Уровни детализации и поэтапная генерация

- **Явные указания**: Четко обозначайте требуемый уровень детализации в запросе
- **Поэтапный подход**: Используйте принцип "сначала что, потом как"
- **Постепенная детализация**: Для сложных классов запрашивайте генерацию основной структуры, затем отдельных методов

**Подсказка**: Добавляйте конкретные технические детали в запрос для получения более точных результатов генерации.

## Иммутабельность

- **Предпочитайте неизменяемые структуры данных**:
  - Используйте `final` для всех полей, которые не должны изменяться после создания объекта
  - Применяйте `const` для создания константных объектов, когда это возможно
  - Избегайте методов, которые модифицируют состояние объекта

- **Корректная работа с коллекциями**:
  - Не модифицируйте существующие коллекции, создавайте новые на основе старых
  - Используйте `.unmodifiable` или `.from()..add()` для безопасного обновления
  - Применяйте шаблон копирования при изменении: `final newList = List<T>.from(oldList)..add(item)`

- **Паттерны обновления состояния**:
  - Используйте методы типа `copyWith()` для создания модифицированных копий объектов
  - Применяйте extension-методы для добавления операций, сохраняющих иммутабельность
  - Для объектов с вложенными структурами используйте глубокое копирование

- **Работа с freezed и codegen**:
  - При использовании библиотек кодогенерации, следуйте их рекомендациям по иммутабельности
  - Используйте сгенерированные методы `.copyWith()` вместо прямого изменения полей
  - Применяйте конструкторы фабрик для создания новых экземпляров объектов

- **Обработка ошибок**:
  - Всегда проверяйте на попытку модификации неизменяемых коллекций
  - Используйте защитное программирование при работе с внешними API
  - Включайте подробные сообщения об ошибках, указывающие на нарушения иммутабельности

## Дополнительные рекомендации

### Локализация

Все строки интерфейса должны поддерживать локализацию
Используйте пакеты flutter_localizations и intl

### Доступность

Добавляйте значения для semanticsLabel и semanticsValue
Используйте достаточный контраст цветов
Обеспечивайте корректный порядок фокусировки

### Жесты и анимации

Используйте стандартные жесты, понятные пользователям
Обеспечивайте визуальную обратную связь для жестов
Делайте анимации плавными, но не навязчивыми


