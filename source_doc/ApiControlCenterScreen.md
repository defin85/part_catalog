## Вариант 2: Раздельные экраны для каждого поставщика + общий центр управления

С акцентом на хранение данных в СУБД (Drift/SQLite) и шифрование учетных данных (шифрование пока не реализуем!!!!).

**[КОНЦЕПТ]**

### I. Общий центр управления API (`ApiControlCenterScreen`)

*   **Назначение:**
    *   Глобальные настройки, влияющие на все API-клиенты.
    *   Навигация к экранам настроек отдельных поставщиков.
    *   Отображение сводного статуса по каждому поставщику.
*   **UI Компоненты:**
    *   **Переключатель режима API (`ApiConnectionMode`):**
        *   Выбор: `Direct`, `Proxy`.
        *   При выборе `Proxy` появляется поле для ввода URL прокси-сервера.
        *   Значения сохраняются (например, в `SharedPreferences` или специальной таблице настроек в БД) и используются `ApiClientManager`.
    *   **Список поставщиков:**
        *   Для каждого поддерживаемого поставщика (Armtek, Autodoc и т.д.) отображается:
            *   Иконка/Логотип поставщика.
            *   Название поставщика.
            *   Текущий статус подключения (например, "Не настроен", "Подключен как [логин/ID клиента]", "Ошибка: неверный ключ", "Требуется настройка"). Статус получается динамически или из сохраненных данных.
            *   Кнопка/иконка "Настроить" или "Перейти к [ИмяПоставщика]", ведущая на соответствующий экран настроек.
*   **Взаимодействие:**
    *   Изменение глобальных настроек (`ApiConnectionMode`, `proxyUrl`) обновляет конфигурацию в `ApiClientManager`.
    *   `ApiClientManager` будет пересоздавать или переконфигурировать экземпляры клиентов при изменении глобальных настроек.

### II. Экран настроек конкретного поставщика (например, `ArmtekSettingsScreen`)

*   **Назначение:**
    *   Управление подключением к API конкретного поставщика.
    *   Отображение специфичной для поставщика информации, полученной после успешного подключения.
*   **Структура экрана (может быть разделена на вкладки или секции):**
    *   **Секция 1: "Учетные данные и подключение"**
        *   **Поля для ввода учетных данных:**
            *   Для Armtek: "Логин", "Пароль".
            *   Для других поставщиков: "API Ключ", "ID пользователя" и т.д., в зависимости от требований API.
            *   **Важно:** Эти поля не отображают сохраненные значения напрямую. Вместо этого может быть индикатор "Данные введены" или "Данные не введены". При редактировании поля могут быть пустыми, и пользователь вводит новые данные.
        *   **Кнопка "Проверить и сохранить подключение":**
            *   При нажатии:
                1.  Данные из полей ввода шифруются.
                2.  Зашифрованные данные сохраняются в специальную таблицу в БД (см. раздел "Хранение данных").
                3.  Выполняется тестовый запрос к API поставщика с использованием введенных (и только что сохраненных/зашифрованных) данных для проверки их корректности (например, для Armtek - `http://ws.armtek.ru/api/ws_ping/index?format=json`).
                4.  Результат проверки (успех/ошибка с сообщением) отображается пользователю.
                5.  В случае успеха, может быть инициирована загрузка дополнительной информации (см. Секцию 2).
        *   **Индикатор статуса подключения:** Отображает результат последней проверки или текущий статус (например, "Подключено успешно", "Ошибка: неверный логин/пароль", "Не проверено").
        *   **Кнопка "Очистить/Удалить настройки подключения":** Удаляет сохраненные учетные данные из БД.
    *   **Секция 2: "Информация от поставщика"** (становится активной/видимой после успешной проверки и сохранения подключения)
        *   **Общая информация:**
            *   ID клиента у поставщика (если применимо).
            *   Дата последней успешной синхронизации/проверки.
        *   **Специфичная информация для Armtek (пример):**
            *   **Выпадающий список "Сбытовая организация":**
                *   Заполняется данными, полученными из `armtekApiClient.getUserVkorgList()`.
                *   Выбранное значение `VKORG` сохраняется в БД (связано с настройками Armtek).
            *   **При выборе сбытовой организации, загружается и отображается:**
                *   **Структура клиента:** Данные из `armtekApiClient.getUserInfo(vkorg: выбранныйVkorg, structure: '1')`. Могут отображаться в виде дерева или списка с возможностью детализации.
                *   **Данные FTP:** Из `armtekApiClient.getUserInfo(vkorg: выбранныйVkorg, ftpData: '1')`.
                *   **Список доступных складов:** Загружается через `armtekApiClient.getStoreList(vkorg: выбранныйVkorg)` (когда будет реализован).
                *   **Список доступных брендов:** Загружается через `armtekApiClient.getBrandList(vkorg: выбранныйVkorg)` (когда будет реализован).
            *   Эта информация (кроме, возможно, очень объемной структуры клиента) может кэшироваться в БД для быстрого отображения.
        *   **Для других поставщиков:** Аналогичные секции с информацией, специфичной для их API.
*   **Взаимодействие:**
    *   Экран использует соответствующий сервис (например, `ArmtekService` или напрямую `ArmtekApiClient`) для выполнения запросов к API.
    *   Состояние экрана (введенные данные, статусы загрузки, ошибки, полученная информация) управляется через State Management решение (Provider, BLoC/Cubit, Riverpod).

### III. Хранение данных в СУБД (Drift/SQLite)

*   **Таблица `SupplierSettings` (или аналогичная):**
    *   `id` (INTEGER, PRIMARY KEY, AUTOINCREMENT)
    *   `supplier_code` (TEXT, NOT NULL, UNIQUE): Уникальный код поставщика (например, "armtek", "autodoc").
    *   `is_enabled` (BOOLEAN, DEFAULT TRUE): Флаг, включен ли поставщик.
    *   `encrypted_credentials` (BLOB или TEXT): Зашифрованные учетные данные (логин, пароль, API-ключ в виде JSON-строки, затем зашифрованной).
    *   `last_check_status` (TEXT): Статус последней проверки ("success", "error_auth", "error_network" и т.д.).
    *   `last_check_message` (TEXT): Сообщение последней проверки.
    *   `last_successful_check_at` (INTEGER, DATETIME): Время последней успешной проверки.
    *   `client_identifier_at_supplier` (TEXT): ID клиента у поставщика (если есть).
    *   `additional_config` (TEXT): JSON-строка для хранения специфичных для поставщика настроек (например, выбранный `VKORG` для Armtek, список выбранных складов и т.д.).
*   **Шифрование учетных данных:**
    *   Используйте пакет `flutter_secure_storage` для генерации и хранения ключа шифрования. Этот ключ будет уникальным для каждого устройства/установки приложения.
        *   **Важно:** Ключ шифрования, хранящийся в `flutter_secure_storage`, сам по себе защищен средствами ОС.
    *   Перед сохранением в БД `encrypted_credentials`:
        1.  Сформируйте JSON-строку из учетных данных (например, `{'username': 'user', 'password': 'pass'}`).
        2.  Зашифруйте эту JSON-строку, используя ключ из `flutter_secure_storage` и надежный алгоритм шифрования (например, AES-GCM из пакета `encrypt`).
    *   При чтении из БД `encrypted_credentials`:
        1.  Расшифруйте данные, используя ключ из `flutter_secure_storage`.
        2.  Распарсите JSON-строку для получения учетных данных.
    *   **Безопасность ключа:** Ключ шифрования, хранящийся в `flutter_secure_storage`, является критически важным. Его утеря приведет к невозможности расшифровать учетные данные.
*   **Кэширование информации от поставщика:**
    *   Для часто запрашиваемой информации (список сбытовых организаций Armtek, список складов) можно создать отдельные таблицы в БД, связанные с `SupplierSettings.supplier_code`.
    *   Например, `ArmtekVkorgCache (supplier_code, vkorg, program_name)` или `ArmtekStoreCache (supplier_code, vkorg, store_id, store_name)`.
    *   Это позволит быстрее отображать информацию на экране настроек без повторных запросов к API, с логикой обновления кэша (например, раз в день или принудительно пользователем).

### IV. Взаимодействие компонентов:

1.  **Пользователь открывает `ApiControlCenterScreen`:**
    *   Загружаются глобальные настройки (`ApiConnectionMode`, `proxyUrl`).
    *   Для каждого поставщика из `SupplierSettings` загружается статус.
2.  **Пользователь переходит на `ArmtekSettingsScreen`:**
    *   Загружаются сохраненные настройки для Armtek из `SupplierSettings` (но не сами учетные данные, а только информация о их наличии и статусе).
    *   Если есть сохраненный `VKORG`, загружается кэшированная информация (склады, бренды).
3.  **Пользователь вводит логин/пароль и нажимает "Проверить и сохранить":**
    *   UI передает данные в ViewModel/BLoC.
    *   ViewModel/BLoC:
        *   Получает ключ шифрования из `flutter_secure_storage`.
        *   Шифрует учетные данные.
        *   Сохраняет зашифрованные данные и другие настройки в `SupplierSettings` через соответствующий DAO/Repository.
        *   Использует `ArmtekApiClient` (полученный от `ApiClientManager`, который уже использует сохраненные и расшифрованные учетные данные) для тестового запроса.
        *   Обновляет `SupplierSettings` с результатом проверки.
        *   Если успешно, инициирует загрузку `UserVkorgList`, `UserInfo` и т.д.
        *   Обновляет UI.
4.  **`ApiClientManager` при создании `ArmtekApiClient`:**
    *   Запрашивает настройки для "armtek" из `SupplierSettings` (через DAO/Repository).
    *   Получает ключ шифрования из `flutter_secure_storage`.
    *   Расшифровывает `encrypted_credentials`.
    *   Использует расшифрованные логин/пароль для инициализации `ArmtekApiClient`.

### Преимущества этого подхода:

*   **Централизованное управление:** Глобальные настройки и статусы всех поставщиков в одном месте.
*   **Фокус на поставщике:** Каждый экран настроек поставщика занимается только им.
*   **Безопасность:** Учетные данные шифруются перед сохранением в локальную БД. Ключ шифрования защищен средствами ОС через `flutter_secure_storage`.
*   **Гибкость:** Легко добавлять новых поставщиков, создавая для них новые экраны настроек и записи в `SupplierSettings`.
*   **Кэширование:** Возможность кэшировать часто запрашиваемую информацию от API для улучшения UX.

### Сложности:

*   Управление ключом шифрования (хотя `flutter_secure_storage` это упрощает).
*   Реализация логики шифрования/дешифрования.
*   Проектирование таблиц БД для настроек и кэша.